[{"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean", "full_name": "EuclideanDomain.mod_add_div'", "start": [131, 1], "end": [133, 24], "traced_tactics": [{"tactic": "rw [mul_comm]", "annotated_tactic": ["rw [<a>mul_comm</a>]", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "R : Type u\ninst\u271d : EuclideanDomain R\nm k : R\n\u22a2 m % k + m / k * k = m", "state_after": "R : Type u\ninst\u271d : EuclideanDomain R\nm k : R\n\u22a2 m % k + k * (m / k) = m"}, {"tactic": "exact mod_add_div _ _", "annotated_tactic": ["exact <a>mod_add_div</a> _ _", [{"full_name": "EuclideanDomain.mod_add_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/EuclideanDomain/Defs.lean", "def_pos": [127, 9], "def_end_pos": [127, 20]}]], "state_before": "R : Type u\ninst\u271d : EuclideanDomain R\nm k : R\n\u22a2 m % k + k * (m / k) = m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.mem_singleton_self", "start": [65, 1], "end": [65, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WellFounded.lean", "full_name": "WellFounded.self_le_of_strictMono", "start": [173, 1], "end": [176, 37], "traced_tactics": [{"tactic": "by_contra' h\u2081", "annotated_tactic": ["by_contra' h\u2081", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf : \u03b2 \u2192 \u03b2\nhf : StrictMono f\n\u22a2 \u2200 (n : \u03b2), n \u2264 f n", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf : \u03b2 \u2192 \u03b2\nhf : StrictMono f\nh\u2081 : \u2203 n, f n < n\n\u22a2 False"}, {"tactic": "have h\u2082 := h.min_mem _ h\u2081", "annotated_tactic": ["have h\u2082 := h.min_mem _ h\u2081", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf : \u03b2 \u2192 \u03b2\nhf : StrictMono f\nh\u2081 : \u2203 n, f n < n\n\u22a2 False", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf : \u03b2 \u2192 \u03b2\nhf : StrictMono f\nh\u2081 : \u2203 n, f n < n\nh\u2082 : min h (fun x => Preorder.toLT.1 (f x) x) h\u2081 \u2208 fun x => Preorder.toLT.1 (f x) x\n\u22a2 False"}, {"tactic": "exact h.not_lt_min _ h\u2081 (hf h\u2082) h\u2082", "annotated_tactic": ["exact h.not_lt_min _ h\u2081 (hf h\u2082) h\u2082", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : LinearOrder \u03b2\nh : WellFounded fun x x_1 => x < x_1\ninst\u271d : PartialOrder \u03b3\nf : \u03b2 \u2192 \u03b2\nhf : StrictMono f\nh\u2081 : \u2203 n, f n < n\nh\u2082 : min h (fun x => Preorder.toLT.1 (f x) x) h\u2081 \u2208 fun x => Preorder.toLT.1 (f x) x\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.sub_sub_self", "start": [475, 11], "end": [476, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Support.lean", "full_name": "Function.mulSupport_add_one", "start": [433, 1], "end": [435, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Eventually.exists_forall_of_atTop", "start": [331, 1], "end": [333, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "GaloisConnection.u_csInf'", "start": [1471, 1], "end": [1473, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeq.lean", "full_name": "CauSeq.coe_mul", "start": [297, 1], "end": [298, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.lookmap_cons_none", "start": [3201, 1], "end": [3204, 33], "traced_tactics": [{"tactic": "simp only [lookmap, lookmap.go, Array.toListAppend_eq, Array.data_toArray, nil_append]", "annotated_tactic": ["simp only [<a>lookmap</a>, <a>lookmap.go</a>, <a>Array.toListAppend_eq</a>, <a>Array.data_toArray</a>, <a>nil_append</a>]", [{"full_name": "List.lookmap", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [788, 15], "def_end_pos": [788, 22]}, {"full_name": "List.lookmap.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [790, 17], "def_end_pos": [790, 19]}, {"full_name": "Array.toListAppend_eq", "def_path": "lake-packages/std/Std/Data/Array/Init/Lemmas.lean", "def_pos": [93, 17], "def_end_pos": [93, 32]}, {"full_name": "Array.data_toArray", "def_path": "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [750, 9], "def_end_pos": [750, 21]}, {"full_name": "List.nil_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [92, 17], "def_end_pos": [92, 27]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 Option \u03b1\na : \u03b1\nl : List \u03b1\nh : f a = none\n\u22a2 lookmap f (a :: l) = a :: lookmap f l", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 Option \u03b1\na : \u03b1\nl : List \u03b1\nh : f a = none\n\u22a2 (match f a with\n    | some b => b :: l\n    | none => lookmap.go f l (Array.push #[] a)) =\n    a :: lookmap.go f l #[]"}, {"tactic": "rw [lookmap.go_append, h]", "annotated_tactic": ["rw [<a>lookmap.go_append</a>, h]", [{"full_name": "List.lookmap.go_append", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [3185, 9], "def_end_pos": [3185, 26]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 Option \u03b1\na : \u03b1\nl : List \u03b1\nh : f a = none\n\u22a2 (match f a with\n    | some b => b :: l\n    | none => lookmap.go f l (Array.push #[] a)) =\n    a :: lookmap.go f l #[]", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 Option \u03b1\na : \u03b1\nl : List \u03b1\nh : f a = none\n\u22a2 (match none with\n    | some b => b :: l\n    | none => Array.toListAppend (Array.push #[] a) (lookmap f l)) =\n    a :: lookmap.go f l #[]"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 Option \u03b1\na : \u03b1\nl : List \u03b1\nh : f a = none\n\u22a2 (match none with\n    | some b => b :: l\n    | none => Array.toListAppend (Array.push #[] a) (lookmap f l)) =\n    a :: lookmap.go f l #[]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.firstDiffPos_eq", "start": [395, 1], "end": [398, 93], "traced_tactics": [{"tactic": "simpa [firstDiffPos] using\n  firstDiffPos_loop_eq [] [] a.1 b.1 ((utf8Len a.1).min (utf8Len b.1)) 0 rfl rfl (by simp)", "annotated_tactic": ["simpa [<a>firstDiffPos</a>] using\n    <a>firstDiffPos_loop_eq</a> [] [] a.1 b.1 ((<a>utf8Len</a> a.1).<a>min</a> (<a>utf8Len</a> b.1)) 0 <a>rfl</a> <a>rfl</a> (by simp)", [{"full_name": "String.firstDiffPos", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [207, 5], "def_end_pos": [207, 17]}, {"full_name": "String.firstDiffPos_loop_eq", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [368, 9], "def_end_pos": [368, 29]}, {"full_name": "String.utf8Len", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [54, 15], "def_end_pos": [54, 22]}, {"full_name": "Nat.min", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [504, 18], "def_end_pos": [504, 21]}, {"full_name": "String.utf8Len", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [54, 15], "def_end_pos": [54, 22]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "a b : String\n\u22a2 firstDiffPos a b = { byteIdx := utf8Len (List.takeWhile\u2082 (fun x x_1 => decide (x = x_1)) a.data b.data).fst }", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "a b : String\n\u22a2 Nat.min (utf8Len a.data) (utf8Len b.data) = min (utf8Len [] + utf8Len a.data) (utf8Len [] + utf8Len b.data)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "LE.le.not_lt_iff_eq", "start": [284, 1], "end": [285, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "full_name": "AddSubmonoid.mul_induction_on", "start": [543, 11], "end": [546, 75], "traced_tactics": [{"tactic": "simpa only [zero_mul] using hm _ (zero_mem _) _ (zero_mem _)", "annotated_tactic": ["simpa only [<a>zero_mul</a>] using hm _ (<a>zero_mem</a> _) _ (<a>zero_mem</a> _)", [{"full_name": "MulZeroClass.zero_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [36, 3], "def_end_pos": [36, 11]}, {"full_name": "ZeroMemClass.zero_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}, {"full_name": "ZeroMemClass.zero_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}]], "state_before": "\u03b1 : Type u_1\nG : Type u_2\nM\u271d : Type u_3\nR : Type u_4\nA : Type u_5\ninst\u271d\u00b2 : Monoid M\u271d\ninst\u271d\u00b9 : AddMonoid A\ninst\u271d : NonUnitalNonAssocSemiring R\nM N : AddSubmonoid R\nC : R \u2192 Prop\nr : R\nhr : r \u2208 M * N\nhm : \u2200 m \u2208 M, \u2200 n \u2208 N, C (m * n)\nha : \u2200 (x y : R), C x \u2192 C y \u2192 C (x + y)\n\u22a2 0 \u2208 { carrier := setOf C, add_mem' := (_ : \u2200 {a b : R}, C a \u2192 C b \u2192 C (a + b)) }.carrier", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "full_name": "Subsemigroup.centralizer_univ", "start": [208, 1], "end": [209, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "full_name": "Polynomial.trailingCoeff_zero", "start": [89, 1], "end": [90, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/IndicatorFunction.lean", "full_name": "Set.indicator_smul_apply_left", "start": [509, 1], "end": [513, 41], "traced_tactics": [{"tactic": "dsimp only [indicator]", "annotated_tactic": ["dsimp only [<a>indicator</a>]", [{"full_name": "Set.indicator", "def_path": "lake-packages/mathlib/Mathlib/Algebra/IndicatorFunction.lean", "def_pos": [46, 3], "def_end_pos": [46, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero M A\ns : Set \u03b1\nr : \u03b1 \u2192 M\nf : \u03b1 \u2192 A\nx : \u03b1\n\u22a2 indicator s (fun x => r x \u2022 f x) x = indicator s r x \u2022 f x", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero M A\ns : Set \u03b1\nr : \u03b1 \u2192 M\nf : \u03b1 \u2192 A\nx : \u03b1\n\u22a2 (if x \u2208 s then r x \u2022 f x else 0) = (if x \u2208 s then r x else 0) \u2022 f x"}, {"tactic": "split_ifs", "annotated_tactic": ["split_ifs", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero M A\ns : Set \u03b1\nr : \u03b1 \u2192 M\nf : \u03b1 \u2192 A\nx : \u03b1\n\u22a2 (if x \u2208 s then r x \u2022 f x else 0) = (if x \u2208 s then r x else 0) \u2022 f x", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero M A\ns : Set \u03b1\nr : \u03b1 \u2192 M\nf : \u03b1 \u2192 A\nx : \u03b1\nh\u271d : x \u2208 s\n\u22a2 r x \u2022 f x = r x \u2022 f x\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero M A\ns : Set \u03b1\nr : \u03b1 \u2192 M\nf : \u03b1 \u2192 A\nx : \u03b1\nh\u271d : x \u2209 s\n\u22a2 0 = 0 \u2022 f x"}, {"tactic": "exacts [rfl, (zero_smul _ (f x)).symm]", "annotated_tactic": ["exacts [<a>rfl</a>, (<a>zero_smul</a> _ (f x)).<a>symm</a>]", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "zero_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero M A\ns : Set \u03b1\nr : \u03b1 \u2192 M\nf : \u03b1 \u2192 A\nx : \u03b1\nh\u271d : x \u2208 s\n\u22a2 r x \u2022 f x = r x \u2022 f x\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_6\ninst\u271d\u00b2 : Zero A\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero M A\ns : Set \u03b1\nr : \u03b1 \u2192 M\nf : \u03b1 \u2192 A\nx : \u03b1\nh\u271d : x \u2209 s\n\u22a2 0 = 0 \u2022 f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Cast/Basic.lean", "full_name": "Int.cast_neg", "start": [83, 1], "end": [86, 57], "traced_tactics": [{"tactic": "erw [cast_zero, neg_zero]", "annotated_tactic": ["erw [<a>cast_zero</a>, <a>neg_zero</a>]", [{"full_name": "Int.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 18]}, {"full_name": "neg_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1014, 3], "def_end_pos": [1014, 14]}]], "state_before": "R : Type u\ninst\u271d : AddGroupWithOne R\n\u22a2 \u2191(-\u21910) = -\u2191\u21910", "state_after": "no goals"}, {"tactic": "erw [cast_ofNat, cast_negSucc]", "annotated_tactic": ["erw [<a>cast_ofNat</a>, <a>cast_negSucc</a>]", [{"full_name": "Int.cast_ofNat", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}, {"full_name": "Int.cast_negSucc", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}]], "state_before": "R : Type u\ninst\u271d : AddGroupWithOne R\nn : \u2115\n\u22a2 \u2191(-\u2191(n + 1)) = -\u2191\u2191(n + 1)", "state_after": "no goals"}, {"tactic": "erw [cast_ofNat, cast_negSucc, neg_neg]", "annotated_tactic": ["erw [<a>cast_ofNat</a>, <a>cast_negSucc</a>, <a>neg_neg</a>]", [{"full_name": "Int.cast_ofNat", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}, {"full_name": "Int.cast_negSucc", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [53, 9], "def_end_pos": [53, 21]}, {"full_name": "neg_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [799, 3], "def_end_pos": [799, 14]}]], "state_before": "R : Type u\ninst\u271d : AddGroupWithOne R\nn : \u2115\n\u22a2 \u2191(- -[n+1]) = -\u2191-[n+1]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NatAntidiagonal.lean", "full_name": "Finset.Nat.antidiagonal_succ'", "start": [60, 1], "end": [68, 40], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n : \u2115\n\u22a2 (n + 1, 0) \u2209\n    map (Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective }) (antidiagonal n)", "state_after": "no goals"}, {"tactic": "apply eq_of_veq", "annotated_tactic": ["apply <a>eq_of_veq</a>", [{"full_name": "Finset.eq_of_veq", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [152, 9], "def_end_pos": [152, 18]}]], "state_before": "n : \u2115\n\u22a2 antidiagonal (n + 1) =\n    cons (n + 1, 0)\n      (map (Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective }) (antidiagonal n))\n      (_ :\n        (n + 1, 0) \u2209\n          map (Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective }) (antidiagonal n))", "state_after": "case a\nn : \u2115\n\u22a2 (antidiagonal (n + 1)).val =\n    (cons (n + 1, 0)\n        (map (Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective }) (antidiagonal n))\n        (_ :\n          (n + 1, 0) \u2209\n            map (Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective })\n              (antidiagonal n))).val"}, {"tactic": "rw [cons_val, map_val]", "annotated_tactic": ["rw [<a>cons_val</a>, <a>map_val</a>]", [{"full_name": "Finset.cons_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [867, 9], "def_end_pos": [867, 17]}, {"full_name": "Finset.map_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [56, 9], "def_end_pos": [56, 16]}]], "state_before": "case a\nn : \u2115\n\u22a2 (antidiagonal (n + 1)).val =\n    (cons (n + 1, 0)\n        (map (Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective }) (antidiagonal n))\n        (_ :\n          (n + 1, 0) \u2209\n            map (Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective })\n              (antidiagonal n))).val", "state_after": "case a\nn : \u2115\n\u22a2 (antidiagonal (n + 1)).val =\n    (n + 1, 0) ::\u2098\n      Multiset.map (\u2191(Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective }))\n        (antidiagonal n).val"}, {"tactic": "exact Multiset.Nat.antidiagonal_succ'", "annotated_tactic": ["exact <a>Multiset.Nat.antidiagonal_succ'</a>", [{"full_name": "Multiset.Nat.antidiagonal_succ'", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/NatAntidiagonal.lean", "def_pos": [64, 9], "def_end_pos": [64, 27]}]], "state_before": "case a\nn : \u2115\n\u22a2 (antidiagonal (n + 1)).val =\n    (n + 1, 0) ::\u2098\n      Multiset.map (\u2191(Embedding.prodMap (Embedding.refl \u2115) { toFun := Nat.succ, inj' := Nat.succ_injective }))\n        (antidiagonal n).val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "Ideal.QuotientKerAlgEquivOfRightInverseSymm.apply", "start": [441, 1], "end": [444, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Control/ForInStep/Lemmas.lean", "full_name": "ForInStep.run_done", "start": [17, 9], "end": [17, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/LinearMap.lean", "full_name": "LinearMap.cancel_left", "start": [595, 1], "end": [596, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "covby_iff_Ioo_eq", "start": [350, 1], "end": [351, 60], "traced_tactics": [{"tactic": "simp [eq_empty_iff_forall_not_mem]", "annotated_tactic": ["simp [<a>eq_empty_iff_forall_not_mem</a>]", [{"full_name": "Set.eq_empty_iff_forall_not_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [575, 9], "def_end_pos": [575, 36]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na b c : \u03b1\n\u22a2 (\u2200 \u2983c : \u03b1\u2984, a < c \u2192 \u00acc < b) \u2194 Ioo a b = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/List.lean", "full_name": "Denumerable.raise_chain", "start": [313, 1], "end": [315, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Quot.lean", "full_name": "Quot.exact", "start": [40, 1], "end": [42, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Nontrivial/Defs.lean", "full_name": "not_subsingleton", "start": [89, 1], "end": [90, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Kleene.lean", "full_name": "mul_kstar_le_self", "start": [211, 1], "end": [212, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "fst_sdiff", "start": [129, 1], "end": [130, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "Decidable.not_imp_not", "start": [570, 1], "end": [571, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "div_mul_comm", "start": [562, 1], "end": [562, 56], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionCommMonoid \u03b1\na b c d : \u03b1\n\u22a2 a / b * c = c / b * a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "AntisymmRel.trans_wcovby", "start": [80, 1], "end": [81, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.mem_range_iff", "start": [904, 1], "end": [917, 11], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "R : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\n\u22a2 y \u2208 range \u2191f \u2194 \u2203 x, (x, y) \u2208 graph f", "state_after": "case mp\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nh : y \u2208 range \u2191f\n\u22a2 \u2203 x, (x, y) \u2208 graph f\n\ncase mpr\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nh : \u2203 x, (x, y) \u2208 graph f\n\u22a2 y \u2208 range \u2191f"}, {"tactic": "cases' h with x h", "annotated_tactic": ["cases' h with x h", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nh : \u2203 x, (x, y) \u2208 graph f\n\u22a2 y \u2208 range \u2191f", "state_after": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nh : (x, y) \u2208 graph f\n\u22a2 y \u2208 range \u2191f"}, {"tactic": "rw [mem_graph_iff] at h", "annotated_tactic": ["rw [<a>mem_graph_iff</a>] at h", [{"full_name": "LinearPMap.mem_graph_iff", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/LinearPMap.lean", "def_pos": [776, 9], "def_end_pos": [776, 22]}]], "state_before": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nh : (x, y) \u2208 graph f\n\u22a2 y \u2208 range \u2191f", "state_after": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nh : \u2203 y_1, \u2191y_1 = (x, y).1 \u2227 \u2191f y_1 = (x, y).2\n\u22a2 y \u2208 range \u2191f"}, {"tactic": "cases' h with x h", "annotated_tactic": ["cases' h with x h", []], "state_before": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nh : \u2203 y_1, \u2191y_1 = (x, y).1 \u2227 \u2191f y_1 = (x, y).2\n\u22a2 y \u2208 range \u2191f", "state_after": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = (x\u271d, y).1 \u2227 \u2191f x = (x\u271d, y).2\n\u22a2 y \u2208 range \u2191f"}, {"tactic": "rw [Set.mem_range]", "annotated_tactic": ["rw [<a>Set.mem_range</a>]", [{"full_name": "Set.mem_range", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [673, 9], "def_end_pos": [673, 18]}]], "state_before": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = (x\u271d, y).1 \u2227 \u2191f x = (x\u271d, y).2\n\u22a2 y \u2208 range \u2191f", "state_after": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = (x\u271d, y).1 \u2227 \u2191f x = (x\u271d, y).2\n\u22a2 \u2203 y_1, \u2191f y_1 = y"}, {"tactic": "use x", "annotated_tactic": ["use x", []], "state_before": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = (x\u271d, y).1 \u2227 \u2191f x = (x\u271d, y).2\n\u22a2 \u2203 y_1, \u2191f y_1 = y", "state_after": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = (x\u271d, y).1 \u2227 \u2191f x = (x\u271d, y).2\n\u22a2 \u2191f x = y"}, {"tactic": "simp only at h", "annotated_tactic": ["simp only at h", []], "state_before": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = (x\u271d, y).1 \u2227 \u2191f x = (x\u271d, y).2\n\u22a2 \u2191f x = y", "state_after": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = x\u271d \u2227 \u2191f x = y\n\u22a2 \u2191f x = y"}, {"tactic": "rw [h.2]", "annotated_tactic": ["rw [h.2]", []], "state_before": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx\u271d : E\nx : \u21a5f.domain\nh : \u2191x = x\u271d \u2227 \u2191f x = y\n\u22a2 \u2191f x = y", "state_after": "no goals"}, {"tactic": "rw [Set.mem_range] at h", "annotated_tactic": ["rw [<a>Set.mem_range</a>] at h", [{"full_name": "Set.mem_range", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [673, 9], "def_end_pos": [673, 18]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nh : y \u2208 range \u2191f\n\u22a2 \u2203 x, (x, y) \u2208 graph f", "state_after": "case mp\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nh : \u2203 y_1, \u2191f y_1 = y\n\u22a2 \u2203 x, (x, y) \u2208 graph f"}, {"tactic": "rcases h with \u27e8\u27e8x, hx\u27e9, h\u27e9", "annotated_tactic": ["rcases h with \u27e8\u27e8x, hx\u27e9, h\u27e9", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nh : \u2203 y_1, \u2191f y_1 = y\n\u22a2 \u2203 x, (x, y) \u2208 graph f", "state_after": "case mp.intro.mk\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nhx : x \u2208 f.domain\nh : \u2191f { val := x, property := hx } = y\n\u22a2 \u2203 x, (x, y) \u2208 graph f"}, {"tactic": "use x", "annotated_tactic": ["use x", []], "state_before": "case mp.intro.mk\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nhx : x \u2208 f.domain\nh : \u2191f { val := x, property := hx } = y\n\u22a2 \u2203 x, (x, y) \u2208 graph f", "state_after": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nhx : x \u2208 f.domain\nh : \u2191f { val := x, property := hx } = y\n\u22a2 (x, y) \u2208 graph f"}, {"tactic": "rw [\u2190 h]", "annotated_tactic": ["rw [\u2190 h]", []], "state_before": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nhx : x \u2208 f.domain\nh : \u2191f { val := x, property := hx } = y\n\u22a2 (x, y) \u2208 graph f", "state_after": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nhx : x \u2208 f.domain\nh : \u2191f { val := x, property := hx } = y\n\u22a2 (x, \u2191f { val := x, property := hx }) \u2208 graph f"}, {"tactic": "exact f.mem_graph \u27e8x, hx\u27e9", "annotated_tactic": ["exact f.mem_graph \u27e8x, hx\u27e9", []], "state_before": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\ny : F\nx : E\nhx : x \u2208 f.domain\nh : \u2191f { val := x, property := hx } = y\n\u22a2 (x, \u2191f { val := x, property := hx }) \u2208 graph f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.eval\u2082_pow", "start": [288, 1], "end": [289, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "bit0_add", "start": [132, 1], "end": [133, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/Basic.lean", "full_name": "Real.cauchy_sub", "start": [161, 1], "end": [164, 8], "traced_tactics": [{"tactic": "rw [sub_eq_add_neg, \u2190 cauchy_neg, \u2190 cauchy_add]", "annotated_tactic": ["rw [<a>sub_eq_add_neg</a>, \u2190 <a>cauchy_neg</a>, \u2190 <a>cauchy_add</a>]", [{"full_name": "sub_eq_add_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [975, 3], "def_end_pos": [975, 14]}, {"full_name": "Real.cauchy_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/Basic.lean", "def_pos": [153, 9], "def_end_pos": [153, 19]}, {"full_name": "Real.cauchy_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/Basic.lean", "def_pos": [149, 9], "def_end_pos": [149, 19]}]], "state_before": "x y : \u211d\na b : Cauchy abs\n\u22a2 ({ cauchy := a } - { cauchy := b }).cauchy = { cauchy := a }.cauchy - { cauchy := b }.cauchy", "state_after": "x y : \u211d\na b : Cauchy abs\n\u22a2 ({ cauchy := a } - { cauchy := b }).cauchy = ({ cauchy := a } + -{ cauchy := b }).cauchy"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "x y : \u211d\na b : Cauchy abs\n\u22a2 ({ cauchy := a } - { cauchy := b }).cauchy = ({ cauchy := a } + -{ cauchy := b }).cauchy", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.iUnion_inv", "start": [222, 1], "end": [223, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/LinearMap.lean", "full_name": "image_smul_set\u209b\u2097", "start": [370, 1], "end": [376, 86], "traced_tactics": [{"tactic": "apply Set.Subset.antisymm", "annotated_tactic": ["apply <a>Set.Subset.antisymm</a>", [{"full_name": "Set.Subset.antisymm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [371, 9], "def_end_pos": [371, 24]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\n\u22a2 \u2191h '' (c \u2022 s) = \u2191\u03c3 c \u2022 \u2191h '' s", "state_after": "case h\u2081\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\n\u22a2 \u2191h '' (c \u2022 s) \u2286 \u2191\u03c3 c \u2022 \u2191h '' s\n\ncase h\u2082\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\n\u22a2 \u2191\u03c3 c \u2022 \u2191h '' s \u2286 \u2191h '' (c \u2022 s)"}, {"tactic": "rintro x \u27e8y, \u27e8z, zs, rfl\u27e9, rfl\u27e9", "annotated_tactic": ["rintro x \u27e8y, \u27e8z, zs, rfl\u27e9, rfl\u27e9", []], "state_before": "case h\u2081\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\n\u22a2 \u2191h '' (c \u2022 s) \u2286 \u2191\u03c3 c \u2022 \u2191h '' s", "state_after": "case h\u2081.intro.intro.intro.intro\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\nz : M\nzs : z \u2208 s\n\u22a2 \u2191h ((fun x => c \u2022 x) z) \u2208 \u2191\u03c3 c \u2022 \u2191h '' s"}, {"tactic": "exact \u27e8h z, Set.mem_image_of_mem _ zs, (map_smul\u209b\u2097 _ _ _).symm\u27e9", "annotated_tactic": ["exact \u27e8h z, <a>Set.mem_image_of_mem</a> _ zs, (<a>map_smul\u209b\u2097</a> _ _ _).<a>symm</a>\u27e9", [{"full_name": "Set.mem_image_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [240, 9], "def_end_pos": [240, 25]}, {"full_name": "SemilinearMapClass.map_smul\u209b\u2097", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [126, 3], "def_end_pos": [126, 13]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case h\u2081.intro.intro.intro.intro\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\nz : M\nzs : z \u2208 s\n\u22a2 \u2191h ((fun x => c \u2022 x) z) \u2208 \u2191\u03c3 c \u2022 \u2191h '' s", "state_after": "no goals"}, {"tactic": "rintro x \u27e8y, \u27e8z, hz, rfl\u27e9, rfl\u27e9", "annotated_tactic": ["rintro x \u27e8y, \u27e8z, hz, rfl\u27e9, rfl\u27e9", []], "state_before": "case h\u2082\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\n\u22a2 \u2191\u03c3 c \u2022 \u2191h '' s \u2286 \u2191h '' (c \u2022 s)", "state_after": "case h\u2082.intro.intro.intro.intro\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\nz : M\nhz : z \u2208 s\n\u22a2 (fun x => \u2191\u03c3 c \u2022 x) (\u2191h z) \u2208 \u2191h '' (c \u2022 s)"}, {"tactic": "exact (Set.mem_image _ _ _).2 \u27e8c \u2022 z, Set.smul_mem_smul_set hz, map_smul\u209b\u2097 _ _ _\u27e9", "annotated_tactic": ["exact (<a>Set.mem_image</a> _ _ _).2 \u27e8c \u2022 z, <a>Set.smul_mem_smul_set</a> hz, <a>map_smul\u209b\u2097</a> _ _ _\u27e9", [{"full_name": "Set.mem_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [231, 9], "def_end_pos": [231, 18]}, {"full_name": "Set.smul_mem_smul_set", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [324, 9], "def_end_pos": [324, 26]}, {"full_name": "SemilinearMapClass.map_smul\u209b\u2097", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [126, 3], "def_end_pos": [126, 13]}]], "state_before": "case h\u2082.intro.intro.intro.intro\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nS\u2083 : Type u_7\nT : Type u_8\nM : Type u_9\nM\u2081 : Type u_10\nM\u2082 : Type u_11\nM\u2083 : Type u_12\nN\u2081 : Type u_13\nN\u2082 : Type u_14\nN\u2083 : Type u_15\n\u03b9 : Type u_16\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring S\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2081\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : AddCommMonoid N\u2081\ninst\u271d\u2075 : AddCommMonoid N\u2082\ninst\u271d\u2074 : AddCommMonoid N\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module S M\u2083\n\u03c3 : R \u2192+* S\nf\u2097 g\u2097 : M \u2192\u2097[R] M\u2082\nf g : M \u2192\u209b\u2097[\u03c3] M\u2083\nF : Type u_17\nh : F\ninst\u271d : SemilinearMapClass F \u03c3 M M\u2083\nc : R\ns : Set M\nz : M\nhz : z \u2208 s\n\u22a2 (fun x => \u2191\u03c3 c \u2022 x) (\u2191h z) \u2208 \u2191h '' (c \u2022 s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.foldr_fixed'", "start": [2349, 1], "end": [2351, 58], "traced_tactics": [{"tactic": "rw [foldr_cons, foldr_fixed' hf l, hf a]", "annotated_tactic": ["rw [<a>foldr_cons</a>, foldr_fixed' hf l, hf a]", [{"full_name": "List.foldr_cons", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [261, 17], "def_end_pos": [261, 27]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\nhf : \u2200 (a : \u03b1), f a b = b\na : \u03b1\nl : List \u03b1\n\u22a2 foldr f b (a :: l) = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "add_le_mul_two_add", "start": [254, 1], "end": [258, 59], "traced_tactics": [{"tactic": "rw [mul_add, mul_two, add_assoc]", "annotated_tactic": ["rw [<a>mul_add</a>, <a>mul_two</a>, <a>add_assoc</a>]", [{"full_name": "mul_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_two", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 16]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\na b c d : \u03b1\na2 : 2 \u2264 a\nb0 : 0 \u2264 b\n\u22a2 a + (a + a * b) \u2264 a * (2 + b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "eq_of_le_of_forall_ge_of_dense", "start": [1348, 1], "end": [1350, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "Units.mul_inv", "start": [268, 1], "end": [269, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.Prime.eq_one_or_self_of_dvd", "start": [88, 1], "end": [95, 19], "traced_tactics": [{"tactic": "obtain \u27e8n, hn\u27e9 := hm", "annotated_tactic": ["obtain \u27e8n, hn\u27e9 := hm", []], "state_before": "p : \u2115\npp : Prime p\nm : \u2115\nhm : m \u2223 p\n\u22a2 m = 1 \u2228 m = p", "state_after": "case intro\np : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\n\u22a2 m = 1 \u2228 m = p"}, {"tactic": "have := pp.isUnit_or_isUnit hn", "annotated_tactic": ["have := pp.isUnit_or_isUnit hn", []], "state_before": "case intro\np : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\n\u22a2 m = 1 \u2228 m = p", "state_after": "case intro\np : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\nthis : IsUnit m \u2228 IsUnit n\n\u22a2 m = 1 \u2228 m = p"}, {"tactic": "rw [Nat.isUnit_iff, Nat.isUnit_iff] at this", "annotated_tactic": ["rw [<a>Nat.isUnit_iff</a>, <a>Nat.isUnit_iff</a>] at this", [{"full_name": "Nat.isUnit_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Units.lean", "def_pos": [25, 19], "def_end_pos": [25, 29]}, {"full_name": "Nat.isUnit_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Units.lean", "def_pos": [25, 19], "def_end_pos": [25, 29]}]], "state_before": "case intro\np : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\nthis : IsUnit m \u2228 IsUnit n\n\u22a2 m = 1 \u2228 m = p", "state_after": "case intro\np : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\nthis : m = 1 \u2228 n = 1\n\u22a2 m = 1 \u2228 m = p"}, {"tactic": "apply Or.imp_right _ this", "annotated_tactic": ["apply <a>Or.imp_right</a> _ this", [{"full_name": "Or.imp_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [259, 9], "def_end_pos": [259, 21]}]], "state_before": "case intro\np : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\nthis : m = 1 \u2228 n = 1\n\u22a2 m = 1 \u2228 m = p", "state_after": "p : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\nthis : m = 1 \u2228 n = 1\n\u22a2 n = 1 \u2192 m = p"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "p : \u2115\npp : Prime p\nm n : \u2115\nhn : p = m * n\nthis : m = 1 \u2228 n = 1\n\u22a2 n = 1 \u2192 m = p", "state_after": "p : \u2115\npp : Prime p\nm : \u2115\nhn : p = m * 1\nthis : m = 1 \u2228 1 = 1\n\u22a2 m = p"}, {"tactic": "rw [hn, mul_one]", "annotated_tactic": ["rw [hn, <a>mul_one</a>]", [{"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "p : \u2115\npp : Prime p\nm : \u2115\nhn : p = m * 1\nthis : m = 1 \u2228 1 = 1\n\u22a2 m = p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.mk_neg", "start": [1055, 1], "end": [1057, 86], "traced_tactics": [{"tactic": "simp only [neg_apply, mk_apply]", "annotated_tactic": ["simp only [<a>neg_apply</a>, <a>mk_apply</a>]", [{"full_name": "DFinsupp.neg_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [311, 9], "def_end_pos": [311, 18]}, {"full_name": "DFinsupp.mk_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [591, 9], "def_end_pos": [591, 17]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni : \u03b9\n\u22a2 \u2191(mk s (-x)) i = \u2191(-mk s x) i", "state_after": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni : \u03b9\n\u22a2 (if H : i \u2208 s then (-x) { val := i, property := H } else 0) = -if H : i \u2208 s then x { val := i, property := H } else 0"}, {"tactic": "split_ifs <;> [rfl; rw [neg_zero]]", "annotated_tactic": ["split_ifs <;> [rfl; rw [<a>neg_zero</a>]]", [{"full_name": "neg_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1014, 3], "def_end_pos": [1014, 14]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni : \u03b9\n\u22a2 (if H : i \u2208 s then (-x) { val := i, property := H } else 0) = -if H : i \u2208 s then x { val := i, property := H } else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_le_one_iff", "start": [551, 1], "end": [553, 8], "traced_tactics": [{"tactic": "rw [card_le_one]", "annotated_tactic": ["rw [<a>card_le_one</a>]", [{"full_name": "Finset.card_le_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [542, 9], "def_end_pos": [542, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 card s \u2264 1 \u2194 \u2200 {a b : \u03b1}, a \u2208 s \u2192 b \u2208 s \u2192 a = b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 (\u2200 a \u2208 s, \u2200 b \u2208 s, a = b) \u2194 \u2200 {a b : \u03b1}, a \u2208 s \u2192 b \u2208 s \u2192 a = b"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 (\u2200 a \u2208 s, \u2200 b \u2208 s, a = b) \u2194 \u2200 {a b : \u03b1}, a \u2208 s \u2192 b \u2208 s \u2192 a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "List.foldl_strictMono", "start": [764, 1], "end": [766, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "le_of_forall_lt'", "start": [561, 1], "end": [562, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "Char.length_toString", "start": [13, 9], "end": [13, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/ModEq.lean", "full_name": "Nat.ModEq.pow", "start": [135, 11], "end": [140, 19], "traced_tactics": [{"tactic": "induction m with\n| zero => rfl\n| succ d hd =>\n  rw[pow_succ, pow_succ]\n  exact hd.mul h", "annotated_tactic": ["induction m with\n  | <a>zero</a> => rfl\n  | <a>succ</a> d hd =>\n    rw[<a>pow_succ</a>, <a>pow_succ</a>]\n    exact hd.mul h", [{"full_name": "Nat.zero", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1041, 5], "def_end_pos": [1041, 9]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}, {"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}, {"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}]], "state_before": "m\u271d n a b c d m : \u2115\nh : a \u2261 b [MOD n]\n\u22a2 a ^ m \u2261 b ^ m [MOD n]", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case zero\nm n a b c d : \u2115\nh : a \u2261 b [MOD n]\n\u22a2 a ^ zero \u2261 b ^ zero [MOD n]", "state_after": "no goals"}, {"tactic": "rw[pow_succ, pow_succ]", "annotated_tactic": ["rw[<a>pow_succ</a>, <a>pow_succ</a>]", [{"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}, {"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}]], "state_before": "case succ\nm n a b c d\u271d : \u2115\nh : a \u2261 b [MOD n]\nd : \u2115\nhd : a ^ d \u2261 b ^ d [MOD n]\n\u22a2 a ^ succ d \u2261 b ^ succ d [MOD n]", "state_after": "case succ\nm n a b c d\u271d : \u2115\nh : a \u2261 b [MOD n]\nd : \u2115\nhd : a ^ d \u2261 b ^ d [MOD n]\n\u22a2 a ^ d * a \u2261 b ^ d * b [MOD n]"}, {"tactic": "exact hd.mul h", "annotated_tactic": ["exact hd.mul h", []], "state_before": "case succ\nm n a b c d\u271d : \u2115\nh : a \u2261 b [MOD n]\nd : \u2115\nhd : a ^ d \u2261 b ^ d [MOD n]\n\u22a2 a ^ d * a \u2261 b ^ d * b [MOD n]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Opposites.lean", "full_name": "MulOpposite.coe_opLinearEquiv_symm_addEquiv", "start": [73, 1], "end": [75, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Max.lean", "full_name": "IsMin.snd", "start": [435, 1], "end": [436, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.closure_induction\u2082", "start": [953, 1], "end": [966, 68], "traced_tactics": [{"tactic": "refine'\n  closure_induction hb _ (H0_right _) (H1_right _) (Hadd_right a) (Hneg_right a) (Hmul_right a)", "annotated_tactic": ["refine'\n    <a>closure_induction</a> hb _ (H0_right _) (H1_right _) (Hadd_right a) (Hneg_right a) (Hmul_right a)", [{"full_name": "Subring.closure_induction", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Subring/Basic.lean", "def_pos": [929, 9], "def_end_pos": [929, 26]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 p a b", "state_after": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 x \u2208 s, p a x"}, {"tactic": "refine' closure_induction ha Hs (fun x _ => H0_left x) (fun x _ => H1_left x) _ _ _", "annotated_tactic": ["refine' <a>closure_induction</a> ha Hs (fun x _ => H0_left x) (fun x _ => H1_left x) _ _ _", [{"full_name": "Subring.closure_induction", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Subring/Basic.lean", "def_pos": [929, 9], "def_end_pos": [929, 26]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 x \u2208 s, p a x", "state_after": "case refine'_1\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 (x y : R), (\u2200 x_1 \u2208 s, p x x_1) \u2192 (\u2200 x \u2208 s, p y x) \u2192 \u2200 x_1 \u2208 s, p (x + y) x_1\n\ncase refine'_2\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 (x : R), (\u2200 x_1 \u2208 s, p x x_1) \u2192 \u2200 x_1 \u2208 s, p (-x) x_1\n\ncase refine'_3\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 (x y : R), (\u2200 x_1 \u2208 s, p x x_1) \u2192 (\u2200 x \u2208 s, p y x) \u2192 \u2200 x_1 \u2208 s, p (x * y) x_1"}, {"tactic": "exact fun x y H\u2081 H\u2082 z zs => Hadd_left x y z (H\u2081 z zs) (H\u2082 z zs)", "annotated_tactic": ["exact fun x y H\u2081 H\u2082 z zs => Hadd_left x y z (H\u2081 z zs) (H\u2082 z zs)", []], "state_before": "case refine'_1\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 (x y : R), (\u2200 x_1 \u2208 s, p x x_1) \u2192 (\u2200 x \u2208 s, p y x) \u2192 \u2200 x_1 \u2208 s, p (x + y) x_1", "state_after": "no goals"}, {"tactic": "exact fun x hx z zs => Hneg_left x z (hx z zs)", "annotated_tactic": ["exact fun x hx z zs => Hneg_left x z (hx z zs)", []], "state_before": "case refine'_2\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 (x : R), (\u2200 x_1 \u2208 s, p x x_1) \u2192 \u2200 x_1 \u2208 s, p (-x) x_1", "state_after": "no goals"}, {"tactic": "exact fun x y H\u2081 H\u2082 z zs => Hmul_left x y z (H\u2081 z zs) (H\u2082 z zs)", "annotated_tactic": ["exact fun x y H\u2081 H\u2082 z zs => Hmul_left x y z (H\u2081 z zs) (H\u2082 z zs)", []], "state_before": "case refine'_3\nR : Type u\nS : Type v\nT : Type w\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Ring S\ninst\u271d : Ring T\ns : Set R\np : R \u2192 R \u2192 Prop\na b : R\nha : a \u2208 closure s\nhb : b \u2208 closure s\nHs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y\nH0_left : \u2200 (x : R), p 0 x\nH0_right : \u2200 (x : R), p x 0\nH1_left : \u2200 (x : R), p 1 x\nH1_right : \u2200 (x : R), p x 1\nHneg_left : \u2200 (x y : R), p x y \u2192 p (-x) y\nHneg_right : \u2200 (x y : R), p x y \u2192 p x (-y)\nHadd_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y\nHadd_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082)\nHmul_left : \u2200 (x\u2081 x\u2082 y : R), p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y\nHmul_right : \u2200 (x y\u2081 y\u2082 : R), p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)\n\u22a2 \u2200 (x y : R), (\u2200 x_1 \u2208 s, p x x_1) \u2192 (\u2200 x \u2208 s, p y x) \u2192 \u2200 x_1 \u2208 s, p (x * y) x_1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.coe_refl", "start": [253, 9], "end": [253, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "full_name": "Multiset.prod_map_eq_pow_single", "start": [135, 1], "end": [138, 44], "traced_tactics": [{"tactic": "induction' m using Quotient.inductionOn with l", "annotated_tactic": ["induction' m using <a>Quotient.inductionOn</a> with l", [{"full_name": "Quotient.inductionOn", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [1367, 19], "def_end_pos": [1367, 30]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b1\ns t : Multiset \u03b1\na : \u03b1\nm : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nhf : \u2200 (i' : \u03b9), i' \u2260 i \u2192 i' \u2208 m \u2192 f i' = 1\n\u22a2 prod (map f m) = f i ^ count i m", "state_after": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b1\ns t : Multiset \u03b1\na : \u03b1\nm : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nl : List \u03b9\nhf : \u2200 (i' : \u03b9), i' \u2260 i \u2192 i' \u2208 \u27e6l\u27e7 \u2192 f i' = 1\n\u22a2 prod (map f \u27e6l\u27e7) = f i ^ count i \u27e6l\u27e7"}, {"tactic": "simp [List.prod_map_eq_pow_single i f hf]", "annotated_tactic": ["simp [<a>List.prod_map_eq_pow_single</a> i f hf]", [{"full_name": "List.prod_map_eq_pow_single", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Count.lean", "def_pos": [165, 9], "def_end_pos": [165, 31]}]], "state_before": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b1\ns t : Multiset \u03b1\na : \u03b1\nm : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nl : List \u03b9\nhf : \u2200 (i' : \u03b9), i' \u2260 i \u2192 i' \u2208 \u27e6l\u27e7 \u2192 f i' = 1\n\u22a2 prod (map f \u27e6l\u27e7) = f i ^ count i \u27e6l\u27e7", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Option.lean", "full_name": "Option.toFinset_some", "start": [46, 1], "end": [47, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "inf_eq_top_iff", "start": [484, 1], "end": [485, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.get?_eq_data_get?", "start": [59, 1], "end": [60, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Control/ForInStep/Lemmas.lean", "full_name": "ForInStep.bindList_append", "start": [44, 9], "end": [47, 43], "traced_tactics": [{"tactic": "induction l\u2081 generalizing s <;> simp [*]", "annotated_tactic": ["induction l\u2081 generalizing s <;> simp [*]", []], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nf : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)\ns : ForInStep \u03b2\nl\u2081 l\u2082 : List \u03b1\n\u22a2 bindList f (l\u2081 ++ l\u2082) s = do\n    let x \u2190 bindList f l\u2081 s\n    bindList f l\u2082 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.Nontrivial.pair_subset", "start": [2496, 1], "end": [2498, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.range_reindex", "start": [446, 1], "end": [447, 33], "traced_tactics": [{"tactic": "simp [coe_reindex, range_comp]", "annotated_tactic": ["simp [<a>coe_reindex</a>, <a>range_comp</a>]", [{"full_name": "Basis.coe_reindex", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [427, 9], "def_end_pos": [427, 20]}, {"full_name": "Set.range_comp", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [744, 9], "def_end_pos": [744, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ne : \u03b9 \u2243 \u03b9'\n\u22a2 range \u2191(reindex b e) = range \u2191b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.Odd.sub_odd", "start": [147, 1], "end": [149, 53], "traced_tactics": [{"tactic": "simp only [even_sub' h, *]", "annotated_tactic": ["simp only [<a>even_sub'</a> h, *]", [{"full_name": "Nat.even_sub'", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [143, 9], "def_end_pos": [143, 18]}]], "state_before": "m n : \u2115\nhm : Odd m\nhn : Odd n\nh : n \u2264 m\n\u22a2 Even (m - n)", "state_after": "no goals"}, {"tactic": "simp only [tsub_eq_zero_iff_le.mpr h, even_zero]", "annotated_tactic": ["simp only [tsub_eq_zero_iff_le.mpr h, <a>even_zero</a>]", [{"full_name": "even_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [99, 3], "def_end_pos": [99, 14]}]], "state_before": "m n : \u2115\nhm : Odd m\nhn : Odd n\nh : m \u2264 n\n\u22a2 Even (m - n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/HashMap/WF.lean", "full_name": "Std.HashMap.Imp.reinsertAux_WF", "start": [70, 1], "end": [77, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.toRingHom_apply_symm_toRingHom_apply", "start": [760, 1], "end": [762, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.domRestrict_apply", "start": [748, 1], "end": [754, 34], "traced_tactics": [{"tactic": "have : Submodule.ofLe (by simp) x = y := by\n  ext\n  simp [h]", "annotated_tactic": ["have : <a>Submodule.ofLe</a> (by simp) x = y := by\n    ext\n    simp [h]", [{"full_name": "Submodule.ofLe", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [527, 5], "def_end_pos": [527, 9]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\n\u22a2 \u2191(domRestrict f S) x = \u2191f y", "state_after": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\nthis : \u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x = y\n\u22a2 \u2191(domRestrict f S) x = \u2191f y"}, {"tactic": "rw [\u2190 this]", "annotated_tactic": ["rw [\u2190 this]", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\nthis : \u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x = y\n\u22a2 \u2191(domRestrict f S) x = \u2191f y", "state_after": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\nthis : \u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x = y\n\u22a2 \u2191(domRestrict f S) x = \u2191f (\u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x)"}, {"tactic": "exact LinearPMap.mk_apply _ _ _", "annotated_tactic": ["exact <a>LinearPMap.mk_apply</a> _ _ _", [{"full_name": "LinearPMap.mk_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/LinearPMap.lean", "def_pos": [114, 9], "def_end_pos": [114, 17]}]], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\nthis : \u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x = y\n\u22a2 \u2191(domRestrict f S) x = \u2191f (\u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\n\u22a2 S \u2293 f.domain \u2264 f.domain", "state_after": "no goals"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\n\u22a2 \u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x = y", "state_after": "case a\nR : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\n\u22a2 \u2191(\u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x) = \u2191y"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case a\nR : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\nx : \u21a5(S \u2293 f.domain)\ny : \u21a5f.domain\nh : \u2191x = \u2191y\n\u22a2 \u2191(\u2191(Submodule.ofLe (_ : S \u2293 f.domain \u2264 f.domain)) x) = \u2191y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.mem_carrier", "start": [406, 1], "end": [407, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.count_factors_eq_find_of_dvd_pow", "start": [1840, 1], "end": [1852, 57], "traced_tactics": [{"tactic": "apply le_antisymm", "annotated_tactic": ["apply <a>le_antisymm</a>", [{"full_name": "le_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) = count p (factors a)", "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2264 count p (factors a)\n\ncase a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)"}, {"tactic": "refine' Nat.find_le \u27e81, _\u27e9", "annotated_tactic": ["refine' <a>Nat.find_le</a> \u27e81, _\u27e9", [{"full_name": "Nat.find_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [877, 9], "def_end_pos": [877, 16]}]], "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2264 count p (factors a)", "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 p ^ count p (factors a) = a * 1"}, {"tactic": "rw [mul_one]", "annotated_tactic": ["rw [<a>mul_one</a>]", [{"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 p ^ count p (factors a) = a * 1", "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 p ^ count p (factors a) = a"}, {"tactic": "symm", "annotated_tactic": ["symm", []], "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 p ^ count p (factors a) = a", "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 a = p ^ count p (factors a)"}, {"tactic": "exact eq_pow_count_factors_of_dvd_pow hp h", "annotated_tactic": ["exact <a>eq_pow_count_factors_of_dvd_pow</a> hp h", [{"full_name": "Associates.eq_pow_count_factors_of_dvd_pow", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1822, 9], "def_end_pos": [1822, 40]}]], "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 a = p ^ count p (factors a)", "state_after": "no goals"}, {"tactic": "have hph := pow_ne_zero (@Nat.find (fun n => a \u2223 p ^ n) _ \u27e8n, h\u27e9) hp.ne_zero", "annotated_tactic": ["have hph := <a>pow_ne_zero</a> (@<a>Nat.find</a> (fun n => a \u2223 p ^ n) _ \u27e8n, h\u27e9) hp.ne_zero", [{"full_name": "pow_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [84, 9], "def_end_pos": [84, 20]}, {"full_name": "Nat.find", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean", "def_pos": [713, 15], "def_end_pos": [713, 19]}]], "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)", "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)"}, {"tactic": "cases' subsingleton_or_nontrivial \u03b1 with h\u03b1 h\u03b1", "annotated_tactic": ["cases' <a>subsingleton_or_nontrivial</a> \u03b1 with h\u03b1 h\u03b1", [{"full_name": "subsingleton_or_nontrivial", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [94, 9], "def_end_pos": [94, 35]}]], "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)", "state_after": "case a.inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\nh\u03b1 : Subsingleton \u03b1\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)\n\ncase a.inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\nh\u03b1 : Nontrivial \u03b1\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)"}, {"tactic": "convert count_le_count_of_le hph hp (@Nat.find_spec (fun n => a \u2223 p ^ n) _ \u27e8n, h\u27e9)", "annotated_tactic": ["convert <a>count_le_count_of_le</a> hph hp (@<a>Nat.find_spec</a> (fun n => a \u2223 p ^ n) _ \u27e8n, h\u27e9)", [{"full_name": "Associates.count_le_count_of_le", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1526, 9], "def_end_pos": [1526, 29]}, {"full_name": "Nat.find_spec", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean", "def_pos": [717, 19], "def_end_pos": [717, 28]}]], "state_before": "case a.inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\nh\u03b1 : Nontrivial \u03b1\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)", "state_after": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\nh\u03b1 : Nontrivial \u03b1\n\u22a2 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) = count p (factors (p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)))"}, {"tactic": "rw [count_pow hp.ne_zero hp, count_self hp, mul_one]", "annotated_tactic": ["rw [<a>count_pow</a> hp.ne_zero hp, <a>count_self</a> hp, <a>mul_one</a>]", [{"full_name": "Associates.count_pow", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1789, 9], "def_end_pos": [1789, 18]}, {"full_name": "Associates.count_self", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1703, 9], "def_end_pos": [1703, 19]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\nh\u03b1 : Nontrivial \u03b1\n\u22a2 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) = count p (factors (p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)))", "state_after": "no goals"}, {"tactic": "simp at hph", "annotated_tactic": ["simp at hph", []], "state_before": "case a.inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\na p : Associates \u03b1\nhp : Irreducible p\ninst\u271d : (n : \u2115) \u2192 Decidable (a \u2223 p ^ n)\nn : \u2115\nh : a \u2223 p ^ n\nhph : p ^ Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n) \u2260 0\nh\u03b1 : Subsingleton \u03b1\n\u22a2 count p (factors a) \u2264 Nat.find (_ : \u2203 n, (fun n => a \u2223 p ^ n) n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.prod_sUnion", "start": [1914, 1], "end": [1915, 59], "traced_tactics": [{"tactic": "simp_rw [sUnion_eq_biUnion, biUnion_image, prod_iUnion\u2082]", "annotated_tactic": ["simp_rw [<a>sUnion_eq_biUnion</a>, <a>biUnion_image</a>, <a>prod_iUnion\u2082</a>]", [{"full_name": "Set.sUnion_eq_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1452, 9], "def_end_pos": [1452, 26]}, {"full_name": "Set.biUnion_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1838, 9], "def_end_pos": [1838, 22]}, {"full_name": "Set.prod_iUnion\u2082", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1908, 9], "def_end_pos": [1908, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ns : Set \u03b1\nC : Set (Set \u03b2)\n\u22a2 s \u00d7\u02e2 \u22c3\u2080 C = \u22c3\u2080 ((fun t => s \u00d7\u02e2 t) '' C)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.tail_add", "start": [486, 1], "end": [487, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Chain.lean", "full_name": "List.Chain'.cons'", "start": [273, 1], "end": [275, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_eq_empty_iff", "start": [174, 1], "end": [176, 35], "traced_tactics": [{"tactic": "rw [\u2190 not_nonempty_iff_eq_empty, image2_nonempty_iff, not_and_or]", "annotated_tactic": ["rw [\u2190 <a>not_nonempty_iff_eq_empty</a>, <a>image2_nonempty_iff</a>, <a>not_and_or</a>]", [{"full_name": "Set.not_nonempty_iff_eq_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [598, 9], "def_end_pos": [598, 34]}, {"full_name": "Set.image2_nonempty_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [161, 9], "def_end_pos": [161, 28]}, {"full_name": "not_and_or", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [470, 9], "def_end_pos": [470, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\n\u22a2 image2 f s t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\n\u22a2 \u00acSet.Nonempty s \u2228 \u00acSet.Nonempty t \u2194 s = \u2205 \u2228 t = \u2205"}, {"tactic": "simp [not_nonempty_iff_eq_empty]", "annotated_tactic": ["simp [<a>not_nonempty_iff_eq_empty</a>]", [{"full_name": "Set.not_nonempty_iff_eq_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [598, 9], "def_end_pos": [598, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\n\u22a2 \u00acSet.Nonempty s \u2228 \u00acSet.Nonempty t \u2194 s = \u2205 \u2228 t = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.multiplicity_eq_zero", "start": [201, 1], "end": [203, 83], "traced_tactics": [{"tactic": "rw [\u2190 Nat.cast_zero, eq_coe_iff]", "annotated_tactic": ["rw [\u2190 <a>Nat.cast_zero</a>, <a>eq_coe_iff</a>]", [{"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}, {"full_name": "multiplicity.eq_coe_iff", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [155, 9], "def_end_pos": [155, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\n\u22a2 multiplicity a b = 0 \u2194 \u00aca \u2223 b", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\n\u22a2 a ^ 0 \u2223 b \u2227 \u00aca ^ (0 + 1) \u2223 b \u2194 \u00aca \u2223 b"}, {"tactic": "simp only [_root_.pow_zero, isUnit_one, IsUnit.dvd, zero_add, pow_one, true_and]", "annotated_tactic": ["simp only [<a>_root_.pow_zero</a>, <a>isUnit_one</a>, <a>IsUnit.dvd</a>, <a>zero_add</a>, <a>pow_one</a>, <a>true_and</a>]", [{"full_name": "pow_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [639, 9], "def_end_pos": [639, 17]}, {"full_name": "isUnit_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [621, 9], "def_end_pos": [621, 19]}, {"full_name": "IsUnit.dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Units.lean", "def_pos": [75, 9], "def_end_pos": [75, 12]}, {"full_name": "zero_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [463, 3], "def_end_pos": [463, 14]}, {"full_name": "pow_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [97, 9], "def_end_pos": [97, 16]}, {"full_name": "true_and", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [90, 17], "def_end_pos": [90, 25]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\n\u22a2 a ^ 0 \u2223 b \u2227 \u00aca ^ (0 + 1) \u2223 b \u2194 \u00aca \u2223 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.IsPeriodicPt.iterate", "start": [137, 11], "end": [139, 31], "traced_tactics": [{"tactic": "rw [IsPeriodicPt, \u2190 iterate_mul, mul_comm, iterate_mul]", "annotated_tactic": ["rw [<a>IsPeriodicPt</a>, \u2190 <a>iterate_mul</a>, <a>mul_comm</a>, <a>iterate_mul</a>]", [{"full_name": "Function.IsPeriodicPt", "def_path": "lake-packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean", "def_pos": [56, 5], "def_end_pos": [56, 17]}, {"full_name": "Function.iterate_mul", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [90, 9], "def_end_pos": [90, 20]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "Function.iterate_mul", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [90, 9], "def_end_pos": [90, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n : \u2115\nhf : IsPeriodicPt f n x\nm : \u2115\n\u22a2 IsPeriodicPt f^[m] n x", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n : \u2115\nhf : IsPeriodicPt f n x\nm : \u2115\n\u22a2 IsFixedPt f^[n]^[m] x"}, {"tactic": "exact hf.isFixedPt.iterate m", "annotated_tactic": ["exact hf.isFixedPt.iterate m", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm\u271d n : \u2115\nhf : IsPeriodicPt f n x\nm : \u2115\n\u22a2 IsFixedPt f^[n]^[m] x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.mem_Icc_of_Ico", "start": [662, 1], "end": [663, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Fintype.prod_subsingleton", "start": [2031, 1], "end": [2034, 50], "traced_tactics": [{"tactic": "haveI : Unique \u03b1 := uniqueOfSubsingleton a", "annotated_tactic": ["haveI : <a>Unique</a> \u03b1 := <a>uniqueOfSubsingleton</a> a", [{"full_name": "Unique", "def_path": "lake-packages/mathlib/Mathlib/Logic/Unique.lean", "def_pos": [55, 11], "def_end_pos": [55, 17]}, {"full_name": "uniqueOfSubsingleton", "def_path": "lake-packages/mathlib/Mathlib/Logic/Unique.lean", "def_pos": [86, 5], "def_end_pos": [86, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b2\u271d : Type u\n\u03b1\u271d : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\u271d\na\u271d : \u03b1\u271d\nf\u271d g : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Subsingleton \u03b1\ninst\u271d : Fintype \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 \u220f x : \u03b1, f x = f a", "state_after": "\u03b9 : Type u_1\n\u03b2\u271d : Type u\n\u03b1\u271d : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\u271d\na\u271d : \u03b1\u271d\nf\u271d g : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Subsingleton \u03b1\ninst\u271d : Fintype \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nthis : Unique \u03b1\n\u22a2 \u220f x : \u03b1, f x = f a"}, {"tactic": "rw [prod_unique f, Subsingleton.elim default a]", "annotated_tactic": ["rw [<a>prod_unique</a> f, <a>Subsingleton.elim</a> <a>default</a> a]", [{"full_name": "Fintype.prod_unique", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [2018, 9], "def_end_pos": [2018, 20]}, {"full_name": "Subsingleton.elim", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [873, 19], "def_end_pos": [873, 36]}, {"full_name": "Inhabited.default", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [674, 3], "def_end_pos": [674, 10]}]], "state_before": "\u03b9 : Type u_1\n\u03b2\u271d : Type u\n\u03b1\u271d : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\u271d\na\u271d : \u03b1\u271d\nf\u271d g : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Subsingleton \u03b1\ninst\u271d : Fintype \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nthis : Unique \u03b1\n\u22a2 \u220f x : \u03b1, f x = f a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Algebra.toSubring_eq_top", "start": [823, 1], "end": [825, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "and_congr_left_iff", "start": [225, 9], "end": [226, 46], "traced_tactics": [{"tactic": "simp only [and_comm, \u2190 and_congr_right_iff]", "annotated_tactic": ["simp only [<a>and_comm</a>, \u2190 <a>and_congr_right_iff</a>]", [{"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}, {"full_name": "and_congr_right_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [222, 17], "def_end_pos": [222, 36]}]], "state_before": "a c b : Prop\n\u22a2 (a \u2227 c \u2194 b \u2227 c) \u2194 c \u2192 (a \u2194 b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Function.Surjective.image_surjective", "start": [1319, 1], "end": [1322, 25], "traced_tactics": [{"tactic": "intro s", "annotated_tactic": ["intro s", []], "state_before": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Sort u_1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 Surjective (image f)", "state_after": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Sort u_1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Set \u03b2\n\u22a2 \u2203 a, f '' a = s"}, {"tactic": "use f \u207b\u00b9' s", "annotated_tactic": ["use f \u207b\u00b9' s", []], "state_before": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Sort u_1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Set \u03b2\n\u22a2 \u2203 a, f '' a = s", "state_after": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Sort u_1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Set \u03b2\n\u22a2 f '' (f \u207b\u00b9' s) = s"}, {"tactic": "rw [hf.image_preimage]", "annotated_tactic": ["rw [hf.image_preimage]", []], "state_before": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Sort u_1\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Set \u03b2\n\u22a2 f '' (f \u207b\u00b9' s) = s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WellFoundedSet.lean", "full_name": "Set.wellFoundedOn_iff_no_descending_seq", "start": [176, 1], "end": [187, 45], "traced_tactics": [{"tactic": "simp only [wellFoundedOn_iff, RelEmbedding.wellFounded_iff_no_descending_seq, \u2190 not_exists, \u2190\n  not_nonempty_iff, not_iff_not]", "annotated_tactic": ["simp only [<a>wellFoundedOn_iff</a>, <a>RelEmbedding.wellFounded_iff_no_descending_seq</a>, \u2190 <a>not_exists</a>, \u2190\n    <a>not_nonempty_iff</a>, <a>not_iff_not</a>]", [{"full_name": "Set.wellFoundedOn_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/WellFoundedSet.lean", "def_pos": [75, 9], "def_end_pos": [75, 26]}, {"full_name": "RelEmbedding.wellFounded_iff_no_descending_seq", "def_path": "lake-packages/mathlib/Mathlib/Order/OrderIsoNat.lean", "def_pos": [89, 9], "def_end_pos": [89, 42]}, {"full_name": "not_exists", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [428, 17], "def_end_pos": [428, 27]}, {"full_name": "not_nonempty_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [137, 9], "def_end_pos": [137, 25]}, {"full_name": "not_iff_not", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [436, 9], "def_end_pos": [436, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\n\u22a2 WellFoundedOn s r \u2194 \u2200 (f : (fun x x_1 => x > x_1) \u21aar r), \u00ac\u2200 (n : \u2115), \u2191f n \u2208 s", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\n\u22a2 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s) \u2194 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\n\u22a2 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s) \u2194 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s", "state_after": "case mp\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\n\u22a2 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s) \u2192 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s\n\ncase mpr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\n\u22a2 (\u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s) \u2192 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s)"}, {"tactic": "rintro \u27e8\u27e8f, hf\u27e9\u27e9", "annotated_tactic": ["rintro \u27e8\u27e8f, hf\u27e9\u27e9", []], "state_before": "case mp\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\n\u22a2 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s) \u2192 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s", "state_after": "case mp.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b\n\u22a2 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s"}, {"tactic": "have H : \u2200 n, f n \u2208 s := fun n => (hf.2 n.lt_succ_self).2.2", "annotated_tactic": ["have H : \u2200 n, f n \u2208 s := fun n => (hf.2 n.lt_succ_self).2.2", []], "state_before": "case mp.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b\n\u22a2 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s", "state_after": "case mp.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b\nH : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s"}, {"tactic": "refine' \u27e8\u27e8f, _\u27e9, H\u27e9", "annotated_tactic": ["refine' \u27e8\u27e8f, _\u27e9, H\u27e9", []], "state_before": "case mp.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b\nH : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 \u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s", "state_after": "case mp.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b\nH : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2194 a > b"}, {"tactic": "simpa only [H, and_true_iff] using @hf", "annotated_tactic": ["simpa only [H, <a>and_true_iff</a>] using @hf", [{"full_name": "and_true_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [145, 9], "def_end_pos": [145, 21]}]], "state_before": "case mp.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b\nH : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2194 a > b", "state_after": "no goals"}, {"tactic": "rintro \u27e8\u27e8f, hf\u27e9, hfs : \u2200 n, f n \u2208 s\u27e9", "annotated_tactic": ["rintro \u27e8\u27e8f, hf\u27e9, hfs : \u2200 n, f n \u2208 s\u27e9", []], "state_before": "case mpr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\n\u22a2 (\u2203 x, \u2200 (n : \u2115), \u2191x n \u2208 s) \u2192 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s)", "state_after": "case mpr.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2194 a > b\nhfs : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s)"}, {"tactic": "refine' \u27e8\u27e8f, _\u27e9\u27e9", "annotated_tactic": ["refine' \u27e8\u27e8f, _\u27e9\u27e9", []], "state_before": "case mpr.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2194 a > b\nhfs : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 Nonempty ((fun x x_1 => x > x_1) \u21aar fun a b => r a b \u2227 a \u2208 s \u2227 b \u2208 s)", "state_after": "case mpr.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2194 a > b\nhfs : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b"}, {"tactic": "simpa only [hfs, and_true_iff] using @hf", "annotated_tactic": ["simpa only [hfs, <a>and_true_iff</a>] using @hf", [{"full_name": "and_true_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [145, 9], "def_end_pos": [145, 21]}]], "state_before": "case mpr.intro.mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03c0 : \u03b9 \u2192 Type u_5\nr r' : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : IsStrictOrder \u03b1 r\ns t : Set \u03b1\nf : \u2115 \u21aa \u03b1\nhf : \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2194 a > b\nhfs : \u2200 (n : \u2115), \u2191f n \u2208 s\n\u22a2 \u2200 {a b : \u2115}, r (\u2191f a) (\u2191f b) \u2227 \u2191f a \u2208 s \u2227 \u2191f b \u2208 s \u2194 a > b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "bot_sdiff", "start": [602, 1], "end": [603, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.IsSuffix.trans", "start": [1809, 1], "end": [1810, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "smul_eq_mul", "start": [93, 1], "end": [94, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "Subtype.mk_eq_top_iff", "start": [802, 1], "end": [804, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.toDual_apply_coe", "start": [702, 1], "end": [703, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.comap_map_eq_of_injective", "start": [343, 1], "end": [344, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/Basic.lean", "full_name": "Real.mk_le", "start": [356, 1], "end": [356, 90], "traced_tactics": [{"tactic": "simp [le_def', mk_eq]", "annotated_tactic": ["simp [<a>le_def'</a>, <a>mk_eq</a>]", [{"full_name": "_private.\u00ablake-packages\u00bb.mathlib.Mathlib.Data.Real.Basic.0.Real.le_def'", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/Basic.lean", "def_pos": [352, 17], "def_end_pos": [352, 24]}, {"full_name": "Real.mk_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/Basic.lean", "def_pos": [302, 9], "def_end_pos": [302, 14]}]], "state_before": "x y : \u211d\nf g : CauSeq \u211a abs\n\u22a2 mk f \u2264 mk g \u2194 f \u2264 g", "state_after": "x y : \u211d\nf g : CauSeq \u211a abs\n\u22a2 f < g \u2228 f \u2248 g \u2194 f \u2264 g"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "x y : \u211d\nf g : CauSeq \u211a abs\n\u22a2 f < g \u2228 f \u2248 g \u2194 f \u2264 g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Reverse.lean", "full_name": "Polynomial.revAtFun_inj", "start": [50, 1], "end": [52, 50], "traced_tactics": [{"tactic": "intro a b hab", "annotated_tactic": ["intro a b hab", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN : \u2115\n\u22a2 Function.Injective (revAtFun N)", "state_after": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN a b : \u2115\nhab : revAtFun N a = revAtFun N b\n\u22a2 a = b"}, {"tactic": "rw [\u2190 @revAtFun_invol N a, hab, revAtFun_invol]", "annotated_tactic": ["rw [\u2190 @<a>revAtFun_invol</a> N a, hab, <a>revAtFun_invol</a>]", [{"full_name": "Polynomial.revAtFun_invol", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [40, 9], "def_end_pos": [40, 23]}, {"full_name": "Polynomial.revAtFun_invol", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [40, 9], "def_end_pos": [40, 23]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nN a b : \u2115\nhab : revAtFun N a = revAtFun N b\n\u22a2 a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Invertible/Basic.lean", "full_name": "div_mul_cancel_of_invertible", "start": [181, 1], "end": [182, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.inf_induction", "start": [455, 1], "end": [457, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.sum_mem_iSup", "start": [323, 1], "end": [325, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.reverse_bijective", "start": [590, 1], "end": [591, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.sumFinsuppLEquivProdFinsupp_symm_inr", "start": [963, 1], "end": [965, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "AddMonoid.coe_one", "start": [1351, 1], "end": [1351, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Hom.lean", "full_name": "DistribMulActionHom.ext", "start": [288, 1], "end": [289, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "MonoidHom.range_one", "start": [2715, 1], "end": [2716, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "BddBelow.bddAbove_image2_of_bddAbove", "start": [1537, 1], "end": [1540, 90], "traced_tactics": [{"tactic": "rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", "annotated_tactic": ["rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nb : \u03b2\nh\u2080 : \u2200 (b : \u03b2), Antitone (swap f b)\nh\u2081 : \u2200 (a : \u03b1), Monotone (f a)\n\u22a2 BddBelow s \u2192 BddAbove t \u2192 BddAbove (Set.image2 f s t)", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na\u271d : \u03b1\nb\u271d : \u03b2\nh\u2080 : \u2200 (b : \u03b2), Antitone (swap f b)\nh\u2081 : \u2200 (a : \u03b1), Monotone (f a)\na : \u03b1\nha : a \u2208 lowerBounds s\nb : \u03b2\nhb : b \u2208 upperBounds t\n\u22a2 BddAbove (Set.image2 f s t)"}, {"tactic": "exact \u27e8f a b, mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds h\u2080 h\u2081 ha hb\u27e9", "annotated_tactic": ["exact \u27e8f a b, <a>mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds</a> h\u2080 h\u2081 ha hb\u27e9", [{"full_name": "mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [1515, 9], "def_end_pos": [1515, 69]}]], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Preorder \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\na\u271d : \u03b1\nb\u271d : \u03b2\nh\u2080 : \u2200 (b : \u03b2), Antitone (swap f b)\nh\u2081 : \u2200 (a : \u03b1), Monotone (f a)\na : \u03b1\nha : a \u2208 lowerBounds s\nb : \u03b2\nhb : b \u2208 upperBounds t\n\u22a2 BddAbove (Set.image2 f s t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.zero_mul", "start": [1024, 11], "end": [1026, 24], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\nM : Matrix m n \u03b1\n\u22a2 0 * M = 0", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\nM : Matrix m n \u03b1\ni\u271d : l\nx\u271d : n\n\u22a2 (0 * M) i\u271d x\u271d = OfNat.ofNat 0 i\u271d x\u271d"}, {"tactic": "apply zero_dotProduct", "annotated_tactic": ["apply <a>zero_dotProduct</a>", [{"full_name": "Matrix.zero_dotProduct", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [797, 9], "def_end_pos": [797, 24]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d : Fintype m\nM : Matrix m n \u03b1\ni\u271d : l\nx\u271d : n\n\u22a2 (0 * M) i\u271d x\u271d = OfNat.ofNat 0 i\u271d x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.add_cons", "start": [469, 1], "end": [472, 54], "traced_tactics": [{"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Add \u03b1\nv : Fin (Nat.succ n) \u2192 \u03b1\ny : \u03b1\nw : Fin n \u2192 \u03b1\n\u22a2 v + vecCons y w = vecCons (vecHead v + y) (vecTail v + w)", "state_after": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Add \u03b1\nv : Fin (Nat.succ n) \u2192 \u03b1\ny : \u03b1\nw : Fin n \u2192 \u03b1\ni : Fin (Nat.succ n)\n\u22a2 (v + vecCons y w) i = vecCons (vecHead v + y) (vecTail v + w) i"}, {"tactic": "refine' Fin.cases _ _ i <;> simp [vecHead, vecTail]", "annotated_tactic": ["refine' <a>Fin.cases</a> _ _ i <;> simp [<a>vecHead</a>, <a>vecTail</a>]", [{"full_name": "Fin.cases", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [614, 21], "def_end_pos": [614, 26]}, {"full_name": "Matrix.vecHead", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [93, 5], "def_end_pos": [93, 12]}, {"full_name": "Matrix.vecTail", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [98, 5], "def_end_pos": [98, 12]}]], "state_before": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Add \u03b1\nv : Fin (Nat.succ n) \u2192 \u03b1\ny : \u03b1\nw : Fin n \u2192 \u03b1\ni : Fin (Nat.succ n)\n\u22a2 (v + vecCons y w) i = vecCons (vecHead v + y) (vecTail v + w) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "Int.emod_lt", "start": [235, 1], "end": [236, 56], "traced_tactics": [{"tactic": "rw [\u2190 emod_abs]", "annotated_tactic": ["rw [\u2190 <a>emod_abs</a>]", [{"full_name": "Int.emod_abs", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [227, 9], "def_end_pos": [227, 17]}]], "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\nH : b \u2260 0\n\u22a2 a % b < |b|", "state_after": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\nH : b \u2260 0\n\u22a2 a % |b| < |b|"}, {"tactic": "exact emod_lt_of_pos _ (abs_pos.2 H)", "annotated_tactic": ["exact <a>emod_lt_of_pos</a> _ (<a>abs_pos</a>.2 H)", [{"full_name": "Int.emod_lt_of_pos", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [392, 9], "def_end_pos": [392, 23]}, {"full_name": "abs_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [133, 9], "def_end_pos": [133, 16]}]], "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\nH : b \u2260 0\n\u22a2 a % |b| < |b|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Indexes.lean", "full_name": "List.mapIdxMAux'_eq_mapIdxMGo", "start": [344, 1], "end": [355, 91], "traced_tactics": [{"tactic": "revert arr", "annotated_tactic": ["revert arr", []], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nas : List \u03b1\narr : Array PUnit.{u + 1}\n\u22a2 mapIdxMAux' f (Array.size arr) as = SeqRight.seqRight (mapIdxM.go f as arr) fun x => pure PUnit.unit", "state_after": "\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nas : List \u03b1\n\u22a2 \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) as = SeqRight.seqRight (mapIdxM.go f as arr) fun x => pure PUnit.unit"}, {"tactic": "induction' as with head tail ih <;> intro arr", "annotated_tactic": ["induction' as with head tail ih <;> intro arr", []], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nas : List \u03b1\n\u22a2 \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) as = SeqRight.seqRight (mapIdxM.go f as arr) fun x => pure PUnit.unit", "state_after": "case nil\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\narr : Array PUnit.{u + 1}\n\u22a2 mapIdxMAux' f (Array.size arr) [] = SeqRight.seqRight (mapIdxM.go f [] arr) fun x => pure PUnit.unit\n\ncase cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\n\u22a2 mapIdxMAux' f (Array.size arr) (head :: tail) =\n    SeqRight.seqRight (mapIdxM.go f (head :: tail) arr) fun x => pure PUnit.unit"}, {"tactic": "simp only [mapIdxMAux', mapIdxM.go, seqRight_eq, map_pure, seq_pure]", "annotated_tactic": ["simp only [<a>mapIdxMAux'</a>, <a>mapIdxM.go</a>, <a>seqRight_eq</a>, <a>map_pure</a>, <a>seq_pure</a>]", [{"full_name": "List.mapIdxMAux'", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [198, 5], "def_end_pos": [198, 16]}, {"full_name": "List.mapIdxM.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [339, 17], "def_end_pos": [339, 19]}, {"full_name": "LawfulApplicative.seqRight_eq", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [30, 3], "def_end_pos": [30, 14]}, {"full_name": "LawfulApplicative.map_pure", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [32, 3], "def_end_pos": [32, 11]}, {"full_name": "LawfulApplicative.seq_pure", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [33, 3], "def_end_pos": [33, 11]}]], "state_before": "case nil\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\narr : Array PUnit.{u + 1}\n\u22a2 mapIdxMAux' f (Array.size arr) [] = SeqRight.seqRight (mapIdxM.go f [] arr) fun x => pure PUnit.unit", "state_after": "no goals"}, {"tactic": "simp only [mapIdxMAux', seqRight_eq, map_eq_pure_bind, seq_eq_bind, bind_pure_unit,\n  LawfulMonad.bind_assoc, pure_bind, mapIdxM.go, seq_pure]", "annotated_tactic": ["simp only [<a>mapIdxMAux'</a>, <a>seqRight_eq</a>, <a>map_eq_pure_bind</a>, <a>seq_eq_bind</a>, <a>bind_pure_unit</a>,\n      <a>LawfulMonad.bind_assoc</a>, <a>pure_bind</a>, <a>mapIdxM.go</a>, <a>seq_pure</a>]", [{"full_name": "List.mapIdxMAux'", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [198, 5], "def_end_pos": [198, 16]}, {"full_name": "LawfulApplicative.seqRight_eq", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [30, 3], "def_end_pos": [30, 14]}, {"full_name": "map_eq_pure_bind", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [62, 9], "def_end_pos": [62, 25]}, {"full_name": "seq_eq_bind", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [77, 9], "def_end_pos": [77, 20]}, {"full_name": "bind_pure_unit", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [71, 17], "def_end_pos": [71, 31]}, {"full_name": "LawfulMonad.bind_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [50, 3], "def_end_pos": [50, 13]}, {"full_name": "LawfulMonad.pure_bind", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [49, 3], "def_end_pos": [49, 12]}, {"full_name": "List.mapIdxM.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [339, 17], "def_end_pos": [339, 19]}, {"full_name": "LawfulApplicative.seq_pure", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [33, 3], "def_end_pos": [33, 11]}]], "state_before": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\n\u22a2 mapIdxMAux' f (Array.size arr) (head :: tail) =\n    SeqRight.seqRight (mapIdxM.go f (head :: tail) arr) fun x => pure PUnit.unit", "state_after": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\n\u22a2 (do\n      f (Array.size arr) head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 f (Array.size arr) head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)"}, {"tactic": "generalize (f (Array.size arr) head) = head", "annotated_tactic": ["generalize (f (<a>Array.size</a> arr) head) = head", [{"full_name": "Array.size", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2531, 5], "def_end_pos": [2531, 15]}]], "state_before": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\n\u22a2 (do\n      f (Array.size arr) head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 f (Array.size arr) head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)", "state_after": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\n\u22a2 (do\n      head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)"}, {"tactic": "let arr_1 := arr.push \u27e8\u27e9", "annotated_tactic": ["let arr_1 := arr.push \u27e8\u27e9", []], "state_before": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\n\u22a2 (do\n      head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)", "state_after": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\narr_1 : Array PUnit.{u + 1} := Array.push arr PUnit.unit\n\u22a2 (do\n      head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)"}, {"tactic": "have : arr_1.size = arr.size + 1 := Array.size_push arr \u27e8\u27e9", "annotated_tactic": ["have : arr_1.size = arr.size + 1 := <a>Array.size_push</a> arr \u27e8\u27e9", [{"full_name": "Array.size_push", "def_path": "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "def_pos": [64, 17], "def_end_pos": [64, 26]}]], "state_before": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\narr_1 : Array PUnit.{u + 1} := Array.push arr PUnit.unit\n\u22a2 (do\n      head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)", "state_after": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\narr_1 : Array PUnit.{u + 1} := Array.push arr PUnit.unit\nthis : Array.size arr_1 = Array.size arr + 1\n\u22a2 (do\n      head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)"}, {"tactic": "rw [\u2190 this, ih arr_1]", "annotated_tactic": ["rw [\u2190 this, ih arr_1]", []], "state_before": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\narr_1 : Array PUnit.{u + 1} := Array.push arr PUnit.unit\nthis : Array.size arr_1 = Array.size arr + 1\n\u22a2 (do\n      head\n      mapIdxMAux' f (Array.size arr + 1) tail) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)", "state_after": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\narr_1 : Array PUnit.{u + 1} := Array.push arr PUnit.unit\nthis : Array.size arr_1 = Array.size arr + 1\n\u22a2 (do\n      head\n      SeqRight.seqRight (mapIdxM.go f tail arr_1) fun x => pure PUnit.unit) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)"}, {"tactic": "simp only [seqRight_eq, map_eq_pure_bind, seq_pure, LawfulMonad.bind_assoc, pure_bind]", "annotated_tactic": ["simp only [<a>seqRight_eq</a>, <a>map_eq_pure_bind</a>, <a>seq_pure</a>, <a>LawfulMonad.bind_assoc</a>, <a>pure_bind</a>]", [{"full_name": "LawfulApplicative.seqRight_eq", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [30, 3], "def_end_pos": [30, 14]}, {"full_name": "map_eq_pure_bind", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [62, 9], "def_end_pos": [62, 25]}, {"full_name": "LawfulApplicative.seq_pure", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [33, 3], "def_end_pos": [33, 11]}, {"full_name": "LawfulMonad.bind_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [50, 3], "def_end_pos": [50, 13]}, {"full_name": "LawfulMonad.pure_bind", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [49, 3], "def_end_pos": [49, 12]}]], "state_before": "case cons\n\u03b1\u271d : Type u\n\u03b2 : Type v\nm : Type u \u2192 Type v\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u03b1 : Type u_1\nf : \u2115 \u2192 \u03b1 \u2192 m PUnit.{u + 1}\nhead\u271d : \u03b1\ntail : List \u03b1\nih :\n  \u2200 (arr : Array PUnit.{u + 1}),\n    mapIdxMAux' f (Array.size arr) tail = SeqRight.seqRight (mapIdxM.go f tail arr) fun x => pure PUnit.unit\narr : Array PUnit.{u + 1}\nhead : m PUnit.{u + 1}\narr_1 : Array PUnit.{u + 1} := Array.push arr PUnit.unit\nthis : Array.size arr_1 = Array.size arr + 1\n\u22a2 (do\n      head\n      SeqRight.seqRight (mapIdxM.go f tail arr_1) fun x => pure PUnit.unit) =\n    do\n    let x \u2190 head\n    let x \u2190 mapIdxM.go f tail (Array.push arr x)\n    pure (const (List PUnit.{u + 1}) id x PUnit.unit)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "IsGreatest.antichain_iff", "start": [245, 1], "end": [246, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.mapDomain_finset_sum", "start": [529, 1], "end": [531, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.toNat_sub_toNat_neg", "start": [1407, 9], "end": [1410, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean", "full_name": "finsuppLequivDFinsupp_symm_apply", "start": [266, 1], "end": [269, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.neg_mulVec", "start": [1916, 1], "end": [1918, 23], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocRing \u03b1\ninst\u271d : Fintype n\nv : n \u2192 \u03b1\nA : Matrix m n \u03b1\n\u22a2 mulVec (-A) v = -mulVec A v", "state_after": "case h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocRing \u03b1\ninst\u271d : Fintype n\nv : n \u2192 \u03b1\nA : Matrix m n \u03b1\nx\u271d : m\n\u22a2 mulVec (-A) v x\u271d = (-mulVec A v) x\u271d"}, {"tactic": "apply neg_dotProduct", "annotated_tactic": ["apply <a>neg_dotProduct</a>", [{"full_name": "Matrix.neg_dotProduct", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [901, 9], "def_end_pos": [901, 23]}]], "state_before": "case h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b9 : NonUnitalNonAssocRing \u03b1\ninst\u271d : Fintype n\nv : n \u2192 \u03b1\nA : Matrix m n \u03b1\nx\u271d : m\n\u22a2 mulVec (-A) v x\u271d = (-mulVec A v) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "Left.one_le_inv_iff", "start": [106, 1], "end": [108, 7], "traced_tactics": [{"tactic": "rw [\u2190 mul_le_mul_iff_left a]", "annotated_tactic": ["rw [\u2190 <a>mul_le_mul_iff_left</a> a]", [{"full_name": "mul_le_mul_iff_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [83, 9], "def_end_pos": [83, 28]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na b c d : \u03b1\n\u22a2 1 \u2264 a\u207b\u00b9 \u2194 a \u2264 1", "state_after": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na b c d : \u03b1\n\u22a2 a * 1 \u2264 a * a\u207b\u00b9 \u2194 a \u2264 1"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na b c d : \u03b1\n\u22a2 a * 1 \u2264 a * a\u207b\u00b9 \u2194 a \u2264 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/MinMax.lean", "full_name": "List.maximum_eq_none", "start": [313, 1], "end": [314, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.map_eq", "start": [756, 1], "end": [757, 39], "traced_tactics": [{"tactic": "simpa using mapAux_of_valid f [] s.1", "annotated_tactic": ["simpa using <a>mapAux_of_valid</a> f [] s.1", [{"full_name": "String.mapAux_of_valid", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [748, 9], "def_end_pos": [748, 24]}]], "state_before": "f : Char \u2192 Char\ns : String\n\u22a2 map f s = { data := List.map f s.data }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_le_mul_of_nonneg_left", "start": [152, 1], "end": [153, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.natCast_le", "start": [1356, 1], "end": [1358, 40], "traced_tactics": [{"tactic": "rw [\u2190 lift_mk_fin, \u2190 lift_mk_fin, lift_le, le_def, Function.Embedding.nonempty_iff_card_le,\n  Fintype.card_fin, Fintype.card_fin]", "annotated_tactic": ["rw [\u2190 <a>lift_mk_fin</a>, \u2190 <a>lift_mk_fin</a>, <a>lift_le</a>, <a>le_def</a>, <a>Function.Embedding.nonempty_iff_card_le</a>,\n    <a>Fintype.card_fin</a>, <a>Fintype.card_fin</a>]", [{"full_name": "Cardinal.lift_mk_fin", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 20]}, {"full_name": "Cardinal.lift_mk_fin", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 20]}, {"full_name": "Cardinal.lift_le", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 16]}, {"full_name": "Cardinal.le_def", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 15]}, {"full_name": "Function.Embedding.nonempty_iff_card_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [823, 9], "def_end_pos": [823, 29]}, {"full_name": "Fintype.card_fin", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [308, 9], "def_end_pos": [308, 25]}, {"full_name": "Fintype.card_fin", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [308, 9], "def_end_pos": [308, 25]}]], "state_before": "\u03b1 \u03b2 : Type u\nm n : \u2115\n\u22a2 \u2191m \u2264 \u2191n \u2194 m \u2264 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "BoundedLatticeHom.cancel_right", "start": [1336, 1], "end": [1339, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.pow_prod_atom", "start": [586, 1], "end": [586, 89], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na : R\nb : \u2115\n\u22a2 a ^ b = (a + 0) ^ b * Nat.rawCast 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Bitwise.lean", "full_name": "Nat.eq_of_testBit_eq", "start": [231, 1], "end": [240, 71], "traced_tactics": [{"tactic": "induction' n using Nat.binaryRec with b n hn generalizing m", "annotated_tactic": ["induction' n using <a>Nat.binaryRec</a> with b n hn generalizing m", [{"full_name": "Nat.binaryRec", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [224, 5], "def_end_pos": [224, 14]}]], "state_before": "n m : \u2115\nh : \u2200 (i : \u2115), testBit n i = testBit m i\n\u22a2 n = m", "state_after": "case z\nm : \u2115\nh : \u2200 (i : \u2115), testBit 0 i = testBit m i\n\u22a2 0 = m\n\ncase f\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nm : \u2115\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit m i\n\u22a2 bit b n = m"}, {"tactic": "induction' m using Nat.binaryRec with b' m", "annotated_tactic": ["induction' m using <a>Nat.binaryRec</a> with b' m", [{"full_name": "Nat.binaryRec", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [224, 5], "def_end_pos": [224, 14]}]], "state_before": "case f\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nm : \u2115\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit m i\n\u22a2 bit b n = m", "state_after": "case f.z\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit 0 i\n\u22a2 bit b n = 0\n\ncase f.f\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nb' : Bool\nm : \u2115\na\u271d : (\u2200 (i : \u2115), testBit (bit b n) i = testBit m i) \u2192 bit b n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit (bit b' m) i\n\u22a2 bit b n = bit b' m"}, {"tactic": "suffices h' : n = m by\n  rw [h', show b = b' by simpa using h 0]", "annotated_tactic": ["suffices h' : n = m by\n    rw [h', show b = b' by simpa using h 0]", []], "state_before": "case f.f\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nb' : Bool\nm : \u2115\na\u271d : (\u2200 (i : \u2115), testBit (bit b n) i = testBit m i) \u2192 bit b n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit (bit b' m) i\n\u22a2 bit b n = bit b' m", "state_after": "case f.f\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nb' : Bool\nm : \u2115\na\u271d : (\u2200 (i : \u2115), testBit (bit b n) i = testBit m i) \u2192 bit b n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit (bit b' m) i\n\u22a2 n = m"}, {"tactic": "exact hn fun i => by convert h (i + 1) using 1 <;> rw [testBit_succ]", "annotated_tactic": ["exact hn fun i => by convert h (i + 1) using 1 <;> rw [<a>testBit_succ</a>]", [{"full_name": "Nat.testBit_succ", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [308, 9], "def_end_pos": [308, 21]}]], "state_before": "case f.f\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nb' : Bool\nm : \u2115\na\u271d : (\u2200 (i : \u2115), testBit (bit b n) i = testBit m i) \u2192 bit b n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit (bit b' m) i\n\u22a2 n = m", "state_after": "no goals"}, {"tactic": "simp only [zero_testBit] at h", "annotated_tactic": ["simp only [<a>zero_testBit</a>] at h", [{"full_name": "Nat.zero_testBit", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [217, 9], "def_end_pos": [217, 21]}]], "state_before": "case z\nm : \u2115\nh : \u2200 (i : \u2115), testBit 0 i = testBit m i\n\u22a2 0 = m", "state_after": "case z\nm : \u2115\nh : \u2200 (i : \u2115), false = testBit m i\n\u22a2 0 = m"}, {"tactic": "exact (zero_of_testBit_eq_false fun i => (h i).symm).symm", "annotated_tactic": ["exact (<a>zero_of_testBit_eq_false</a> fun i => (h i).<a>symm</a>).<a>symm</a>", [{"full_name": "Nat.zero_of_testBit_eq_false", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [209, 9], "def_end_pos": [209, 33]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case z\nm : \u2115\nh : \u2200 (i : \u2115), false = testBit m i\n\u22a2 0 = m", "state_after": "no goals"}, {"tactic": "simp only [zero_testBit] at h", "annotated_tactic": ["simp only [<a>zero_testBit</a>] at h", [{"full_name": "Nat.zero_testBit", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [217, 9], "def_end_pos": [217, 21]}]], "state_before": "case f.z\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit 0 i\n\u22a2 bit b n = 0", "state_after": "case f.z\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = false\n\u22a2 bit b n = 0"}, {"tactic": "exact zero_of_testBit_eq_false h", "annotated_tactic": ["exact <a>zero_of_testBit_eq_false</a> h", [{"full_name": "Nat.zero_of_testBit_eq_false", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [209, 9], "def_end_pos": [209, 33]}]], "state_before": "case f.z\nb : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = false\n\u22a2 bit b n = 0", "state_after": "no goals"}, {"tactic": "rw [h', show b = b' by simpa using h 0]", "annotated_tactic": ["rw [h', show b = b' by simpa using h 0]", []], "state_before": "b : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nb' : Bool\nm : \u2115\na\u271d : (\u2200 (i : \u2115), testBit (bit b n) i = testBit m i) \u2192 bit b n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit (bit b' m) i\nh' : n = m\n\u22a2 bit b n = bit b' m", "state_after": "no goals"}, {"tactic": "simpa using h 0", "annotated_tactic": ["simpa using h 0", []], "state_before": "b : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nb' : Bool\nm : \u2115\na\u271d : (\u2200 (i : \u2115), testBit (bit b n) i = testBit m i) \u2192 bit b n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit (bit b' m) i\nh' : n = m\n\u22a2 b = b'", "state_after": "no goals"}, {"tactic": "convert h (i + 1) using 1 <;> rw [testBit_succ]", "annotated_tactic": ["convert h (i + 1) using 1 <;> rw [<a>testBit_succ</a>]", [{"full_name": "Nat.testBit_succ", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [308, 9], "def_end_pos": [308, 21]}]], "state_before": "b : Bool\nn : \u2115\nhn : \u2200 {m : \u2115}, (\u2200 (i : \u2115), testBit n i = testBit m i) \u2192 n = m\nb' : Bool\nm : \u2115\na\u271d : (\u2200 (i : \u2115), testBit (bit b n) i = testBit m i) \u2192 bit b n = m\nh : \u2200 (i : \u2115), testBit (bit b n) i = testBit (bit b' m) i\ni : \u2115\n\u22a2 testBit n i = testBit m i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Invertible.lean", "full_name": "invOf_pos", "start": [21, 1], "end": [23, 84], "traced_tactics": [{"tactic": "simp only [mul_invOf_self, zero_lt_one]", "annotated_tactic": ["simp only [<a>mul_invOf_self</a>, <a>zero_lt_one</a>]", [{"full_name": "mul_invOf_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Invertible/Defs.lean", "def_pos": [112, 9], "def_end_pos": [112, 23]}, {"full_name": "zero_lt_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\na : \u03b1\ninst\u271d : Invertible a\n\u22a2 0 < a * \u215fa", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Option/Defs.lean", "full_name": "Option.iget_some", "start": [111, 1], "end": [112, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Finiteness.lean", "full_name": "Submonoid.FG.map", "start": [143, 1], "end": [147, 72], "traced_tactics": [{"tactic": "classical\n  obtain \u27e8s, rfl\u27e9 := h\n  exact \u27e8s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]\u27e9", "annotated_tactic": ["classical\n    obtain \u27e8s, rfl\u27e9 := h\n    exact \u27e8s.image e, by rw [<a>Finset.coe_image</a>, <a>MonoidHom.map_mclosure</a>]\u27e9", [{"full_name": "Finset.coe_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [392, 9], "def_end_pos": [392, 18]}, {"full_name": "MonoidHom.map_mclosure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [1094, 9], "def_end_pos": [1094, 21]}]], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddMonoid N\nM' : Type u_3\ninst\u271d : Monoid M'\nP : Submonoid M\nh : FG P\ne : M \u2192* M'\n\u22a2 FG (Submonoid.map e P)", "state_after": "no goals"}, {"tactic": "obtain \u27e8s, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8s, rfl\u27e9 := h", []], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddMonoid N\nM' : Type u_3\ninst\u271d : Monoid M'\nP : Submonoid M\nh : FG P\ne : M \u2192* M'\n\u22a2 FG (Submonoid.map e P)", "state_after": "case intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddMonoid N\nM' : Type u_3\ninst\u271d : Monoid M'\ne : M \u2192* M'\ns : Finset M\n\u22a2 FG (Submonoid.map e (closure \u2191s))"}, {"tactic": "exact \u27e8s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]\u27e9", "annotated_tactic": ["exact \u27e8s.image e, by rw [<a>Finset.coe_image</a>, <a>MonoidHom.map_mclosure</a>]\u27e9", [{"full_name": "Finset.coe_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [392, 9], "def_end_pos": [392, 18]}, {"full_name": "MonoidHom.map_mclosure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [1094, 9], "def_end_pos": [1094, 21]}]], "state_before": "case intro\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddMonoid N\nM' : Type u_3\ninst\u271d : Monoid M'\ne : M \u2192* M'\ns : Finset M\n\u22a2 FG (Submonoid.map e (closure \u2191s))", "state_after": "no goals"}, {"tactic": "rw [Finset.coe_image, MonoidHom.map_mclosure]", "annotated_tactic": ["rw [<a>Finset.coe_image</a>, <a>MonoidHom.map_mclosure</a>]", [{"full_name": "Finset.coe_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [392, 9], "def_end_pos": [392, 18]}, {"full_name": "MonoidHom.map_mclosure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [1094, 9], "def_end_pos": [1094, 21]}]], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddMonoid N\nM' : Type u_3\ninst\u271d : Monoid M'\ne : M \u2192* M'\ns : Finset M\n\u22a2 closure \u2191(Finset.image (\u2191e) s) = Submonoid.map e (closure \u2191s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "min_lt_min_left_iff", "start": [191, 1], "end": [193, 59], "traced_tactics": [{"tactic": "simp_rw [lt_min_iff, min_lt_iff, or_iff_left (lt_irrefl _)]", "annotated_tactic": ["simp_rw [<a>lt_min_iff</a>, <a>min_lt_iff</a>, <a>or_iff_left</a> (<a>lt_irrefl</a> _)]", [{"full_name": "lt_min_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [53, 9], "def_end_pos": [53, 19]}, {"full_name": "min_lt_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [63, 9], "def_end_pos": [63, 19]}, {"full_name": "or_iff_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [307, 9], "def_end_pos": [307, 20]}, {"full_name": "lt_irrefl", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [79, 9], "def_end_pos": [79, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na b c d : \u03b1\n\u22a2 min a c < min b c \u2194 a < b \u2227 a < c", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na b c d : \u03b1\n\u22a2 (a < b \u2228 c < b) \u2227 a < c \u2194 a < b \u2227 a < c"}, {"tactic": "exact and_congr_left fun h => or_iff_left_of_imp h.trans", "annotated_tactic": ["exact <a>and_congr_left</a> fun h => <a>or_iff_left_of_imp</a> h.trans", [{"full_name": "and_congr_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [167, 9], "def_end_pos": [167, 23]}, {"full_name": "or_iff_left_of_imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [297, 9], "def_end_pos": [297, 27]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na b c d : \u03b1\n\u22a2 (a < b \u2228 c < b) \u2227 a < c \u2194 a < b \u2227 a < c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "List.all_one_of_le_one_le_of_prod_eq_one", "start": [522, 1], "end": [524, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "Units.val_eq_one", "start": [241, 1], "end": [241, 85], "traced_tactics": [{"tactic": "rw [\u2190 Units.val_one, eq_iff]", "annotated_tactic": ["rw [\u2190 <a>Units.val_one</a>, <a>eq_iff</a>]", [{"full_name": "Units.val_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [235, 9], "def_end_pos": [235, 16]}, {"full_name": "Units.eq_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [147, 9], "def_end_pos": [147, 15]}]], "state_before": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na\u271d b c u a : \u03b1\u02e3\n\u22a2 \u2191a = 1 \u2194 a = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "not_isOfFinOrder_of_injective_pow", "start": [77, 1], "end": [83, 24], "traced_tactics": [{"tactic": "simp_rw [isOfFinOrder_iff_pow_eq_one, not_exists, not_and]", "annotated_tactic": ["simp_rw [<a>isOfFinOrder_iff_pow_eq_one</a>, <a>not_exists</a>, <a>not_and</a>]", [{"full_name": "isOfFinOrder_iff_pow_eq_one", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [70, 9], "def_end_pos": [70, 36]}, {"full_name": "not_exists", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [428, 17], "def_end_pos": [428, 27]}, {"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}]], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn m : \u2115\nx : G\nh : Injective fun n => x ^ n\n\u22a2 \u00acIsOfFinOrder x", "state_after": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn m : \u2115\nx : G\nh : Injective fun n => x ^ n\n\u22a2 \u2200 (x_1 : \u2115), 0 < x_1 \u2192 \u00acx ^ x_1 = 1"}, {"tactic": "intro n hn_pos hnx", "annotated_tactic": ["intro n hn_pos hnx", []], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn m : \u2115\nx : G\nh : Injective fun n => x ^ n\n\u22a2 \u2200 (x_1 : \u2115), 0 < x_1 \u2192 \u00acx ^ x_1 = 1", "state_after": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn\u271d m : \u2115\nx : G\nh : Injective fun n => x ^ n\nn : \u2115\nhn_pos : 0 < n\nhnx : x ^ n = 1\n\u22a2 False"}, {"tactic": "rw [\u2190 pow_zero x] at hnx", "annotated_tactic": ["rw [\u2190 <a>pow_zero</a> x] at hnx", [{"full_name": "pow_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [639, 9], "def_end_pos": [639, 17]}]], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn\u271d m : \u2115\nx : G\nh : Injective fun n => x ^ n\nn : \u2115\nhn_pos : 0 < n\nhnx : x ^ n = 1\n\u22a2 False", "state_after": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn\u271d m : \u2115\nx : G\nh : Injective fun n => x ^ n\nn : \u2115\nhn_pos : 0 < n\nhnx : x ^ n = x ^ 0\n\u22a2 False"}, {"tactic": "rw [h hnx] at hn_pos", "annotated_tactic": ["rw [h hnx] at hn_pos", []], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn\u271d m : \u2115\nx : G\nh : Injective fun n => x ^ n\nn : \u2115\nhn_pos : 0 < n\nhnx : x ^ n = x ^ 0\n\u22a2 False", "state_after": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn\u271d m : \u2115\nx : G\nh : Injective fun n => x ^ n\nn : \u2115\nhn_pos : 0 < 0\nhnx : x ^ n = x ^ 0\n\u22a2 False"}, {"tactic": "exact irrefl 0 hn_pos", "annotated_tactic": ["exact <a>irrefl</a> 0 hn_pos", [{"full_name": "irrefl", "def_path": "lake-packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [300, 9], "def_end_pos": [300, 15]}]], "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn\u271d m : \u2115\nx : G\nh : Injective fun n => x ^ n\nn : \u2115\nhn_pos : 0 < 0\nhnx : x ^ n = x ^ 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "associated_unit_mul_right", "start": [473, 1], "end": [475, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Bitwise.lean", "full_name": "Nat.xor_cancel_left", "start": [412, 1], "end": [413, 39], "traced_tactics": [{"tactic": "rw [\u2190 xor_assoc, xor_self, zero_xor]", "annotated_tactic": ["rw [\u2190 <a>xor_assoc</a>, <a>xor_self</a>, <a>zero_xor</a>]", [{"full_name": "Nat.xor_assoc", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [393, 9], "def_end_pos": [393, 18]}, {"full_name": "Nat.xor_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [403, 9], "def_end_pos": [403, 17]}, {"full_name": "Nat.zero_xor", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bitwise.lean", "def_pos": [352, 9], "def_end_pos": [352, 17]}]], "state_before": "n m : \u2115\n\u22a2 n ^^^ (n ^^^ m) = m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.ofNat_succ_pos", "start": [607, 1], "end": [607, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval\u2082Hom_zero_apply", "start": [1519, 1], "end": [1521, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.image2_iUnion\u2082_right", "start": [2035, 1], "end": [2037, 35], "traced_tactics": [{"tactic": "simp_rw [image2_iUnion_right]", "annotated_tactic": ["simp_rw [<a>image2_iUnion_right</a>]", [{"full_name": "Set.image2_iUnion_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [2022, 9], "def_end_pos": [2022, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 image2 f s (\u22c3 i, \u22c3 j, t i j) = \u22c3 i, \u22c3 j, image2 f s (t i j)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Fin.lean", "full_name": "Fin.Iio_castSucc", "start": [66, 1], "end": [70, 42], "traced_tactics": [{"tactic": "apply Finset.map_injective Fin.valEmbedding", "annotated_tactic": ["apply <a>Finset.map_injective</a> <a>Fin.valEmbedding</a>", [{"full_name": "Finset.map_injective", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [176, 9], "def_end_pos": [176, 22]}, {"full_name": "Fin.valEmbedding", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [269, 5], "def_end_pos": [269, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 Iio (castSucc i) = map castSuccEmb.toEmbedding (Iio i)", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 map valEmbedding (Iio (castSucc i)) = map valEmbedding (map castSuccEmb.toEmbedding (Iio i))"}, {"tactic": "rw [Finset.map_map, Fin.map_valEmbedding_Iio]", "annotated_tactic": ["rw [<a>Finset.map_map</a>, <a>Fin.map_valEmbedding_Iio</a>]", [{"full_name": "Finset.map_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [140, 9], "def_end_pos": [140, 16]}, {"full_name": "Fin.map_valEmbedding_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Interval.lean", "def_pos": [211, 9], "def_end_pos": [211, 29]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 map valEmbedding (Iio (castSucc i)) = map valEmbedding (map castSuccEmb.toEmbedding (Iio i))", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 Iio \u2191(castSucc i) = map (Function.Embedding.trans castSuccEmb.toEmbedding valEmbedding) (Iio i)"}, {"tactic": "exact (Fin.map_valEmbedding_Iio i).symm", "annotated_tactic": ["exact (<a>Fin.map_valEmbedding_Iio</a> i).<a>symm</a>", [{"full_name": "Fin.map_valEmbedding_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Interval.lean", "def_pos": [211, 9], "def_end_pos": [211, 29]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 Iio \u2191(castSucc i) = map (Function.Embedding.trans castSuccEmb.toEmbedding valEmbedding) (Iio i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "WithTop.Ico_coe_top", "start": [1143, 1], "end": [1144, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Order.lean", "full_name": "Finsupp.le_iff'", "start": [166, 1], "end": [169, 98], "traced_tactics": [{"tactic": "classical exact\n    if H : s \u2208 f.support then h s (hf H) else (not_mem_support_iff.1 H).symm \u25b8 zero_le (g s)", "annotated_tactic": ["classical exact\n        if H : s \u2208 f.support then h s (hf H) else (<a>not_mem_support_iff</a>.1 H).<a>symm</a> \u25b8 <a>zero_le</a> (g s)", [{"full_name": "Finsupp.not_mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [195, 9], "def_end_pos": [195, 28]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}, {"full_name": "zero_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [217, 30], "def_end_pos": [217, 37]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CanonicallyOrderedAddCommMonoid \u03b1\nf\u271d g\u271d f g : \u03b9 \u2192\u2080 \u03b1\ns\u271d : Finset \u03b9\nhf : f.support \u2286 s\u271d\nh : \u2200 i \u2208 s\u271d, \u2191f i \u2264 \u2191g i\ns : \u03b9\n\u22a2 \u2191f s \u2264 \u2191g s", "state_after": "no goals"}, {"tactic": "exact\nif H : s \u2208 f.support then h s (hf H) else (not_mem_support_iff.1 H).symm \u25b8 zero_le (g s)", "annotated_tactic": ["exact\n        if H : s \u2208 f.support then h s (hf H) else (<a>not_mem_support_iff</a>.1 H).<a>symm</a> \u25b8 <a>zero_le</a> (g s)", [{"full_name": "Finsupp.not_mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [195, 9], "def_end_pos": [195, 28]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}, {"full_name": "zero_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [217, 30], "def_end_pos": [217, 37]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CanonicallyOrderedAddCommMonoid \u03b1\nf\u271d g\u271d f g : \u03b9 \u2192\u2080 \u03b1\ns\u271d : Finset \u03b9\nhf : f.support \u2286 s\u271d\nh : \u2200 i \u2208 s\u271d, \u2191f i \u2264 \u2191g i\ns : \u03b9\n\u22a2 \u2191f s \u2264 \u2191g s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "GaloisConnection.l_comm_iff_u_comm", "start": [369, 1], "end": [375, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Subtype.lean", "full_name": "Subtype.val_injective", "start": [122, 1], "end": [123, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finite/Basic.lean", "full_name": "Finite.sum_right", "start": [90, 1], "end": [91, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Int/Basic.lean", "full_name": "Int.coprime_iff_nat_coprime", "start": [201, 1], "end": [202, 75], "traced_tactics": [{"tactic": "rw [\u2190 gcd_eq_one_iff_coprime, Nat.coprime_iff_gcd_eq_one, gcd_eq_natAbs]", "annotated_tactic": ["rw [\u2190 <a>gcd_eq_one_iff_coprime</a>, <a>Nat.coprime_iff_gcd_eq_one</a>, <a>gcd_eq_natAbs</a>]", [{"full_name": "Int.gcd_eq_one_iff_coprime", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Int/Basic.lean", "def_pos": [185, 9], "def_end_pos": [185, 31]}, {"full_name": "Nat.coprime_iff_gcd_eq_one", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [255, 9], "def_end_pos": [255, 31]}, {"full_name": "Int.gcd_eq_natAbs", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Int/Basic.lean", "def_pos": [181, 9], "def_end_pos": [181, 22]}]], "state_before": "a b : \u2124\n\u22a2 IsCoprime a b \u2194 Nat.Coprime (natAbs a) (natAbs b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.floor_add_one", "start": [454, 1], "end": [456, 37], "traced_tactics": [{"tactic": "rw [\u2190cast_one, floor_add_nat ha 1]", "annotated_tactic": ["rw [\u2190<a>cast_one</a>, <a>floor_add_nat</a> ha 1]", [{"full_name": "Nat.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [147, 9], "def_end_pos": [147, 17]}, {"full_name": "Nat.floor_add_nat", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [441, 9], "def_end_pos": [441, 22]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na : \u03b1\nn : \u2115\nha : 0 \u2264 a\n\u22a2 \u230aa + 1\u230b\u208a = \u230aa\u230b\u208a + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.diff_iInter", "start": [686, 1], "end": [687, 48], "traced_tactics": [{"tactic": "rw [diff_eq, compl_iInter, inter_iUnion]", "annotated_tactic": ["rw [<a>diff_eq</a>, <a>compl_iInter</a>, <a>inter_iUnion</a>]", [{"full_name": "Set.diff_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1807, 9], "def_end_pos": [1807, 16]}, {"full_name": "Set.compl_iInter", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [615, 9], "def_end_pos": [615, 21]}, {"full_name": "Set.inter_iUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [635, 9], "def_end_pos": [635, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ns : Set \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 s \\ \u22c2 i, t i = \u22c3 i, s \\ t i", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ns : Set \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c3 i, s \u2229 (t i)\u1d9c = \u22c3 i, s \\ t i"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ns : Set \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c3 i, s \u2229 (t i)\u1d9c = \u22c3 i, s \\ t i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.natAdd_natAdd", "start": [460, 1], "end": [462, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Lattice.lean", "full_name": "Nat.iInf_lt_succ'", "start": [198, 1], "end": [199, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.toOption_eq_none_iff", "start": [307, 1], "end": [308, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "AddAction.stabilizer_vadd_eq_stabilizer_map_conj", "start": [487, 1], "end": [492, 28], "traced_tactics": [{"tactic": "ext h", "annotated_tactic": ["ext h", []], "state_before": "G : Type u\ninst\u271d\u00b9 : AddGroup G\n\u03b1 : Type v\ninst\u271d : AddAction G \u03b1\ng : G\na : \u03b1\n\u22a2 stabilizer G (g +\u1d65 a) = AddSubgroup.map (AddEquiv.toAddMonoidHom (\u2191AddAut.conj g)) (stabilizer G a)", "state_after": "case h\nG : Type u\ninst\u271d\u00b9 : AddGroup G\n\u03b1 : Type v\ninst\u271d : AddAction G \u03b1\ng : G\na : \u03b1\nh : G\n\u22a2 h \u2208 stabilizer G (g +\u1d65 a) \u2194 h \u2208 AddSubgroup.map (AddEquiv.toAddMonoidHom (\u2191AddAut.conj g)) (stabilizer G a)"}, {"tactic": "rw [mem_stabilizer_iff, \u2190 vadd_left_cancel_iff (-g), vadd_vadd, vadd_vadd, vadd_vadd,\n  add_left_neg, zero_vadd, \u2190 mem_stabilizer_iff, AddSubgroup.mem_map_equiv,\n  AddAut.conj_symm_apply]", "annotated_tactic": ["rw [<a>mem_stabilizer_iff</a>, \u2190 <a>vadd_left_cancel_iff</a> (-g), <a>vadd_vadd</a>, <a>vadd_vadd</a>, <a>vadd_vadd</a>,\n    <a>add_left_neg</a>, <a>zero_vadd</a>, \u2190 <a>mem_stabilizer_iff</a>, <a>AddSubgroup.mem_map_equiv</a>,\n    <a>AddAut.conj_symm_apply</a>]", [{"full_name": "AddAction.mem_stabilizer_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Basic.lean", "def_pos": [454, 3], "def_end_pos": [454, 14]}, {"full_name": "vadd_left_cancel_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [167, 3], "def_end_pos": [167, 14]}, {"full_name": "vadd_vadd", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [483, 3], "def_end_pos": [483, 14]}, {"full_name": "vadd_vadd", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [483, 3], "def_end_pos": [483, 14]}, {"full_name": "vadd_vadd", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [483, 3], "def_end_pos": [483, 14]}, {"full_name": "add_left_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1118, 3], "def_end_pos": [1118, 14]}, {"full_name": "zero_vadd", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [491, 3], "def_end_pos": [491, 14]}, {"full_name": "AddAction.mem_stabilizer_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Basic.lean", "def_pos": [454, 3], "def_end_pos": [454, 14]}, {"full_name": "AddSubgroup.mem_map_equiv", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1478, 3], "def_end_pos": [1478, 14]}, {"full_name": "AddAut.conj_symm_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Aut.lean", "def_pos": [290, 9], "def_end_pos": [290, 24]}]], "state_before": "case h\nG : Type u\ninst\u271d\u00b9 : AddGroup G\n\u03b1 : Type v\ninst\u271d : AddAction G \u03b1\ng : G\na : \u03b1\nh : G\n\u22a2 h \u2208 stabilizer G (g +\u1d65 a) \u2194 h \u2208 AddSubgroup.map (AddEquiv.toAddMonoidHom (\u2191AddAut.conj g)) (stabilizer G a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "isGLB_ciInf_set", "start": [522, 1], "end": [524, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.Eventually.prod_inl", "start": [151, 1], "end": [153, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Succ.rec", "start": [1392, 1], "end": [1398, 55], "traced_tactics": [{"tactic": "obtain \u27e8n, rfl\u27e9 := hmn.exists_succ_iterate", "annotated_tactic": ["obtain \u27e8n, rfl\u27e9 := hmn.exists_succ_iterate", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u03b1\nhmn : m \u2264 n\n\u22a2 P n", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\nhmn : m \u2264 succ^[n] m\n\u22a2 P (succ^[n] m)"}, {"tactic": "clear hmn", "annotated_tactic": ["clear hmn", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\nhmn : m \u2264 succ^[n] m\n\u22a2 P (succ^[n] m)", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\n\u22a2 P (succ^[n] m)"}, {"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\n\u22a2 P (succ^[n] m)", "state_after": "case intro.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\n\u22a2 P (succ^[Nat.zero] m)\n\ncase intro.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\nih : P (succ^[n] m)\n\u22a2 P (succ^[Nat.succ n] m)"}, {"tactic": "exact h0", "annotated_tactic": ["exact h0", []], "state_before": "case intro.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\n\u22a2 P (succ^[Nat.zero] m)", "state_after": "no goals"}, {"tactic": "rw [Function.iterate_succ_apply']", "annotated_tactic": ["rw [<a>Function.iterate_succ_apply'</a>]", [{"full_name": "Function.iterate_succ_apply'", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [190, 9], "def_end_pos": [190, 28]}]], "state_before": "case intro.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\nih : P (succ^[n] m)\n\u22a2 P (succ^[Nat.succ n] m)", "state_after": "case intro.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\nih : P (succ^[n] m)\n\u22a2 P (succ (succ^[n] m))"}, {"tactic": "exact h1 _ (id_le_iterate_of_id_le le_succ n m) ih", "annotated_tactic": ["exact h1 _ (<a>id_le_iterate_of_id_le</a> <a>le_succ</a> n m) ih", [{"full_name": "Function.id_le_iterate_of_id_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Iterate.lean", "def_pos": [137, 9], "def_end_pos": [137, 31]}, {"full_name": "Order.le_succ", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}]], "state_before": "case intro.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\na b : \u03b1\nP : \u03b1 \u2192 Prop\nm : \u03b1\nh0 : P m\nh1 : \u2200 (n : \u03b1), m \u2264 n \u2192 P n \u2192 P (succ n)\nn : \u2115\nih : P (succ^[n] m)\n\u22a2 P (succ (succ^[n] m))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.inter_mem_inter", "start": [825, 1], "end": [826, 50], "traced_tactics": [{"tactic": "simp [inter_def]", "annotated_tactic": ["simp [<a>inter_def</a>]", [{"full_name": "Part.inter_def", "def_path": "lake-packages/mathlib/Mathlib/Data/Part.lean", "def_pos": [707, 9], "def_end_pos": [707, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Inter \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 ma \u2229 mb \u2208 a \u2229 b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Inter \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 \u2229 a = ma \u2229 mb"}, {"tactic": "aesop", "annotated_tactic": ["aesop", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Inter \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 \u2229 a = ma \u2229 mb", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.coeff_injective", "start": [673, 1], "end": [676, 66], "traced_tactics": [{"tactic": "rintro \u27e8p\u27e9 \u27e8q\u27e9", "annotated_tactic": ["rintro \u27e8p\u27e9 \u27e8q\u27e9", []], "state_before": "R : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 Injective coeff", "state_after": "case ofFinsupp.ofFinsupp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d : R[X]\np q : R[\u2115]\n\u22a2 coeff { toFinsupp := p } = coeff { toFinsupp := q } \u2192 { toFinsupp := p } = { toFinsupp := q }"}, {"tactic": "simp only [coeff, FunLike.coe_fn_eq, imp_self, ofFinsupp.injEq]", "annotated_tactic": ["simp only [<a>coeff</a>, <a>FunLike.coe_fn_eq</a>, <a>imp_self</a>, ofFinsupp.injEq]", [{"full_name": "Polynomial.coeff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [665, 5], "def_end_pos": [665, 10]}, {"full_name": "FunLike.coe_fn_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [165, 9], "def_end_pos": [165, 18]}, {"full_name": "imp_self", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [122, 17], "def_end_pos": [122, 25]}]], "state_before": "case ofFinsupp.ofFinsupp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d : R[X]\np q : R[\u2115]\n\u22a2 coeff { toFinsupp := p } = coeff { toFinsupp := q } \u2192 { toFinsupp := p } = { toFinsupp := q }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "self_ne_mul_left", "start": [228, 1], "end": [228, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/LocallyFinite.lean", "full_name": "Finset.filter_lt_lt_eq_Ioo", "start": [375, 1], "end": [378, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidablePred fun j => a < j \u2227 j < b\n\u22a2 filter (fun j => a < j \u2227 j < b) univ = Ioo a b", "state_after": "case a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidablePred fun j => a < j \u2227 j < b\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 filter (fun j => a < j \u2227 j < b) univ \u2194 a\u271d \u2208 Ioo a b"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidablePred fun j => a < j \u2227 j < b\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 filter (fun j => a < j \u2227 j < b) univ \u2194 a\u271d \u2208 Ioo a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Submodule.IsPrincipal.mem_iff_generator_dvd", "start": [132, 1], "end": [133, 99], "traced_tactics": [{"tactic": "simp only [mul_comm, smul_eq_mul]", "annotated_tactic": ["simp only [<a>mul_comm</a>, <a>smul_eq_mul</a>]", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "smul_eq_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nS : Ideal R\ninst\u271d : IsPrincipal S\nx a : R\n\u22a2 x = a \u2022 generator S \u2194 x = generator S * a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.mul_assoc", "start": [398, 11], "end": [399, 59], "traced_tactics": [{"tactic": "cases a <;> cases b <;> cases c <;> simp [Nat.mul_assoc]", "annotated_tactic": ["cases a <;> cases b <;> cases c <;> simp [<a>Nat.mul_assoc</a>]", [{"full_name": "Nat.mul_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [198, 19], "def_end_pos": [198, 28]}]], "state_before": "a b c : Int\n\u22a2 a * b * c = a * (b * c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.eta", "start": [85, 1], "end": [86, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.frequently_and_distrib_left", "start": [1390, 1], "end": [1392, 79], "traced_tactics": [{"tactic": "simp only [Filter.Frequently, not_and, eventually_imp_distrib_left, not_imp]", "annotated_tactic": ["simp only [<a>Filter.Frequently</a>, <a>not_and</a>, <a>eventually_imp_distrib_left</a>, <a>not_imp</a>]", [{"full_name": "Filter.Frequently", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1259, 15], "def_end_pos": [1259, 25]}, {"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}, {"full_name": "Filter.eventually_imp_distrib_left", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1207, 9], "def_end_pos": [1207, 36]}, {"full_name": "not_imp", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [430, 9], "def_end_pos": [430, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : Filter \u03b1\np : Prop\nq : \u03b1 \u2192 Prop\n\u22a2 (\u2203\u1da0 (x : \u03b1) in f, p \u2227 q x) \u2194 p \u2227 \u2203\u1da0 (x : \u03b1) in f, q x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Dedup.lean", "full_name": "List.count_dedup", "start": [142, 1], "end": [143, 58], "traced_tactics": [{"tactic": "simp_rw [count_eq_of_nodup <| nodup_dedup l, mem_dedup]", "annotated_tactic": ["simp_rw [<a>count_eq_of_nodup</a> <| <a>nodup_dedup</a> l, <a>mem_dedup</a>]", [{"full_name": "List.count_eq_of_nodup", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Nodup.lean", "def_pos": [200, 9], "def_end_pos": [200, 26]}, {"full_name": "List.nodup_dedup", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Dedup.lean", "def_pos": [72, 9], "def_end_pos": [72, 20]}, {"full_name": "List.mem_dedup", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Dedup.lean", "def_pos": [44, 9], "def_end_pos": [44, 18]}]], "state_before": "\u03b1 : Type u\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\na : \u03b1\n\u22a2 count a (dedup l) = if a \u2208 l then 1 else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.singleton_eq_cons_iff", "start": [359, 1], "end": [361, 17], "traced_tactics": [{"tactic": "rw [\u2190 cons_zero, cons_eq_cons]", "annotated_tactic": ["rw [\u2190 <a>cons_zero</a>, <a>cons_eq_cons</a>]", [{"full_name": "Multiset.cons_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [328, 9], "def_end_pos": [328, 18]}, {"full_name": "Multiset.cons_eq_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [294, 9], "def_end_pos": [294, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na b : \u03b1\nm : Multiset \u03b1\n\u22a2 {a} = b ::\u2098 m \u2194 a = b \u2227 m = 0", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na b : \u03b1\nm : Multiset \u03b1\n\u22a2 (a = b \u2227 0 = m \u2228 a \u2260 b \u2227 \u2203 cs, 0 = b ::\u2098 cs \u2227 m = a ::\u2098 cs) \u2194 a = b \u2227 m = 0"}, {"tactic": "simp [eq_comm]", "annotated_tactic": ["simp [<a>eq_comm</a>]", [{"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na b : \u03b1\nm : Multiset \u03b1\n\u22a2 (a = b \u2227 0 = m \u2228 a \u2260 b \u2227 \u2203 cs, 0 = b ::\u2098 cs \u2227 m = a ::\u2098 cs) \u2194 a = b \u2227 m = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.bUnion_ptsOfPeriod", "start": [247, 1], "end": [248, 45], "traced_tactics": [{"tactic": "simp [mem_periodicPts]", "annotated_tactic": ["simp [<a>mem_periodicPts</a>]", [{"full_name": "Function.mem_periodicPts", "def_path": "lake-packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean", "def_pos": [229, 9], "def_end_pos": [229, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx\u271d y : \u03b1\nm n : \u2115\nx : \u03b1\n\u22a2 x \u2208 \u22c3 n, \u22c3 (_ : n > 0), ptsOfPeriod f n \u2194 x \u2208 periodicPts f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "NonUnitalRingHom.coe_one", "start": [309, 1], "end": [310, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.prod_ne_zero", "start": [1074, 1], "end": [1074, 98], "traced_tactics": [{"tactic": "simp [prod_eq_zero]", "annotated_tactic": ["simp [<a>prod_eq_zero</a>]", [{"full_name": "Cardinal.prod_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1069, 9], "def_end_pos": [1069, 21]}]], "state_before": "\u03b1 \u03b2 : Type u\n\u03b9 : Type u_1\nf : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 prod f \u2260 0 \u2194 \u2200 (i : \u03b9), f i \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.not_isPeriodicPt_of_pos_of_lt_minimalPeriod", "start": [389, 1], "end": [392, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/BilinearMap.lean", "full_name": "LinearMap.mk\u2082'\u209b\u2097_apply", "start": [92, 1], "end": [93, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.refl_trans", "start": [339, 9], "end": [339, 87], "traced_tactics": [{"tactic": "cases e", "annotated_tactic": ["cases e", []], "state_before": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\ne : \u03b1 \u2243 \u03b2\n\u22a2 (Equiv.refl \u03b1).trans e = e", "state_after": "case mk\n\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\ntoFun\u271d : \u03b1 \u2192 \u03b2\ninvFun\u271d : \u03b2 \u2192 \u03b1\nleft_inv\u271d : LeftInverse invFun\u271d toFun\u271d\nright_inv\u271d : Function.RightInverse invFun\u271d toFun\u271d\n\u22a2 (Equiv.refl \u03b1).trans { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d } =\n    { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d }"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\n\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\ntoFun\u271d : \u03b1 \u2192 \u03b2\ninvFun\u271d : \u03b2 \u2192 \u03b1\nleft_inv\u271d : LeftInverse invFun\u271d toFun\u271d\nright_inv\u271d : Function.RightInverse invFun\u271d toFun\u271d\n\u22a2 (Equiv.refl \u03b1).trans { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d } =\n    { toFun := toFun\u271d, invFun := invFun\u271d, left_inv := left_inv\u271d, right_inv := right_inv\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Nodup.lean", "full_name": "List.nodup_join", "start": [329, 1], "end": [331, 70], "traced_tactics": [{"tactic": "simp only [Nodup, pairwise_join, disjoint_left.symm, forall_mem_ne]", "annotated_tactic": ["simp only [<a>Nodup</a>, <a>pairwise_join</a>, disjoint_left.symm, <a>forall_mem_ne</a>]", [{"full_name": "List.Nodup", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1192, 5], "def_end_pos": [1192, 10]}, {"full_name": "List.pairwise_join", "def_path": "lake-packages/std/Std/Data/List/Pairwise.lean", "def_pos": [156, 9], "def_end_pos": [156, 22]}, {"full_name": "List.forall_mem_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Nodup.lean", "def_pos": [30, 9], "def_end_pos": [30, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nL : List (List \u03b1)\n\u22a2 Nodup (join L) \u2194 (\u2200 l \u2208 L, Nodup l) \u2227 Pairwise Disjoint L", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "forall\u2084_congr", "start": [407, 1], "end": [409, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.mem_coprod_iff", "start": [478, 1], "end": [480, 23], "traced_tactics": [{"tactic": "simp [Filter.coprod]", "annotated_tactic": ["simp [<a>Filter.coprod</a>]", [{"full_name": "Filter.coprod", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Prod.lean", "def_pos": [474, 15], "def_end_pos": [474, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\nf\u271d : Filter \u03b1\ng\u271d : Filter \u03b2\ns : Set (\u03b1 \u00d7 \u03b2)\nf : Filter \u03b1\ng : Filter \u03b2\n\u22a2 s \u2208 Filter.coprod f g \u2194 (\u2203 t\u2081 \u2208 f, Prod.fst \u207b\u00b9' t\u2081 \u2286 s) \u2227 \u2203 t\u2082 \u2208 g, Prod.snd \u207b\u00b9' t\u2082 \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Subsemiring.map_id", "start": [566, 1], "end": [567, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/List.lean", "full_name": "Set.range_list_getI", "start": [63, 1], "end": [64, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Logic.lean", "full_name": "or_comm'", "start": [168, 23], "end": [168, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/Basic.lean", "full_name": "Std.RBNode.cmpLT_iff", "start": [238, 1], "end": [238, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Set.lean", "full_name": "Equiv.Set.union_symm_apply_left", "start": [250, 1], "end": [252, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/Cast/CharZero.lean", "full_name": "Rat.cast_ne_zero", "start": [49, 1], "end": [50, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "UniqueFactorizationMonoid.normalizedFactors_mul", "start": [658, 1], "end": [677, 58], "traced_tactics": [{"tactic": "have h : (normalize : \u03b1 \u2192 \u03b1) = Associates.out \u2218 Associates.mk := by\n  ext\n  rw [Function.comp_apply, Associates.out_mk]", "annotated_tactic": ["have h : (<a>normalize</a> : \u03b1 \u2192 \u03b1) = <a>Associates.out</a> \u2218 <a>Associates.mk</a> := by\n    ext\n    rw [<a>Function.comp_apply</a>, <a>Associates.out_mk</a>]", [{"full_name": "normalize", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [100, 5], "def_end_pos": [100, 14]}, {"full_name": "Associates.out", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [214, 15], "def_end_pos": [214, 18]}, {"full_name": "Associates.mk", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [762, 18], "def_end_pos": [762, 20]}, {"full_name": "Function.comp_apply", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [33, 17], "def_end_pos": [33, 36]}, {"full_name": "Associates.out_mk", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [220, 9], "def_end_pos": [220, 15]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 normalizedFactors (x * y) = normalizedFactors x + normalizedFactors y", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 normalizedFactors (x * y) = normalizedFactors x + normalizedFactors y"}, {"tactic": "rw [\u2190 Multiset.map_id' (normalizedFactors (x * y)), \u2190 Multiset.map_id' (normalizedFactors x), \u2190\n  Multiset.map_id' (normalizedFactors y), \u2190 Multiset.map_congr rfl normalize_normalized_factor, \u2190\n  Multiset.map_congr rfl normalize_normalized_factor, \u2190\n  Multiset.map_congr rfl normalize_normalized_factor, \u2190 Multiset.map_add, h, \u2190\n  Multiset.map_map Associates.out, eq_comm, \u2190 Multiset.map_map Associates.out]", "annotated_tactic": ["rw [\u2190 <a>Multiset.map_id'</a> (<a>normalizedFactors</a> (x * y)), \u2190 <a>Multiset.map_id'</a> (<a>normalizedFactors</a> x), \u2190\n    <a>Multiset.map_id'</a> (<a>normalizedFactors</a> y), \u2190 <a>Multiset.map_congr</a> <a>rfl</a> <a>normalize_normalized_factor</a>, \u2190\n    <a>Multiset.map_congr</a> <a>rfl</a> <a>normalize_normalized_factor</a>, \u2190\n    <a>Multiset.map_congr</a> <a>rfl</a> <a>normalize_normalized_factor</a>, \u2190 <a>Multiset.map_add</a>, h, \u2190\n    <a>Multiset.map_map</a> <a>Associates.out</a>, <a>eq_comm</a>, \u2190 <a>Multiset.map_map</a> <a>Associates.out</a>]", [{"full_name": "Multiset.map_id'", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1296, 9], "def_end_pos": [1296, 16]}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [545, 19], "def_end_pos": [545, 36]}, {"full_name": "Multiset.map_id'", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1296, 9], "def_end_pos": [1296, 16]}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [545, 19], "def_end_pos": [545, 36]}, {"full_name": "Multiset.map_id'", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1296, 9], "def_end_pos": [1296, 16]}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [545, 19], "def_end_pos": [545, 36]}, {"full_name": "Multiset.map_congr", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1151, 9], "def_end_pos": [1151, 18]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "UniqueFactorizationMonoid.normalize_normalized_factor", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [584, 9], "def_end_pos": [584, 36]}, {"full_name": "Multiset.map_congr", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1151, 9], "def_end_pos": [1151, 18]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "UniqueFactorizationMonoid.normalize_normalized_factor", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [584, 9], "def_end_pos": [584, 36]}, {"full_name": "Multiset.map_congr", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1151, 9], "def_end_pos": [1151, 18]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "UniqueFactorizationMonoid.normalize_normalized_factor", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [584, 9], "def_end_pos": [584, 36]}, {"full_name": "Multiset.map_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1200, 9], "def_end_pos": [1200, 16]}, {"full_name": "Multiset.map_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1287, 9], "def_end_pos": [1287, 16]}, {"full_name": "Associates.out", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [214, 15], "def_end_pos": [214, 18]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}, {"full_name": "Multiset.map_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1287, 9], "def_end_pos": [1287, 16]}, {"full_name": "Associates.out", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [214, 15], "def_end_pos": [214, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 normalizedFactors (x * y) = normalizedFactors x + normalizedFactors y", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.map Associates.out (Multiset.map Associates.mk (normalizedFactors x + normalizedFactors y)) =\n    Multiset.map Associates.out (Multiset.map Associates.mk (normalizedFactors (x * y)))"}, {"tactic": "refine' congr rfl _", "annotated_tactic": ["refine' <a>congr</a> <a>rfl</a> _", [{"full_name": "congr", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [359, 9], "def_end_pos": [359, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.map Associates.out (Multiset.map Associates.mk (normalizedFactors x + normalizedFactors y)) =\n    Multiset.map Associates.out (Multiset.map Associates.mk (normalizedFactors (x * y)))", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.map Associates.mk (normalizedFactors x + normalizedFactors y) =\n    Multiset.map Associates.mk (normalizedFactors (x * y))"}, {"tactic": "apply Multiset.map_mk_eq_map_mk_of_rel", "annotated_tactic": ["apply <a>Multiset.map_mk_eq_map_mk_of_rel</a>", [{"full_name": "Multiset.map_mk_eq_map_mk_of_rel", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2881, 9], "def_end_pos": [2881, 32]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.map Associates.mk (normalizedFactors x + normalizedFactors y) =\n    Multiset.map Associates.mk (normalizedFactors (x * y))", "state_after": "case hst\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.Rel Setoid.r (normalizedFactors x + normalizedFactors y) (normalizedFactors (x * y))"}, {"tactic": "apply factors_unique", "annotated_tactic": ["apply <a>factors_unique</a>", [{"full_name": "UniqueFactorizationMonoid.factors_unique", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [240, 9], "def_end_pos": [240, 23]}]], "state_before": "case hst\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.Rel Setoid.r (normalizedFactors x + normalizedFactors y) (normalizedFactors (x * y))", "state_after": "case hst.hf\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 \u2200 x_1 \u2208 normalizedFactors x + normalizedFactors y, Irreducible x_1\n\ncase hst.hg\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 \u2200 x_1 \u2208 normalizedFactors (x * y), Irreducible x_1\n\ncase hst.h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.prod (normalizedFactors x + normalizedFactors y) ~\u1d64 Multiset.prod (normalizedFactors (x * y))"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 \u2191normalize = Associates.out \u2218 Associates.mk", "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nx\u271d : \u03b1\n\u22a2 \u2191normalize x\u271d = (Associates.out \u2218 Associates.mk) x\u271d"}, {"tactic": "rw [Function.comp_apply, Associates.out_mk]", "annotated_tactic": ["rw [<a>Function.comp_apply</a>, <a>Associates.out_mk</a>]", [{"full_name": "Function.comp_apply", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [33, 17], "def_end_pos": [33, 36]}, {"full_name": "Associates.out_mk", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [220, 9], "def_end_pos": [220, 15]}]], "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nx\u271d : \u03b1\n\u22a2 \u2191normalize x\u271d = (Associates.out \u2218 Associates.mk) x\u271d", "state_after": "no goals"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "case hst.hf\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 \u2200 x_1 \u2208 normalizedFactors x + normalizedFactors y, Irreducible x_1", "state_after": "case hst.hf\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d y : \u03b1\nhx\u271d : x\u271d \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\nx : \u03b1\nhx : x \u2208 normalizedFactors x\u271d + normalizedFactors y\n\u22a2 Irreducible x"}, {"tactic": "rcases Multiset.mem_add.1 hx with (hx | hx) <;> exact irreducible_of_normalized_factor x hx", "annotated_tactic": ["rcases <a>Multiset.mem_add</a>.1 hx with (hx | hx) <;> exact <a>irreducible_of_normalized_factor</a> x hx", [{"full_name": "Multiset.mem_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [683, 9], "def_end_pos": [683, 16]}, {"full_name": "UniqueFactorizationMonoid.irreducible_of_normalized_factor", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [579, 9], "def_end_pos": [579, 41]}]], "state_before": "case hst.hf\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx\u271d y : \u03b1\nhx\u271d : x\u271d \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\nx : \u03b1\nhx : x \u2208 normalizedFactors x\u271d + normalizedFactors y\n\u22a2 Irreducible x", "state_after": "no goals"}, {"tactic": "exact irreducible_of_normalized_factor", "annotated_tactic": ["exact <a>irreducible_of_normalized_factor</a>", [{"full_name": "UniqueFactorizationMonoid.irreducible_of_normalized_factor", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [579, 9], "def_end_pos": [579, 41]}]], "state_before": "case hst.hg\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 \u2200 x_1 \u2208 normalizedFactors (x * y), Irreducible x_1", "state_after": "no goals"}, {"tactic": "rw [Multiset.prod_add]", "annotated_tactic": ["rw [<a>Multiset.prod_add</a>]", [{"full_name": "Multiset.prod_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [115, 9], "def_end_pos": [115, 17]}]], "state_before": "case hst.h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.prod (normalizedFactors x + normalizedFactors y) ~\u1d64 Multiset.prod (normalizedFactors (x * y))", "state_after": "case hst.h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.prod (normalizedFactors x) * Multiset.prod (normalizedFactors y) ~\u1d64 Multiset.prod (normalizedFactors (x * y))"}, {"tactic": "exact\n  ((normalizedFactors_prod hx).mul_mul (normalizedFactors_prod hy)).trans\n    (normalizedFactors_prod (mul_ne_zero hx hy)).symm", "annotated_tactic": ["exact\n      ((<a>normalizedFactors_prod</a> hx).<a>mul_mul</a> (<a>normalizedFactors_prod</a> hy)).<a>trans</a>\n        (<a>normalizedFactors_prod</a> (<a>mul_ne_zero</a> hx hy)).<a>symm</a>", [{"full_name": "UniqueFactorizationMonoid.normalizedFactors_prod", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [560, 9], "def_end_pos": [560, 31]}, {"full_name": "Associated.mul_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [523, 9], "def_end_pos": [523, 27]}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_prod", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [560, 9], "def_end_pos": [560, 31]}, {"full_name": "Associated.trans", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [410, 19], "def_end_pos": [410, 24]}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_prod", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [560, 9], "def_end_pos": [560, 31]}, {"full_name": "mul_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [88, 9], "def_end_pos": [88, 20]}, {"full_name": "Associated.symm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [398, 19], "def_end_pos": [398, 23]}]], "state_before": "case hst.h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : NormalizationMonoid \u03b1\ninst\u271d : UniqueFactorizationMonoid \u03b1\nx y : \u03b1\nhx : x \u2260 0\nhy : y \u2260 0\nh : \u2191normalize = Associates.out \u2218 Associates.mk\n\u22a2 Multiset.prod (normalizedFactors x) * Multiset.prod (normalizedFactors y) ~\u1d64 Multiset.prod (normalizedFactors (x * y))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Iterate.lean", "full_name": "Function.Commute.iterate_right", "start": [137, 1], "end": [138, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/LinearCombination.lean", "full_name": "Mathlib.Tactic.LinearCombination.mul_pf", "start": [48, 1], "end": [48, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "full_name": "Subgroup.smul_mem_pointwise_smul", "start": [287, 1], "end": [288, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.toLin_self", "start": [606, 1], "end": [615, 18], "traced_tactics": [{"tactic": "rw [Matrix.toLin_apply, Finset.sum_congr rfl fun j _hj => ?_]", "annotated_tactic": ["rw [<a>Matrix.toLin_apply</a>, <a>Finset.sum_congr</a> <a>rfl</a> fun j _hj => ?_]", [{"full_name": "Matrix.toLin_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [599, 9], "def_end_pos": [599, 27]}, {"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\n\u22a2 \u2191(\u2191(toLin v\u2081 v\u2082) M) (\u2191v\u2081 i) = \u2211 j : m, M j i \u2022 \u2191v\u2082 j", "state_after": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\n\u22a2 mulVec M (\u2191(\u2191v\u2081.repr (\u2191v\u2081 i))) j \u2022 \u2191v\u2082 j = M j i \u2022 \u2191v\u2082 j"}, {"tactic": "rw [Basis.repr_self, Matrix.mulVec, dotProduct, Finset.sum_eq_single i, Finsupp.single_eq_same,\n  mul_one]", "annotated_tactic": ["rw [<a>Basis.repr_self</a>, <a>Matrix.mulVec</a>, <a>dotProduct</a>, <a>Finset.sum_eq_single</a> i, <a>Finsupp.single_eq_same</a>,\n    <a>mul_one</a>]", [{"full_name": "Basis.repr_self", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [148, 9], "def_end_pos": [148, 18]}, {"full_name": "Matrix.mulVec", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1688, 5], "def_end_pos": [1688, 11]}, {"full_name": "Matrix.dotProduct", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [748, 5], "def_end_pos": [748, 15]}, {"full_name": "Finset.sum_eq_single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [804, 3], "def_end_pos": [804, 14]}, {"full_name": "Finsupp.single_eq_same", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [324, 9], "def_end_pos": [324, 23]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\n\u22a2 mulVec M (\u2191(\u2191v\u2081.repr (\u2191v\u2081 i))) j \u2022 \u2191v\u2082 j = M j i \u2022 \u2191v\u2082 j", "state_after": "case h\u2080\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\n\u22a2 \u2200 b \u2208 Finset.univ, b \u2260 i \u2192 M j b * (\u2191fun\u2080 | i => 1) b = 0\n\ncase h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\n\u22a2 i \u2209 Finset.univ \u2192 M j i * (\u2191fun\u2080 | i => 1) i = 0"}, {"tactic": "intro i' _ i'_ne", "annotated_tactic": ["intro i' _ i'_ne", []], "state_before": "case h\u2080\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\n\u22a2 \u2200 b \u2208 Finset.univ, b \u2260 i \u2192 M j b * (\u2191fun\u2080 | i => 1) b = 0", "state_after": "case h\u2080\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\ni' : n\na\u271d : i' \u2208 Finset.univ\ni'_ne : i' \u2260 i\n\u22a2 M j i' * (\u2191fun\u2080 | i => 1) i' = 0"}, {"tactic": "rw [Finsupp.single_eq_of_ne i'_ne.symm, mul_zero]", "annotated_tactic": ["rw [<a>Finsupp.single_eq_of_ne</a> i'_ne.symm, <a>mul_zero</a>]", [{"full_name": "Finsupp.single_eq_of_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [329, 9], "def_end_pos": [329, 24]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}]], "state_before": "case h\u2080\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\ni' : n\na\u271d : i' \u2208 Finset.univ\ni'_ne : i' \u2260 i\n\u22a2 M j i' * (\u2191fun\u2080 | i => 1) i' = 0", "state_after": "no goals"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "case h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\n\u22a2 i \u2209 Finset.univ \u2192 M j i * (\u2191fun\u2080 | i => 1) i = 0", "state_after": "case h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\na\u271d : i \u2209 Finset.univ\n\u22a2 M j i * (\u2191fun\u2080 | i => 1) i = 0"}, {"tactic": "have := Finset.mem_univ i", "annotated_tactic": ["have := <a>Finset.mem_univ</a> i", [{"full_name": "Finset.mem_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 17]}]], "state_before": "case h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\na\u271d : i \u2209 Finset.univ\n\u22a2 M j i * (\u2191fun\u2080 | i => 1) i = 0", "state_after": "case h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\na\u271d : i \u2209 Finset.univ\nthis : i \u2208 Finset.univ\n\u22a2 M j i * (\u2191fun\u2080 | i => 1) i = 0"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "case h\u2081\nR : Type u_1\ninst\u271d\u2077 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2076 : Fintype n\ninst\u271d\u2075 : Fintype m\ninst\u271d\u2074 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b3 : AddCommMonoid M\u2081\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\u2081\ninst\u271d : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM : Matrix m n R\ni : n\nj : m\n_hj : j \u2208 Finset.univ\na\u271d : i \u2209 Finset.univ\nthis : i \u2208 Finset.univ\n\u22a2 M j i * (\u2191fun\u2080 | i => 1) i = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Directed.lean", "full_name": "exists_ge_ge", "start": [180, 1], "end": [181, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/Alter.lean", "full_name": "Std.RBSet.ModifyWF.of_eq", "start": [417, 1], "end": [421, 64], "traced_tactics": [{"tactic": "refine \u27e8.modify ?_ t.2\u27e9", "annotated_tactic": ["refine \u27e8.modify ?_ t.2\u27e9", []], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\ncut : \u03b1 \u2192 Ordering\nf : \u03b1 \u2192 \u03b1\nt : RBSet \u03b1 cmp\nH : \u2200 {x : \u03b1}, RBNode.find? cut t.val = some x \u2192 cmpEq cmp (f x) x\n\u22a2 ModifyWF t cut f", "state_after": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\ncut : \u03b1 \u2192 Ordering\nf : \u03b1 \u2192 \u03b1\nt : RBSet \u03b1 cmp\nH : \u2200 {x : \u03b1}, RBNode.find? cut t.val = some x \u2192 cmpEq cmp (f x) x\n\u22a2 OnRoot (fun x => cmpEq cmp (f x) x) (zoom cut t.val Path.root).fst"}, {"tactic": "revert H", "annotated_tactic": ["revert H", []], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\ncut : \u03b1 \u2192 Ordering\nf : \u03b1 \u2192 \u03b1\nt : RBSet \u03b1 cmp\nH : \u2200 {x : \u03b1}, RBNode.find? cut t.val = some x \u2192 cmpEq cmp (f x) x\n\u22a2 OnRoot (fun x => cmpEq cmp (f x) x) (zoom cut t.val Path.root).fst", "state_after": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\ncut : \u03b1 \u2192 Ordering\nf : \u03b1 \u2192 \u03b1\nt : RBSet \u03b1 cmp\n\u22a2 (\u2200 {x : \u03b1}, RBNode.find? cut t.val = some x \u2192 cmpEq cmp (f x) x) \u2192\n    OnRoot (fun x => cmpEq cmp (f x) x) (zoom cut t.val Path.root).fst"}, {"tactic": "rw [find?_eq_zoom]", "annotated_tactic": ["rw [<a>find?_eq_zoom</a>]", [{"full_name": "Std.RBNode.find?_eq_zoom", "def_path": "lake-packages/std/Std/Data/RBMap/Alter.lean", "def_pos": [405, 9], "def_end_pos": [405, 22]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\ncut : \u03b1 \u2192 Ordering\nf : \u03b1 \u2192 \u03b1\nt : RBSet \u03b1 cmp\n\u22a2 (\u2200 {x : \u03b1}, RBNode.find? cut t.val = some x \u2192 cmpEq cmp (f x) x) \u2192\n    OnRoot (fun x => cmpEq cmp (f x) x) (zoom cut t.val Path.root).fst", "state_after": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\ncut : \u03b1 \u2192 Ordering\nf : \u03b1 \u2192 \u03b1\nt : RBSet \u03b1 cmp\n\u22a2 (\u2200 {x : \u03b1}, root? (zoom cut t.val Path.root).fst = some x \u2192 cmpEq cmp (f x) x) \u2192\n    OnRoot (fun x => cmpEq cmp (f x) x) (zoom cut t.val Path.root).fst"}, {"tactic": "cases (t.1.zoom cut).1 <;> intro H <;> [trivial; exact H rfl]", "annotated_tactic": ["cases (t.1.<a>zoom</a> cut).1 <;> intro H <;> [trivial; exact H <a>rfl</a>]", [{"full_name": "Std.RBNode.zoom", "def_path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [451, 19], "def_end_pos": [451, 23]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\ncut : \u03b1 \u2192 Ordering\nf : \u03b1 \u2192 \u03b1\nt : RBSet \u03b1 cmp\n\u22a2 (\u2200 {x : \u03b1}, root? (zoom cut t.val Path.root).fst = some x \u2192 cmpEq cmp (f x) x) \u2192\n    OnRoot (fun x => cmpEq cmp (f x) x) (zoom cut t.val Path.root).fst", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SupIndep.lean", "full_name": "Finset.supIndep_univ_fin_two", "start": [157, 1], "end": [160, 21], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns t : Finset \u03b9\nf\u271d : \u03b9 \u2192 \u03b1\ni : \u03b9\nf : Fin 2 \u2192 \u03b1\n\u22a2 0 \u2260 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "himp_bihimp_right", "start": [593, 1], "end": [594, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "covby_congr_right", "start": [334, 1], "end": [335, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.roots_C", "start": [688, 1], "end": [693, 83], "traced_tactics": [{"tactic": "classical exact\nif H : x = 0 then by rw [H, C_0, roots_zero]\nelse\n  Multiset.ext.mpr fun r => (by\n    rw [count_roots, count_zero, rootMultiplicity_eq_zero (not_isRoot_C _ _ H)])", "annotated_tactic": ["classical exact\n  if H : x = 0 then by rw [H, <a>C_0</a>, <a>roots_zero</a>]\n  else\n    Multiset.ext.mpr fun r => (by\n      rw [<a>count_roots</a>, <a>count_zero</a>, <a>rootMultiplicity_eq_zero</a> (<a>not_isRoot_C</a> _ _ H)])", [{"full_name": "Polynomial.C_0", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [515, 9], "def_end_pos": [515, 12]}, {"full_name": "Polynomial.roots_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [556, 9], "def_end_pos": [556, 19]}, {"full_name": "Polynomial.count_roots", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [591, 9], "def_end_pos": [591, 20]}, {"full_name": "Multiset.count_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2365, 9], "def_end_pos": [2365, 19]}, {"full_name": "Polynomial.rootMultiplicity_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [612, 9], "def_end_pos": [612, 33]}, {"full_name": "Polynomial.not_isRoot_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [528, 9], "def_end_pos": [528, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nx : R\n\u22a2 roots (\u2191C x) = 0", "state_after": "no goals"}, {"tactic": "exact\nif H : x = 0 then by rw [H, C_0, roots_zero]\nelse\nMultiset.ext.mpr fun r => (by\nrw [count_roots, count_zero, rootMultiplicity_eq_zero (not_isRoot_C _ _ H)])", "annotated_tactic": ["exact\n  if H : x = 0 then by rw [H, <a>C_0</a>, <a>roots_zero</a>]\n  else\n    Multiset.ext.mpr fun r => (by\n      rw [<a>count_roots</a>, <a>count_zero</a>, <a>rootMultiplicity_eq_zero</a> (<a>not_isRoot_C</a> _ _ H)])", [{"full_name": "Polynomial.C_0", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [515, 9], "def_end_pos": [515, 12]}, {"full_name": "Polynomial.roots_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [556, 9], "def_end_pos": [556, 19]}, {"full_name": "Polynomial.count_roots", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [591, 9], "def_end_pos": [591, 20]}, {"full_name": "Multiset.count_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2365, 9], "def_end_pos": [2365, 19]}, {"full_name": "Polynomial.rootMultiplicity_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [612, 9], "def_end_pos": [612, 33]}, {"full_name": "Polynomial.not_isRoot_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [528, 9], "def_end_pos": [528, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nx : R\n\u22a2 roots (\u2191C x) = 0", "state_after": "no goals"}, {"tactic": "rw [H, C_0, roots_zero]", "annotated_tactic": ["rw [H, <a>C_0</a>, <a>roots_zero</a>]", [{"full_name": "Polynomial.C_0", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [515, 9], "def_end_pos": [515, 12]}, {"full_name": "Polynomial.roots_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [556, 9], "def_end_pos": [556, 19]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nx : R\nH : x = 0\n\u22a2 roots (\u2191C x) = 0", "state_after": "no goals"}, {"tactic": "rw [count_roots, count_zero, rootMultiplicity_eq_zero (not_isRoot_C _ _ H)]", "annotated_tactic": ["rw [<a>count_roots</a>, <a>count_zero</a>, <a>rootMultiplicity_eq_zero</a> (<a>not_isRoot_C</a> _ _ H)]", [{"full_name": "Polynomial.count_roots", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [591, 9], "def_end_pos": [591, 20]}, {"full_name": "Multiset.count_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2365, 9], "def_end_pos": [2365, 19]}, {"full_name": "Polynomial.rootMultiplicity_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [612, 9], "def_end_pos": [612, 33]}, {"full_name": "Polynomial.not_isRoot_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [528, 9], "def_end_pos": [528, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nx : R\nH : \u00acx = 0\nr : R\n\u22a2 count r (roots (\u2191C x)) = count r 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.uncurryRight_apply", "start": [1343, 1], "end": [1346, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Invertible/Defs.lean", "full_name": "invOf_one'", "start": [204, 1], "end": [205, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Pi.lean", "full_name": "LinearEquiv.sumArrowLequivProdArrow_apply_fst", "start": [447, 1], "end": [449, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "bddAbove_Iic", "start": [534, 1], "end": [535, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "eventuallyConst_of_isNoetherian", "start": [369, 1], "end": [372, 65], "traced_tactics": [{"tactic": "simp_rw [eventuallyConst_atTop, eq_comm]", "annotated_tactic": ["simp_rw [<a>eventuallyConst_atTop</a>, <a>eq_comm</a>]", [{"full_name": "Filter.eventuallyConst_atTop", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/EventuallyConst.lean", "def_pos": [152, 7], "def_end_pos": [152, 28]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type w\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192o Submodule R M\n\u22a2 EventuallyConst (\u2191f) atTop", "state_after": "R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type w\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192o Submodule R M\n\u22a2 \u2203 i, \u2200 (j : \u2115), i \u2264 j \u2192 \u2191f i = \u2191f j"}, {"tactic": "exact (monotone_stabilizes_iff_noetherian.mpr inferInstance) f", "annotated_tactic": ["exact (monotone_stabilizes_iff_noetherian.mpr <a>inferInstance</a>) f", [{"full_name": "inferInstance", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [86, 8], "def_end_pos": [86, 21]}]], "state_before": "R : Type u_1\nM : Type u_2\nP : Type u_3\nN : Type w\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 : AddCommMonoid P\ninst\u271d\u00b9 : Module R P\ninst\u271d : IsNoetherian R M\nf : \u2115 \u2192o Submodule R M\n\u22a2 \u2203 i, \u2200 (j : \u2115), i \u2264 j \u2192 \u2191f i = \u2191f j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Cast/Field.lean", "full_name": "Nat.one_div_lt_one_div", "start": [76, 1], "end": [79, 8], "traced_tactics": [{"tactic": "refine' one_div_lt_one_div_of_lt _ _", "annotated_tactic": ["refine' <a>one_div_lt_one_div_of_lt</a> _ _", [{"full_name": "one_div_lt_one_div_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [455, 9], "def_end_pos": [455, 33]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 1 / (\u2191m + 1) < 1 / (\u2191n + 1)", "state_after": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 0 < \u2191n + 1\n\ncase refine'_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 \u2191n + 1 < \u2191m + 1"}, {"tactic": "exact Nat.cast_add_one_pos _", "annotated_tactic": ["exact <a>Nat.cast_add_one_pos</a> _", [{"full_name": "Nat.cast_add_one_pos", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean", "def_pos": [62, 9], "def_end_pos": [62, 25]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 0 < \u2191n + 1\n\ncase refine'_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 \u2191n + 1 < \u2191m + 1", "state_after": "case refine'_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 \u2191n + 1 < \u2191m + 1"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 \u2191n + 1 < \u2191m + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_le_one_iff", "start": [854, 1], "end": [858, 49], "traced_tactics": [{"tactic": "rcases lt_trichotomy b 0 with (hb | rfl | hb)", "annotated_tactic": ["rcases <a>lt_trichotomy</a> b 0 with (hb | rfl | hb)", [{"full_name": "lt_trichotomy", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [311, 9], "def_end_pos": [311, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\n\u22a2 a / b \u2264 1 \u2194 0 < b \u2227 a \u2264 b \u2228 b = 0 \u2228 b < 0 \u2227 b \u2264 a", "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhb : b < 0\n\u22a2 a / b \u2264 1 \u2194 0 < b \u2227 a \u2264 b \u2228 b = 0 \u2228 b < 0 \u2227 b \u2264 a\n\ncase inr.inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na c d : \u03b1\nn : \u2124\n\u22a2 a / 0 \u2264 1 \u2194 0 < 0 \u2227 a \u2264 0 \u2228 0 = 0 \u2228 0 < 0 \u2227 0 \u2264 a\n\ncase inr.inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhb : 0 < b\n\u22a2 a / b \u2264 1 \u2194 0 < b \u2227 a \u2264 b \u2228 b = 0 \u2228 b < 0 \u2227 b \u2264 a"}, {"tactic": "simp [hb, hb.not_lt, hb.ne, div_le_one_of_neg]", "annotated_tactic": ["simp [hb, hb.not_lt, hb.ne, <a>div_le_one_of_neg</a>]", [{"full_name": "div_le_one_of_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [808, 9], "def_end_pos": [808, 26]}]], "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhb : b < 0\n\u22a2 a / b \u2264 1 \u2194 0 < b \u2227 a \u2264 b \u2228 b = 0 \u2228 b < 0 \u2227 b \u2264 a", "state_after": "no goals"}, {"tactic": "simp [zero_le_one]", "annotated_tactic": ["simp [<a>zero_le_one</a>]", [{"full_name": "zero_le_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [26, 15], "def_end_pos": [26, 26]}]], "state_before": "case inr.inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na c d : \u03b1\nn : \u2124\n\u22a2 a / 0 \u2264 1 \u2194 0 < 0 \u2227 a \u2264 0 \u2228 0 = 0 \u2228 0 < 0 \u2227 0 \u2264 a", "state_after": "no goals"}, {"tactic": "simp [hb, hb.not_lt, div_le_one, hb.ne.symm]", "annotated_tactic": ["simp [hb, hb.not_lt, <a>div_le_one</a>, hb.ne.symm]", [{"full_name": "div_le_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [425, 9], "def_end_pos": [425, 19]}]], "state_before": "case inr.inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nhb : 0 < b\n\u22a2 a / b \u2264 1 \u2194 0 < b \u2227 a \u2264 b \u2228 b = 0 \u2228 b < 0 \u2227 b \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/MinMax.lean", "full_name": "List.minimum_eq_none", "start": [318, 1], "end": [319, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Sigma/Lex.lean", "full_name": "PSigma.Lex.mono_left", "start": [179, 1], "end": [181, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "sup_biSup", "start": [1342, 1], "end": [1344, 55], "traced_tactics": [{"tactic": "simpa only [sup_comm] using @biSup_sup \u03b1 _ _ p _ _ h", "annotated_tactic": ["simpa only [<a>sup_comm</a>] using @<a>biSup_sup</a> \u03b1 _ _ p _ _ h", [{"full_name": "sup_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [250, 9], "def_end_pos": [250, 17]}, {"full_name": "biSup_sup", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1334, 9], "def_end_pos": [1334, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g s t : \u03b9 \u2192 \u03b1\na\u271d b : \u03b1\np : \u03b9 \u2192 Prop\nf : (i : \u03b9) \u2192 p i \u2192 \u03b1\na : \u03b1\nh : \u2203 i, p i\n\u22a2 a \u2294 \u2a06 i, \u2a06 (h : p i), f i h = \u2a06 i, \u2a06 (h : p i), a \u2294 f i h", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.mulHom_ext'", "start": [1168, 1], "end": [1172, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "full_name": "Subgroup.conj_smul_subgroupOf", "start": [320, 1], "end": [326, 43], "traced_tactics": [{"tactic": "refine' le_antisymm _ _", "annotated_tactic": ["refine' <a>le_antisymm</a> _ _", [{"full_name": "le_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}]], "state_before": "\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh : \u21a5H\n\u22a2 \u2191MulAut.conj h \u2022 subgroupOf P H = subgroupOf (\u2191MulAut.conj \u2191h \u2022 P) H", "state_after": "case refine'_1\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh : \u21a5H\n\u22a2 \u2191MulAut.conj h \u2022 subgroupOf P H \u2264 subgroupOf (\u2191MulAut.conj \u2191h \u2022 P) H\n\ncase refine'_2\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh : \u21a5H\n\u22a2 subgroupOf (\u2191MulAut.conj \u2191h \u2022 P) H \u2264 \u2191MulAut.conj h \u2022 subgroupOf P H"}, {"tactic": "rintro - \u27e8g, hg, rfl\u27e9", "annotated_tactic": ["rintro - \u27e8g, hg, rfl\u27e9", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh : \u21a5H\n\u22a2 \u2191MulAut.conj h \u2022 subgroupOf P H \u2264 subgroupOf (\u2191MulAut.conj \u2191h \u2022 P) H", "state_after": "case refine'_1.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh g : \u21a5H\nhg : g \u2208 \u2191(subgroupOf P H)\n\u22a2 \u2191(\u2191(MulDistribMulAction.toMonoidEnd ((fun x => MulAut (\u21a5H)) h) (\u21a5H)) (\u2191MulAut.conj h)) g \u2208\n    subgroupOf (\u2191MulAut.conj \u2191h \u2022 P) H"}, {"tactic": "exact \u27e8g, hg, rfl\u27e9", "annotated_tactic": ["exact \u27e8g, hg, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case refine'_1.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh g : \u21a5H\nhg : g \u2208 \u2191(subgroupOf P H)\n\u22a2 \u2191(\u2191(MulDistribMulAction.toMonoidEnd ((fun x => MulAut (\u21a5H)) h) (\u21a5H)) (\u2191MulAut.conj h)) g \u2208\n    subgroupOf (\u2191MulAut.conj \u2191h \u2022 P) H", "state_after": "no goals"}, {"tactic": "rintro p \u27e8g, hg, hp\u27e9", "annotated_tactic": ["rintro p \u27e8g, hg, hp\u27e9", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh : \u21a5H\n\u22a2 subgroupOf (\u2191MulAut.conj \u2191h \u2022 P) H \u2264 \u2191MulAut.conj h \u2022 subgroupOf P H", "state_after": "case refine'_2.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh p : \u21a5H\ng : G\nhg : g \u2208 \u2191P\nhp : \u2191(\u2191(MulDistribMulAction.toMonoidEnd ((fun x => MulAut G) \u2191h) G) (\u2191MulAut.conj \u2191h)) g = \u2191(Subgroup.subtype H) p\n\u22a2 p \u2208 \u2191MulAut.conj h \u2022 subgroupOf P H"}, {"tactic": "exact \u27e8\u27e8g, hP hg\u27e9, hg, Subtype.ext hp\u27e9", "annotated_tactic": ["exact \u27e8\u27e8g, hP hg\u27e9, hg, <a>Subtype.ext</a> hp\u27e9", [{"full_name": "Subtype.ext", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [65, 19], "def_end_pos": [65, 22]}]], "state_before": "case refine'_2.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : AddGroup A\ns : Set G\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : MulDistribMulAction \u03b1 G\nP H : Subgroup G\nhP : P \u2264 H\nh p : \u21a5H\ng : G\nhg : g \u2208 \u2191P\nhp : \u2191(\u2191(MulDistribMulAction.toMonoidEnd ((fun x => MulAut G) \u2191h) G) (\u2191MulAut.conj \u2191h)) g = \u2191(Subgroup.subtype H) p\n\u22a2 p \u2208 \u2191MulAut.conj h \u2022 subgroupOf P H", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.map_sigma_mk_comap", "start": [966, 1], "end": [971, 43], "traced_tactics": [{"tactic": "refine' (((basis_sets _).comap _).map _).eq_of_same_basis _", "annotated_tactic": ["refine' (((<a>basis_sets</a> _).<a>comap</a> _).<a>map</a> _).<a>eq_of_same_basis</a> _", [{"full_name": "Filter.basis_sets", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [404, 9], "def_end_pos": [404, 19]}, {"full_name": "Filter.HasBasis.comap", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [793, 9], "def_end_pos": [793, 23]}, {"full_name": "Filter.HasBasis.map", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [789, 9], "def_end_pos": [789, 21]}, {"full_name": "Filter.HasBasis.eq_of_same_basis", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [266, 9], "def_end_pos": [266, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03c0 : \u03b1 \u2192 Type u_6\n\u03c0' : \u03b2 \u2192 Type u_7\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\n\u22a2 map (Sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (Sigma.mk (f a)) l)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03c0 : \u03b1 \u2192 Type u_6\n\u03c0' : \u03b2 \u2192 Type u_7\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\n\u22a2 HasBasis (comap (Sigma.map f g) (map (Sigma.mk (f a)) l)) (fun s => s \u2208 l) fun i => Sigma.mk a '' (g a \u207b\u00b9' id i)"}, {"tactic": "convert ((basis_sets l).map (Sigma.mk (f a))).comap (Sigma.map f g)", "annotated_tactic": ["convert ((<a>basis_sets</a> l).<a>map</a> (<a>Sigma.mk</a> (f a))).<a>comap</a> (<a>Sigma.map</a> f g)", [{"full_name": "Filter.basis_sets", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [404, 9], "def_end_pos": [404, 19]}, {"full_name": "Filter.HasBasis.map", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [789, 9], "def_end_pos": [789, 21]}, {"full_name": "Sigma.mk", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [140, 3], "def_end_pos": [140, 5]}, {"full_name": "Filter.HasBasis.comap", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [793, 9], "def_end_pos": [793, 23]}, {"full_name": "Sigma.map", "def_path": "lake-packages/mathlib/Mathlib/Data/Sigma/Basic.lean", "def_pos": [113, 5], "def_end_pos": [113, 8]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03c0 : \u03b1 \u2192 Type u_6\n\u03c0' : \u03b2 \u2192 Type u_7\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\n\u22a2 HasBasis (comap (Sigma.map f g) (map (Sigma.mk (f a)) l)) (fun s => s \u2208 l) fun i => Sigma.mk a '' (g a \u207b\u00b9' id i)", "state_after": "case h.e'_5.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03c0 : \u03b1 \u2192 Type u_6\n\u03c0' : \u03b2 \u2192 Type u_7\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\nx\u271d : Set (\u03c0' (f a))\n\u22a2 Sigma.mk a '' (g a \u207b\u00b9' id x\u271d) = Sigma.map f g \u207b\u00b9' (Sigma.mk (f a) '' id x\u271d)"}, {"tactic": "apply image_sigmaMk_preimage_sigmaMap hf", "annotated_tactic": ["apply <a>image_sigmaMk_preimage_sigmaMap</a> hf", [{"full_name": "Set.image_sigmaMk_preimage_sigmaMap", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Sigma.lean", "def_pos": [42, 9], "def_end_pos": [42, 40]}]], "state_before": "case h.e'_5.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03c0 : \u03b1 \u2192 Type u_6\n\u03c0' : \u03b2 \u2192 Type u_7\nf : \u03b1 \u2192 \u03b2\nhf : Function.Injective f\ng : (a : \u03b1) \u2192 \u03c0 a \u2192 \u03c0' (f a)\na : \u03b1\nl : Filter (\u03c0' (f a))\nx\u271d : Set (\u03c0' (f a))\n\u22a2 Sigma.mk a '' (g a \u207b\u00b9' id x\u271d) = Sigma.map f g \u207b\u00b9' (Sigma.mk (f a) '' id x\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.elim_comp_inl", "start": [99, 9], "end": [100, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Forall2.lean", "full_name": "List.left_unique_forall\u2082'", "start": [134, 1], "end": [137, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.IsInfix.trans", "start": [1812, 1], "end": [1813, 95], "traced_tactics": [{"tactic": "simp only [append_assoc]", "annotated_tactic": ["simp only [<a>append_assoc</a>]", [{"full_name": "List.append_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 21]}]], "state_before": "\u03b1 : Type u_1\nl l\u2081 r\u2081 l\u2082 r\u2082 : List \u03b1\n\u22a2 l\u2082 ++ l\u2081 ++ l ++ (r\u2081 ++ r\u2082) = l\u2082 ++ (l\u2081 ++ l ++ r\u2081) ++ r\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Basic.lean", "full_name": "left_ne_zero_of_mul_eq_one", "start": [146, 1], "end": [147, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.strictAnti_iff", "start": [1176, 1], "end": [1178, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_zero_le", "start": [1119, 1], "end": [1119, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Order/Units.lean", "full_name": "Int.units_pow_eq_pow_mod_two", "start": [67, 1], "end": [71, 56], "traced_tactics": [{"tactic": "conv =>\n    lhs\n    rw [\u2190 Nat.mod_add_div n 2];\n    rw [pow_add, pow_mul, units_sq, one_pow, mul_one]", "annotated_tactic": ["conv =>\n      lhs\n      rw [\u2190 <a>Nat.mod_add_div</a> n 2];\n      rw [<a>pow_add</a>, <a>pow_mul</a>, <a>units_sq</a>, <a>one_pow</a>, <a>mul_one</a>]", [{"full_name": "Nat.mod_add_div", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [749, 9], "def_end_pos": [749, 20]}, {"full_name": "pow_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 16]}, {"full_name": "pow_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [125, 9], "def_end_pos": [125, 16]}, {"full_name": "Int.units_sq", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Order/Units.lean", "def_pos": [27, 9], "def_end_pos": [27, 17]}, {"full_name": "one_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "u : \u2124\u02e3\nn : \u2115\n\u22a2 u ^ n = u ^ (n % 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.indexOf_of_not_mem", "start": [1137, 1], "end": [1138, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/List.lean", "full_name": "List.formPerm_apply_head", "start": [145, 1], "end": [146, 87], "traced_tactics": [{"tactic": "simp [formPerm_apply_of_not_mem _ _ h.not_mem]", "annotated_tactic": ["simp [<a>formPerm_apply_of_not_mem</a> _ _ h.not_mem]", [{"full_name": "List.formPerm_apply_of_not_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/List.lean", "def_pos": [73, 9], "def_end_pos": [73, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\nxs : List \u03b1\nh : Nodup (x :: y :: xs)\n\u22a2 \u2191(formPerm (x :: y :: xs)) x = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.lt_iff_add_one_le", "start": [556, 1], "end": [556, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.mem_assert", "start": [461, 1], "end": [462, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean", "full_name": "Multiset.dvd_gcd", "start": [153, 1], "end": [155, 83], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\ns : Multiset \u03b1\na : \u03b1\n\u22a2 a \u2223 gcd 0 \u2194 \u2200 b \u2208 0, a \u2223 b", "state_after": "no goals"}, {"tactic": "simp (config := { contextual := true }) [or_imp, forall_and, dvd_gcd_iff]", "annotated_tactic": ["simp (config := { contextual := <a>true</a> }) [<a>or_imp</a>, <a>forall_and</a>, <a>dvd_gcd_iff</a>]", [{"full_name": "Bool.true", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [549, 5], "def_end_pos": [549, 9]}, {"full_name": "or_imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [343, 9], "def_end_pos": [343, 15]}, {"full_name": "forall_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [432, 9], "def_end_pos": [432, 19]}, {"full_name": "dvd_gcd_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [325, 9], "def_end_pos": [325, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\ns : Multiset \u03b1\na : \u03b1\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984 {s : Multiset \u03b1}, (a \u2223 gcd s \u2194 \u2200 b \u2208 s, a \u2223 b) \u2192 (a \u2223 gcd (a_1 ::\u2098 s) \u2194 \u2200 b \u2208 a_1 ::\u2098 s, a \u2223 b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Function.Surjective.preimage_injective", "start": [1296, 1], "end": [1297, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Option/Lemmas.lean", "full_name": "Option.map_eq_map", "start": [127, 9], "end": [127, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_filterMap_of_inv", "start": [2193, 1], "end": [2195, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.natDegree_X_pow", "start": [1305, 1], "end": [1306, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.IsPrime.pow_mem_iff_mem", "start": [582, 1], "end": [584, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.smul_set_iUnion\u2082", "start": [384, 1], "end": [386, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.eq_biInf", "start": [751, 1], "end": [752, 100], "traced_tactics": [{"tactic": "simp only [h.mem_iff, mem_principal, exists_prop]", "annotated_tactic": ["simp only [h.mem_iff, <a>mem_principal</a>, <a>exists_prop</a>]", [{"full_name": "Filter.mem_principal", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [294, 17], "def_end_pos": [294, 30]}, {"full_name": "exists_prop", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [491, 17], "def_end_pos": [491, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nh : HasBasis l p s\nx\u271d : Set \u03b1\n\u22a2 x\u271d \u2208 l \u2194 \u2203 i, p i \u2227 x\u271d \u2208 \ud835\udcdf (s i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/PNat/Basic.lean", "full_name": "PNat.natPred_monotone", "start": [49, 1], "end": [50, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Pi.lean", "full_name": "LinearMap.proj_pi", "start": [96, 1], "end": [97, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Field/Basic.lean", "full_name": "div_add_div", "start": [205, 1], "end": [207, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_insert", "start": [2230, 1], "end": [2233, 8], "traced_tactics": [{"tactic": "rw [\u2190 union_singleton, mk_union_of_disjoint, mk_singleton]", "annotated_tactic": ["rw [\u2190 <a>union_singleton</a>, <a>mk_union_of_disjoint</a>, <a>mk_singleton</a>]", [{"full_name": "Set.union_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1340, 9], "def_end_pos": [1340, 24]}, {"full_name": "Cardinal.mk_union_of_disjoint", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2225, 9], "def_end_pos": [2225, 29]}, {"full_name": "Cardinal.mk_singleton", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2057, 9], "def_end_pos": [2057, 21]}]], "state_before": "\u03b1\u271d \u03b2 \u03b1 : Type u\ns : Set \u03b1\na : \u03b1\nh : a \u2209 s\n\u22a2 #\u2191(insert a s) = #\u2191s + 1", "state_after": "\u03b1\u271d \u03b2 \u03b1 : Type u\ns : Set \u03b1\na : \u03b1\nh : a \u2209 s\n\u22a2 Disjoint s {a}"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b1\u271d \u03b2 \u03b1 : Type u\ns : Set \u03b1\na : \u03b1\nh : a \u2209 s\n\u22a2 Disjoint s {a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "sInf_lt_iff", "start": [652, 1], "end": [653, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Star/Module.lean", "full_name": "skewAdjointPart_comp_subtype_selfAdjoint", "start": [156, 1], "end": [158, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/WithTop.lean", "full_name": "WithBot.coe_add", "start": [584, 1], "end": [585, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "MvPolynomial.isNoetherianRing_fin_0", "start": [1061, 1], "end": [1064, 54], "traced_tactics": [{"tactic": "apply isNoetherianRing_of_ringEquiv R", "annotated_tactic": ["apply <a>isNoetherianRing_of_ringEquiv</a> R", [{"full_name": "isNoetherianRing_of_ringEquiv", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Noetherian.lean", "def_pos": [619, 9], "def_end_pos": [619, 38]}]], "state_before": "R : Type u\nS : Type u_1\n\u03c3 : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherianRing R\n\u22a2 IsNoetherianRing (MvPolynomial (Fin 0) R)", "state_after": "case f\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherianRing R\n\u22a2 R \u2243+* MvPolynomial (Fin 0) R"}, {"tactic": "symm", "annotated_tactic": ["symm", []], "state_before": "case f\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherianRing R\n\u22a2 R \u2243+* MvPolynomial (Fin 0) R", "state_after": "case f\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherianRing R\n\u22a2 MvPolynomial (Fin 0) R \u2243+* R"}, {"tactic": "apply MvPolynomial.isEmptyRingEquiv R (Fin 0)", "annotated_tactic": ["apply <a>MvPolynomial.isEmptyRingEquiv</a> R (<a>Fin</a> 0)", [{"full_name": "MvPolynomial.isEmptyRingEquiv", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Equiv.lean", "def_pos": [228, 5], "def_end_pos": [228, 21]}, {"full_name": "Fin", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1745, 11], "def_end_pos": [1745, 14]}]], "state_before": "case f\nR : Type u\nS : Type u_1\n\u03c3 : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherianRing R\n\u22a2 MvPolynomial (Fin 0) R \u2243+* R", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Int/Basic.lean", "full_name": "Int.natAbs_pos_of_ne_zero", "start": [95, 1], "end": [95, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Ultrafilter.lean", "full_name": "Ultrafilter.coe_map", "start": [215, 1], "end": [216, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeq.lean", "full_name": "CauSeq.smul_equiv_smul", "start": [576, 1], "end": [579, 65], "traced_tactics": [{"tactic": "simpa [const_smul, smul_one_mul _ _] using\n  mul_equiv_mul (const_equiv.mpr <| Eq.refl <| c \u2022 (1 : \u03b2)) hf", "annotated_tactic": ["simpa [<a>const_smul</a>, <a>smul_one_mul</a> _ _] using\n    <a>mul_equiv_mul</a> (const_equiv.mpr <| <a>Eq.refl</a> <| c \u2022 (1 : \u03b2)) hf", [{"full_name": "CauSeq.const_smul", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/CauSeq.lean", "def_pos": [361, 9], "def_end_pos": [361, 19]}, {"full_name": "smul_one_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [679, 9], "def_end_pos": [679, 21]}, {"full_name": "CauSeq.mul_equiv_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/CauSeq.lean", "def_pos": [562, 9], "def_end_pos": [562, 22]}, {"full_name": "Eq.refl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [266, 5], "def_end_pos": [266, 9]}]], "state_before": "\u03b1 : Type u_3\n\u03b2 : Type u_2\ninst\u271d\u2074 : LinearOrderedField \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nG : Type u_1\ninst\u271d\u00b9 : SMul G \u03b2\ninst\u271d : IsScalarTower G \u03b2 \u03b2\nf1 f2 : CauSeq \u03b2 abv\nc : G\nhf : f1 \u2248 f2\n\u22a2 c \u2022 f1 \u2248 c \u2022 f2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean", "full_name": "Set.pairwiseDisjoint_union", "start": [306, 1], "end": [310, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycleOn.range_zpow", "start": [929, 1], "end": [931, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/ENat/Basic.lean", "full_name": "ENat.some_eq_coe", "start": [60, 9], "end": [60, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.erase_eq_sub_single", "start": [775, 1], "end": [780, 63], "traced_tactics": [{"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u271d i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2\u271d \u2191i\ni\u271d : \u03b9\n\u03b2 : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\n\u22a2 erase i f = f - single i (\u2191f i)", "state_after": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u271d i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2\u271d \u2191i\ni\u271d : \u03b9\n\u03b2 : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni j : \u03b9\n\u22a2 \u2191(erase i f) j = \u2191(f - single i (\u2191f i)) j"}, {"tactic": "rcases eq_or_ne i j with (rfl | h)", "annotated_tactic": ["rcases <a>eq_or_ne</a> i j with (rfl | h)", [{"full_name": "eq_or_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u271d i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2\u271d \u2191i\ni\u271d : \u03b9\n\u03b2 : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni j : \u03b9\n\u22a2 \u2191(erase i f) j = \u2191(f - single i (\u2191f i)) j", "state_after": "case h.inl\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u271d i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2\u271d \u2191i\ni\u271d : \u03b9\n\u03b2 : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\n\u22a2 \u2191(erase i f) i = \u2191(f - single i (\u2191f i)) i\n\ncase h.inr\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u271d i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2\u271d \u2191i\ni\u271d : \u03b9\n\u03b2 : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni j : \u03b9\nh : i \u2260 j\n\u22a2 \u2191(erase i f) j = \u2191(f - single i (\u2191f i)) j"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.inl\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u271d i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2\u271d \u2191i\ni\u271d : \u03b9\n\u03b2 : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\n\u22a2 \u2191(erase i f) i = \u2191(f - single i (\u2191f i)) i", "state_after": "no goals"}, {"tactic": "simp [erase_ne h.symm, single_eq_of_ne h, @eq_comm _ j, h]", "annotated_tactic": ["simp [<a>erase_ne</a> h.symm, <a>single_eq_of_ne</a> h, @<a>eq_comm</a> _ j, h]", [{"full_name": "DFinsupp.erase_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [764, 9], "def_end_pos": [764, 17]}, {"full_name": "DFinsupp.single_eq_of_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [665, 9], "def_end_pos": [665, 24]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "case h.inr\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2\u271d : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2\u271d i)\ns : Finset \u03b9\nx : (i : \u2191\u2191s) \u2192 \u03b2\u271d \u2191i\ni\u271d : \u03b9\n\u03b2 : \u03b9 \u2192 Type u_1\ninst\u271d : (i : \u03b9) \u2192 AddGroup (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni j : \u03b9\nh : i \u2260 j\n\u22a2 \u2191(erase i f) j = \u2191(f - single i (\u2191f i)) j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Order/Defs.lean", "full_name": "ge_trans", "start": [76, 1], "end": [76, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "GaloisInsertion.l_u_eq", "start": [530, 1], "end": [531, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Lattice.lean", "full_name": "Nat.sSup_def", "start": [37, 1], "end": [39, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "iSup_iUnion", "start": [2390, 1], "end": [2392, 36], "traced_tactics": [{"tactic": "rw [iSup_comm]", "annotated_tactic": ["rw [<a>iSup_comm</a>]", [{"full_name": "iSup_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1204, 9], "def_end_pos": [1204, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ninst\u271d : CompleteLattice \u03b2\ns : \u03b9 \u2192 Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 a \u2208 \u22c3 i, s i, f a = \u2a06 i, \u2a06 a \u2208 s i, f a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ninst\u271d : CompleteLattice \u03b2\ns : \u03b9 \u2192 Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 a \u2208 \u22c3 i, s i, f a = \u2a06 j, \u2a06 i, \u2a06 (_ : j \u2208 s i), f j"}, {"tactic": "simp_rw [mem_iUnion, iSup_exists]", "annotated_tactic": ["simp_rw [<a>mem_iUnion</a>, <a>iSup_exists</a>]", [{"full_name": "Set.mem_iUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [201, 9], "def_end_pos": [201, 19]}, {"full_name": "iSup_exists", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1377, 9], "def_end_pos": [1377, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\ninst\u271d : CompleteLattice \u03b2\ns : \u03b9 \u2192 Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 a \u2208 \u22c3 i, s i, f a = \u2a06 j, \u2a06 i, \u2a06 (_ : j \u2208 s i), f j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.mem_iInf_of_finite", "start": [647, 1], "end": [651, 55], "traced_tactics": [{"tactic": "refine' \u27e8exists_iInter_of_mem_iInf, _\u27e9", "annotated_tactic": ["refine' \u27e8<a>exists_iInter_of_mem_iInf</a>, _\u27e9", [{"full_name": "Filter.exists_iInter_of_mem_iInf", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [642, 9], "def_end_pos": [642, 34]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d g : Filter \u03b1\u271d\ns\u271d t : Set \u03b1\u271d\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\ns : Set \u03b1\n\u22a2 s \u2208 \u2a05 i, f i \u2194 \u2203 t, (\u2200 (i : \u03b9), t i \u2208 f i) \u2227 s = \u22c2 i, t i", "state_after": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d g : Filter \u03b1\u271d\ns\u271d t : Set \u03b1\u271d\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 t, (\u2200 (i : \u03b9), t i \u2208 f i) \u2227 s = \u22c2 i, t i) \u2192 s \u2208 \u2a05 i, f i"}, {"tactic": "rintro \u27e8t, ht, rfl\u27e9", "annotated_tactic": ["rintro \u27e8t, ht, rfl\u27e9", []], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d g : Filter \u03b1\u271d\ns\u271d t : Set \u03b1\u271d\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 t, (\u2200 (i : \u03b9), t i \u2208 f i) \u2227 s = \u22c2 i, t i) \u2192 s \u2208 \u2a05 i, f i", "state_after": "case intro.intro\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d g : Filter \u03b1\u271d\ns t\u271d : Set \u03b1\u271d\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\nt : \u03b9 \u2192 Set \u03b1\nht : \u2200 (i : \u03b9), t i \u2208 f i\n\u22a2 \u22c2 i, t i \u2208 \u2a05 i, f i"}, {"tactic": "exact iInter_mem.2 fun i => mem_iInf_of_mem i (ht i)", "annotated_tactic": ["exact <a>iInter_mem</a>.2 fun i => <a>mem_iInf_of_mem</a> i (ht i)", [{"full_name": "Filter.iInter_mem", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [206, 9], "def_end_pos": [206, 19]}, {"full_name": "Filter.mem_iInf_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [595, 9], "def_end_pos": [595, 24]}]], "state_before": "case intro.intro\n\u03b1\u271d : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9\u271d : Sort x\nf\u271d g : Filter \u03b1\u271d\ns t\u271d : Set \u03b1\u271d\n\u03b9 : Type u_2\ninst\u271d : Finite \u03b9\n\u03b1 : Type u_3\nf : \u03b9 \u2192 Filter \u03b1\nt : \u03b9 \u2192 Set \u03b1\nht : \u2200 (i : \u03b9), t i \u2208 f i\n\u22a2 \u22c2 i, t i \u2208 \u2a05 i, f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.insert_inter_of_not_mem", "start": [1710, 1], "end": [1714, 72], "traced_tactics": [{"tactic": "have : \u00ac(x = a \u2227 x \u2208 s\u2082) := by rintro \u27e8rfl, H\u27e9; exact h H", "annotated_tactic": ["have : \u00ac(x = a \u2227 x \u2208 s\u2082) := by rintro \u27e8rfl, H\u27e9; exact h H", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081\u271d s\u2082\u271d t t\u2081 t\u2082 u v : Finset \u03b1\na\u271d b : \u03b1\ns\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nh : a \u2209 s\u2082\nx : \u03b1\n\u22a2 x \u2208 insert a s\u2081 \u2229 s\u2082 \u2194 x \u2208 s\u2081 \u2229 s\u2082", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081\u271d s\u2082\u271d t t\u2081 t\u2082 u v : Finset \u03b1\na\u271d b : \u03b1\ns\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nh : a \u2209 s\u2082\nx : \u03b1\nthis : \u00ac(x = a \u2227 x \u2208 s\u2082)\n\u22a2 x \u2208 insert a s\u2081 \u2229 s\u2082 \u2194 x \u2208 s\u2081 \u2229 s\u2082"}, {"tactic": "simp only [mem_inter, mem_insert, or_and_right, this, false_or_iff]", "annotated_tactic": ["simp only [<a>mem_inter</a>, <a>mem_insert</a>, <a>or_and_right</a>, this, <a>false_or_iff</a>]", [{"full_name": "Finset.mem_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1618, 9], "def_end_pos": [1618, 18]}, {"full_name": "Finset.mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1099, 9], "def_end_pos": [1099, 19]}, {"full_name": "or_and_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [331, 9], "def_end_pos": [331, 21]}, {"full_name": "false_or_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [185, 9], "def_end_pos": [185, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081\u271d s\u2082\u271d t t\u2081 t\u2082 u v : Finset \u03b1\na\u271d b : \u03b1\ns\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nh : a \u2209 s\u2082\nx : \u03b1\nthis : \u00ac(x = a \u2227 x \u2208 s\u2082)\n\u22a2 x \u2208 insert a s\u2081 \u2229 s\u2082 \u2194 x \u2208 s\u2081 \u2229 s\u2082", "state_after": "no goals"}, {"tactic": "rintro \u27e8rfl, H\u27e9", "annotated_tactic": ["rintro \u27e8rfl, H\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081\u271d s\u2082\u271d t t\u2081 t\u2082 u v : Finset \u03b1\na\u271d b : \u03b1\ns\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nh : a \u2209 s\u2082\nx : \u03b1\n\u22a2 \u00ac(x = a \u2227 x \u2208 s\u2082)", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081\u271d s\u2082\u271d t t\u2081 t\u2082 u v : Finset \u03b1\na b : \u03b1\ns\u2081 s\u2082 : Finset \u03b1\nx : \u03b1\nH : x \u2208 s\u2082\nh : x \u2209 s\u2082\n\u22a2 False"}, {"tactic": "exact h H", "annotated_tactic": ["exact h H", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081\u271d s\u2082\u271d t t\u2081 t\u2082 u v : Finset \u03b1\na b : \u03b1\ns\u2081 s\u2082 : Finset \u03b1\nx : \u03b1\nH : x \u2208 s\u2082\nh : x \u2209 s\u2082\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/ModEq.lean", "full_name": "Int.add_modEq_left", "start": [260, 1], "end": [260, 88], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "m n a b c d : \u2124\n\u22a2 n \u2223 n + a - a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Submonoid/Basic.lean", "full_name": "Submonoid.disjoint_def'", "start": [571, 1], "end": [573, 100], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "Subsemigroup.top_prod_top", "start": [679, 1], "end": [680, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Bitwise.lean", "full_name": "Int.bit0_val", "start": [121, 1], "end": [122, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ModularLattice.lean", "full_name": "sup_lt_sup_of_lt_of_inf_le_inf", "start": [246, 1], "end": [248, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.dualDual_symm_apply", "start": [978, 1], "end": [979, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Commutator.lean", "full_name": "Subgroup.commutator_bot_right", "start": [161, 1], "end": [162, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Conj.lean", "full_name": "IsConj.symm", "start": [38, 1], "end": [39, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.nat_cast_mul_comp", "start": [636, 1], "end": [637, 50], "traced_tactics": [{"tactic": "rw [\u2190 C_eq_nat_cast, C_mul_comp, C_eq_nat_cast]", "annotated_tactic": ["rw [\u2190 <a>C_eq_nat_cast</a>, <a>C_mul_comp</a>, <a>C_eq_nat_cast</a>]", [{"full_name": "Polynomial.C_eq_nat_cast", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [551, 9], "def_end_pos": [551, 22]}, {"full_name": "Polynomial.C_mul_comp", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [626, 9], "def_end_pos": [626, 19]}, {"full_name": "Polynomial.C_eq_nat_cast", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [551, 9], "def_end_pos": [551, 22]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\n\u22a2 comp (\u2191n * p) r = \u2191n * comp p r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "IsMax.Ici_eq", "start": [966, 1], "end": [967, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.powersetCard_mono", "start": [208, 1], "end": [210, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "StrictMono.isMax_of_apply", "start": [605, 1], "end": [608, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finite/Defs.lean", "full_name": "Finite.exists_equiv_fin", "start": [66, 1], "end": [67, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.Tendsto.congr", "start": [3029, 1], "end": [3031, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Lemmas.lean", "full_name": "zpow_induction_right", "start": [294, 1], "end": [301, 21], "traced_tactics": [{"tactic": "induction' n using Int.induction_on with n ih n ih", "annotated_tactic": ["induction' n using <a>Int.induction_on</a> with n ih n ih", [{"full_name": "Int.induction_on", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Basic.lean", "def_pos": [193, 35], "def_end_pos": [193, 47]}]], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2124\n\u22a2 P (g ^ n)", "state_after": "case hz\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\n\u22a2 P (g ^ 0)\n\ncase hp\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ \u2191n)\n\u22a2 P (g ^ (\u2191n + 1))\n\ncase hn\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ (-\u2191n))\n\u22a2 P (g ^ (-\u2191n - 1))"}, {"tactic": "rwa [zpow_zero]", "annotated_tactic": ["rwa [<a>zpow_zero</a>]", [{"full_name": "zpow_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [942, 50], "def_end_pos": [942, 59]}]], "state_before": "case hz\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\n\u22a2 P (g ^ 0)", "state_after": "no goals"}, {"tactic": "rw [zpow_add_one]", "annotated_tactic": ["rw [<a>zpow_add_one</a>]", [{"full_name": "zpow_add_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [196, 9], "def_end_pos": [196, 21]}]], "state_before": "case hp\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ \u2191n)\n\u22a2 P (g ^ (\u2191n + 1))", "state_after": "case hp\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ \u2191n)\n\u22a2 P (g ^ \u2191n * g)"}, {"tactic": "exact h_mul _ ih", "annotated_tactic": ["exact h_mul _ ih", []], "state_before": "case hp\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ \u2191n)\n\u22a2 P (g ^ \u2191n * g)", "state_after": "no goals"}, {"tactic": "rw [zpow_sub_one]", "annotated_tactic": ["rw [<a>zpow_sub_one</a>]", [{"full_name": "zpow_sub_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [207, 9], "def_end_pos": [207, 21]}]], "state_before": "case hn\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ (-\u2191n))\n\u22a2 P (g ^ (-\u2191n - 1))", "state_after": "case hn\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ (-\u2191n))\n\u22a2 P (g ^ (-\u2191n) * g\u207b\u00b9)"}, {"tactic": "exact h_inv _ ih", "annotated_tactic": ["exact h_inv _ ih", []], "state_before": "case hn\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Group G\ng : G\nP : G \u2192 Prop\nh_one : P 1\nh_mul : \u2200 (a : G), P a \u2192 P (a * g)\nh_inv : \u2200 (a : G), P a \u2192 P (a * g\u207b\u00b9)\nn : \u2115\nih : P (g ^ (-\u2191n))\n\u22a2 P (g ^ (-\u2191n) * g\u207b\u00b9)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.castAdd_cast", "start": [325, 1], "end": [326, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.prod_inf_prod", "start": [784, 1], "end": [785, 44], "traced_tactics": []}, {"url": "https://github.com/Moyvbai/Theorem", "commit": "2fad0ff51bf93233afcde842768074b0c8b33efa", "file_path": "Theorem/example_separate/even_choose.lean", "full_name": "even_choose", "start": [11, 1], "end": [27, 22], "traced_tactics": [{"tactic": "rw[two_even_congr hnm hm]", "annotated_tactic": ["rw[<a>two_even_congr</a> hnm hm]", [{"full_name": "two_even_congr", "def_path": "Theorem/example_separate/two_even_congr.lean", "def_pos": [11, 9], "def_end_pos": [11, 23]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 \u2211 k in range (n + 1), (-1) ^ k / \u2191(Nat.choose n k) = 2 * (\u2191n + 1) / (\u2191n + 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 2 + \u2211 k in Ico 1 (2 * m), (-1) ^ k / \u2191(Nat.choose (2 * m) k) = 2 * (\u2191n + 1) / (\u2191n + 2)"}, {"tactic": "rw[two_congr]", "annotated_tactic": ["rw[<a>two_congr</a>]", [{"full_name": "two_congr", "def_path": "Theorem/example_separate/two_congr.lean", "def_pos": [12, 9], "def_end_pos": [12, 18]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 2 + \u2211 k in Ico 1 (2 * m), (-1) ^ k / \u2191(Nat.choose (2 * m) k) = 2 * (\u2191n + 1) / (\u2191n + 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 2 + -1 / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)"}, {"tactic": "rw[add_neg_div hm]", "annotated_tactic": ["rw[<a>add_neg_div</a> hm]", [{"full_name": "add_neg_div", "def_path": "Theorem/example_separate/add_neg_div.lean", "def_pos": [4, 9], "def_end_pos": [4, 20]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 2 + -1 / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)"}, {"tactic": "have mul_two_div_mul : (2 * (m : \u211d) + 1) / (((m : \u211d) + 1)) * (1/2) = 2 * ((n : \u211d) + 1) / ((n : \u211d) + 2) * (1/2) := by\n    rw[\u2190 div_eq_mul_one_div]\n    rw[div_div]\n    rw[add_mul, mul_comm (m : \u211d) 2]\n    simp\n    rw[\u2190 mul_div]\n    rw[mul_right_comm]\n    simp\n    rw[hnm]\n    rw[cast_mul]\n    simp", "annotated_tactic": ["have mul_two_div_mul : (2 * (m : \u211d) + 1) / (((m : \u211d) + 1)) * (1/2) = 2 * ((n : \u211d) + 1) / ((n : \u211d) + 2) * (1/2) := by\n      rw[\u2190 <a>div_eq_mul_one_div</a>]\n      rw[<a>div_div</a>]\n      rw[<a>add_mul</a>, <a>mul_comm</a> (m : \u211d) 2]\n      simp\n      rw[\u2190 <a>mul_div</a>]\n      rw[<a>mul_right_comm</a>]\n      simp\n      rw[hnm]\n      rw[<a>cast_mul</a>]\n      simp", [{"full_name": "div_eq_mul_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [329, 9], "def_end_pos": [329, 27]}, {"full_name": "div_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [527, 9], "def_end_pos": [527, 16]}, {"full_name": "add_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "mul_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [324, 9], "def_end_pos": [324, 16]}, {"full_name": "mul_right_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [102, 9], "def_end_pos": [102, 23]}, {"full_name": "Nat.cast_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [47, 9], "def_end_pos": [47, 17]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\nmul_two_div_mul : (2 * \u2191m + 1) / (\u2191m + 1) * (1 / 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)"}, {"tactic": "simp at mul_two_div_mul", "annotated_tactic": ["simp at mul_two_div_mul", []], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\nmul_two_div_mul : (2 * \u2191m + 1) / (\u2191m + 1) * (1 / 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\nmul_two_div_mul : (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)"}, {"tactic": "rw[mul_two_div_mul]", "annotated_tactic": ["rw[mul_two_div_mul]", []], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\nmul_two_div_mul : (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) = 2 * (\u2191n + 1) / (\u2191n + 2)", "state_after": "no goals"}, {"tactic": "rw[\u2190 div_eq_mul_one_div]", "annotated_tactic": ["rw[\u2190 <a>div_eq_mul_one_div</a>]", [{"full_name": "div_eq_mul_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [329, 9], "def_end_pos": [329, 27]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) * (1 / 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) / 2 = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)"}, {"tactic": "rw[div_div]", "annotated_tactic": ["rw[<a>div_div</a>]", [{"full_name": "div_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [527, 9], "def_end_pos": [527, 16]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (\u2191m + 1) / 2 = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / ((\u2191m + 1) * 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)"}, {"tactic": "rw[add_mul, mul_comm (m : \u211d) 2]", "annotated_tactic": ["rw[<a>add_mul</a>, <a>mul_comm</a> (m : \u211d) 2]", [{"full_name": "add_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / ((\u2191m + 1) * 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 1 * 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 1 * 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * (1 / 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * 2\u207b\u00b9"}, {"tactic": "rw[\u2190 mul_div]", "annotated_tactic": ["rw[\u2190 <a>mul_div</a>]", [{"full_name": "mul_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [324, 9], "def_end_pos": [324, 16]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = 2 * (\u2191n + 1) / (\u2191n + 2) * 2\u207b\u00b9", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = 2 * ((\u2191n + 1) / (\u2191n + 2)) * 2\u207b\u00b9"}, {"tactic": "rw[mul_right_comm]", "annotated_tactic": ["rw[<a>mul_right_comm</a>]", [{"full_name": "mul_right_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [102, 9], "def_end_pos": [102, 23]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = 2 * ((\u2191n + 1) / (\u2191n + 2)) * 2\u207b\u00b9", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = 2 * 2\u207b\u00b9 * ((\u2191n + 1) / (\u2191n + 2))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = 2 * 2\u207b\u00b9 * ((\u2191n + 1) / (\u2191n + 2))", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = (\u2191n + 1) / (\u2191n + 2)"}, {"tactic": "rw[hnm]", "annotated_tactic": ["rw[hnm]", []], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = (\u2191n + 1) / (\u2191n + 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = (\u2191(2 * m) + 1) / (\u2191(2 * m) + 2)"}, {"tactic": "rw[cast_mul]", "annotated_tactic": ["rw[<a>cast_mul</a>]", [{"full_name": "Nat.cast_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [47, 9], "def_end_pos": [47, 17]}]], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = (\u2191(2 * m) + 1) / (\u2191(2 * m) + 2)", "state_after": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = (\u21912 * \u2191m + 1) / (\u21912 * \u2191m + 2)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n m : \u2115\nhnm : n = 2 * m\nhm : 0 < m\n\u22a2 (2 * \u2191m + 1) / (2 * \u2191m + 2) = (\u21912 * \u2191m + 1) / (\u21912 * \u2191m + 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.coe_eq_zero_iff_isEmpty", "start": [113, 1], "end": [114, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/BigOperators.lean", "full_name": "Fintype.prod_sum_type", "start": [293, 1], "end": [295, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Finset.map_disjiUnion", "start": [280, 1], "end": [284, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get_replicate", "start": [713, 9], "end": [714, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.recOn_one", "start": [166, 1], "end": [167, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_subset_iff_right", "start": [91, 1], "end": [92, 91], "traced_tactics": [{"tactic": "simp_rw [image2_subset_iff, image_subset_iff, subset_def, mem_preimage, @forall\u2082_swap \u03b1]", "annotated_tactic": ["simp_rw [<a>image2_subset_iff</a>, <a>image_subset_iff</a>, <a>subset_def</a>, <a>mem_preimage</a>, @<a>forall\u2082_swap</a> \u03b1]", [{"full_name": "Set.image2_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [83, 9], "def_end_pos": [83, 26]}, {"full_name": "Set.image_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [497, 9], "def_end_pos": [497, 25]}, {"full_name": "Set.subset_def", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [346, 9], "def_end_pos": [346, 19]}, {"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "forall\u2082_swap", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [667, 9], "def_end_pos": [667, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\n\u22a2 image2 f s t \u2286 u \u2194 \u2200 b \u2208 t, (fun a => f a b) '' s \u2286 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Bind.lean", "full_name": "Multiset.product_cons", "start": [267, 1], "end": [268, 30], "traced_tactics": [{"tactic": "simp [SProd.sprod, product]", "annotated_tactic": ["simp [<a>SProd.sprod</a>, <a>product</a>]", [{"full_name": "SProd.sprod", "def_path": "lake-packages/mathlib/Mathlib/Data/SProd.lean", "def_pos": [29, 3], "def_end_pos": [29, 8]}, {"full_name": "Multiset.product", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Bind.lean", "def_pos": [238, 5], "def_end_pos": [238, 12]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\na : \u03b1\nb : \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\n\u22a2 s \u00d7\u02e2 (b ::\u2098 t) = map (fun a => (a, b)) s + s \u00d7\u02e2 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.transpose_injective", "start": [1982, 1], "end": [1983, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "gcd_same", "start": [426, 1], "end": [427, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.inf_subgroupOf_inf_normal_of_left", "start": [3659, 1], "end": [3664, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.NeBot.comap_of_range_mem", "start": [2452, 1], "end": [2454, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Fin.lean", "full_name": "Equiv.Perm.decomposeFin_symm_of_one", "start": [35, 1], "end": [37, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.congr_arg", "start": [532, 11], "end": [533, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.lift_coe", "start": [925, 1], "end": [926, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Hom/Basic.lean", "full_name": "map_ne_zero_iff_ne_one", "start": [298, 1], "end": [299, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.mem_getLast?_cons", "start": [766, 1], "end": [768, 19], "traced_tactics": [{"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nx y : \u03b1\nx\u271d : x \u2208 getLast? []\n\u22a2 x \u2208 getLast? [y]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Sort.lean", "full_name": "Finset.orderEmbOfFin_apply", "start": [173, 1], "end": [176, 6], "traced_tactics": [{"tactic": "rw [length_sort, h]", "annotated_tactic": ["rw [<a>length_sort</a>, h]", [{"full_name": "Finset.length_sort", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Sort.lean", "def_pos": [63, 9], "def_end_pos": [63, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\nk : \u2115\nh : card s = k\ni : Fin k\n\u22a2 \u2191i < List.length (sort (fun x x_1 => x \u2264 x_1) s)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\nk : \u2115\nh : card s = k\ni : Fin k\n\u22a2 \u2191i < k"}, {"tactic": "exact i.2", "annotated_tactic": ["exact i.2", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\ns : Finset \u03b1\nk : \u2115\nh : card s = k\ni : Fin k\n\u22a2 \u2191i < k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Pi.lean", "full_name": "OneHom.single_apply", "start": [445, 1], "end": [447, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "compositionAsSet_card", "start": [849, 1], "end": [852, 53], "traced_tactics": [{"tactic": "have : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1) := by simp", "annotated_tactic": ["have : <a>Fintype.card</a> (<a>Finset</a> (<a>Fin</a> (n - 1))) = 2 ^ (n - 1) := by simp", [{"full_name": "Fintype.card", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [61, 5], "def_end_pos": [61, 9]}, {"full_name": "Finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [139, 11], "def_end_pos": [139, 17]}, {"full_name": "Fin", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1745, 11], "def_end_pos": [1745, 14]}]], "state_before": "n\u271d n : \u2115\n\u22a2 Fintype.card (CompositionAsSet n) = 2 ^ (n - 1)", "state_after": "n\u271d n : \u2115\nthis : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1)\n\u22a2 Fintype.card (CompositionAsSet n) = 2 ^ (n - 1)"}, {"tactic": "rw [\u2190 this]", "annotated_tactic": ["rw [\u2190 this]", []], "state_before": "n\u271d n : \u2115\nthis : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1)\n\u22a2 Fintype.card (CompositionAsSet n) = 2 ^ (n - 1)", "state_after": "n\u271d n : \u2115\nthis : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1)\n\u22a2 Fintype.card (CompositionAsSet n) = Fintype.card (Finset (Fin (n - 1)))"}, {"tactic": "exact Fintype.card_congr (compositionAsSetEquiv n)", "annotated_tactic": ["exact <a>Fintype.card_congr</a> (<a>compositionAsSetEquiv</a> n)", [{"full_name": "Fintype.card_congr", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [149, 9], "def_end_pos": [149, 19]}, {"full_name": "compositionAsSetEquiv", "def_path": "lake-packages/mathlib/Mathlib/Combinatorics/Composition.lean", "def_pos": [775, 5], "def_end_pos": [775, 26]}]], "state_before": "n\u271d n : \u2115\nthis : Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1)\n\u22a2 Fintype.card (CompositionAsSet n) = Fintype.card (Finset (Fin (n - 1)))", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n\u271d n : \u2115\n\u22a2 Fintype.card (Finset (Fin (n - 1))) = 2 ^ (n - 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.succ_one_eq_two", "start": [231, 9], "end": [231, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.utf8Len_append", "start": [64, 9], "end": [65, 49], "traced_tactics": [{"tactic": "induction cs\u2081 <;> simp [*, Nat.add_right_comm]", "annotated_tactic": ["induction cs\u2081 <;> simp [*, <a>Nat.add_right_comm</a>]", [{"full_name": "Nat.add_right_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}]], "state_before": "cs\u2081 cs\u2082 : List Char\n\u22a2 utf8Len (cs\u2081 ++ cs\u2082) = utf8Len cs\u2081 + utf8Len cs\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.get_enum", "start": [3862, 1], "end": [3866, 26], "traced_tactics": [{"tactic": "simpa [length_enum] using i.2", "annotated_tactic": ["simpa [<a>length_enum</a>] using i.2", [{"full_name": "List.length_enum", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [3730, 9], "def_end_pos": [3730, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\ni : Fin (length (enum l))\n\u22a2 \u2191i < length l", "state_after": "no goals"}, {"tactic": "convert get_enumFrom _ _ i", "annotated_tactic": ["convert <a>get_enumFrom</a> _ _ i", [{"full_name": "List.get_enumFrom", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [3848, 9], "def_end_pos": [3848, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\ni : Fin (length (enum l))\nhi : optParam (\u2191i < length l) (_ : \u2191i < length l)\n\u22a2 get (enum l) i = (\u2191i, get l { val := \u2191i, isLt := hi })", "state_after": "case h.e'_3.h.e'_3\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\ni : Fin (length (enum l))\nhi : optParam (\u2191i < length l) (_ : \u2191i < length l)\n\u22a2 \u2191i = 0 + \u2191i"}, {"tactic": "exact (zero_add _).symm", "annotated_tactic": ["exact (<a>zero_add</a> _).<a>symm</a>", [{"full_name": "zero_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [463, 3], "def_end_pos": [463, 14]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case h.e'_3.h.e'_3\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\ni : Fin (length (enum l))\nhi : optParam (\u2191i < length l) (_ : \u2191i < length l)\n\u22a2 \u2191i = 0 + \u2191i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Defs.lean", "full_name": "distrib_three_right", "start": [94, 1], "end": [95, 71], "traced_tactics": [{"tactic": "simp [right_distrib]", "annotated_tactic": ["simp [<a>right_distrib</a>]", [{"full_name": "right_distrib", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [86, 9], "def_end_pos": [86, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nR : Type x\ninst\u271d\u00b2 : Mul R\ninst\u271d\u00b9 : Add R\ninst\u271d : RightDistribClass R\na b c d : R\n\u22a2 (a + b + c) * d = a * d + b * d + c * d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "IsWeakAntichain.insert", "start": [373, 11], "end": [376, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Option/Lemmas.lean", "full_name": "Option.get_of_mem", "start": [27, 1], "end": [28, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.coe_compRingHom", "start": [1119, 1], "end": [1120, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Fin.lean", "full_name": "finSuccEquiv'_above", "start": [152, 1], "end": [154, 60], "traced_tactics": [{"tactic": "rw [\u2190 Fin.succAbove_above _ _ h, finSuccEquiv'_succAbove]", "annotated_tactic": ["rw [\u2190 <a>Fin.succAbove_above</a> _ _ h, <a>finSuccEquiv'_succAbove</a>]", [{"full_name": "Fin.succAbove_above", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [1359, 9], "def_end_pos": [1359, 24]}, {"full_name": "finSuccEquiv'_succAbove", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Fin.lean", "def_pos": [142, 9], "def_end_pos": [142, 32]}]], "state_before": "m\u271d n : \u2115\ni : Fin (n + 1)\nm : Fin n\nh : i \u2264 Fin.castSucc m\n\u22a2 \u2191(finSuccEquiv' i) (Fin.succ m) = some m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quot.map\u2082_mk", "start": [157, 1], "end": [160, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Opposites.lean", "full_name": "AddOpposite.op_one", "start": [371, 1], "end": [372, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/CharP/Basic.lean", "full_name": "NeZero.of_not_dvd", "start": [730, 1], "end": [731, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Lattice.lean", "full_name": "List.inter_cons_of_mem", "start": [136, 1], "end": [137, 61], "traced_tactics": [{"tactic": "simp only [Inter.inter, List.inter, filter_cons_of_pos, h]", "annotated_tactic": ["simp only [<a>Inter.inter</a>, <a>List.inter</a>, <a>filter_cons_of_pos</a>, h]", [{"full_name": "Inter.inter", "def_path": "lake-packages/std/Std/Classes/SetNotation.lean", "def_pos": [46, 3], "def_end_pos": [46, 8]}, {"full_name": "List.inter", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [433, 25], "def_end_pos": [433, 30]}, {"full_name": "List.filter_cons_of_pos", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1263, 17], "def_end_pos": [1263, 35]}]], "state_before": "\u03b1 : Type u_1\nl l\u2081\u271d l\u2082 : List \u03b1\np : \u03b1 \u2192 Prop\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u2081 : List \u03b1\nh : a \u2208 l\u2082\n\u22a2 (a :: l\u2081) \u2229 l\u2082 = a :: l\u2081 \u2229 l\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "Codisjoint.map_orderIso", "start": [1222, 1], "end": [1225, 29], "traced_tactics": [{"tactic": "rw [codisjoint_iff_le_sup, \u2190 f.map_sup, \u2190 f.map_top]", "annotated_tactic": ["rw [<a>codisjoint_iff_le_sup</a>, \u2190 f.map_sup, \u2190 f.map_top]", [{"full_name": "codisjoint_iff_le_sup", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [310, 9], "def_end_pos": [310, 30]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : SemilatticeSup \u03b2\ninst\u271d : OrderTop \u03b2\na b : \u03b1\nf : \u03b1 \u2243o \u03b2\nha : Codisjoint a b\n\u22a2 Codisjoint (\u2191f a) (\u2191f b)", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : SemilatticeSup \u03b2\ninst\u271d : OrderTop \u03b2\na b : \u03b1\nf : \u03b1 \u2243o \u03b2\nha : Codisjoint a b\n\u22a2 \u2191f \u22a4 \u2264 \u2191f (a \u2294 b)"}, {"tactic": "exact f.monotone ha.top_le", "annotated_tactic": ["exact f.monotone ha.top_le", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : SemilatticeSup \u03b1\ninst\u271d\u00b2 : OrderTop \u03b1\ninst\u271d\u00b9 : SemilatticeSup \u03b2\ninst\u271d : OrderTop \u03b2\na b : \u03b1\nf : \u03b1 \u2243o \u03b2\nha : Codisjoint a b\n\u22a2 \u2191f \u22a4 \u2264 \u2191f (a \u2294 b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.erase_ne_self", "start": [2024, 1], "end": [2025, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Infix.lean", "full_name": "List.eq_of_prefix_of_length_eq", "start": [119, 1], "end": [120, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "ball_true_iff", "start": [1098, 1], "end": [1099, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.sdiff_nonempty", "start": [2221, 1], "end": [2222, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Sum/Basic.lean", "full_name": "Sum.map_inr", "start": [109, 9], "end": [109, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iInter_true", "start": [788, 1], "end": [789, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "LinearOrderedCommGroup.mul_lt_mul_left'", "start": [1109, 1], "end": [1110, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "congr_arg_refl", "start": [547, 1], "end": [547, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/PNat/Defs.lean", "full_name": "PNat.not_lt_one", "start": [181, 1], "end": [182, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iio_injective", "start": [1133, 1], "end": [1134, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.sizeOf_lt_sizeOf_of_mem", "start": [2992, 1], "end": [2997, 36], "traced_tactics": [{"tactic": "induction' l with h t ih <;> cases hx <;> rw [cons.sizeOf_spec]", "annotated_tactic": ["induction' l with h t ih <;> cases hx <;> rw [cons.sizeOf_spec]", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\nl : List \u03b1\nhx : x \u2208 l\n\u22a2 sizeOf x < sizeOf l", "state_after": "case cons.head\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\n\u22a2 sizeOf x < 1 + sizeOf x + sizeOf t\n\ncase cons.tail\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx h : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\na\u271d : Mem x t\n\u22a2 sizeOf x < 1 + sizeOf h + sizeOf t"}, {"tactic": "exact lt_add_of_lt_of_nonneg (lt_one_add _) (Nat.zero_le _)", "annotated_tactic": ["exact <a>lt_add_of_lt_of_nonneg</a> (<a>lt_one_add</a> _) (<a>Nat.zero_le</a> _)", [{"full_name": "lt_add_of_lt_of_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [735, 3], "def_end_pos": [735, 14]}, {"full_name": "lt_one_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [25, 7], "def_end_pos": [25, 17]}, {"full_name": "Nat.zero_le", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1578, 9], "def_end_pos": [1578, 20]}]], "state_before": "case cons.head\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\n\u22a2 sizeOf x < 1 + sizeOf x + sizeOf t", "state_after": "no goals"}, {"tactic": "refine lt_add_of_pos_of_le ?_ (le_of_lt (ih \u2039_\u203a))", "annotated_tactic": ["refine <a>lt_add_of_pos_of_le</a> ?_ (<a>le_of_lt</a> (ih \u2039_\u203a))", [{"full_name": "lt_add_of_pos_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [947, 3], "def_end_pos": [947, 14]}, {"full_name": "le_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [110, 9], "def_end_pos": [110, 17]}]], "state_before": "case cons.tail\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx h : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\na\u271d : Mem x t\n\u22a2 sizeOf x < 1 + sizeOf h + sizeOf t", "state_after": "case cons.tail\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx h : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\na\u271d : Mem x t\n\u22a2 0 < 1 + sizeOf h"}, {"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}]], "state_before": "case cons.tail\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx h : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\na\u271d : Mem x t\n\u22a2 0 < 1 + sizeOf h", "state_after": "case cons.tail\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx h : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\na\u271d : Mem x t\n\u22a2 0 < sizeOf h + 1"}, {"tactic": "exact succ_pos _", "annotated_tactic": ["exact <a>succ_pos</a> _", [{"full_name": "Nat.succ_pos", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1608, 9], "def_end_pos": [1608, 21]}]], "state_before": "case cons.tail\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\ninst\u271d : SizeOf \u03b1\nx h : \u03b1\nt : List \u03b1\nih : x \u2208 t \u2192 sizeOf x < sizeOf t\na\u271d : Mem x t\n\u22a2 0 < sizeOf h + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "TopHom.comp_id", "start": [274, 1], "end": [275, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.subset_zero", "start": [431, 1], "end": [432, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "sup_congr_left", "start": [295, 1], "end": [296, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Ring.lean", "full_name": "Finset.prod_add", "start": [132, 1], "end": [160, 76], "traced_tactics": [{"tactic": "classical\ncalc\n  \u220f a in s, (f a + g a) =\n      \u220f a in s, \u2211 p in ({True, False} : Finset Prop), if p then f a else g a :=\n    by simp\n  _ = \u2211 p in (s.pi fun _ => {True, False} : Finset (\u2200 a \u2208 s, Prop)),\n        \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 :=\n    prod_sum\n  _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n    sum_bij'\n      (fun f _ => s.filter (fun a => \u2200 h : a \u2208 s, f a h))\n      (by simp)\n      (fun a _ => by\n        rw [prod_ite]\n        congr 1\n        exact prod_bij'\n          (fun a _ => a.1) (by simp) (by simp)\n          (fun a ha => \u27e8a, (mem_filter.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n          (by simp) (by simp)\n        exact prod_bij'\n          (fun a _ => a.1) (by simp) (by simp)\n          (fun a ha => \u27e8a, (mem_sdiff.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n          (by simp) (by simp))\n      (fun t _ a _ => a \u2208 t)\n      (by simp [Classical.em])\n      (by simp_rw [mem_filter, Function.funext_iff, eq_iff_iff, mem_pi, mem_insert]; tauto)\n      (by simp_rw [ext_iff, @mem_filter _ _ (id _), mem_powerset]; tauto)", "annotated_tactic": ["classical\n  calc\n    \u220f a in s, (f a + g a) =\n        \u220f a in s, \u2211 p in ({<a>True</a>, <a>False</a>} : <a>Finset</a> Prop), if p then f a else g a :=\n      by simp\n    _ = \u2211 p in (s.pi fun _ => {<a>True</a>, <a>False</a>} : <a>Finset</a> (\u2200 a \u2208 s, Prop)),\n          \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 :=\n      <a>prod_sum</a>\n    _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n      <a>sum_bij'</a>\n        (fun f _ => s.filter (fun a => \u2200 h : a \u2208 s, f a h))\n        (by simp)\n        (fun a _ => by\n          rw [<a>prod_ite</a>]\n          congr 1\n          exact <a>prod_bij'</a>\n            (fun a _ => a.1) (by simp) (by simp)\n            (fun a ha => \u27e8a, (<a>mem_filter</a>.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n            (by simp) (by simp)\n          exact <a>prod_bij'</a>\n            (fun a _ => a.1) (by simp) (by simp)\n            (fun a ha => \u27e8a, (<a>mem_sdiff</a>.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n            (by simp) (by simp))\n        (fun t _ a _ => a \u2208 t)\n        (by simp [<a>Classical.em</a>])\n        (by simp_rw [<a>mem_filter</a>, <a>Function.funext_iff</a>, <a>eq_iff_iff</a>, <a>mem_pi</a>, <a>mem_insert</a>]; tauto)\n        (by simp_rw [<a>ext_iff</a>, @<a>mem_filter</a> _ _ (<a>id</a> _), <a>mem_powerset</a>]; tauto)", [{"full_name": "True", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [176, 11], "def_end_pos": [176, 15]}, {"full_name": "False", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 16]}, {"full_name": "Finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [139, 11], "def_end_pos": [139, 17]}, {"full_name": "True", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [176, 11], "def_end_pos": [176, 15]}, {"full_name": "False", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 16]}, {"full_name": "Finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [139, 11], "def_end_pos": [139, 17]}, {"full_name": "Finset.prod_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [98, 9], "def_end_pos": [98, 17]}, {"full_name": "Finset.sum_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [566, 3], "def_end_pos": [566, 14]}, {"full_name": "Finset.prod_ite", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1001, 9], "def_end_pos": [1001, 17]}, {"full_name": "Finset.prod_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [570, 9], "def_end_pos": [570, 18]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "Finset.prod_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [570, 9], "def_end_pos": [570, 18]}, {"full_name": "Finset.mem_sdiff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2097, 9], "def_end_pos": [2097, 18]}, {"full_name": "Classical.em", "def_path": "lake-packages/lean4/src/lean/Init/Classical.lean", "def_pos": [26, 9], "def_end_pos": [26, 11]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "Function.funext_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 19]}, {"full_name": "eq_iff_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [53, 17], "def_end_pos": [53, 27]}, {"full_name": "Finset.mem_pi", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Pi.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Finset.mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1099, 9], "def_end_pos": [1099, 19]}, {"full_name": "Finset.ext_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 16]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.mem_powerset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u220f a in s, (f a + g a) = \u2211 t in powerset s, (\u220f a in t, f a) * \u220f a in s \\ t, g a", "state_after": "no goals"}, {"tactic": "calc\n  \u220f a in s, (f a + g a) =\n      \u220f a in s, \u2211 p in ({True, False} : Finset Prop), if p then f a else g a :=\n    by simp\n  _ = \u2211 p in (s.pi fun _ => {True, False} : Finset (\u2200 a \u2208 s, Prop)),\n        \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 :=\n    prod_sum\n  _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n    sum_bij'\n      (fun f _ => s.filter (fun a => \u2200 h : a \u2208 s, f a h))\n      (by simp)\n      (fun a _ => by\n        rw [prod_ite]\n        congr 1\n        exact prod_bij'\n          (fun a _ => a.1) (by simp) (by simp)\n          (fun a ha => \u27e8a, (mem_filter.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n          (by simp) (by simp)\n        exact prod_bij'\n          (fun a _ => a.1) (by simp) (by simp)\n          (fun a ha => \u27e8a, (mem_sdiff.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n          (by simp) (by simp))\n      (fun t _ a _ => a \u2208 t)\n      (by simp [Classical.em])\n      (by simp_rw [mem_filter, Function.funext_iff, eq_iff_iff, mem_pi, mem_insert]; tauto)\n      (by simp_rw [ext_iff, @mem_filter _ _ (id _), mem_powerset]; tauto)", "annotated_tactic": ["calc\n    \u220f a in s, (f a + g a) =\n        \u220f a in s, \u2211 p in ({<a>True</a>, <a>False</a>} : <a>Finset</a> Prop), if p then f a else g a :=\n      by simp\n    _ = \u2211 p in (s.pi fun _ => {<a>True</a>, <a>False</a>} : <a>Finset</a> (\u2200 a \u2208 s, Prop)),\n          \u220f a in s.attach, if p a.1 a.2 then f a.1 else g a.1 :=\n      <a>prod_sum</a>\n    _ = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a :=\n      <a>sum_bij'</a>\n        (fun f _ => s.filter (fun a => \u2200 h : a \u2208 s, f a h))\n        (by simp)\n        (fun a _ => by\n          rw [<a>prod_ite</a>]\n          congr 1\n          exact <a>prod_bij'</a>\n            (fun a _ => a.1) (by simp) (by simp)\n            (fun a ha => \u27e8a, (<a>mem_filter</a>.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n            (by simp) (by simp)\n          exact <a>prod_bij'</a>\n            (fun a _ => a.1) (by simp) (by simp)\n            (fun a ha => \u27e8a, (<a>mem_sdiff</a>.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n            (by simp) (by simp))\n        (fun t _ a _ => a \u2208 t)\n        (by simp [<a>Classical.em</a>])\n        (by simp_rw [<a>mem_filter</a>, <a>Function.funext_iff</a>, <a>eq_iff_iff</a>, <a>mem_pi</a>, <a>mem_insert</a>]; tauto)\n        (by simp_rw [<a>ext_iff</a>, @<a>mem_filter</a> _ _ (<a>id</a> _), <a>mem_powerset</a>]; tauto)", [{"full_name": "True", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [176, 11], "def_end_pos": [176, 15]}, {"full_name": "False", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 16]}, {"full_name": "Finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [139, 11], "def_end_pos": [139, 17]}, {"full_name": "True", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [176, 11], "def_end_pos": [176, 15]}, {"full_name": "False", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [189, 11], "def_end_pos": [189, 16]}, {"full_name": "Finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [139, 11], "def_end_pos": [139, 17]}, {"full_name": "Finset.prod_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [98, 9], "def_end_pos": [98, 17]}, {"full_name": "Finset.sum_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [566, 3], "def_end_pos": [566, 14]}, {"full_name": "Finset.prod_ite", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1001, 9], "def_end_pos": [1001, 17]}, {"full_name": "Finset.prod_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [570, 9], "def_end_pos": [570, 18]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "Finset.prod_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [570, 9], "def_end_pos": [570, 18]}, {"full_name": "Finset.mem_sdiff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2097, 9], "def_end_pos": [2097, 18]}, {"full_name": "Classical.em", "def_path": "lake-packages/lean4/src/lean/Init/Classical.lean", "def_pos": [26, 9], "def_end_pos": [26, 11]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "Function.funext_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 19]}, {"full_name": "eq_iff_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [53, 17], "def_end_pos": [53, 27]}, {"full_name": "Finset.mem_pi", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Pi.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Finset.mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1099, 9], "def_end_pos": [1099, 19]}, {"full_name": "Finset.ext_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 16]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.mem_powerset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u220f a in s, (f a + g a) = \u2211 t in powerset s, (\u220f a in t, f a) * \u220f a in s \\ t, g a", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u220f a in s, (f a + g a) = \u220f a in s, \u2211 p in {True, False}, if p then f a else g a", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 (a : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop) (ha : a \u2208 pi s fun x => {True, False}),\n    (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a ha \u2208 powerset s", "state_after": "no goals"}, {"tactic": "rw [prod_ite]", "annotated_tactic": ["rw [<a>prod_ite</a>]", [{"full_name": "Finset.prod_ite", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1001, 9], "def_end_pos": [1001, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 (\u220f a_1 in attach s, if a \u2191a_1 (_ : \u2191a_1 \u2208 s) then f \u2191a_1 else g \u2191a_1) =\n    (\u220f a in (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, f a) *\n      \u220f a in s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, g a", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 (\u220f x in filter (fun a_1 => a \u2191a_1 (_ : \u2191a_1 \u2208 s)) (attach s), f \u2191x) *\n      \u220f x in filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s), g \u2191x =\n    (\u220f a in (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, f a) *\n      \u220f a in s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, g a"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 (\u220f x in filter (fun a_1 => a \u2191a_1 (_ : \u2191a_1 \u2208 s)) (attach s), f \u2191x) *\n      \u220f x in filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s), g \u2191x =\n    (\u220f a in (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, f a) *\n      \u220f a in s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, g a", "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u220f x in filter (fun a_1 => a \u2191a_1 (_ : \u2191a_1 \u2208 s)) (attach s), f \u2191x =\n    \u220f a in (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, f a\n\ncase e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u220f x in filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s), g \u2191x =\n    \u220f a in s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, g a"}, {"tactic": "exact prod_bij'\n  (fun a _ => a.1) (by simp) (by simp)\n  (fun a ha => \u27e8a, (mem_filter.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n  (by simp) (by simp)", "annotated_tactic": ["exact <a>prod_bij'</a>\n            (fun a _ => a.1) (by simp) (by simp)\n            (fun a ha => \u27e8a, (<a>mem_filter</a>.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n            (by simp) (by simp)", [{"full_name": "Finset.prod_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [570, 9], "def_end_pos": [570, 18]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}]], "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u220f x in filter (fun a_1 => a \u2191a_1 (_ : \u2191a_1 \u2208 s)) (attach s), f \u2191x =\n    \u220f a in (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, f a\n\ncase e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u220f x in filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s), g \u2191x =\n    \u220f a in s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, g a", "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u220f x in filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s), g \u2191x =\n    \u220f a in s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, g a"}, {"tactic": "exact prod_bij'\n  (fun a _ => a.1) (by simp) (by simp)\n  (fun a ha => \u27e8a, (mem_sdiff.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n  (by simp) (by simp)", "annotated_tactic": ["exact <a>prod_bij'</a>\n            (fun a _ => a.1) (by simp) (by simp)\n            (fun a ha => \u27e8a, (<a>mem_sdiff</a>.1 ha).1\u27e9) (fun a ha => by simp at ha; simp; tauto)\n            (by simp) (by simp)", [{"full_name": "Finset.prod_bij'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [570, 9], "def_end_pos": [570, 18]}, {"full_name": "Finset.mem_sdiff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2097, 9], "def_end_pos": [2097, 18]}]], "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u220f x in filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s), g \u2191x =\n    \u220f a in s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d, g a", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : { x // x \u2208 s }) (ha : a_1 \u2208 filter (fun a_2 => a \u2191a_2 (_ : \u2191a_2 \u2208 s)) (attach s)),\n    (fun a_2 x => \u2191a_2) a_1 ha \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : { x // x \u2208 s }) (ha : a_1 \u2208 filter (fun a_2 => a \u2191a_2 (_ : \u2191a_2 \u2208 s)) (attach s)),\n    f \u2191a_1 = f ((fun a_2 x => \u2191a_2) a_1 ha)", "state_after": "no goals"}, {"tactic": "simp at ha", "annotated_tactic": ["simp at ha", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha : a \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\n\u22a2 (fun a ha => { val := a, property := (_ : a \u2208 s) }) a ha \u2208 filter (fun a => a\u271d \u2191a (_ : \u2191a \u2208 s)) (attach s)", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 \u2200 (h : a \u2208 s), a\u271d a h\n\u22a2 (fun a ha => { val := a, property := (_ : a \u2208 s) }) a ha\u271d \u2208 filter (fun a => a\u271d \u2191a (_ : \u2191a \u2208 s)) (attach s)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 \u2200 (h : a \u2208 s), a\u271d a h\n\u22a2 (fun a ha => { val := a, property := (_ : a \u2208 s) }) a ha\u271d \u2208 filter (fun a => a\u271d \u2191a (_ : \u2191a \u2208 s)) (attach s)", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 \u2200 (h : a \u2208 s), a\u271d a h\n\u22a2 a\u271d a (_ : \u2191{ val := a, property := (_ : a \u2208 s) } \u2208 s)"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 \u2200 (h : a \u2208 s), a\u271d a h\n\u22a2 a\u271d a (_ : \u2191{ val := a, property := (_ : a \u2208 s) } \u2208 s)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : { x // x \u2208 s }) (ha : a_1 \u2208 filter (fun a_2 => a \u2191a_2 (_ : \u2191a_2 \u2208 s)) (attach s)),\n    (fun a_2 ha => { val := a_2, property := (_ : a_2 \u2208 s) }) ((fun a_2 x => \u2191a_2) a_1 ha)\n        (_ : (fun a_2 x => \u2191a_2) a_1 ha \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d) =\n      a_1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : \u03b1) (ha : a_1 \u2208 (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d),\n    (fun a_2 x => \u2191a_2) ((fun a_2 ha => { val := a_2, property := (_ : a_2 \u2208 s) }) a_1 ha)\n        (_ :\n          (fun a_2 ha => { val := a_2, property := (_ : a_2 \u2208 s) }) a_1 ha \u2208\n            filter (fun a_2 => a \u2191a_2 (_ : \u2191a_2 \u2208 s)) (attach s)) =\n      a_1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : { x // x \u2208 s }) (ha : a_1 \u2208 filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s)),\n    (fun a_2 x => \u2191a_2) a_1 ha \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : { x // x \u2208 s }) (ha : a_1 \u2208 filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s)),\n    g \u2191a_1 = g ((fun a_2 x => \u2191a_2) a_1 ha)", "state_after": "no goals"}, {"tactic": "simp at ha", "annotated_tactic": ["simp at ha", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha : a \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\n\u22a2 (fun a ha => { val := a, property := (_ : a \u2208 s) }) a ha \u2208 filter (fun x => \u00aca\u271d \u2191x (_ : \u2191x \u2208 s)) (attach s)", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 (a \u2208 s \u2192 \u2203 (x : a \u2208 s), \u00aca\u271d a x)\n\u22a2 (fun a ha => { val := a, property := (_ : a \u2208 s) }) a ha\u271d \u2208 filter (fun x => \u00aca\u271d \u2191x (_ : \u2191x \u2208 s)) (attach s)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 (a \u2208 s \u2192 \u2203 (x : a \u2208 s), \u00aca\u271d a x)\n\u22a2 (fun a ha => { val := a, property := (_ : a \u2208 s) }) a ha\u271d \u2208 filter (fun x => \u00aca\u271d \u2191x (_ : \u2191x \u2208 s)) (attach s)", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 (a \u2208 s \u2192 \u2203 (x : a \u2208 s), \u00aca\u271d a x)\n\u22a2 \u00aca\u271d a (_ : \u2191{ val := a, property := (_ : a \u2208 s) } \u2208 s)"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d\u00b9 : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na\u271d : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a\u271d \u2208 pi s fun x => {True, False}\na : \u03b1\nha\u271d : a \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a\u271d x\u271d\nha : a \u2208 s \u2227 (a \u2208 s \u2192 \u2203 (x : a \u2208 s), \u00aca\u271d a x)\n\u22a2 \u00aca\u271d a (_ : \u2191{ val := a, property := (_ : a \u2208 s) } \u2208 s)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : { x // x \u2208 s }) (ha : a_1 \u2208 filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s)),\n    (fun a_2 ha => { val := a_2, property := (_ : a_2 \u2208 s) }) ((fun a_2 x => \u2191a_2) a_1 ha)\n        (_ : (fun a_2 x => \u2191a_2) a_1 ha \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d) =\n      a_1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\na : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop\nx\u271d : a \u2208 pi s fun x => {True, False}\n\u22a2 \u2200 (a_1 : \u03b1) (ha : a_1 \u2208 s \\ (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a x\u271d),\n    (fun a_2 x => \u2191a_2) ((fun a_2 ha => { val := a_2, property := (_ : a_2 \u2208 s) }) a_1 ha)\n        (_ :\n          (fun a_2 ha => { val := a_2, property := (_ : a_2 \u2208 s) }) a_1 ha \u2208\n            filter (fun x => \u00aca \u2191x (_ : \u2191x \u2208 s)) (attach s)) =\n      a_1", "state_after": "no goals"}, {"tactic": "simp [Classical.em]", "annotated_tactic": ["simp [<a>Classical.em</a>]", [{"full_name": "Classical.em", "def_path": "lake-packages/lean4/src/lean/Init/Classical.lean", "def_pos": [26, 9], "def_end_pos": [26, 11]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 (a : Finset \u03b1) (ha : a \u2208 powerset s), (fun t x a x => a \u2208 t) a ha \u2208 pi s fun x => {True, False}", "state_after": "no goals"}, {"tactic": "simp_rw [mem_filter, Function.funext_iff, eq_iff_iff, mem_pi, mem_insert]", "annotated_tactic": ["simp_rw [<a>mem_filter</a>, <a>Function.funext_iff</a>, <a>eq_iff_iff</a>, <a>mem_pi</a>, <a>mem_insert</a>]", [{"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "Function.funext_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 19]}, {"full_name": "eq_iff_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [53, 17], "def_end_pos": [53, 27]}, {"full_name": "Finset.mem_pi", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Pi.lean", "def_pos": [49, 9], "def_end_pos": [49, 15]}, {"full_name": "Finset.mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1099, 9], "def_end_pos": [1099, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 (a : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop) (ha : a \u2208 pi s fun x => {True, False}),\n    (fun t x a x => a \u2208 t) ((fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a ha)\n        (_ : (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) a ha \u2208 powerset s) =\n      a", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 (a : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop),\n    (\u2200 (a_1 : \u03b1) (h : a_1 \u2208 s), a a_1 h = True \u2228 a a_1 h \u2208 {False}) \u2192\n      \u2200 (a_1 : \u03b1) (a_2 : a_1 \u2208 s), (a_1 \u2208 s \u2227 \u2200 (h : a_1 \u2208 s), a a_1 h) \u2194 a a_1 a_2"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 (a : (a : \u03b1) \u2192 a \u2208 s \u2192 Prop),\n    (\u2200 (a_1 : \u03b1) (h : a_1 \u2208 s), a a_1 h = True \u2228 a a_1 h \u2208 {False}) \u2192\n      \u2200 (a_1 : \u03b1) (a_2 : a_1 \u2208 s), (a_1 \u2208 s \u2227 \u2200 (h : a_1 \u2208 s), a a_1 h) \u2194 a a_1 a_2", "state_after": "no goals"}, {"tactic": "simp_rw [ext_iff, @mem_filter _ _ (id _), mem_powerset]", "annotated_tactic": ["simp_rw [<a>ext_iff</a>, @<a>mem_filter</a> _ _ (<a>id</a> _), <a>mem_powerset</a>]", [{"full_name": "Finset.ext_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 16]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Finset.mem_powerset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [34, 9], "def_end_pos": [34, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 (a : Finset \u03b1) (ha : a \u2208 powerset s),\n    (fun f x => filter (fun a => \u2200 (h : a \u2208 s), f a h) s) ((fun t x a x => a \u2208 t) a ha)\n        (_ : (fun t x a x => a \u2208 t) a ha \u2208 pi s fun x => {True, False}) =\n      a", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 a \u2286 s, \u2200 (a_1 : \u03b1), a_1 \u2208 s \u2227 (a_1 \u2208 s \u2192 a_1 \u2208 a) \u2194 a_1 \u2208 a"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommSemiring \u03b2\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\n\u22a2 \u2200 a \u2286 s, \u2200 (a_1 : \u03b1), a_1 \u2208 s \u2227 (a_1 \u2208 s \u2192 a_1 \u2208 a) \u2194 a_1 \u2208 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "full_name": "Multiset.prod_map_le_prod", "start": [410, 1], "end": [411, 68], "traced_tactics": []}, {"url": "https://github.com/Moyvbai/Theorem", "commit": "2fad0ff51bf93233afcde842768074b0c8b33efa", "file_path": "Theorem/example_separate/mul_two_div_mul.lean", "full_name": "mul_two_div_mul", "start": [4, 1], "end": [12, 10], "traced_tactics": [{"tactic": "rw[\u2190 div_eq_mul_one_div]", "annotated_tactic": ["rw[\u2190 <a>div_eq_mul_one_div</a>]", [{"full_name": "div_eq_mul_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [329, 9], "def_end_pos": [329, 27]}]], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) * (1 / 2) = 2 * (n + 1) / (n + 2) * (1 / 2)", "state_after": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) / 2 = 2 * (n + 1) / (n + 2) * (1 / 2)"}, {"tactic": "rw[div_div]", "annotated_tactic": ["rw[<a>div_div</a>]", [{"full_name": "div_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [527, 9], "def_end_pos": [527, 16]}]], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (m + 1) / 2 = 2 * (n + 1) / (n + 2) * (1 / 2)", "state_after": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / ((m + 1) * 2) = 2 * (n + 1) / (n + 2) * (1 / 2)"}, {"tactic": "rw[add_mul, mul_comm (m : \u211d) 2]", "annotated_tactic": ["rw[<a>add_mul</a>, <a>mul_comm</a> (m : \u211d) 2]", [{"full_name": "add_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / ((m + 1) * 2) = 2 * (n + 1) / (n + 2) * (1 / 2)", "state_after": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 1 * 2) = 2 * (n + 1) / (n + 2) * (1 / 2)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 1 * 2) = 2 * (n + 1) / (n + 2) * (1 / 2)", "state_after": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = 2 * (n + 1) / (n + 2) * 2\u207b\u00b9"}, {"tactic": "rw[\u2190 mul_div]", "annotated_tactic": ["rw[\u2190 <a>mul_div</a>]", [{"full_name": "mul_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [324, 9], "def_end_pos": [324, 16]}]], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = 2 * (n + 1) / (n + 2) * 2\u207b\u00b9", "state_after": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = 2 * ((n + 1) / (n + 2)) * 2\u207b\u00b9"}, {"tactic": "rw[mul_right_comm]", "annotated_tactic": ["rw[<a>mul_right_comm</a>]", [{"full_name": "mul_right_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [102, 9], "def_end_pos": [102, 23]}]], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = 2 * ((n + 1) / (n + 2)) * 2\u207b\u00b9", "state_after": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = 2 * 2\u207b\u00b9 * ((n + 1) / (n + 2))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = 2 * 2\u207b\u00b9 * ((n + 1) / (n + 2))", "state_after": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = (n + 1) / (n + 2)"}, {"tactic": "rw[hnm]", "annotated_tactic": ["rw[hnm]", []], "state_before": "n m : \u211d\nhnm : n = 2 * m\n\u22a2 (2 * m + 1) / (2 * m + 2) = (n + 1) / (n + 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.image_mul_left", "start": [1151, 1], "end": [1153, 27], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b2\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : DivisionMonoid \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\ns t : Finset \u03b1\na b : \u03b1\n\u22a2 \u2191(image (fun b => a * b) t) =\n    \u2191(preimage t (fun b => a\u207b\u00b9 * b) (_ : Set.InjOn ((fun x x_1 => x * x_1) a\u207b\u00b9) ((fun b => a\u207b\u00b9 * b) \u207b\u00b9' \u2191t)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean", "full_name": "Polynomial.leadingCoeff_prod'", "start": [161, 1], "end": [163, 73], "traced_tactics": [{"tactic": "simpa using leadingCoeff_multiset_prod' (s.1.map f) (by simpa using h)", "annotated_tactic": ["simpa using <a>leadingCoeff_multiset_prod'</a> (s.1.<a>map</a> f) (by simpa using h)", [{"full_name": "Polynomial.leadingCoeff_multiset_prod'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Polynomial/BigOperators.lean", "def_pos": [141, 9], "def_end_pos": [141, 36]}, {"full_name": "Multiset.map", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1146, 5], "def_end_pos": [1146, 8]}]], "state_before": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nh : \u220f i in s, leadingCoeff (f i) \u2260 0\n\u22a2 leadingCoeff (\u220f i in s, f i) = \u220f i in s, leadingCoeff (f i)", "state_after": "no goals"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nh : \u220f i in s, leadingCoeff (f i) \u2260 0\n\u22a2 prod (Multiset.map leadingCoeff (Multiset.map f s.val)) \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.mul_def", "start": [20, 1], "end": [20, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "full_name": "eq_div_of_mul_eq", "start": [109, 1], "end": [110, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Zip.lean", "full_name": "List.unzip_swap", "start": [165, 1], "end": [167, 6], "traced_tactics": [{"tactic": "simp only [unzip_eq_map, map_map]", "annotated_tactic": ["simp only [<a>unzip_eq_map</a>, <a>map_map</a>]", [{"full_name": "List.unzip_eq_map", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Zip.lean", "def_pos": [154, 9], "def_end_pos": [154, 21]}, {"full_name": "List.map_map", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [106, 17], "def_end_pos": [106, 24]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List (\u03b1 \u00d7 \u03b2)\n\u22a2 unzip (map Prod.swap l) = Prod.swap (unzip l)", "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List (\u03b1 \u00d7 \u03b2)\n\u22a2 (map (Prod.fst \u2218 Prod.swap) l, map (Prod.snd \u2218 Prod.swap) l) = Prod.swap (map Prod.fst l, map Prod.snd l)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List (\u03b1 \u00d7 \u03b2)\n\u22a2 (map (Prod.fst \u2218 Prod.swap) l, map (Prod.snd \u2218 Prod.swap) l) = Prod.swap (map Prod.fst l, map Prod.snd l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Order/Basic.lean", "full_name": "Nat.div_dvd_of_dvd", "start": [451, 1], "end": [452, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_lt_iff_left", "start": [238, 1], "end": [239, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Bits.lean", "full_name": "Nat.bodd_bit0", "start": [44, 1], "end": [45, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.forall_of_forall_insert", "start": [3166, 1], "end": [3168, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NoncommProd.lean", "full_name": "Finset.noncommProd_singleton", "start": [343, 1], "end": [348, 23], "traced_tactics": [{"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : Monoid \u03b3\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.Pairwise \u2191{a} fun a b => Commute (f a) (f b)", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : Monoid \u03b3\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.Pairwise {a} fun a b => Commute (f a) (f b)"}, {"tactic": "exact Set.pairwise_singleton _ _", "annotated_tactic": ["exact <a>Set.pairwise_singleton</a> _ _", [{"full_name": "Set.pairwise_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pairwise/Basic.lean", "def_pos": [89, 9], "def_end_pos": [89, 27]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : Monoid \u03b3\na : \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.Pairwise {a} fun a b => Commute (f a) (f b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/List.lean", "full_name": "List.formPerm_apply_nthLe_length", "start": [140, 1], "end": [142, 54], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x : \u03b1\nxs : List \u03b1\n\u22a2 length xs < length (x :: xs)", "state_after": "no goals"}, {"tactic": "rw [nthLe_cons_length, formPerm_apply_getLast]", "annotated_tactic": ["rw [<a>nthLe_cons_length</a>, <a>formPerm_apply_getLast</a>]", [{"full_name": "List.nthLe_cons_length", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1311, 9], "def_end_pos": [1311, 26]}, {"full_name": "List.formPerm_apply_getLast", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/List.lean", "def_pos": [133, 9], "def_end_pos": [133, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x : \u03b1\nxs : List \u03b1\n\u22a2 \u2191(formPerm (x :: xs)) (nthLe (x :: xs) (length xs) (_ : length xs < Nat.succ (length xs))) = x", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x : \u03b1\nxs : List \u03b1\n\u22a2 length xs = length xs"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x : \u03b1\nxs : List \u03b1\n\u22a2 length xs = length xs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.fromBlocks_apply\u2081\u2081", "start": [51, 1], "end": [53, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.append_eq_append", "start": [103, 1], "end": [103, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.isPeriodicPt_zero", "start": [71, 1], "end": [72, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Function.Semiconj.mapsTo_range", "start": [1669, 1], "end": [1670, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.image_subset_iff", "start": [497, 1], "end": [498, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.neg_of", "start": [311, 1], "end": [312, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "TensorProduct.neg_tmul", "start": [1279, 1], "end": [1280, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.MapsTo.iterate_restrict", "start": [446, 1], "end": [452, 28], "traced_tactics": [{"tactic": "funext x", "annotated_tactic": ["funext x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nn : \u2115\n\u22a2 (restrict f s s h)^[n] = restrict f^[n] s s (_ : MapsTo f^[n] s s)", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nn : \u2115\nx : \u2191s\n\u22a2 (restrict f s s h)^[n] x = restrict f^[n] s s (_ : MapsTo f^[n] s s) x"}, {"tactic": "rw [Subtype.ext_iff, MapsTo.val_restrict_apply]", "annotated_tactic": ["rw [<a>Subtype.ext_iff</a>, <a>MapsTo.val_restrict_apply</a>]", [{"full_name": "Subtype.ext_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [69, 9], "def_end_pos": [69, 16]}, {"full_name": "Set.MapsTo.val_restrict_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [363, 9], "def_end_pos": [363, 34]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nn : \u2115\nx : \u2191s\n\u22a2 (restrict f s s h)^[n] x = restrict f^[n] s s (_ : MapsTo f^[n] s s) x", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nn : \u2115\nx : \u2191s\n\u22a2 \u2191((restrict f s s h)^[n] x) = f^[n] \u2191x"}, {"tactic": "induction' n with n ihn generalizing x", "annotated_tactic": ["induction' n with n ihn generalizing x", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nn : \u2115\nx : \u2191s\n\u22a2 \u2191((restrict f s s h)^[n] x) = f^[n] \u2191x", "state_after": "case h.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nx : \u2191s\n\u22a2 \u2191((restrict f s s h)^[Nat.zero] x) = f^[Nat.zero] \u2191x\n\ncase h.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nn : \u2115\nihn : \u2200 (x : \u2191s), \u2191((restrict f s s h)^[n] x) = f^[n] \u2191x\nx : \u2191s\n\u22a2 \u2191((restrict f s s h)^[Nat.succ n] x) = f^[Nat.succ n] \u2191x"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nx : \u2191s\n\u22a2 \u2191((restrict f s s h)^[Nat.zero] x) = f^[Nat.zero] \u2191x", "state_after": "no goals"}, {"tactic": "simp [Nat.iterate, ihn]", "annotated_tactic": ["simp [<a>Nat.iterate</a>, ihn]", [{"full_name": "Nat.iterate", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [38, 5], "def_end_pos": [38, 16]}]], "state_before": "case h.succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf\u271d f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\nh : MapsTo f s s\nn : \u2115\nihn : \u2200 (x : \u2191s), \u2191((restrict f s s h)^[n] x) = f^[n] \u2191x\nx : \u2191s\n\u22a2 \u2191((restrict f s s h)^[Nat.succ n] x) = f^[Nat.succ n] \u2191x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/CommRing.lean", "full_name": "MvPolynomial.eval\u2082_sub", "start": [134, 1], "end": [135, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Divisibility/Basic.lean", "full_name": "mul_dvd_mul_left", "start": [195, 1], "end": [196, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.succ_le_succ", "start": [272, 1], "end": [277, 90], "traced_tactics": [{"tactic": "by_cases hb : IsMax b", "annotated_tactic": ["by_cases hb : <a>IsMax</a> b", [{"full_name": "IsMax", "def_path": "lake-packages/mathlib/Mathlib/Order/Max.lean", "def_pos": [209, 5], "def_end_pos": [209, 10]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\n\u22a2 succ a \u2264 succ b", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : IsMax b\n\u22a2 succ a \u2264 succ b\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : \u00acIsMax b\n\u22a2 succ a \u2264 succ b"}, {"tactic": "by_cases hba : b \u2264 a", "annotated_tactic": ["by_cases hba : b \u2264 a", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : IsMax b\n\u22a2 succ a \u2264 succ b", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : IsMax b\nhba : b \u2264 a\n\u22a2 succ a \u2264 succ b\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : IsMax b\nhba : \u00acb \u2264 a\n\u22a2 succ a \u2264 succ b"}, {"tactic": "exact (hb <| hba.trans <| le_succ _).trans (le_succ _)", "annotated_tactic": ["exact (hb <| hba.trans <| <a>le_succ</a> _).<a>trans</a> (<a>le_succ</a> _)", [{"full_name": "Order.le_succ", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}, {"full_name": "LE.le.trans", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [120, 7], "def_end_pos": [120, 18]}, {"full_name": "Order.le_succ", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : IsMax b\nhba : b \u2264 a\n\u22a2 succ a \u2264 succ b", "state_after": "no goals"}, {"tactic": "exact succ_le_of_lt ((h.lt_of_not_le hba).trans_le <| le_succ b)", "annotated_tactic": ["exact <a>succ_le_of_lt</a> ((h.lt_of_not_le hba).<a>trans_le</a> <| <a>le_succ</a> b)", [{"full_name": "Order.succ_le_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [221, 9], "def_end_pos": [221, 22]}, {"full_name": "LT.lt.trans_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [148, 7], "def_end_pos": [148, 21]}, {"full_name": "Order.le_succ", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [213, 9], "def_end_pos": [213, 16]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : IsMax b\nhba : \u00acb \u2264 a\n\u22a2 succ a \u2264 succ b", "state_after": "no goals"}, {"tactic": "rwa [succ_le_iff_of_not_isMax fun ha => hb <| ha.mono h, lt_succ_iff_of_not_isMax hb]", "annotated_tactic": ["rwa [<a>succ_le_iff_of_not_isMax</a> fun ha => hb <| ha.mono h, <a>lt_succ_iff_of_not_isMax</a> hb]", [{"full_name": "Order.succ_le_iff_of_not_isMax", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [254, 9], "def_end_pos": [254, 33]}, {"full_name": "Order.lt_succ_iff_of_not_isMax", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [250, 9], "def_end_pos": [250, 33]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2264 b\nhb : \u00acIsMax b\n\u22a2 succ a \u2264 succ b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.isRotated_nil_iff", "start": [488, 1], "end": [489, 58], "traced_tactics": [{"tactic": "simpa using hn", "annotated_tactic": ["simpa using hn", []], "state_before": "\u03b1 : Type u\nl l' : List \u03b1\nx\u271d : l ~r []\nn : \u2115\nhn : rotate l n = []\n\u22a2 l = []", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u\nl l' : List \u03b1\nh : l = []\n\u22a2 l ~r l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/WithTop.lean", "full_name": "WithTop.add_right_cancel_iff", "start": [183, 1], "end": [189, 60], "traced_tactics": [{"tactic": "lift a to \u03b1 using ha", "annotated_tactic": ["lift a to \u03b1 using ha", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\na b c d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\nha : a \u2260 \u22a4\n\u22a2 b + a = c + a \u2194 b = c", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nb c d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na : \u03b1\n\u22a2 b + \u2191a = c + \u2191a \u2194 b = c"}, {"tactic": "obtain rfl | hb := (eq_or_ne b \u22a4)", "annotated_tactic": ["obtain rfl | hb := (<a>eq_or_ne</a> b \u22a4)", [{"full_name": "eq_or_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nb c d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na : \u03b1\n\u22a2 b + \u2191a = c + \u2191a \u2194 b = c", "state_after": "case intro.inl\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nc d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na : \u03b1\n\u22a2 \u22a4 + \u2191a = c + \u2191a \u2194 \u22a4 = c\n\ncase intro.inr\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nb c d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na : \u03b1\nhb : b \u2260 \u22a4\n\u22a2 b + \u2191a = c + \u2191a \u2194 b = c"}, {"tactic": "lift b to \u03b1 using hb", "annotated_tactic": ["lift b to \u03b1 using hb", []], "state_before": "case intro.inr\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nb c d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na : \u03b1\nhb : b \u2260 \u22a4\n\u22a2 b + \u2191a = c + \u2191a \u2194 b = c", "state_after": "case intro.inr.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nc d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na b : \u03b1\n\u22a2 \u2191b + \u2191a = c + \u2191a \u2194 \u2191b = c"}, {"tactic": "simp_rw [\u2190WithTop.coe_add, eq_comm, WithTop.add_eq_coe, coe_eq_coe, exists_and_left,\n  exists_eq_left, add_left_inj, exists_eq_right, eq_comm]", "annotated_tactic": ["simp_rw [\u2190<a>WithTop.coe_add</a>, <a>eq_comm</a>, <a>WithTop.add_eq_coe</a>, <a>coe_eq_coe</a>, <a>exists_and_left</a>,\n    <a>exists_eq_left</a>, <a>add_left_inj</a>, <a>exists_eq_right</a>, <a>eq_comm</a>]", [{"full_name": "WithTop.coe_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/WithTop.lean", "def_pos": [122, 9], "def_end_pos": [122, 16]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}, {"full_name": "WithTop.add_eq_coe", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/WithTop.lean", "def_pos": [163, 9], "def_end_pos": [163, 19]}, {"full_name": "WithTop.coe_eq_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [728, 9], "def_end_pos": [728, 19]}, {"full_name": "exists_and_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [471, 17], "def_end_pos": [471, 32]}, {"full_name": "exists_eq_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [465, 17], "def_end_pos": [465, 31]}, {"full_name": "add_left_inj", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [223, 3], "def_end_pos": [223, 14]}, {"full_name": "exists_eq_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [468, 17], "def_end_pos": [468, 32]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "case intro.inr.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nc d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na b : \u03b1\n\u22a2 \u2191b + \u2191a = c + \u2191a \u2194 \u2191b = c", "state_after": "no goals"}, {"tactic": "rw [top_add, eq_comm, WithTop.add_coe_eq_top_iff, eq_comm]", "annotated_tactic": ["rw [<a>top_add</a>, <a>eq_comm</a>, <a>WithTop.add_coe_eq_top_iff</a>, <a>eq_comm</a>]", [{"full_name": "WithTop.top_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/WithTop.lean", "def_pos": [142, 9], "def_end_pos": [142, 16]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}, {"full_name": "WithTop.add_coe_eq_top_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/WithTop.lean", "def_pos": [173, 9], "def_end_pos": [173, 27]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "case intro.inl\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : Add \u03b1\nc d : WithTop \u03b1\nx y : \u03b1\ninst\u271d : IsRightCancelAdd \u03b1\na : \u03b1\n\u22a2 \u22a4 + \u2191a = c + \u2191a \u2194 \u22a4 = c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.diff_union_inter", "start": [1887, 1], "end": [1889, 26], "traced_tactics": [{"tactic": "rw [union_comm]", "annotated_tactic": ["rw [<a>union_comm</a>]", [{"full_name": "Set.union_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [779, 9], "def_end_pos": [779, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u s t : Set \u03b1\n\u22a2 s \\ t \u222a s \u2229 t = s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u s t : Set \u03b1\n\u22a2 s \u2229 t \u222a s \\ t = s"}, {"tactic": "exact sup_inf_sdiff _ _", "annotated_tactic": ["exact <a>sup_inf_sdiff</a> _ _", [{"full_name": "sup_inf_sdiff", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [97, 9], "def_end_pos": [97, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t\u271d t\u2081 t\u2082 u s t : Set \u03b1\n\u22a2 s \u2229 t \u222a s \\ t = s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Sign.lean", "full_name": "Equiv.Perm.sign_sumCongr", "start": [768, 1], "end": [779, 67], "traced_tactics": [{"tactic": "suffices sign (sumCongr \u03c3a (1 : Perm \u03b2)) = sign \u03c3a \u2227 sign (sumCongr (1 : Perm \u03b1) \u03c3b) = sign \u03c3b\n  by rw [\u2190 this.1, \u2190 this.2, \u2190 sign_mul, sumCongr_mul, one_mul, mul_one]", "annotated_tactic": ["suffices <a>sign</a> (<a>sumCongr</a> \u03c3a (1 : <a>Perm</a> \u03b2)) = <a>sign</a> \u03c3a \u2227 <a>sign</a> (<a>sumCongr</a> (1 : <a>Perm</a> \u03b1) \u03c3b) = <a>sign</a> \u03c3b\n    by rw [\u2190 this.1, \u2190 this.2, \u2190 <a>sign_mul</a>, <a>sumCongr_mul</a>, <a>one_mul</a>, <a>mul_one</a>]", [{"full_name": "Equiv.Perm.sign", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [537, 5], "def_end_pos": [537, 9]}, {"full_name": "Equiv.Perm.sumCongr", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [356, 5], "def_end_pos": [356, 13]}, {"full_name": "Equiv.Perm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [91, 5], "def_end_pos": [91, 15]}, {"full_name": "Equiv.Perm.sign", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [537, 5], "def_end_pos": [537, 9]}, {"full_name": "Equiv.Perm.sign", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [537, 5], "def_end_pos": [537, 9]}, {"full_name": "Equiv.Perm.sumCongr", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [356, 5], "def_end_pos": [356, 13]}, {"full_name": "Equiv.Perm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [91, 5], "def_end_pos": [91, 15]}, {"full_name": "Equiv.Perm.sign", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [537, 5], "def_end_pos": [537, 9]}, {"full_name": "Equiv.Perm.sign_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [546, 9], "def_end_pos": [546, 17]}, {"full_name": "Equiv.Perm.sumCongr_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [190, 9], "def_end_pos": [190, 21]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr \u03c3a \u03c3b) = \u2191sign \u03c3a * \u2191sign \u03c3b", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr \u03c3a 1) = \u2191sign \u03c3a \u2227 \u2191sign (sumCongr 1 \u03c3b) = \u2191sign \u03c3b"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr \u03c3a 1) = \u2191sign \u03c3a \u2227 \u2191sign (sumCongr 1 \u03c3b) = \u2191sign \u03c3b", "state_after": "case left\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr \u03c3a 1) = \u2191sign \u03c3a\n\ncase right\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr 1 \u03c3b) = \u2191sign \u03c3b"}, {"tactic": "rw [\u2190 this.1, \u2190 this.2, \u2190 sign_mul, sumCongr_mul, one_mul, mul_one]", "annotated_tactic": ["rw [\u2190 this.1, \u2190 this.2, \u2190 <a>sign_mul</a>, <a>sumCongr_mul</a>, <a>one_mul</a>, <a>mul_one</a>]", [{"full_name": "Equiv.Perm.sign_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [546, 9], "def_end_pos": [546, 17]}, {"full_name": "Equiv.Perm.sumCongr_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [190, 9], "def_end_pos": [190, 21]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\nthis : \u2191sign (sumCongr \u03c3a 1) = \u2191sign \u03c3a \u2227 \u2191sign (sumCongr 1 \u03c3b) = \u2191sign \u03c3b\n\u22a2 \u2191sign (sumCongr \u03c3a \u03c3b) = \u2191sign \u03c3a * \u2191sign \u03c3b", "state_after": "no goals"}, {"tactic": "refine' \u03c3a.swap_induction_on ?_ fun \u03c3a' a\u2081 a\u2082 ha ih => ?_", "annotated_tactic": ["refine' \u03c3a.swap_induction_on ?_ fun \u03c3a' a\u2081 a\u2082 ha ih => ?_", []], "state_before": "case left\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr \u03c3a 1) = \u2191sign \u03c3a", "state_after": "case left.refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr 1 1) = \u2191sign 1\n\ncase left.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u03c3a' : Perm \u03b1\na\u2081 a\u2082 : \u03b1\nha : a\u2081 \u2260 a\u2082\nih : \u2191sign (sumCongr \u03c3a' 1) = \u2191sign \u03c3a'\n\u22a2 \u2191sign (sumCongr (swap a\u2081 a\u2082 * \u03c3a') 1) = \u2191sign (swap a\u2081 a\u2082 * \u03c3a')"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case left.refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr 1 1) = \u2191sign 1", "state_after": "no goals"}, {"tactic": "rw [\u2190 one_mul (1 : Perm \u03b2), \u2190 sumCongr_mul, sign_mul, sign_mul, ih, sumCongr_swap_one,\n  sign_swap ha, sign_swap (Sum.inl_injective.ne_iff.mpr ha)]", "annotated_tactic": ["rw [\u2190 <a>one_mul</a> (1 : <a>Perm</a> \u03b2), \u2190 <a>sumCongr_mul</a>, <a>sign_mul</a>, <a>sign_mul</a>, ih, <a>sumCongr_swap_one</a>,\n        <a>sign_swap</a> ha, <a>sign_swap</a> (Sum.inl_injective.ne_iff.mpr ha)]", [{"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "Equiv.Perm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [91, 5], "def_end_pos": [91, 15]}, {"full_name": "Equiv.Perm.sumCongr_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [190, 9], "def_end_pos": [190, 21]}, {"full_name": "Equiv.Perm.sign_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [546, 9], "def_end_pos": [546, 17]}, {"full_name": "Equiv.Perm.sign_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [546, 9], "def_end_pos": [546, 17]}, {"full_name": "Equiv.Perm.sumCongr_swap_one", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [227, 9], "def_end_pos": [227, 26]}, {"full_name": "Equiv.Perm.sign_swap", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [575, 9], "def_end_pos": [575, 18]}, {"full_name": "Equiv.Perm.sign_swap", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [575, 9], "def_end_pos": [575, 18]}]], "state_before": "case left.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u03c3a' : Perm \u03b1\na\u2081 a\u2082 : \u03b1\nha : a\u2081 \u2260 a\u2082\nih : \u2191sign (sumCongr \u03c3a' 1) = \u2191sign \u03c3a'\n\u22a2 \u2191sign (sumCongr (swap a\u2081 a\u2082 * \u03c3a') 1) = \u2191sign (swap a\u2081 a\u2082 * \u03c3a')", "state_after": "no goals"}, {"tactic": "refine' \u03c3b.swap_induction_on ?_ fun \u03c3b' b\u2081 b\u2082 hb ih => ?_", "annotated_tactic": ["refine' \u03c3b.swap_induction_on ?_ fun \u03c3b' b\u2081 b\u2082 hb ih => ?_", []], "state_before": "case right\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr 1 \u03c3b) = \u2191sign \u03c3b", "state_after": "case right.refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr 1 1) = \u2191sign 1\n\ncase right.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b \u03c3b' : Perm \u03b2\nb\u2081 b\u2082 : \u03b2\nhb : b\u2081 \u2260 b\u2082\nih : \u2191sign (sumCongr 1 \u03c3b') = \u2191sign \u03c3b'\n\u22a2 \u2191sign (sumCongr 1 (swap b\u2081 b\u2082 * \u03c3b')) = \u2191sign (swap b\u2081 b\u2082 * \u03c3b')"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case right.refine'_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b : Perm \u03b2\n\u22a2 \u2191sign (sumCongr 1 1) = \u2191sign 1", "state_after": "no goals"}, {"tactic": "rw [\u2190 one_mul (1 : Perm \u03b1), \u2190 sumCongr_mul, sign_mul, sign_mul, ih, sumCongr_one_swap,\n  sign_swap hb, sign_swap (Sum.inr_injective.ne_iff.mpr hb)]", "annotated_tactic": ["rw [\u2190 <a>one_mul</a> (1 : <a>Perm</a> \u03b1), \u2190 <a>sumCongr_mul</a>, <a>sign_mul</a>, <a>sign_mul</a>, ih, <a>sumCongr_one_swap</a>,\n        <a>sign_swap</a> hb, <a>sign_swap</a> (Sum.inr_injective.ne_iff.mpr hb)]", [{"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "Equiv.Perm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [91, 5], "def_end_pos": [91, 15]}, {"full_name": "Equiv.Perm.sumCongr_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [190, 9], "def_end_pos": [190, 21]}, {"full_name": "Equiv.Perm.sign_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [546, 9], "def_end_pos": [546, 17]}, {"full_name": "Equiv.Perm.sign_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [546, 9], "def_end_pos": [546, 17]}, {"full_name": "Equiv.Perm.sumCongr_one_swap", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [233, 9], "def_end_pos": [233, 26]}, {"full_name": "Equiv.Perm.sign_swap", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [575, 9], "def_end_pos": [575, 18]}, {"full_name": "Equiv.Perm.sign_swap", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [575, 9], "def_end_pos": [575, 18]}]], "state_before": "case right.refine'_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Fintype \u03b2\n\u03c3a : Perm \u03b1\n\u03c3b \u03c3b' : Perm \u03b2\nb\u2081 b\u2082 : \u03b2\nhb : b\u2081 \u2260 b\u2082\nih : \u2191sign (sumCongr 1 \u03c3b') = \u2191sign \u03c3b'\n\u22a2 \u2191sign (sumCongr 1 (swap b\u2081 b\u2082 * \u03c3b')) = \u2191sign (swap b\u2081 b\u2082 * \u03c3b')", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.take_zero", "start": [180, 9], "end": [180, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Quotient.lean", "full_name": "Ideal.quotEquivOfEq_symm", "start": [316, 1], "end": [317, 77], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R\u271d : Type u\ninst\u271d\u00b9 : CommRing R\u271d\nI\u271d : Ideal R\u271d\na b : R\u271d\nS : Type v\nR : Type u_1\ninst\u271d : CommRing R\nI J : Ideal R\nh : I = J\n\u22a2 RingEquiv.symm (quotEquivOfEq h) = quotEquivOfEq (_ : J = I)", "state_after": "case h\nR\u271d : Type u\ninst\u271d\u00b9 : CommRing R\u271d\nI\u271d : Ideal R\u271d\na b : R\u271d\nS : Type v\nR : Type u_1\ninst\u271d : CommRing R\nI J : Ideal R\nh : I = J\nx\u271d : R \u29f8 J\n\u22a2 \u2191(RingEquiv.symm (quotEquivOfEq h)) x\u271d = \u2191(quotEquivOfEq (_ : J = I)) x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h\nR\u271d : Type u\ninst\u271d\u00b9 : CommRing R\u271d\nI\u271d : Ideal R\u271d\na b : R\u271d\nS : Type v\nR : Type u_1\ninst\u271d : CommRing R\nI J : Ideal R\nh : I = J\nx\u271d : R \u29f8 J\n\u22a2 \u2191(RingEquiv.symm (quotEquivOfEq h)) x\u271d = \u2191(quotEquivOfEq (_ : J = I)) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.coeff_monomial_mul'", "start": [795, 1], "end": [799, 36], "traced_tactics": [{"tactic": "rw [mul_comm, mul_comm r]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>mul_comm</a> r]", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm s : \u03c3 \u2192\u2080 \u2115\nr : R\np : MvPolynomial \u03c3 R\n\u22a2 coeff m (\u2191(monomial s) r * p) = if s \u2264 m then r * coeff (m - s) p else 0", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm s : \u03c3 \u2192\u2080 \u2115\nr : R\np : MvPolynomial \u03c3 R\n\u22a2 coeff m (p * \u2191(monomial s) r) = if s \u2264 m then coeff (m - s) p * r else 0"}, {"tactic": "exact coeff_mul_monomial' _ _ _ _", "annotated_tactic": ["exact <a>coeff_mul_monomial'</a> _ _ _ _", [{"full_name": "MvPolynomial.coeff_mul_monomial'", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [772, 9], "def_end_pos": [772, 28]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m\u271d : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np\u271d q : MvPolynomial \u03c3 R\nm s : \u03c3 \u2192\u2080 \u2115\nr : R\np : MvPolynomial \u03c3 R\n\u22a2 coeff m (p * \u2191(monomial s) r) = if s \u2264 m then coeff (m - s) p * r else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/RowCol.lean", "full_name": "Matrix.updateColumn_ne", "start": [194, 1], "end": [197, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_filter_le", "start": [270, 1], "end": [272, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Basic.lean", "full_name": "Nat.succ_ne_succ", "start": [178, 1], "end": [179, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/LocallyFinite.lean", "full_name": "Finset.right_not_mem_Ico", "start": [163, 1], "end": [163, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Unique.lean", "full_name": "Unique.forall_iff", "start": [155, 1], "end": [156, 56], "traced_tactics": [{"tactic": "rwa [Unique.eq_default x]", "annotated_tactic": ["rwa [<a>Unique.eq_default</a> x]", [{"full_name": "Unique.eq_default", "def_path": "lake-packages/mathlib/Mathlib/Logic/Unique.lean", "def_pos": [143, 9], "def_end_pos": [143, 19]}]], "state_before": "\u03b1 : Sort u_1\ninst\u271d : Unique \u03b1\np : \u03b1 \u2192 Prop\nh : p default\nx : \u03b1\n\u22a2 p x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.prod_mono_right", "start": [1126, 1], "end": [1127, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "Set.wcovby_insert", "start": [482, 1], "end": [487, 64], "traced_tactics": [{"tactic": "refine' wcovby_of_eq_or_eq (subset_insert x s) fun t hst h2t => _", "annotated_tactic": ["refine' <a>wcovby_of_eq_or_eq</a> (<a>subset_insert</a> x s) fun t hst h2t => _", [{"full_name": "wcovby_of_eq_or_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/Cover.lean", "def_pos": [76, 9], "def_end_pos": [76, 27]}, {"full_name": "Set.subset_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns : Set \u03b1\n\u22a2 s \u2a7f insert x s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\n\u22a2 t = s \u2228 t = insert x s"}, {"tactic": "by_cases h : x \u2208 t", "annotated_tactic": ["by_cases h : x \u2208 t", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\n\u22a2 t = s \u2228 t = insert x s", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\nh : x \u2208 t\n\u22a2 t = s \u2228 t = insert x s\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\nh : x \u2209 t\n\u22a2 t = s \u2228 t = insert x s"}, {"tactic": "exact Or.inr (subset_antisymm h2t <| insert_subset_iff.mpr \u27e8h, hst\u27e9)", "annotated_tactic": ["exact <a>Or.inr</a> (<a>subset_antisymm</a> h2t <| insert_subset_iff.mpr \u27e8h, hst\u27e9)", [{"full_name": "Or.inr", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [519, 5], "def_end_pos": [519, 8]}, {"full_name": "subset_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [649, 7], "def_end_pos": [649, 22]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\nh : x \u2208 t\n\u22a2 t = s \u2228 t = insert x s", "state_after": "no goals"}, {"tactic": "refine' Or.inl (subset_antisymm _ hst)", "annotated_tactic": ["refine' <a>Or.inl</a> (<a>subset_antisymm</a> _ hst)", [{"full_name": "Or.inl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 5], "def_end_pos": [517, 8]}, {"full_name": "subset_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [649, 7], "def_end_pos": [649, 22]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\nh : x \u2209 t\n\u22a2 t = s \u2228 t = insert x s", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\nh : x \u2209 t\n\u22a2 t \u2286 s"}, {"tactic": "rwa [\u2190 diff_singleton_eq_self h, diff_singleton_subset_iff]", "annotated_tactic": ["rwa [\u2190 <a>diff_singleton_eq_self</a> h, <a>diff_singleton_subset_iff</a>]", [{"full_name": "Set.diff_singleton_eq_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2061, 9], "def_end_pos": [2061, 31]}, {"full_name": "Set.diff_singleton_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1954, 9], "def_end_pos": [1954, 34]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\ns t : Set \u03b1\nhst : s \u2264 t\nh2t : t \u2264 insert x s\nh : x \u2209 t\n\u22a2 t \u2286 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Algebra.coe_iInf", "start": [886, 1], "end": [887, 14], "traced_tactics": [{"tactic": "simp [iInf]", "annotated_tactic": ["simp [<a>iInf</a>]", [{"full_name": "iInf", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [83, 5], "def_end_pos": [83, 9]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\n\u03b9 : Sort u_1\nS : \u03b9 \u2192 Subalgebra R A\n\u22a2 \u2191(\u2a05 i, S i) = \u22c2 i, \u2191(S i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Fin.lean", "full_name": "support_finRotate", "start": [112, 1], "end": [114, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "n : \u2115\n\u22a2 support (finRotate (n + 2)) = Finset.univ", "state_after": "case a\nn : \u2115\na\u271d : Fin (n + 2)\n\u22a2 a\u271d \u2208 support (finRotate (n + 2)) \u2194 a\u271d \u2208 Finset.univ"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\nn : \u2115\na\u271d : Fin (n + 2)\n\u22a2 a\u271d \u2208 support (finRotate (n + 2)) \u2194 a\u271d \u2208 Finset.univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidWithZeroHom.ext", "start": [650, 1], "end": [651, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.map_smul", "start": [461, 11], "end": [464, 79], "traced_tactics": [{"tactic": "rw [map_le_iff_le_comap, comap_smul f _ a h, \u2190 map_le_iff_le_comap]", "annotated_tactic": ["rw [<a>map_le_iff_le_comap</a>, <a>comap_smul</a> f _ a h, \u2190 <a>map_le_iff_le_comap</a>]", [{"full_name": "Submodule.map_le_iff_le_comap", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [217, 9], "def_end_pos": [217, 28]}, {"full_name": "Submodule.comap_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [456, 9], "def_end_pos": [456, 19]}, {"full_name": "Submodule.map_le_iff_le_comap", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [217, 9], "def_end_pos": [217, 28]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\nK : Type u_10\nV : Type u_11\nV\u2082 : Type u_12\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\na : K\nh : a \u2260 0\n\u22a2 map (a \u2022 f) p \u2264 map f p", "state_after": "no goals"}, {"tactic": "rw [map_le_iff_le_comap, \u2190 comap_smul f _ a h, \u2190 map_le_iff_le_comap]", "annotated_tactic": ["rw [<a>map_le_iff_le_comap</a>, \u2190 <a>comap_smul</a> f _ a h, \u2190 <a>map_le_iff_le_comap</a>]", [{"full_name": "Submodule.map_le_iff_le_comap", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [217, 9], "def_end_pos": [217, 28]}, {"full_name": "Submodule.comap_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [456, 9], "def_end_pos": [456, 19]}, {"full_name": "Submodule.map_le_iff_le_comap", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [217, 9], "def_end_pos": [217, 28]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\nK : Type u_10\nV : Type u_11\nV\u2082 : Type u_12\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\na : K\nh : a \u2260 0\n\u22a2 map f p \u2264 map (a \u2022 f) p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/IndicatorFunction.lean", "full_name": "Set.mulIndicator_of_mem", "start": [68, 1], "end": [69, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.cast_int_comp", "start": [1305, 1], "end": [1305, 77], "traced_tactics": [{"tactic": "cases i <;> simp", "annotated_tactic": ["cases i <;> simp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d : Ring R\np q r : R[X]\ni : \u2124\n\u22a2 comp (\u2191i) p = \u2191i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "Substring.ValidFor.nextn_stop", "start": [868, 1], "end": [870, 72], "traced_tactics": [{"tactic": "simp [Substring.nextn, h.next_stop, h.nextn_stop n]", "annotated_tactic": ["simp [<a>Substring.nextn</a>, h.next_stop, h.nextn_stop n]", [{"full_name": "Substring.nextn", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [558, 5], "def_end_pos": [558, 10]}]], "state_before": "l m r : List Char\nx\u271d : Substring\nh : ValidFor l m r x\u271d\nn : Nat\n\u22a2 nextn x\u271d (n + 1) { byteIdx := utf8Len m } = { byteIdx := utf8Len m }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Archimedean.lean", "full_name": "exists_rat_near", "start": [331, 1], "end": [334, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "full_name": "Set.ordConnected_Ico", "start": [180, 1], "end": [181, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.min_empty", "start": [1338, 1], "end": [1339, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.le_iff_le", "start": [991, 1], "end": [992, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csSup_image2_eq_csSup_csSup", "start": [1549, 1], "end": [1556, 71], "traced_tactics": [{"tactic": "refine' eq_of_forall_ge_iff fun c => _", "annotated_tactic": ["refine' <a>eq_of_forall_ge_iff</a> fun c => _", [{"full_name": "eq_of_forall_ge_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [569, 9], "def_end_pos": [569, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b2\ninst\u271d : ConditionallyCompleteLattice \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nl u : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nl\u2081 u\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03b1\nl\u2082 u\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b2\nh\u2081 : \u2200 (b : \u03b2), GaloisConnection (swap l b) (u\u2081 b)\nh\u2082 : \u2200 (a : \u03b1), GaloisConnection (l a) (u\u2082 a)\nhs\u2080 : Set.Nonempty s\nhs\u2081 : BddAbove s\nht\u2080 : Set.Nonempty t\nht\u2081 : BddAbove t\n\u22a2 sSup (image2 l s t) = l (sSup s) (sSup t)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b2\ninst\u271d : ConditionallyCompleteLattice \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nl u : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nl\u2081 u\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03b1\nl\u2082 u\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b2\nh\u2081 : \u2200 (b : \u03b2), GaloisConnection (swap l b) (u\u2081 b)\nh\u2082 : \u2200 (a : \u03b1), GaloisConnection (l a) (u\u2082 a)\nhs\u2080 : Set.Nonempty s\nhs\u2081 : BddAbove s\nht\u2080 : Set.Nonempty t\nht\u2081 : BddAbove t\nc : \u03b3\n\u22a2 sSup (image2 l s t) \u2264 c \u2194 l (sSup s) (sSup t) \u2264 c"}, {"tactic": "rw [csSup_le_iff (hs\u2081.image2 (fun _ => (h\u2081 _).monotone_l) (fun _ => (h\u2082 _).monotone_l) ht\u2081)\n    (hs\u2080.image2 ht\u2080),\n  forall_image2_iff, forall\u2082_swap, (h\u2082 _).le_iff_le, csSup_le_iff ht\u2081 ht\u2080]", "annotated_tactic": ["rw [<a>csSup_le_iff</a> (hs\u2081.image2 (fun _ => (h\u2081 _).<a>monotone_l</a>) (fun _ => (h\u2082 _).<a>monotone_l</a>) ht\u2081)\n      (hs\u2080.image2 ht\u2080),\n    <a>forall_image2_iff</a>, <a>forall\u2082_swap</a>, (h\u2082 _).<a>le_iff_le</a>, <a>csSup_le_iff</a> ht\u2081 ht\u2080]", [{"full_name": "csSup_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [595, 9], "def_end_pos": [595, 21]}, {"full_name": "GaloisConnection.monotone_l", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [110, 9], "def_end_pos": [110, 19]}, {"full_name": "GaloisConnection.monotone_l", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [110, 9], "def_end_pos": [110, 19]}, {"full_name": "Set.forall_image2_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [77, 9], "def_end_pos": [77, 26]}, {"full_name": "forall\u2082_swap", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [667, 9], "def_end_pos": [667, 21]}, {"full_name": "GaloisConnection.le_iff_le", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [87, 9], "def_end_pos": [87, 18]}, {"full_name": "csSup_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [595, 9], "def_end_pos": [595, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b2\ninst\u271d : ConditionallyCompleteLattice \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nl u : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nl\u2081 u\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03b1\nl\u2082 u\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b2\nh\u2081 : \u2200 (b : \u03b2), GaloisConnection (swap l b) (u\u2081 b)\nh\u2082 : \u2200 (a : \u03b1), GaloisConnection (l a) (u\u2082 a)\nhs\u2080 : Set.Nonempty s\nhs\u2081 : BddAbove s\nht\u2080 : Set.Nonempty t\nht\u2081 : BddAbove t\nc : \u03b3\n\u22a2 sSup (image2 l s t) \u2264 c \u2194 l (sSup s) (sSup t) \u2264 c", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b2\ninst\u271d : ConditionallyCompleteLattice \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nl u : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nl\u2081 u\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03b1\nl\u2082 u\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b2\nh\u2081 : \u2200 (b : \u03b2), GaloisConnection (swap l b) (u\u2081 b)\nh\u2082 : \u2200 (a : \u03b1), GaloisConnection (l a) (u\u2082 a)\nhs\u2080 : Set.Nonempty s\nhs\u2081 : BddAbove s\nht\u2080 : Set.Nonempty t\nht\u2081 : BddAbove t\nc : \u03b3\n\u22a2 (\u2200 i\u2082 \u2208 t, \u2200 i\u2081 \u2208 s, l i\u2081 i\u2082 \u2264 c) \u2194 \u2200 b \u2208 t, b \u2264 u\u2082 (sSup s) c"}, {"tactic": "simp_rw [\u2190 (h\u2082 _).le_iff_le, (h\u2081 _).le_iff_le, csSup_le_iff hs\u2081 hs\u2080]", "annotated_tactic": ["simp_rw [\u2190 (h\u2082 _).<a>le_iff_le</a>, (h\u2081 _).<a>le_iff_le</a>, <a>csSup_le_iff</a> hs\u2081 hs\u2080]", [{"full_name": "GaloisConnection.le_iff_le", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [87, 9], "def_end_pos": [87, 18]}, {"full_name": "GaloisConnection.le_iff_le", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [87, 9], "def_end_pos": [87, 18]}, {"full_name": "csSup_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "def_pos": [595, 9], "def_end_pos": [595, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : ConditionallyCompleteLattice \u03b1\ninst\u271d\u00b9 : ConditionallyCompleteLattice \u03b2\ninst\u271d : ConditionallyCompleteLattice \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nl u : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nl\u2081 u\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03b1\nl\u2082 u\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b2\nh\u2081 : \u2200 (b : \u03b2), GaloisConnection (swap l b) (u\u2081 b)\nh\u2082 : \u2200 (a : \u03b1), GaloisConnection (l a) (u\u2082 a)\nhs\u2080 : Set.Nonempty s\nhs\u2081 : BddAbove s\nht\u2080 : Set.Nonempty t\nht\u2081 : BddAbove t\nc : \u03b3\n\u22a2 (\u2200 i\u2082 \u2208 t, \u2200 i\u2081 \u2208 s, l i\u2081 i\u2082 \u2264 c) \u2194 \u2200 b \u2208 t, b \u2264 u\u2082 (sSup s) c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.zipWith_get?", "start": [197, 1], "end": [206, 40], "traced_tactics": [{"tactic": "induction as generalizing bs i with\n| nil => cases bs with\n  | nil => simp\n  | cons b bs => simp\n| cons a as aih => cases bs with\n  | nil => simp\n  | cons b bs => cases i <;> simp_all", "annotated_tactic": ["induction as generalizing bs i with\n  | <a>nil</a> => cases bs with\n    | <a>nil</a> => simp\n    | <a>cons</a> b bs => simp\n  | <a>cons</a> a as aih => cases bs with\n    | <a>nil</a> => simp\n    | <a>cons</a> b bs => cases i <;> simp_all", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nas : List \u03b1\nbs : List \u03b2\ni : Nat\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 get? (zipWith f as bs) i =\n    match get? as i, get? bs i with\n    | some a, some b => some (f a b)\n    | x, x_1 => none", "state_after": "no goals"}, {"tactic": "cases bs with\n| nil => simp\n| cons b bs => simp", "annotated_tactic": ["cases bs with\n    | <a>nil</a> => simp\n    | <a>cons</a> b bs => simp", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nbs : List \u03b2\ni : Nat\n\u22a2 get? (zipWith f [] bs) i =\n    match get? [] i, get? bs i with\n    | some a, some b => some (f a b)\n    | x, x_1 => none", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ni : Nat\n\u22a2 get? (zipWith f [] []) i =\n    match get? [] i, get? [] i with\n    | some a, some b => some (f a b)\n    | x, x_1 => none", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil.cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ni : Nat\nb : \u03b2\nbs : List \u03b2\n\u22a2 get? (zipWith f [] (b :: bs)) i =\n    match get? [] i, get? (b :: bs) i with\n    | some a, some b => some (f a b)\n    | x, x_1 => none", "state_after": "no goals"}, {"tactic": "cases bs with\n| nil => simp\n| cons b bs => cases i <;> simp_all", "annotated_tactic": ["cases bs with\n    | <a>nil</a> => simp\n    | <a>cons</a> b bs => cases i <;> simp_all", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\naih :\n  \u2200 {bs : List \u03b2} {i : Nat},\n    get? (zipWith f as bs) i =\n      match get? as i, get? bs i with\n      | some a, some b => some (f a b)\n      | x, x_1 => none\nbs : List \u03b2\ni : Nat\n\u22a2 get? (zipWith f (a :: as) bs) i =\n    match get? (a :: as) i, get? bs i with\n    | some a, some b => some (f a b)\n    | x, x_1 => none", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case cons.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\naih :\n  \u2200 {bs : List \u03b2} {i : Nat},\n    get? (zipWith f as bs) i =\n      match get? as i, get? bs i with\n      | some a, some b => some (f a b)\n      | x, x_1 => none\ni : Nat\n\u22a2 get? (zipWith f (a :: as) []) i =\n    match get? (a :: as) i, get? [] i with\n    | some a, some b => some (f a b)\n    | x, x_1 => none", "state_after": "no goals"}, {"tactic": "cases i <;> simp_all", "annotated_tactic": ["cases i <;> simp_all", []], "state_before": "case cons.cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\naih :\n  \u2200 {bs : List \u03b2} {i : Nat},\n    get? (zipWith f as bs) i =\n      match get? as i, get? bs i with\n      | some a, some b => some (f a b)\n      | x, x_1 => none\ni : Nat\nb : \u03b2\nbs : List \u03b2\n\u22a2 get? (zipWith f (a :: as) (b :: bs)) i =\n    match get? (a :: as) i, get? (b :: bs) i with\n    | some a, some b => some (f a b)\n    | x, x_1 => none", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Lemmas.lean", "full_name": "zpow_le_zpow", "start": [347, 1], "end": [348, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/NormNum/Basic.lean", "full_name": "Mathlib.Meta.NormNum.isInt_neg", "start": [234, 1], "end": [236, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.sum_single", "start": [1243, 1], "end": [1244, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.divByMonic_zero", "start": [210, 1], "end": [215, 61], "traced_tactics": [{"tactic": "haveI := monic_zero_iff_subsingleton.mp h", "annotated_tactic": ["haveI := monic_zero_iff_subsingleton.mp h", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q p : R[X]\nthis : DecidableEq R := Classical.decEq R\nh : Monic 0\n\u22a2 p /\u2098 0 = 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q p : R[X]\nthis\u271d : DecidableEq R := Classical.decEq R\nh : Monic 0\nthis : Subsingleton R\n\u22a2 p /\u2098 0 = 0"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q p : R[X]\nthis\u271d : DecidableEq R := Classical.decEq R\nh : Monic 0\nthis : Subsingleton R\n\u22a2 p /\u2098 0 = 0", "state_after": "no goals"}, {"tactic": "unfold divByMonic divModByMonicAux", "annotated_tactic": ["unfold <a>divByMonic</a> <a>divModByMonicAux</a>", [{"full_name": "Polynomial.divByMonic", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [123, 5], "def_end_pos": [123, 15]}, {"full_name": "Polynomial.divModByMonicAux", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [110, 19], "def_end_pos": [110, 35]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q p : R[X]\nthis : DecidableEq R := Classical.decEq R\nh : \u00acMonic 0\n\u22a2 p /\u2098 0 = 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q p : R[X]\nthis : DecidableEq R := Classical.decEq R\nh : \u00acMonic 0\n\u22a2 (if h : Monic 0 then\n      (if h_1 : degree 0 \u2264 degree p \u2227 p \u2260 0 then\n          let z := \u2191C (leadingCoeff p) * X ^ (natDegree p - natDegree 0);\n          let_fun _wf := (_ : degree (p - \u2191C (leadingCoeff p) * X ^ (natDegree p - natDegree 0) * 0) < degree p);\n          let dm := divModByMonicAux (p - z * 0) (_ : Monic 0);\n          (z + dm.1, dm.2)\n        else (0, p)).1\n    else 0) =\n    0"}, {"tactic": "rw [dif_neg h]", "annotated_tactic": ["rw [<a>dif_neg</a> h]", [{"full_name": "dif_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [812, 9], "def_end_pos": [812, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Ring R\np\u271d q p : R[X]\nthis : DecidableEq R := Classical.decEq R\nh : \u00acMonic 0\n\u22a2 (if h : Monic 0 then\n      (if h_1 : degree 0 \u2264 degree p \u2227 p \u2260 0 then\n          let z := \u2191C (leadingCoeff p) * X ^ (natDegree p - natDegree 0);\n          let_fun _wf := (_ : degree (p - \u2191C (leadingCoeff p) * X ^ (natDegree p - natDegree 0) * 0) < degree p);\n          let dm := divModByMonicAux (p - z * 0) (_ : Monic 0);\n          (z + dm.1, dm.2)\n        else (0, p)).1\n    else 0) =\n    0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "sInf_image2_eq_sSup_sSup", "start": [433, 1], "end": [436, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Variables.lean", "full_name": "MvPolynomial.totalDegree_multiset_prod", "start": [718, 1], "end": [722, 32], "traced_tactics": [{"tactic": "refine' Quotient.inductionOn s fun l => _", "annotated_tactic": ["refine' <a>Quotient.inductionOn</a> s fun l => _", [{"full_name": "Quotient.inductionOn", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [1367, 19], "def_end_pos": [1367, 30]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ns : Multiset (MvPolynomial \u03c3 R)\n\u22a2 totalDegree (Multiset.prod s) \u2264 Multiset.sum (Multiset.map totalDegree s)", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ns : Multiset (MvPolynomial \u03c3 R)\nl : List (MvPolynomial \u03c3 R)\n\u22a2 totalDegree (Multiset.prod \u27e6l\u27e7) \u2264 Multiset.sum (Multiset.map totalDegree \u27e6l\u27e7)"}, {"tactic": "rw [Multiset.quot_mk_to_coe, Multiset.coe_prod, Multiset.coe_map, Multiset.coe_sum]", "annotated_tactic": ["rw [<a>Multiset.quot_mk_to_coe</a>, <a>Multiset.coe_prod</a>, <a>Multiset.coe_map</a>, <a>Multiset.coe_sum</a>]", [{"full_name": "Multiset.quot_mk_to_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [43, 9], "def_end_pos": [43, 23]}, {"full_name": "Multiset.coe_prod", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [64, 9], "def_end_pos": [64, 17]}, {"full_name": "Multiset.coe_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1170, 9], "def_end_pos": [1170, 16]}, {"full_name": "Multiset.coe_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [63, 3], "def_end_pos": [63, 14]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ns : Multiset (MvPolynomial \u03c3 R)\nl : List (MvPolynomial \u03c3 R)\n\u22a2 totalDegree (Multiset.prod \u27e6l\u27e7) \u2264 Multiset.sum (Multiset.map totalDegree \u27e6l\u27e7)", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ns : Multiset (MvPolynomial \u03c3 R)\nl : List (MvPolynomial \u03c3 R)\n\u22a2 totalDegree (List.prod l) \u2264 List.sum (List.map totalDegree l)"}, {"tactic": "exact totalDegree_list_prod l", "annotated_tactic": ["exact <a>totalDegree_list_prod</a> l", [{"full_name": "MvPolynomial.totalDegree_list_prod", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [710, 9], "def_end_pos": [710, 30]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns\u271d : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\ns : Multiset (MvPolynomial \u03c3 R)\nl : List (MvPolynomial \u03c3 R)\n\u22a2 totalDegree (List.prod l) \u2264 List.sum (List.map totalDegree l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Finset.lean", "full_name": "Finset.lcm_dvd", "start": [68, 1], "end": [69, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.coe_some", "start": [361, 1], "end": [362, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Opposites.lean", "full_name": "MulOpposite.unop_sub", "start": [312, 1], "end": [313, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.empty_pow", "start": [977, 1], "end": [978, 97], "traced_tactics": [{"tactic": "rw [\u2190 tsub_add_cancel_of_le (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero hn), pow_succ, empty_mul]", "annotated_tactic": ["rw [\u2190 <a>tsub_add_cancel_of_le</a> (<a>Nat.succ_le_of_lt</a> <| <a>Nat.pos_of_ne_zero</a> hn), <a>pow_succ</a>, <a>empty_mul</a>]", [{"full_name": "tsub_add_cancel_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}, {"full_name": "Nat.succ_le_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 22]}, {"full_name": "Nat.pos_of_ne_zero", "def_path": "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "def_pos": [25, 19], "def_end_pos": [25, 33]}, {"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}, {"full_name": "Set.empty_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [355, 9], "def_end_pos": [355, 18]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : Monoid \u03b1\ns t : Set \u03b1\na : \u03b1\nm n\u271d n : \u2115\nhn : n \u2260 0\n\u22a2 \u2205 ^ n = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.groupSMul_apply", "start": [1225, 1], "end": [1229, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "exists_exists_and_eq_and", "start": [783, 9], "end": [785, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.piecewise_single_erase", "start": [767, 1], "end": [772, 21], "traced_tactics": [{"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\n\u22a2 piecewise (single i (\u2191x i)) (erase i x) {i} = x", "state_after": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\n\u22a2 \u2191(piecewise (single i (\u2191x i)) (erase i x) {i}) j = \u2191x j"}, {"tactic": "rw [piecewise_apply]", "annotated_tactic": ["rw [<a>piecewise_apply</a>]", [{"full_name": "DFinsupp.piecewise_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [218, 9], "def_end_pos": [218, 24]}]], "state_before": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\n\u22a2 \u2191(piecewise (single i (\u2191x i)) (erase i x) {i}) j = \u2191x j", "state_after": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\n\u22a2 (if j \u2208 {i} then \u2191(single i (\u2191x i)) j else \u2191(erase i x) j) = \u2191x j"}, {"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "case h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\n\u22a2 (if j \u2208 {i} then \u2191(single i (\u2191x i)) j else \u2191(erase i x) j) = \u2191x j", "state_after": "case pos\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\nh : j \u2208 {i}\n\u22a2 \u2191(single i (\u2191x i)) j = \u2191x j\n\ncase neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\nh : j \u2209 {i}\n\u22a2 \u2191(erase i x) j = \u2191x j"}, {"tactic": "rw [(id h : j = i), single_eq_same]", "annotated_tactic": ["rw [(<a>id</a> h : j = i), <a>single_eq_same</a>]", [{"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "DFinsupp.single_eq_same", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [661, 9], "def_end_pos": [661, 23]}]], "state_before": "case pos\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\nh : j \u2208 {i}\n\u22a2 \u2191(single i (\u2191x i)) j = \u2191x j", "state_after": "no goals"}, {"tactic": "exact erase_ne h", "annotated_tactic": ["exact <a>erase_ne</a> h", [{"full_name": "DFinsupp.erase_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [764, 9], "def_end_pos": [764, 17]}]], "state_before": "case neg\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ns : Finset \u03b9\nx\u271d : (i : \u2191\u2191s) \u2192 \u03b2 \u2191i\ni\u271d : \u03b9\nx : \u03a0\u2080 (i : \u03b9), \u03b2 i\ni : \u03b9\ninst\u271d : (i' : \u03b9) \u2192 Decidable (i' \u2208 {i})\nj : \u03b9\nh : j \u2209 {i}\n\u22a2 \u2191(erase i x) j = \u2191x j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.sigma_sum", "start": [1815, 1], "end": [1817, 57], "traced_tactics": [{"tactic": "simp only [sum, sigma_support, sum_sigma, split_apply]", "annotated_tactic": ["simp only [<a>sum</a>, <a>sigma_support</a>, <a>sum_sigma</a>, <a>split_apply</a>]", [{"full_name": "Finsupp.sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [51, 3], "def_end_pos": [51, 14]}, {"full_name": "Finsupp.sigma_support", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1808, 9], "def_end_pos": [1808, 22]}, {"full_name": "Finset.sum_sigma", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [529, 3], "def_end_pos": [529, 14]}, {"full_name": "Finsupp.split_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1775, 9], "def_end_pos": [1775, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\n\u03b1s : \u03b9 \u2192 Type u_13\ninst\u271d\u00b9 : Zero M\nl : (i : \u03b9) \u00d7 \u03b1s i \u2192\u2080 M\ninst\u271d : AddCommMonoid N\nf : (i : \u03b9) \u00d7 \u03b1s i \u2192 M \u2192 N\n\u22a2 sum l f = \u2211 i in splitSupport l, sum (split l i) fun a b => f { fst := i, snd := a } b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.mod_lt_of_pos", "start": [386, 1], "end": [390, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "Units.eq_inv_of_mul_eq_one_left", "start": [366, 11], "end": [367, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/IntervalCases.lean", "full_name": "Mathlib.Tactic.IntervalCases.of_not_lt_left", "start": [127, 1], "end": [127, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.piecewise_piecewise_of_subset_right", "start": [2588, 1], "end": [2591, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidWithZeroHom.coe_comp", "start": [1092, 1], "end": [1093, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.prod_eq_biUnion_right", "start": [2079, 1], "end": [2080, 45], "traced_tactics": [{"tactic": "rw [iUnion_image_right, image2_mk_eq_prod]", "annotated_tactic": ["rw [<a>iUnion_image_right</a>, <a>image2_mk_eq_prod</a>]", [{"full_name": "Set.iUnion_image_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [2010, 9], "def_end_pos": [2010, 27]}, {"full_name": "Set.image2_mk_eq_prod", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [108, 15], "def_end_pos": [108, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = \u22c3 b \u2208 t, (fun a => (a, b)) '' s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.span_eq", "start": [153, 1], "end": [154, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "List.prod_erase", "start": [565, 1], "end": [567, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Multiplicity.lean", "full_name": "Nat.Prime.multiplicity_self", "start": [96, 1], "end": [97, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/PNat/Basic.lean", "full_name": "PNat.recOn_succ", "start": [336, 1], "end": [339, 48], "traced_tactics": [{"tactic": "cases' n with n h", "annotated_tactic": ["cases' n with n h", []], "state_before": "n : \u2115+\np : \u2115+ \u2192 Sort u_1\np1 : p 1\nhp : (n : \u2115+) \u2192 p n \u2192 p (n + 1)\n\u22a2 recOn (n + 1) p1 hp = hp n (recOn n p1 hp)", "state_after": "case mk\np : \u2115+ \u2192 Sort u_1\np1 : p 1\nhp : (n : \u2115+) \u2192 p n \u2192 p (n + 1)\nn : \u2115\nh : 0 < n\n\u22a2 recOn ({ val := n, property := h } + 1) p1 hp =\n    hp { val := n, property := h } (recOn { val := n, property := h } p1 hp)"}, {"tactic": "cases n <;> [exact absurd h (by decide); rfl]", "annotated_tactic": ["cases n <;> [exact <a>absurd</a> h (by decide); rfl]", [{"full_name": "absurd", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [233, 21], "def_end_pos": [233, 27]}]], "state_before": "case mk\np : \u2115+ \u2192 Sort u_1\np1 : p 1\nhp : (n : \u2115+) \u2192 p n \u2192 p (n + 1)\nn : \u2115\nh : 0 < n\n\u22a2 recOn ({ val := n, property := h } + 1) p1 hp =\n    hp { val := n, property := h } (recOn { val := n, property := h } p1 hp)", "state_after": "no goals"}, {"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "p : \u2115+ \u2192 Sort u_1\np1 : p 1\nhp : (n : \u2115+) \u2192 p n \u2192 p (n + 1)\nh : 0 < zero\n\u22a2 \u00ac0 < zero", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "full_name": "one_le", "start": [218, 1], "end": [219, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.coe_coeEmb", "start": [465, 1], "end": [466, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/List.lean", "full_name": "List.formPerm_cons_cons", "start": [62, 1], "end": [64, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.currySum_apply", "start": [1444, 1], "end": [1446, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "pow_inj_mod", "start": [508, 1], "end": [509, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.preimage_invFun_of_not_mem", "start": [1348, 1], "end": [1354, 53], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\n\u22a2 invFun f \u207b\u00b9' s = f '' s", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\nx : \u03b2\n\u22a2 x \u2208 invFun f \u207b\u00b9' s \u2194 x \u2208 f '' s"}, {"tactic": "rcases em (x \u2208 range f) with (\u27e8a, rfl\u27e9 | hx)", "annotated_tactic": ["rcases <a>em</a> (x \u2208 <a>range</a> f) with (\u27e8a, rfl\u27e9 | hx)", [{"full_name": "em", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [193, 7], "def_end_pos": [193, 9]}, {"full_name": "Set.range", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [668, 5], "def_end_pos": [668, 10]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\nx : \u03b2\n\u22a2 x \u2208 invFun f \u207b\u00b9' s \u2194 x \u2208 f '' s", "state_after": "case h.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\na : \u03b1\n\u22a2 f a \u2208 invFun f \u207b\u00b9' s \u2194 f a \u2208 f '' s\n\ncase h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\nx : \u03b2\nhx : x \u2209 range f\n\u22a2 x \u2208 invFun f \u207b\u00b9' s \u2194 x \u2208 f '' s"}, {"tactic": "rw [mem_preimage, leftInverse_invFun hf, hf.mem_set_image]", "annotated_tactic": ["rw [<a>mem_preimage</a>, <a>leftInverse_invFun</a> hf, hf.mem_set_image]", [{"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Function.leftInverse_invFun", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [474, 9], "def_end_pos": [474, 27]}]], "state_before": "case h.inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\na : \u03b1\n\u22a2 f a \u2208 invFun f \u207b\u00b9' s \u2194 f a \u2208 f '' s", "state_after": "no goals"}, {"tactic": "have : x \u2209 f '' s := fun h' => hx (image_subset_range _ _ h')", "annotated_tactic": ["have : x \u2209 f '' s := fun h' => hx (<a>image_subset_range</a> _ _ h')", [{"full_name": "Set.image_subset_range", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [723, 9], "def_end_pos": [723, 27]}]], "state_before": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\nx : \u03b2\nhx : x \u2209 range f\n\u22a2 x \u2208 invFun f \u207b\u00b9' s \u2194 x \u2208 f '' s", "state_after": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\nx : \u03b2\nhx : x \u2209 range f\nthis : x \u2209 f '' s\n\u22a2 x \u2208 invFun f \u207b\u00b9' s \u2194 x \u2208 f '' s"}, {"tactic": "simp only [mem_preimage, invFun_neg hx, h, this]", "annotated_tactic": ["simp only [<a>mem_preimage</a>, <a>invFun_neg</a> hx, h, this]", [{"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Function.invFun_neg", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [457, 9], "def_end_pos": [457, 19]}]], "state_before": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns\u271d s\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nf\u271d : \u03b1 \u2192 \u03b2\nn : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\nh : Classical.choice n \u2209 s\nx : \u03b2\nhx : x \u2209 range f\nthis : x \u2209 f '' s\n\u22a2 x \u2208 invFun f \u207b\u00b9' s \u2194 x \u2208 f '' s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.preimage_const_of_mem", "start": [138, 1], "end": [139, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Quotient.lean", "full_name": "Submodule.range_mkQ", "start": [381, 1], "end": [382, 49], "traced_tactics": [{"tactic": "rintro \u27e8x\u27e9", "annotated_tactic": ["rintro \u27e8x\u27e9", []], "state_before": "R : Type u_1\nM : Type u_2\nr : R\nx y : M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\np p' : Submodule R M\nR\u2082 : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u00b2 : Ring R\u2082\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u22a2 \u2200 (x : M \u29f8 p), x \u2208 range (mkQ p)", "state_after": "case mk\nR : Type u_1\nM : Type u_2\nr : R\nx\u271d\u00b9 y : M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\np p' : Submodule R M\nR\u2082 : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u00b2 : Ring R\u2082\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\nx\u271d : M \u29f8 p\nx : M\n\u22a2 \u27e6x\u27e7 \u2208 range (mkQ p)"}, {"tactic": "exact \u27e8x, rfl\u27e9", "annotated_tactic": ["exact \u27e8x, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case mk\nR : Type u_1\nM : Type u_2\nr : R\nx\u271d\u00b9 y : M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\np p' : Submodule R M\nR\u2082 : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u00b2 : Ring R\u2082\ninst\u271d\u00b9 : AddCommGroup M\u2082\ninst\u271d : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\nx\u271d : M \u29f8 p\nx : M\n\u22a2 \u27e6x\u27e7 \u2208 range (mkQ p)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.map_id_id", "start": [127, 9], "end": [128, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.neg_smul", "start": [1113, 11], "end": [1115, 40], "traced_tactics": [{"tactic": "simp_rw [\u2190 image_neg]", "annotated_tactic": ["simp_rw [\u2190 <a>image_neg</a>]", [{"full_name": "Set.image_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [256, 3], "def_end_pos": [256, 14]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : Ring \u03b1\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\na : \u03b1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 -s \u2022 t = -(s \u2022 t)", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : Ring \u03b1\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\na : \u03b1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Neg.neg '' s \u2022 t = Neg.neg '' (s \u2022 t)"}, {"tactic": "exact image2_image_left_comm neg_smul", "annotated_tactic": ["exact <a>image2_image_left_comm</a> <a>neg_smul</a>", [{"full_name": "Set.image2_image_left_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [370, 9], "def_end_pos": [370, 31]}, {"full_name": "neg_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [278, 9], "def_end_pos": [278, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : Ring \u03b1\ninst\u271d\u00b9 : AddCommGroup \u03b2\ninst\u271d : Module \u03b1 \u03b2\na : \u03b1\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Neg.neg '' s \u2022 t = Neg.neg '' (s \u2022 t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.le_mk_iff_exists_set", "start": [282, 1], "end": [284, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.mem_bind", "start": [254, 1], "end": [256, 93], "traced_tactics": [{"tactic": "simp [List.bind, mem_join]", "annotated_tactic": ["simp [<a>List.bind</a>, <a>mem_join</a>]", [{"full_name": "List.bind", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [643, 25], "def_end_pos": [643, 29]}, {"full_name": "List.mem_join", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [244, 9], "def_end_pos": [244, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 List \u03b2\nb : \u03b2\nl : List \u03b1\n\u22a2 b \u2208 List.bind l f \u2194 \u2203 a, a \u2208 l \u2227 b \u2208 f a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 List \u03b2\nb : \u03b2\nl : List \u03b1\n\u22a2 (\u2203 l_1, (\u2203 a, a \u2208 l \u2227 f a = l_1) \u2227 b \u2208 l_1) \u2194 \u2203 a, a \u2208 l \u2227 b \u2208 f a"}, {"tactic": "exact \u27e8fun \u27e8_, \u27e8a, h\u2081, rfl\u27e9, h\u2082\u27e9 => \u27e8a, h\u2081, h\u2082\u27e9, fun \u27e8a, h\u2081, h\u2082\u27e9 => \u27e8_, \u27e8a, h\u2081, rfl\u27e9, h\u2082\u27e9\u27e9", "annotated_tactic": ["exact \u27e8fun \u27e8_, \u27e8a, h\u2081, <a>rfl</a>\u27e9, h\u2082\u27e9 => \u27e8a, h\u2081, h\u2082\u27e9, fun \u27e8a, h\u2081, h\u2082\u27e9 => \u27e8_, \u27e8a, h\u2081, <a>rfl</a>\u27e9, h\u2082\u27e9\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 List \u03b2\nb : \u03b2\nl : List \u03b1\n\u22a2 (\u2203 l_1, (\u2203 a, a \u2208 l \u2227 f a = l_1) \u2227 b \u2208 l_1) \u2194 \u2203 a, a \u2208 l \u2227 b \u2208 f a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "LinearIndependent.insert", "start": [1233, 11], "end": [1238, 36], "traced_tactics": [{"tactic": "have x0 : x \u2260 0 := mt (by rintro rfl; apply zero_mem (span K s)) hx", "annotated_tactic": ["have x0 : x \u2260 0 := <a>mt</a> (by rintro rfl; apply <a>zero_mem</a> (<a>span</a> K s)) hx", [{"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "ZeroMemClass.zero_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}, {"full_name": "Submodule.span", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [49, 5], "def_end_pos": [49, 9]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\nx y z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : x \u2209 span K s\n\u22a2 LinearIndependent K fun b => \u2191b", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\nx y z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : x \u2209 span K s\nx0 : x \u2260 0\n\u22a2 LinearIndependent K fun b => \u2191b"}, {"tactic": "apply hs.union (linearIndependent_singleton x0)", "annotated_tactic": ["apply hs.union (<a>linearIndependent_singleton</a> x0)", [{"full_name": "linearIndependent_singleton", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [1185, 9], "def_end_pos": [1185, 36]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\nx y z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : x \u2209 span K s\nx0 : x \u2260 0\n\u22a2 LinearIndependent K fun b => \u2191b", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\nx y z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : x \u2209 span K s\nx0 : x \u2260 0\n\u22a2 Disjoint (span K s) (span K {x})"}, {"tactic": "rwa [disjoint_span_singleton' x0]", "annotated_tactic": ["rwa [<a>disjoint_span_singleton'</a> x0]", [{"full_name": "Submodule.disjoint_span_singleton'", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [483, 9], "def_end_pos": [483, 33]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\nx y z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : x \u2209 span K s\nx0 : x \u2260 0\n\u22a2 Disjoint (span K s) (span K {x})", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\nx y z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : x \u2209 span K s\n\u22a2 x = 0 \u2192 x \u2208 span K s", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\ny z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : 0 \u2209 span K s\n\u22a2 0 \u2208 span K s"}, {"tactic": "apply zero_mem (span K s)", "annotated_tactic": ["apply <a>zero_mem</a> (<a>span</a> K s)", [{"full_name": "ZeroMemClass.zero_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}, {"full_name": "Submodule.span", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [49, 5], "def_end_pos": [49, 9]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\ninst\u271d\u2074 : DivisionRing K\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module K V\ninst\u271d : Module K V'\nv : \u03b9 \u2192 V\ns t : Set V\ny z : V\nhs : LinearIndependent K fun b => \u2191b\nhx : 0 \u2209 span K s\n\u22a2 0 \u2208 span K s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "Pi.sdiff_apply", "start": [931, 1], "end": [933, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.single_algebraMap_eq_algebraMap_mul_of", "start": [826, 1], "end": [828, 91], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\nA : Type u_3\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra k A\ninst\u271d : Monoid G\na : G\nb : k\n\u22a2 single a (\u2191(algebraMap k A) b) = \u2191(algebraMap k (MonoidAlgebra A G)) b * \u2191(of A G) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Polynomial/Content.lean", "full_name": "Polynomial.IsPrimitive.dvd_primPart_iff_dvd", "start": [421, 1], "end": [426, 39], "traced_tactics": [{"tactic": "refine' \u27e8fun h => h.trans (Dvd.intro_left _ q.eq_C_content_mul_primPart.symm), fun h => _\u27e9", "annotated_tactic": ["refine' \u27e8fun h => h.trans (<a>Dvd.intro_left</a> _ q.eq_C_content_mul_primPart.symm), fun h => _\u27e9", [{"full_name": "Dvd.intro_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [147, 9], "def_end_pos": [147, 23]}]], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np q : R[X]\nhp : IsPrimitive p\nhq : q \u2260 0\n\u22a2 p \u2223 primPart q \u2194 p \u2223 q", "state_after": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np q : R[X]\nhp : IsPrimitive p\nhq : q \u2260 0\nh : p \u2223 q\n\u22a2 p \u2223 primPart q"}, {"tactic": "rcases h with \u27e8r, rfl\u27e9", "annotated_tactic": ["rcases h with \u27e8r, rfl\u27e9", []], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np q : R[X]\nhp : IsPrimitive p\nhq : q \u2260 0\nh : p \u2223 q\n\u22a2 p \u2223 primPart q", "state_after": "case intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nr : R[X]\nhq : p * r \u2260 0\n\u22a2 p \u2223 primPart (p * r)"}, {"tactic": "apply Dvd.intro _", "annotated_tactic": ["apply <a>Dvd.intro</a> _", [{"full_name": "Dvd.intro", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [48, 9], "def_end_pos": [48, 18]}]], "state_before": "case intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nr : R[X]\nhq : p * r \u2260 0\n\u22a2 p \u2223 primPart (p * r)", "state_after": "case intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nr : R[X]\nhq : p * r \u2260 0\n\u22a2 p * ?m.667084 = primPart (p * r)\n\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nr : R[X]\nhq : p * r \u2260 0\n\u22a2 R[X]"}, {"tactic": "rw [primPart_mul hq, hp.primPart_eq]", "annotated_tactic": ["rw [<a>primPart_mul</a> hq, hp.primPart_eq]", [{"full_name": "Polynomial.primPart_mul", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Polynomial/Content.lean", "def_pos": [410, 9], "def_end_pos": [410, 21]}]], "state_before": "case intro\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nr : R[X]\nhq : p * r \u2260 0\n\u22a2 p * ?m.667084 = primPart (p * r)\n\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : IsPrimitive p\nr : R[X]\nhq : p * r \u2260 0\n\u22a2 R[X]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.pairwise_coe_iff_pairwise", "start": [3029, 1], "end": [3031, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.range_cons", "start": [173, 1], "end": [174, 58], "traced_tactics": [{"tactic": "simp [Fin.exists_fin_succ, eq_comm]", "annotated_tactic": ["simp [<a>Fin.exists_fin_succ</a>, <a>eq_comm</a>]", [{"full_name": "Fin.exists_fin_succ", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [631, 9], "def_end_pos": [631, 24]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\nx : \u03b1\nu : Fin n \u2192 \u03b1\ny : \u03b1\n\u22a2 y \u2208 Set.range (vecCons x u) \u2194 y \u2208 {x} \u222a Set.range u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.ofDual_sup'", "start": [1124, 1], "end": [1126, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.one_pos", "start": [206, 1], "end": [206, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.disjoint_def", "start": [376, 1], "end": [377, 90], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMul S R\ninst\u271d : IsScalarTower S R M\np\u271d q p p' : Submodule R M\n\u22a2 (\u2200 (x : M), x \u2208 p \u2227 x \u2208 p' \u2192 x \u2208 {0}) \u2194 \u2200 x \u2208 p, x \u2208 p' \u2192 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.Iterator.hasNext_cons_addChar", "start": [512, 1], "end": [514, 43], "traced_tactics": [{"tactic": "simp [hasNext, Nat.add_lt_add_iff_right]", "annotated_tactic": ["simp [<a>hasNext</a>, <a>Nat.add_lt_add_iff_right</a>]", [{"full_name": "String.Iterator.hasNext", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [332, 5], "def_end_pos": [332, 12]}, {"full_name": "Nat.add_lt_add_iff_right", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [379, 19], "def_end_pos": [379, 39]}]], "state_before": "c : Char\ncs : List Char\ni : Pos\n\u22a2 hasNext { s := { data := c :: cs }, i := i + c } = hasNext { s := { data := cs }, i := i }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Digits.lean", "full_name": "Nat.dvd_iff_dvd_ofDigits", "start": [715, 1], "end": [719, 99], "traced_tactics": [{"tactic": "rw [\u2190 Int.coe_nat_dvd]", "annotated_tactic": ["rw [\u2190 <a>Int.coe_nat_dvd</a>]", [{"full_name": "Int.coe_nat_dvd", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Dvd/Basic.lean", "def_pos": [21, 9], "def_end_pos": [21, 20]}]], "state_before": "n\u271d b b' : \u2115\nc : \u2124\nh : \u2191b \u2223 \u2191b' - c\nn : \u2115\n\u22a2 b \u2223 n \u2194 \u2191b \u2223 ofDigits c (digits b' n)", "state_after": "n\u271d b b' : \u2115\nc : \u2124\nh : \u2191b \u2223 \u2191b' - c\nn : \u2115\n\u22a2 \u2191b \u2223 \u2191n \u2194 \u2191b \u2223 ofDigits c (digits b' n)"}, {"tactic": "exact\n  dvd_iff_dvd_of_dvd_sub (zmodeq_ofDigits_digits b b' c (Int.modEq_iff_dvd.2 h).symm _).symm.dvd", "annotated_tactic": ["exact\n    <a>dvd_iff_dvd_of_dvd_sub</a> (<a>zmodeq_ofDigits_digits</a> b b' c (<a>Int.modEq_iff_dvd</a>.2 h).<a>symm</a> _).symm.dvd", [{"full_name": "dvd_iff_dvd_of_dvd_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 31]}, {"full_name": "Nat.zmodeq_ofDigits_digits", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [671, 9], "def_end_pos": [671, 31]}, {"full_name": "Int.modEq_iff_dvd", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/ModEq.lean", "def_pos": [94, 9], "def_end_pos": [94, 22]}, {"full_name": "Int.ModEq.symm", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/ModEq.lean", "def_pos": [58, 19], "def_end_pos": [58, 23]}]], "state_before": "n\u271d b b' : \u2115\nc : \u2124\nh : \u2191b \u2223 \u2191b' - c\nn : \u2115\n\u22a2 \u2191b \u2223 \u2191n \u2194 \u2191b \u2223 ofDigits c (digits b' n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Basic.lean", "full_name": "Submodule.copy_eq", "start": [122, 1], "end": [123, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "associated_gcd_right_iff", "start": [705, 1], "end": [707, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.mul_single_apply", "start": [1074, 1], "end": [1076, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ModularLattice.lean", "full_name": "sup_strictMonoOn_Icc_inf", "start": [314, 1], "end": [315, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_X_add_C", "start": [1445, 1], "end": [1451, 54], "traced_tactics": [{"tactic": "have : degree (C a) < degree (X : R[X]) :=\n  calc\n    degree (C a) \u2264 0 := degree_C_le\n    _ < 1 := (WithBot.some_lt_some.mpr zero_lt_one)\n    _ = degree X := degree_X.symm", "annotated_tactic": ["have : <a>degree</a> (<a>C</a> a) < <a>degree</a> (<a>X</a> : R[X]) :=\n    calc\n      <a>degree</a> (<a>C</a> a) \u2264 0 := <a>degree_C_le</a>\n      _ < 1 := (WithBot.some_lt_some.mpr <a>zero_lt_one</a>)\n      _ = <a>degree</a> <a>X</a> := degree_X.symm", [{"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [498, 5], "def_end_pos": [498, 6]}, {"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [566, 5], "def_end_pos": [566, 6]}, {"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [498, 5], "def_end_pos": [498, 6]}, {"full_name": "Polynomial.degree_C_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [250, 9], "def_end_pos": [250, 20]}, {"full_name": "zero_lt_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}, {"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [566, 5], "def_end_pos": [566, 6]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\na : R\n\u22a2 degree (X + \u2191C a) = 1", "state_after": "R : Type u\nS : Type v\na\u271d b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\na : R\nthis : degree (\u2191C a) < degree X\n\u22a2 degree (X + \u2191C a) = 1"}, {"tactic": "rw [degree_add_eq_left_of_degree_lt this, degree_X]", "annotated_tactic": ["rw [<a>degree_add_eq_left_of_degree_lt</a> this, <a>degree_X</a>]", [{"full_name": "Polynomial.degree_add_eq_left_of_degree_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [699, 9], "def_end_pos": [699, 40]}, {"full_name": "Polynomial.degree_X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [517, 9], "def_end_pos": [517, 17]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : Semiring R\na : R\nthis : degree (\u2191C a) < degree X\n\u22a2 degree (X + \u2191C a) = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.le_prod_iff", "start": [1789, 1], "end": [1791, 69], "traced_tactics": [{"tactic": "simpa only [\u2190 Subgroup.toSubmonoid_le] using Submonoid.le_prod_iff", "annotated_tactic": ["simpa only [\u2190 <a>Subgroup.toSubmonoid_le</a>] using <a>Submonoid.le_prod_iff</a>", [{"full_name": "Subgroup.toSubmonoid_le", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [476, 9], "def_end_pos": [476, 23]}, {"full_name": "Submonoid.le_prod_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [961, 9], "def_end_pos": [961, 20]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : Group G'\ninst\u271d\u00b3 : Group G''\nA : Type u_4\ninst\u271d\u00b2 : AddGroup A\nH\u271d K\u271d : Subgroup G\nk : Set G\nN : Type u_5\ninst\u271d\u00b9 : Group N\nP : Type u_6\ninst\u271d : Group P\nH : Subgroup G\nK : Subgroup N\nJ : Subgroup (G \u00d7 N)\n\u22a2 J \u2264 prod H K \u2194 map (MonoidHom.fst G N) J \u2264 H \u2227 map (MonoidHom.snd G N) J \u2264 K", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.comap_smul'", "start": [467, 1], "end": [469, 56], "traced_tactics": [{"tactic": "classical by_cases h : a = 0 <;> simp [h, comap_smul]", "annotated_tactic": ["classical by_cases h : a = 0 <;> simp [h, <a>comap_smul</a>]", [{"full_name": "Submodule.comap_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [456, 9], "def_end_pos": [456, 19]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\nK : Type u_10\nV : Type u_11\nV\u2082 : Type u_12\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\u2082\na : K\n\u22a2 comap (a \u2022 f) p = \u2a05 (_ : a \u2260 0), comap f p", "state_after": "no goals"}, {"tactic": "by_cases h : a = 0 <;> simp [h, comap_smul]", "annotated_tactic": ["by_cases h : a = 0 <;> simp [h, <a>comap_smul</a>]", [{"full_name": "Submodule.comap_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [456, 9], "def_end_pos": [456, 19]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\nK : Type u_10\nV : Type u_11\nV\u2082 : Type u_12\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\u2082\na : K\n\u22a2 comap (a \u2022 f) p = \u2a05 (_ : a \u2260 0), comap f p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "Composition.sizeUpTo_succ", "start": [224, 1], "end": [227, 27], "traced_tactics": [{"tactic": "simp only [sizeUpTo]", "annotated_tactic": ["simp only [<a>sizeUpTo</a>]", [{"full_name": "Composition.sizeUpTo", "def_path": "lake-packages/mathlib/Mathlib/Combinatorics/Composition.lean", "def_pos": [200, 5], "def_end_pos": [200, 13]}]], "state_before": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < length c\n\u22a2 sizeUpTo c (i + 1) = sizeUpTo c i + List.get c.blocks { val := i, isLt := h }", "state_after": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < length c\n\u22a2 sum (take (i + 1) c.blocks) = sum (take i c.blocks) + List.get c.blocks { val := i, isLt := h }"}, {"tactic": "rw [sum_take_succ _ _ h]", "annotated_tactic": ["rw [<a>sum_take_succ</a> _ _ h]", [{"full_name": "List.sum_take_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [180, 3], "def_end_pos": [180, 14]}]], "state_before": "n : \u2115\nc : Composition n\ni : \u2115\nh : i < length c\n\u22a2 sum (take (i + 1) c.blocks) = sum (take i c.blocks) + List.get c.blocks { val := i, isLt := h }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.union_mul", "start": [436, 1], "end": [437, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.atTop_eq_generate_Ici", "start": [139, 1], "end": [142, 53], "traced_tactics": [{"tactic": "rcases isEmpty_or_nonempty \u03b1 with h\u03b1|h\u03b1", "annotated_tactic": ["rcases <a>isEmpty_or_nonempty</a> \u03b1 with h\u03b1|h\u03b1", [{"full_name": "isEmpty_or_nonempty", "def_path": "lake-packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [207, 9], "def_end_pos": [207, 28]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeSup \u03b1\n\u22a2 atTop = generate (range Ici)", "state_after": "case inl\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeSup \u03b1\nh\u03b1 : IsEmpty \u03b1\n\u22a2 atTop = generate (range Ici)\n\ncase inr\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeSup \u03b1\nh\u03b1 : Nonempty \u03b1\n\u22a2 atTop = generate (range Ici)"}, {"tactic": "simp only [eq_iff_true_of_subsingleton]", "annotated_tactic": ["simp only [<a>eq_iff_true_of_subsingleton</a>]", [{"full_name": "eq_iff_true_of_subsingleton", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [802, 9], "def_end_pos": [802, 36]}]], "state_before": "case inl\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeSup \u03b1\nh\u03b1 : IsEmpty \u03b1\n\u22a2 atTop = generate (range Ici)", "state_after": "no goals"}, {"tactic": "simp [(atTop_basis (\u03b1 := \u03b1)).eq_generate, range]", "annotated_tactic": ["simp [(<a>atTop_basis</a> (\u03b1 := \u03b1)).<a>eq_generate</a>, <a>range</a>]", [{"full_name": "Filter.atTop_basis", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [135, 9], "def_end_pos": [135, 20]}, {"full_name": "Filter.HasBasis.eq_generate", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [325, 9], "def_end_pos": [325, 29]}, {"full_name": "Set.range", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [668, 5], "def_end_pos": [668, 10]}]], "state_before": "case inr\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeSup \u03b1\nh\u03b1 : Nonempty \u03b1\n\u22a2 atTop = generate (range Ici)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Array/Init/Lemmas.lean", "full_name": "Array.SatisfiesM_mapM'", "start": [174, 1], "end": [180, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.preimage_ceil_zero", "start": [371, 1], "end": [372, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "DoubleQuot.coe_quotQuotEquivQuotSup\u2090", "start": [874, 1], "end": [875, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Tower.lean", "full_name": "AlgHom.coe_restrictScalars", "start": [217, 1], "end": [217, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "inf_inf_sdiff", "start": [102, 1], "end": [103, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "codisjoint_assoc", "start": [326, 1], "end": [327, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.toFun_eq_coe", "start": [112, 1], "end": [113, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "IsUnit.div_eq_iff", "start": [414, 11], "end": [415, 47], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv, h.mul_inv_eq_iff_eq_mul]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>, h.mul_inv_eq_iff_eq_mul]", [{"full_name": "div_eq_mul_inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [977, 9], "def_end_pos": [977, 23]}]], "state_before": "F : Type u_1\nG : Type u_2\n\u03b1 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d : DivisionMonoid \u03b1\na b c : \u03b1\nh : IsUnit b\n\u22a2 a / b = c \u2194 a = c * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.toNat_lt", "start": [1392, 9], "end": [1393, 50], "traced_tactics": [{"tactic": "rw [\u2190 Int.not_le, \u2190 Nat.not_le, Int.le_toNat h]", "annotated_tactic": ["rw [\u2190 <a>Int.not_le</a>, \u2190 <a>Nat.not_le</a>, <a>Int.le_toNat</a> h]", [{"full_name": "Int.not_le", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [663, 19], "def_end_pos": [663, 25]}, {"full_name": "Nat.not_le", "def_path": "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "def_pos": [57, 27], "def_end_pos": [57, 33]}, {"full_name": "Int.le_toNat", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [1389, 17], "def_end_pos": [1389, 25]}]], "state_before": "n : Nat\nz : Int\nh : 0 \u2264 z\n\u22a2 toNat z < n \u2194 z < \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.map_Ici", "start": [1177, 1], "end": [1179, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : UpperSet \u03b1\na\u271d b : \u03b1\nf : \u03b1 \u2243o \u03b2\na : \u03b1\n\u22a2 \u2191(map f) (Ici a) = Ici (\u2191f a)", "state_after": "case a.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : UpperSet \u03b1\na\u271d b : \u03b1\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 \u2191(\u2191(map f) (Ici a)) \u2194 x\u271d \u2208 \u2191(Ici (\u2191f a))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : UpperSet \u03b1\na\u271d b : \u03b1\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 \u2191(\u2191(map f) (Ici a)) \u2194 x\u271d \u2208 \u2191(Ici (\u2191f a))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/IndicatorFunction.lean", "full_name": "Set.mulSupport_mulIndicator", "start": [136, 1], "end": [138, 76], "traced_tactics": [{"tactic": "simp [Function.mem_mulSupport, mulIndicator_apply_eq_one]", "annotated_tactic": ["simp [<a>Function.mem_mulSupport</a>, <a>mulIndicator_apply_eq_one</a>]", [{"full_name": "Function.mem_mulSupport", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Support.lean", "def_pos": [67, 9], "def_end_pos": [67, 23]}, {"full_name": "Set.mulIndicator_apply_eq_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/IndicatorFunction.lean", "def_pos": [110, 9], "def_end_pos": [110, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns t : Set \u03b1\nf g : \u03b1 \u2192 M\na x : \u03b1\n\u22a2 x \u2208 mulSupport (mulIndicator s f) \u2194 x \u2208 s \u2229 mulSupport f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup_mono_fun", "start": [147, 1], "end": [148, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "GT.gt.lt", "start": [346, 11], "end": [347, 4], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/Defs.lean", "full_name": "Rat.coe_nat_num", "start": [533, 1], "end": [534, 37], "traced_tactics": [{"tactic": "rw [\u2190 Int.cast_ofNat, coe_int_num]", "annotated_tactic": ["rw [\u2190 <a>Int.cast_ofNat</a>, <a>coe_int_num</a>]", [{"full_name": "Int.cast_ofNat", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}, {"full_name": "Rat.coe_int_num", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [48, 9], "def_end_pos": [48, 20]}]], "state_before": "a b c : \u211a\nn : \u2115\n\u22a2 (\u2191n).num = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Nat.lean", "full_name": "Equiv.natSumNatEquivNat_apply", "start": [47, 1], "end": [48, 22], "traced_tactics": [{"tactic": "ext (x | x) <;> rfl", "annotated_tactic": ["ext (x | x) <;> rfl", []], "state_before": "\u03b1 : Type u_1\n\u22a2 \u2191natSumNatEquivNat = Sum.elim bit0 bit1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.disjoint_sdiff", "start": [2415, 1], "end": [2416, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "LinearMap.lTensor_comp_rTensor", "start": [1170, 1], "end": [1172, 61], "traced_tactics": [{"tactic": "simp only [lTensor, rTensor, \u2190 map_comp, id_comp, comp_id]", "annotated_tactic": ["simp only [<a>lTensor</a>, <a>rTensor</a>, \u2190 <a>map_comp</a>, <a>id_comp</a>, <a>comp_id</a>]", [{"full_name": "LinearMap.lTensor", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [1020, 5], "def_end_pos": [1020, 12]}, {"full_name": "LinearMap.rTensor", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [1025, 5], "def_end_pos": [1025, 12]}, {"full_name": "TensorProduct.map_comp", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [798, 9], "def_end_pos": [798, 17]}, {"full_name": "LinearMap.id_comp", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [564, 9], "def_end_pos": [564, 16]}, {"full_name": "LinearMap.comp_id", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [559, 9], "def_end_pos": [559, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2074 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u00b3 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : AddCommMonoid P\ninst\u271d\u2078 : AddCommMonoid Q\ninst\u271d\u2077 : AddCommMonoid S\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : Module R Q\ninst\u271d\u00b2 : Module R S\ninst\u271d\u00b9 : DistribMulAction R' M\ninst\u271d : Module R'' M\ng\u271d : P \u2192\u2097[R] Q\nf\u271d : N \u2192\u2097[R] P\nf : M \u2192\u2097[R] P\ng : N \u2192\u2097[R] Q\n\u22a2 comp (lTensor P g) (rTensor N f) = map f g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "List.pmap_next_eq_rotate_one", "start": [357, 1], "end": [361, 50], "traced_tactics": [{"tactic": "apply List.ext_nthLe", "annotated_tactic": ["apply <a>List.ext_nthLe</a>", [{"full_name": "List.ext_nthLe", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1340, 9], "def_end_pos": [1340, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : Nodup l\n\u22a2 pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l) = rotate l 1", "state_after": "case hl\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : Nodup l\n\u22a2 length (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l)) = length (rotate l 1)\n\ncase h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : Nodup l\n\u22a2 \u2200 (n : \u2115) (h\u2081 : n < length (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l))) (h\u2082 : n < length (rotate l 1)),\n    nthLe (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l)) n h\u2081 = nthLe (rotate l 1) n h\u2082"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case hl\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : Nodup l\n\u22a2 length (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l)) = length (rotate l 1)", "state_after": "no goals"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : Nodup l\n\u22a2 \u2200 (n : \u2115) (h\u2081 : n < length (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l))) (h\u2082 : n < length (rotate l 1)),\n    nthLe (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l)) n h\u2081 = nthLe (rotate l 1) n h\u2082", "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : Nodup l\nn\u271d : \u2115\nh\u2081\u271d : n\u271d < length (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l))\nh\u2082\u271d : n\u271d < length (rotate l 1)\n\u22a2 nthLe (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l)) n\u271d h\u2081\u271d = nthLe (rotate l 1) n\u271d h\u2082\u271d"}, {"tactic": "rw [nthLe_pmap, nthLe_rotate, next_nthLe _ h]", "annotated_tactic": ["rw [<a>nthLe_pmap</a>, <a>nthLe_rotate</a>, <a>next_nthLe</a> _ h]", [{"full_name": "List.nthLe_pmap", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [3115, 9], "def_end_pos": [3115, 19]}, {"full_name": "List.nthLe_rotate", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [271, 9], "def_end_pos": [271, 21]}, {"full_name": "List.next_nthLe", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Cycle.lean", "def_pos": [307, 9], "def_end_pos": [307, 19]}]], "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : Nodup l\nn\u271d : \u2115\nh\u2081\u271d : n\u271d < length (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l))\nh\u2082\u271d : n\u271d < length (rotate l 1)\n\u22a2 nthLe (pmap (next l) l (_ : \u2200 x \u2208 l, x \u2208 l)) n\u271d h\u2081\u271d = nthLe (rotate l 1) n\u271d h\u2082\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.modByMonic_eq_of_not_monic", "start": [222, 1], "end": [223, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.toWithTop_natCast", "start": [575, 1], "end": [577, 8], "traced_tactics": [{"tactic": "simp only [\u2190 toWithTop_some]", "annotated_tactic": ["simp only [\u2190 <a>toWithTop_some</a>]", [{"full_name": "PartENat.toWithTop_some", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [571, 9], "def_end_pos": [571, 23]}]], "state_before": "n : \u2115\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 toWithTop \u2191n = \u2191n", "state_after": "n : \u2115\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 toWithTop \u2191n = toWithTop \u2191n"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "n : \u2115\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 toWithTop \u2191n = toWithTop \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "AddEquiv.toIntLinearEquiv_symm", "start": [878, 1], "end": [879, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "lt_trans'", "start": [81, 1], "end": [82, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.smul_iUnion\u2082", "start": [259, 1], "end": [261, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.min'_erase_ne_self", "start": [1638, 1], "end": [1639, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/PEquiv.lean", "full_name": "PEquiv.single_trans_of_eq_none", "start": [400, 1], "end": [402, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "IsStrictOrder.swap", "start": [101, 1], "end": [102, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.negSucc_inj", "start": [72, 1], "end": [72, 91], "traced_tactics": [{"tactic": "simp [H]", "annotated_tactic": ["simp [H]", []], "state_before": "m n : Nat\nH : m = n\n\u22a2 -[m+1] = -[n+1]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.sublist.erase", "start": [1234, 1], "end": [1235, 46], "traced_tactics": [{"tactic": "simp only [erase_eq_eraseP]", "annotated_tactic": ["simp only [<a>erase_eq_eraseP</a>]", [{"full_name": "List.erase_eq_eraseP", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1197, 9], "def_end_pos": [1197, 24]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl\u2081 l\u2082 : List \u03b1\nh : l\u2081 <+ l\u2082\n\u22a2 List.erase l\u2081 a <+ List.erase l\u2082 a", "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl\u2081 l\u2082 : List \u03b1\nh : l\u2081 <+ l\u2082\n\u22a2 eraseP (fun b => decide (a = b)) l\u2081 <+ eraseP (fun b => decide (a = b)) l\u2082"}, {"tactic": "exact h.eraseP", "annotated_tactic": ["exact h.eraseP", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl\u2081 l\u2082 : List \u03b1\nh : l\u2081 <+ l\u2082\n\u22a2 eraseP (fun b => decide (a = b)) l\u2081 <+ eraseP (fun b => decide (a = b)) l\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.rel_of_forall", "start": [2812, 1], "end": [2824, 21], "traced_tactics": [{"tactic": "revert m1", "annotated_tactic": ["revert m1", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm1 m2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 m2 \u2192 r a b\nhc : \u2191card m1 = \u2191card m2\n\u22a2 Rel r m1 m2", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 m2 \u2192 r a b) \u2192 \u2191card m1 = \u2191card m2 \u2192 Rel r m1 m2"}, {"tactic": "refine' @(m2.induction_on _ _)", "annotated_tactic": ["refine' @(m2.induction_on _ _)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 m2 \u2192 r a b) \u2192 \u2191card m1 = \u2191card m2 \u2192 Rel r m1 m2", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 0 \u2192 r a b) \u2192 \u2191card m1 = \u2191card 0 \u2192 Rel r m1 0\n\ncase refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 \u2983a : \u03b1\u2984 {s : Multiset \u03b1},\n    (\u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 s \u2192 r a b) \u2192 \u2191card m1 = \u2191card s \u2192 Rel r m1 s) \u2192\n      \u2200 {m1 : Multiset \u03b1},\n        (\u2200 (a_2 b : \u03b1), a_2 \u2208 m1 \u2192 b \u2208 a ::\u2098 s \u2192 r a_2 b) \u2192 \u2191card m1 = \u2191card (a ::\u2098 s) \u2192 Rel r m1 (a ::\u2098 s)"}, {"tactic": "intro m _h hc", "annotated_tactic": ["intro m _h hc", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 0 \u2192 r a b) \u2192 \u2191card m1 = \u2191card 0 \u2192 Rel r m1 0", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nm : Multiset \u03b1\n_h : \u2200 (a b : \u03b1), a \u2208 m \u2192 b \u2208 0 \u2192 r a b\nhc : \u2191card m = \u2191card 0\n\u22a2 Rel r m 0"}, {"tactic": "rw [rel_zero_right, \u2190 card_eq_zero, hc, card_zero]", "annotated_tactic": ["rw [<a>rel_zero_right</a>, \u2190 <a>card_eq_zero</a>, hc, <a>card_zero</a>]", [{"full_name": "Multiset.rel_zero_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2734, 9], "def_end_pos": [2734, 23]}, {"full_name": "Multiset.card_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [784, 9], "def_end_pos": [784, 21]}, {"full_name": "Multiset.card_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [730, 9], "def_end_pos": [730, 18]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nm : Multiset \u03b1\n_h : \u2200 (a b : \u03b1), a \u2208 m \u2192 b \u2208 0 \u2192 r a b\nhc : \u2191card m = \u2191card 0\n\u22a2 Rel r m 0", "state_after": "no goals"}, {"tactic": "intro a t ih m h hc", "annotated_tactic": ["intro a t ih m h hc", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 \u2983a : \u03b1\u2984 {s : Multiset \u03b1},\n    (\u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 s \u2192 r a b) \u2192 \u2191card m1 = \u2191card s \u2192 Rel r m1 s) \u2192\n      \u2200 {m1 : Multiset \u03b1},\n        (\u2200 (a_2 b : \u03b1), a_2 \u2208 m1 \u2192 b \u2208 a ::\u2098 s \u2192 r a_2 b) \u2192 \u2191card m1 = \u2191card (a ::\u2098 s) \u2192 Rel r m1 (a ::\u2098 s)", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nm : Multiset \u03b1\nh : \u2200 (a_1 b : \u03b1), a_1 \u2208 m \u2192 b \u2208 a ::\u2098 t \u2192 r a_1 b\nhc : \u2191card m = \u2191card (a ::\u2098 t)\n\u22a2 Rel r m (a ::\u2098 t)"}, {"tactic": "rw [card_cons] at hc", "annotated_tactic": ["rw [<a>card_cons</a>] at hc", [{"full_name": "Multiset.card_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [743, 9], "def_end_pos": [743, 18]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nm : Multiset \u03b1\nh : \u2200 (a_1 b : \u03b1), a_1 \u2208 m \u2192 b \u2208 a ::\u2098 t \u2192 r a_1 b\nhc : \u2191card m = \u2191card (a ::\u2098 t)\n\u22a2 Rel r m (a ::\u2098 t)", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nm : Multiset \u03b1\nh : \u2200 (a_1 b : \u03b1), a_1 \u2208 m \u2192 b \u2208 a ::\u2098 t \u2192 r a_1 b\nhc : \u2191card m = \u2191card t + 1\n\u22a2 Rel r m (a ::\u2098 t)"}, {"tactic": "obtain \u27e8b, hb\u27e9 := card_pos_iff_exists_mem.1 (show 0 < card m from hc.symm \u25b8 Nat.succ_pos _)", "annotated_tactic": ["obtain \u27e8b, hb\u27e9 := <a>card_pos_iff_exists_mem</a>.1 (show 0 < <a>card</a> m from hc.symm \u25b8 <a>Nat.succ_pos</a> _)", [{"full_name": "Multiset.card_pos_iff_exists_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [792, 9], "def_end_pos": [792, 32]}, {"full_name": "Multiset.card", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [713, 5], "def_end_pos": [713, 9]}, {"full_name": "Nat.succ_pos", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1608, 9], "def_end_pos": [1608, 21]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nm : Multiset \u03b1\nh : \u2200 (a_1 b : \u03b1), a_1 \u2208 m \u2192 b \u2208 a ::\u2098 t \u2192 r a_1 b\nhc : \u2191card m = \u2191card t + 1\n\u22a2 Rel r m (a ::\u2098 t)", "state_after": "case refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nm : Multiset \u03b1\nh : \u2200 (a_1 b : \u03b1), a_1 \u2208 m \u2192 b \u2208 a ::\u2098 t \u2192 r a_1 b\nhc : \u2191card m = \u2191card t + 1\nb : \u03b1\nhb : b \u2208 m\n\u22a2 Rel r m (a ::\u2098 t)"}, {"tactic": "obtain \u27e8m', rfl\u27e9 := exists_cons_of_mem hb", "annotated_tactic": ["obtain \u27e8m', rfl\u27e9 := <a>exists_cons_of_mem</a> hb", [{"full_name": "Multiset.exists_cons_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [253, 9], "def_end_pos": [253, 27]}]], "state_before": "case refine'_2.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nm : Multiset \u03b1\nh : \u2200 (a_1 b : \u03b1), a_1 \u2208 m \u2192 b \u2208 a ::\u2098 t \u2192 r a_1 b\nhc : \u2191card m = \u2191card t + 1\nb : \u03b1\nhb : b \u2208 m\n\u22a2 Rel r m (a ::\u2098 t)", "state_after": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nb : \u03b1\nm' : Multiset \u03b1\nh : \u2200 (a_1 b_1 : \u03b1), a_1 \u2208 b ::\u2098 m' \u2192 b_1 \u2208 a ::\u2098 t \u2192 r a_1 b_1\nhc : \u2191card (b ::\u2098 m') = \u2191card t + 1\nhb : b \u2208 b ::\u2098 m'\n\u22a2 Rel r (b ::\u2098 m') (a ::\u2098 t)"}, {"tactic": "refine' rel_cons_right.mpr \u27e8b, m', h _ _ hb (mem_cons_self _ _), ih _ _, rfl\u27e9", "annotated_tactic": ["refine' rel_cons_right.mpr \u27e8b, m', h _ _ hb (<a>mem_cons_self</a> _ _), ih _ _, <a>rfl</a>\u27e9", [{"full_name": "Multiset.mem_cons_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [244, 9], "def_end_pos": [244, 22]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case refine'_2.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nb : \u03b1\nm' : Multiset \u03b1\nh : \u2200 (a_1 b_1 : \u03b1), a_1 \u2208 b ::\u2098 m' \u2192 b_1 \u2208 a ::\u2098 t \u2192 r a_1 b_1\nhc : \u2191card (b ::\u2098 m') = \u2191card t + 1\nhb : b \u2208 b ::\u2098 m'\n\u22a2 Rel r (b ::\u2098 m') (a ::\u2098 t)", "state_after": "case refine'_2.intro.intro.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nb : \u03b1\nm' : Multiset \u03b1\nh : \u2200 (a_1 b_1 : \u03b1), a_1 \u2208 b ::\u2098 m' \u2192 b_1 \u2208 a ::\u2098 t \u2192 r a_1 b_1\nhc : \u2191card (b ::\u2098 m') = \u2191card t + 1\nhb : b \u2208 b ::\u2098 m'\n\u22a2 \u2200 (a b : \u03b1), a \u2208 m' \u2192 b \u2208 t \u2192 r a b\n\ncase refine'_2.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nb : \u03b1\nm' : Multiset \u03b1\nh : \u2200 (a_1 b_1 : \u03b1), a_1 \u2208 b ::\u2098 m' \u2192 b_1 \u2208 a ::\u2098 t \u2192 r a_1 b_1\nhc : \u2191card (b ::\u2098 m') = \u2191card t + 1\nhb : b \u2208 b ::\u2098 m'\n\u22a2 \u2191card m' = \u2191card t"}, {"tactic": "exact fun _ _ ha hb => h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb)", "annotated_tactic": ["exact fun _ _ ha hb => h _ _ (<a>mem_cons_of_mem</a> ha) (<a>mem_cons_of_mem</a> hb)", [{"full_name": "Multiset.mem_cons_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 24]}, {"full_name": "Multiset.mem_cons_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 24]}]], "state_before": "case refine'_2.intro.intro.refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nb : \u03b1\nm' : Multiset \u03b1\nh : \u2200 (a_1 b_1 : \u03b1), a_1 \u2208 b ::\u2098 m' \u2192 b_1 \u2208 a ::\u2098 t \u2192 r a_1 b_1\nhc : \u2191card (b ::\u2098 m') = \u2191card t + 1\nhb : b \u2208 b ::\u2098 m'\n\u22a2 \u2200 (a b : \u03b1), a \u2208 m' \u2192 b \u2208 t \u2192 r a b", "state_after": "no goals"}, {"tactic": "simpa using hc", "annotated_tactic": ["simpa using hc", []], "state_before": "case refine'_2.intro.intro.refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b3 \u2192 \u03b4 \u2192 Prop\nm2 : Multiset \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nt : Multiset \u03b1\nih : \u2200 {m1 : Multiset \u03b1}, (\u2200 (a b : \u03b1), a \u2208 m1 \u2192 b \u2208 t \u2192 r a b) \u2192 \u2191card m1 = \u2191card t \u2192 Rel r m1 t\nb : \u03b1\nm' : Multiset \u03b1\nh : \u2200 (a_1 b_1 : \u03b1), a_1 \u2208 b ::\u2098 m' \u2192 b_1 \u2208 a ::\u2098 t \u2192 r a_1 b_1\nhc : \u2191card (b ::\u2098 m') = \u2191card t + 1\nhb : b \u2208 b ::\u2098 m'\n\u22a2 \u2191card m' = \u2191card t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "Polynomial.toSubring_one", "start": [403, 1], "end": [409, 27], "traced_tactics": [{"tactic": "rw [coeff_toSubring', coeff_one, coeff_one, apply_ite Subtype.val, ZeroMemClass.coe_zero,\n  OneMemClass.coe_one]", "annotated_tactic": ["rw [<a>coeff_toSubring'</a>, <a>coeff_one</a>, <a>coeff_one</a>, <a>apply_ite</a> <a>Subtype.val</a>, <a>ZeroMemClass.coe_zero</a>,\n      <a>OneMemClass.coe_one</a>]", [{"full_name": "Polynomial.coeff_toSubring'", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Polynomial/Basic.lean", "def_pos": [370, 9], "def_end_pos": [370, 25]}, {"full_name": "Polynomial.coeff_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [699, 9], "def_end_pos": [699, 18]}, {"full_name": "Polynomial.coeff_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [699, 9], "def_end_pos": [699, 18]}, {"full_name": "apply_ite", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [751, 9], "def_end_pos": [751, 18]}, {"full_name": "Subtype.val", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [564, 3], "def_end_pos": [564, 6]}, {"full_name": "ZeroMemClass.coe_zero", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [520, 3], "def_end_pos": [520, 14]}, {"full_name": "OneMemClass.coe_one", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [521, 9], "def_end_pos": [521, 16]}]], "state_before": "R : Type u\nS : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : Semiring S\nf : R \u2192+* S\nx : S\np : R[X]\nT : Subring R\nhp : \u2191(frange p) \u2286 \u2191T\ni : \u2115\n\u22a2 \u2191(coeff (toSubring 1 T (_ : \u2191(frange 1) \u2286 \u2191T)) i) = \u2191(coeff 1 i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.compl_range_some", "start": [1205, 1], "end": [1206, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "WithBot.Ioc_coe_coe", "start": [1198, 1], "end": [1199, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.binomial_eq_binomial", "start": [961, 1], "end": [965, 61], "traced_tactics": [{"tactic": "simp_rw [C_mul_X_pow_eq_monomial, \u2190 toFinsupp_inj, toFinsupp_add, toFinsupp_monomial]", "annotated_tactic": ["simp_rw [<a>C_mul_X_pow_eq_monomial</a>, \u2190 <a>toFinsupp_inj</a>, <a>toFinsupp_add</a>, <a>toFinsupp_monomial</a>]", [{"full_name": "Polynomial.C_mul_X_pow_eq_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [773, 9], "def_end_pos": [773, 32]}, {"full_name": "Polynomial.toFinsupp_inj", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [257, 9], "def_end_pos": [257, 22]}, {"full_name": "Polynomial.toFinsupp_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 22]}, {"full_name": "Polynomial.toFinsupp_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [438, 9], "def_end_pos": [438, 27]}]], "state_before": "R : Type u\na b : R\nm\u271d n\u271d : \u2115\ninst\u271d : Semiring R\np q : R[X]\nk l m n : \u2115\nu v : R\nhu : u \u2260 0\nhv : v \u2260 0\n\u22a2 \u2191C u * X ^ k + \u2191C v * X ^ l = \u2191C u * X ^ m + \u2191C v * X ^ n \u2194\n    k = m \u2227 l = n \u2228 u = v \u2227 k = n \u2227 l = m \u2228 u + v = 0 \u2227 k = l \u2227 m = n", "state_after": "R : Type u\na b : R\nm\u271d n\u271d : \u2115\ninst\u271d : Semiring R\np q : R[X]\nk l m n : \u2115\nu v : R\nhu : u \u2260 0\nhv : v \u2260 0\n\u22a2 (((fun\u2080 | k => u) + fun\u2080 | l => v) = (fun\u2080 | m => u) + fun\u2080 | n => v) \u2194\n    k = m \u2227 l = n \u2228 u = v \u2227 k = n \u2227 l = m \u2228 u + v = 0 \u2227 k = l \u2227 m = n"}, {"tactic": "exact Finsupp.single_add_single_eq_single_add_single hu hv", "annotated_tactic": ["exact <a>Finsupp.single_add_single_eq_single_add_single</a> hu hv", [{"full_name": "Finsupp.single_add_single_eq_single_add_single", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1298, 9], "def_end_pos": [1298, 47]}]], "state_before": "R : Type u\na b : R\nm\u271d n\u271d : \u2115\ninst\u271d : Semiring R\np q : R[X]\nk l m n : \u2115\nu v : R\nhu : u \u2260 0\nhv : v \u2260 0\n\u22a2 (((fun\u2080 | k => u) + fun\u2080 | l => v) = (fun\u2080 | m => u) + fun\u2080 | n => v) \u2194\n    k = m \u2227 l = n \u2228 u = v \u2227 k = n \u2227 l = m \u2228 u + v = 0 \u2227 k = l \u2227 m = n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.coe_pow", "start": [425, 11], "end": [426, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "codisjoint_hnot_right", "start": [1048, 1], "end": [1049, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean", "full_name": "Function.mem_fixedPoints_iff", "start": [144, 1], "end": [145, 6], "traced_tactics": [{"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1\u271d : Type u\n\u03b2 : Type v\nf\u271d fa g : \u03b1\u271d \u2192 \u03b1\u271d\nx\u271d y : \u03b1\u271d\nfb : \u03b2 \u2192 \u03b2\nm n k : \u2115\ne : Perm \u03b1\u271d\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\nx : \u03b1\n\u22a2 x \u2208 fixedPoints f \u2194 f x = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Sublists.lean", "full_name": "List.mem_sublistsLen", "start": [330, 1], "end": [334, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "NonUnitalRingHom.coe_comp_addMonoidHom", "start": [261, 1], "end": [263, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "densely_ordered_iff_forall_not_covby", "start": [248, 1], "end": [250, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Tower.lean", "full_name": "Submodule.smul_mem_span_smul", "start": [310, 1], "end": [315, 52], "traced_tactics": [{"tactic": "rw [smul_zero]", "annotated_tactic": ["rw [<a>smul_zero</a>]", [{"full_name": "smul_zero", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [732, 9], "def_end_pos": [732, 18]}]], "state_before": "R : Type u\nS : Type v\nA : Type w\nB : Type u\u2081\nM : Type v\u2081\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : Module R S\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R S A\ninst\u271d : SMulCommClass R S A\ns : Set S\nhs : span R s = \u22a4\nt : Set A\nk : S\nx : A\nhx : x \u2208 span R t\n\u22a2 k \u2022 0 \u2208 span R (s \u2022 t)", "state_after": "R : Type u\nS : Type v\nA : Type w\nB : Type u\u2081\nM : Type v\u2081\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : Module R S\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R S A\ninst\u271d : SMulCommClass R S A\ns : Set S\nhs : span R s = \u22a4\nt : Set A\nk : S\nx : A\nhx : x \u2208 span R t\n\u22a2 0 \u2208 span R (s \u2022 t)"}, {"tactic": "exact zero_mem _", "annotated_tactic": ["exact <a>zero_mem</a> _", [{"full_name": "ZeroMemClass.zero_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}]], "state_before": "R : Type u\nS : Type v\nA : Type w\nB : Type u\u2081\nM : Type v\u2081\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : Module R S\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R S A\ninst\u271d : SMulCommClass R S A\ns : Set S\nhs : span R s = \u22a4\nt : Set A\nk : S\nx : A\nhx : x \u2208 span R t\n\u22a2 0 \u2208 span R (s \u2022 t)", "state_after": "no goals"}, {"tactic": "rw [smul_add]", "annotated_tactic": ["rw [<a>smul_add</a>]", [{"full_name": "smul_add", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [807, 9], "def_end_pos": [807, 17]}]], "state_before": "R : Type u\nS : Type v\nA : Type w\nB : Type u\u2081\nM : Type v\u2081\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : Module R S\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R S A\ninst\u271d : SMulCommClass R S A\ns : Set S\nhs : span R s = \u22a4\nt : Set A\nk : S\nx\u271d : A\nhx : x\u271d \u2208 span R t\nx y : A\nihx : k \u2022 x \u2208 span R (s \u2022 t)\nihy : k \u2022 y \u2208 span R (s \u2022 t)\n\u22a2 k \u2022 (x + y) \u2208 span R (s \u2022 t)", "state_after": "R : Type u\nS : Type v\nA : Type w\nB : Type u\u2081\nM : Type v\u2081\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : Module R S\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R S A\ninst\u271d : SMulCommClass R S A\ns : Set S\nhs : span R s = \u22a4\nt : Set A\nk : S\nx\u271d : A\nhx : x\u271d \u2208 span R t\nx y : A\nihx : k \u2022 x \u2208 span R (s \u2022 t)\nihy : k \u2022 y \u2208 span R (s \u2022 t)\n\u22a2 k \u2022 x + k \u2022 y \u2208 span R (s \u2022 t)"}, {"tactic": "exact add_mem ihx ihy", "annotated_tactic": ["exact <a>add_mem</a> ihx ihy", [{"full_name": "AddMemClass.add_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Basic.lean", "def_pos": [72, 3], "def_end_pos": [72, 10]}]], "state_before": "R : Type u\nS : Type v\nA : Type w\nB : Type u\u2081\nM : Type v\u2081\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : Module R S\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R S A\ninst\u271d : SMulCommClass R S A\ns : Set S\nhs : span R s = \u22a4\nt : Set A\nk : S\nx\u271d : A\nhx : x\u271d \u2208 span R t\nx y : A\nihx : k \u2022 x \u2208 span R (s \u2022 t)\nihy : k \u2022 y \u2208 span R (s \u2022 t)\n\u22a2 k \u2022 x + k \u2022 y \u2208 span R (s \u2022 t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Conj.lean", "full_name": "IsConj.trans", "start": [47, 1], "end": [48, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Subtype.preimage_coe_inter_self", "start": [1463, 1], "end": [1465, 65], "traced_tactics": [{"tactic": "rw [preimage_coe_eq_preimage_coe_iff, inter_assoc, inter_self]", "annotated_tactic": ["rw [<a>preimage_coe_eq_preimage_coe_iff</a>, <a>inter_assoc</a>, <a>inter_self</a>]", [{"full_name": "Subtype.preimage_coe_eq_preimage_coe_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1456, 9], "def_end_pos": [1456, 41]}, {"full_name": "Set.inter_assoc", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [937, 9], "def_end_pos": [937, 20]}, {"full_name": "Set.inter_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [919, 9], "def_end_pos": [919, 19]}]], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 val \u207b\u00b9' (t \u2229 s) = val \u207b\u00b9' t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.join_eq_joinTR", "start": [91, 10], "end": [92, 60], "traced_tactics": [{"tactic": "funext \u03b1 l", "annotated_tactic": ["funext \u03b1 l", []], "state_before": "\u22a2 @join = @joinTR", "state_after": "case h.h\n\u03b1 : Type u_1\nl : List (List \u03b1)\n\u22a2 join l = joinTR l"}, {"tactic": "rw [\u2190 List.bind_id, List.bind_eq_bindTR]", "annotated_tactic": ["rw [\u2190 <a>List.bind_id</a>, <a>List.bind_eq_bindTR</a>]", [{"full_name": "List.bind_id", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [120, 17], "def_end_pos": [120, 24]}, {"full_name": "List.bind_eq_bindTR", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [81, 18], "def_end_pos": [81, 32]}]], "state_before": "case h.h\n\u03b1 : Type u_1\nl : List (List \u03b1)\n\u22a2 join l = joinTR l", "state_after": "case h.h\n\u03b1 : Type u_1\nl : List (List \u03b1)\n\u22a2 bindTR l id = joinTR l"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.h\n\u03b1 : Type u_1\nl : List (List \u03b1)\n\u22a2 bindTR l id = joinTR l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.fst_swap", "start": [172, 1], "end": [173, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Int/Basic.lean", "full_name": "Int.prime_iff_natAbs_prime", "start": [365, 1], "end": [366, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Log.lean", "full_name": "Nat.log_eq_iff", "start": [134, 1], "end": [145, 65], "traced_tactics": [{"tactic": "rcases em (1 < b \u2227 n \u2260 0) with (\u27e8hb, hn\u27e9 | hbn)", "annotated_tactic": ["rcases <a>em</a> (1 < b \u2227 n \u2260 0) with (\u27e8hb, hn\u27e9 | hbn)", [{"full_name": "em", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [193, 7], "def_end_pos": [193, 9]}]], "state_before": "b m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)", "state_after": "case inl.intro\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhb : 1 < b\nhn : n \u2260 0\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)\n\ncase inr\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhbn : \u00ac(1 < b \u2227 n \u2260 0)\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)"}, {"tactic": "rw [le_antisymm_iff, \u2190 lt_succ_iff, \u2190 pow_le_iff_le_log, \u2190 lt_pow_iff_log_lt, and_comm] <;>\n  assumption", "annotated_tactic": ["rw [<a>le_antisymm_iff</a>, \u2190 <a>lt_succ_iff</a>, \u2190 <a>pow_le_iff_le_log</a>, \u2190 <a>lt_pow_iff_log_lt</a>, <a>and_comm</a>] <;>\n      assumption", [{"full_name": "le_antisymm_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [192, 9], "def_end_pos": [192, 24]}, {"full_name": "Nat.lt_succ_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [200, 9], "def_end_pos": [200, 20]}, {"full_name": "Nat.pow_le_iff_le_log", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [88, 9], "def_end_pos": [88, 26]}, {"full_name": "Nat.lt_pow_iff_log_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [103, 9], "def_end_pos": [103, 26]}, {"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}]], "state_before": "case inl.intro\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhb : 1 < b\nhn : n \u2260 0\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)", "state_after": "no goals"}, {"tactic": "have hm : m \u2260 0 := h.resolve_right hbn", "annotated_tactic": ["have hm : m \u2260 0 := h.resolve_right hbn", []], "state_before": "case inr\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhbn : \u00ac(1 < b \u2227 n \u2260 0)\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)", "state_after": "case inr\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhbn : \u00ac(1 < b \u2227 n \u2260 0)\nhm : m \u2260 0\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)"}, {"tactic": "rw [not_and_or, not_lt, Ne.def, not_not] at hbn", "annotated_tactic": ["rw [<a>not_and_or</a>, <a>not_lt</a>, <a>Ne.def</a>, <a>not_not</a>] at hbn", [{"full_name": "not_and_or", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [470, 9], "def_end_pos": [470, 19]}, {"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Classical.not_not", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [689, 24], "def_end_pos": [689, 31]}]], "state_before": "case inr\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhbn : \u00ac(1 < b \u2227 n \u2260 0)\nhm : m \u2260 0\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)", "state_after": "case inr\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhbn : b \u2264 1 \u2228 n = 0\nhm : m \u2260 0\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)"}, {"tactic": "rcases hbn with (hb | rfl)", "annotated_tactic": ["rcases hbn with (hb | rfl)", []], "state_before": "case inr\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhbn : b \u2264 1 \u2228 n = 0\nhm : m \u2260 0\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)", "state_after": "case inr.inl\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhm : m \u2260 0\nhb : b \u2264 1\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)\n\ncase inr.inr\nb m : \u2115\nhm : m \u2260 0\nh : m \u2260 0 \u2228 1 < b \u2227 0 \u2260 0\n\u22a2 log b 0 = m \u2194 b ^ m \u2264 0 \u2227 0 < b ^ (m + 1)"}, {"tactic": "simpa only [log_of_left_le_one hb, hm.symm, false_iff_iff, not_and, not_lt] using\n  le_trans (pow_le_pow_of_le_one' hb m.le_succ)", "annotated_tactic": ["simpa only [<a>log_of_left_le_one</a> hb, hm.symm, <a>false_iff_iff</a>, <a>not_and</a>, <a>not_lt</a>] using\n        <a>le_trans</a> (<a>pow_le_pow_of_le_one'</a> hb m.le_succ)", [{"full_name": "Nat.log_of_left_le_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [48, 9], "def_end_pos": [48, 27]}, {"full_name": "false_iff_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [202, 9], "def_end_pos": [202, 22]}, {"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}, {"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}, {"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}, {"full_name": "pow_le_pow_of_le_one'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/CovariantClass.lean", "def_pos": [69, 9], "def_end_pos": [69, 30]}]], "state_before": "case inr.inl\nb m n : \u2115\nh : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0\nhm : m \u2260 0\nhb : b \u2264 1\n\u22a2 log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)", "state_after": "no goals"}, {"tactic": "simpa only [log_zero_right, hm.symm, nonpos_iff_eq_zero, false_iff, not_and, not_lt,\n  add_pos_iff, or_true, pow_eq_zero_iff] using pow_eq_zero", "annotated_tactic": ["simpa only [<a>log_zero_right</a>, hm.symm, <a>nonpos_iff_eq_zero</a>, <a>false_iff</a>, <a>not_and</a>, <a>not_lt</a>,\n        <a>add_pos_iff</a>, <a>or_true</a>, <a>pow_eq_zero_iff</a>] using <a>pow_eq_zero</a>", [{"full_name": "Nat.log_zero_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [72, 9], "def_end_pos": [72, 23]}, {"full_name": "nonpos_iff_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [237, 3], "def_end_pos": [237, 14]}, {"full_name": "false_iff", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [102, 17], "def_end_pos": [102, 26]}, {"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}, {"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}, {"full_name": "add_pos_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [255, 30], "def_end_pos": [255, 41]}, {"full_name": "or_true", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [94, 17], "def_end_pos": [94, 24]}, {"full_name": "pow_eq_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [63, 9], "def_end_pos": [63, 24]}, {"full_name": "pow_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [54, 9], "def_end_pos": [54, 20]}]], "state_before": "case inr.inr\nb m : \u2115\nhm : m \u2260 0\nh : m \u2260 0 \u2228 1 < b \u2227 0 \u2260 0\n\u22a2 log b 0 = m \u2194 b ^ m \u2264 0 \u2227 0 < b ^ (m + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Commutator.lean", "full_name": "Subgroup.commutator_prod_prod", "start": [197, 1], "end": [208, 60], "traced_tactics": [{"tactic": "apply le_antisymm", "annotated_tactic": ["apply <a>le_antisymm</a>", [{"full_name": "le_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}]], "state_before": "G : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046 = prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046", "state_after": "case a\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046 \u2264 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046\n\ncase a\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046 \u2264 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046"}, {"tactic": "rw [commutator_le]", "annotated_tactic": ["rw [<a>commutator_le</a>]", [{"full_name": "Subgroup.commutator_le", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Commutator.lean", "def_pos": [89, 9], "def_end_pos": [89, 22]}]], "state_before": "case a\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046 \u2264 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046", "state_after": "case a\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 \u2200 g\u2081 \u2208 prod H\u2081 K\u2081, \u2200 g\u2082 \u2208 prod H\u2082 K\u2082, \u2045g\u2081, g\u2082\u2046 \u2208 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046"}, {"tactic": "rintro \u27e8p\u2081, p\u2082\u27e9 \u27e8hp\u2081, hp\u2082\u27e9 \u27e8q\u2081, q\u2082\u27e9 \u27e8hq\u2081, hq\u2082\u27e9", "annotated_tactic": ["rintro \u27e8p\u2081, p\u2082\u27e9 \u27e8hp\u2081, hp\u2082\u27e9 \u27e8q\u2081, q\u2082\u27e9 \u27e8hq\u2081, hq\u2082\u27e9", []], "state_before": "case a\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 \u2200 g\u2081 \u2208 prod H\u2081 K\u2081, \u2200 g\u2082 \u2208 prod H\u2082 K\u2082, \u2045g\u2081, g\u2082\u2046 \u2208 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046", "state_after": "case a.mk.intro.mk.intro\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\np\u2081 : G\np\u2082 : G'\nhp\u2081 : (p\u2081, p\u2082).1 \u2208 \u2191H\u2081.toSubmonoid\nhp\u2082 : (p\u2081, p\u2082).2 \u2208 \u2191K\u2081.toSubmonoid\nq\u2081 : G\nq\u2082 : G'\nhq\u2081 : (q\u2081, q\u2082).1 \u2208 \u2191H\u2082.toSubmonoid\nhq\u2082 : (q\u2081, q\u2082).2 \u2208 \u2191K\u2082.toSubmonoid\n\u22a2 \u2045(p\u2081, p\u2082), (q\u2081, q\u2082)\u2046 \u2208 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046"}, {"tactic": "exact \u27e8commutator_mem_commutator hp\u2081 hq\u2081, commutator_mem_commutator hp\u2082 hq\u2082\u27e9", "annotated_tactic": ["exact \u27e8<a>commutator_mem_commutator</a> hp\u2081 hq\u2081, <a>commutator_mem_commutator</a> hp\u2082 hq\u2082\u27e9", [{"full_name": "Subgroup.commutator_mem_commutator", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Commutator.lean", "def_pos": [85, 9], "def_end_pos": [85, 34]}, {"full_name": "Subgroup.commutator_mem_commutator", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Commutator.lean", "def_pos": [85, 9], "def_end_pos": [85, 34]}]], "state_before": "case a.mk.intro.mk.intro\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\np\u2081 : G\np\u2082 : G'\nhp\u2081 : (p\u2081, p\u2082).1 \u2208 \u2191H\u2081.toSubmonoid\nhp\u2082 : (p\u2081, p\u2082).2 \u2208 \u2191K\u2081.toSubmonoid\nq\u2081 : G\nq\u2082 : G'\nhq\u2081 : (q\u2081, q\u2082).1 \u2208 \u2191H\u2082.toSubmonoid\nhq\u2082 : (q\u2081, q\u2082).2 \u2208 \u2191K\u2082.toSubmonoid\n\u22a2 \u2045(p\u2081, p\u2082), (q\u2081, q\u2082)\u2046 \u2208 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046", "state_after": "no goals"}, {"tactic": "rw [prod_le_iff]", "annotated_tactic": ["rw [<a>prod_le_iff</a>]", [{"full_name": "Subgroup.prod_le_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1796, 9], "def_end_pos": [1796, 20]}]], "state_before": "case a\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 prod \u2045H\u2081, H\u2082\u2046 \u2045K\u2081, K\u2082\u2046 \u2264 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046", "state_after": "case a\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 map (MonoidHom.inl G G') \u2045H\u2081, H\u2082\u2046 \u2264 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046 \u2227\n    map (MonoidHom.inr G G') \u2045K\u2081, K\u2082\u2046 \u2264 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046"}, {"tactic": "rw [map_commutator]", "annotated_tactic": ["rw [<a>map_commutator</a>]", [{"full_name": "Subgroup.map_commutator", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Commutator.lean", "def_pos": [171, 9], "def_end_pos": [171, 23]}]], "state_before": "case a.right\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 map (MonoidHom.inr G G') \u2045K\u2081, K\u2082\u2046 \u2264 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046", "state_after": "case a.right\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 \u2045map (MonoidHom.inr G G') K\u2081, map (MonoidHom.inr G G') K\u2082\u2046 \u2264 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046"}, {"tactic": "apply commutator_mono <;>\n  simp [le_prod_iff, map_map, MonoidHom.fst_comp_inl, MonoidHom.snd_comp_inl,\n    MonoidHom.fst_comp_inr, MonoidHom.snd_comp_inr]", "annotated_tactic": ["apply <a>commutator_mono</a> <;>\n          simp [<a>le_prod_iff</a>, <a>map_map</a>, <a>MonoidHom.fst_comp_inl</a>, <a>MonoidHom.snd_comp_inl</a>,\n            <a>MonoidHom.fst_comp_inr</a>, <a>MonoidHom.snd_comp_inr</a>]", [{"full_name": "Subgroup.commutator_mono", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Commutator.lean", "def_pos": [94, 9], "def_end_pos": [94, 24]}, {"full_name": "Subgroup.le_prod_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1789, 9], "def_end_pos": [1789, 20]}, {"full_name": "Subgroup.map_map", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1465, 9], "def_end_pos": [1465, 16]}, {"full_name": "MonoidHom.fst_comp_inl", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [514, 9], "def_end_pos": [514, 21]}, {"full_name": "MonoidHom.snd_comp_inl", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [520, 9], "def_end_pos": [520, 21]}, {"full_name": "MonoidHom.fst_comp_inr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [526, 9], "def_end_pos": [526, 21]}, {"full_name": "MonoidHom.snd_comp_inr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [532, 9], "def_end_pos": [532, 21]}]], "state_before": "case a.right\nG : Type u_1\nG' : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Group G'\ninst\u271d : MonoidHomClass F G G'\nf : F\ng\u2081 g\u2082 g\u2083 g : G\nH\u2081 H\u2082 H\u2083 K\u2081\u271d K\u2082\u271d : Subgroup G\nK\u2081 K\u2082 : Subgroup G'\n\u22a2 \u2045map (MonoidHom.inr G G') K\u2081, map (MonoidHom.inr G G') K\u2082\u2046 \u2264 \u2045prod H\u2081 K\u2081, prod H\u2082 K\u2082\u2046", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quotient.eq''", "start": [784, 11], "end": [785, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Bind.lean", "full_name": "Multiset.product_singleton", "start": [272, 1], "end": [273, 66], "traced_tactics": [{"tactic": "simp only [SProd.sprod, product, bind_singleton, map_singleton]", "annotated_tactic": ["simp only [<a>SProd.sprod</a>, <a>product</a>, <a>bind_singleton</a>, <a>map_singleton</a>]", [{"full_name": "SProd.sprod", "def_path": "lake-packages/mathlib/Mathlib/Data/SProd.lean", "def_pos": [29, 3], "def_end_pos": [29, 8]}, {"full_name": "Multiset.product", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Bind.lean", "def_pos": [238, 5], "def_end_pos": [238, 12]}, {"full_name": "Multiset.bind_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Bind.lean", "def_pos": [136, 9], "def_end_pos": [136, 23]}, {"full_name": "Multiset.map_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1190, 9], "def_end_pos": [1190, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\n\u03b4 : Type u_3\na : \u03b1\nb : \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\n\u22a2 {a} \u00d7\u02e2 {b} = {(a, b)}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Basic.lean", "full_name": "coe_invMonoidHom", "start": [58, 1], "end": [58, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/PushNeg.lean", "full_name": "Mathlib.Tactic.PushNeg.not_forall_eq", "start": [26, 1], "end": [26, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Ne.ite_eq_right_iff", "start": [1191, 11], "end": [1192, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.pairwiseDisjoint_smul_iff", "start": [1877, 1], "end": [1879, 83], "traced_tactics": [{"tactic": "simp_rw [\u2190 pairwiseDisjoint_coe, coe_smul_finset, Set.pairwiseDisjoint_smul_iff]", "annotated_tactic": ["simp_rw [\u2190 <a>pairwiseDisjoint_coe</a>, <a>coe_smul_finset</a>, <a>Set.pairwiseDisjoint_smul_iff</a>]", [{"full_name": "Finset.pairwiseDisjoint_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1021, 9], "def_end_pos": [1021, 29]}, {"full_name": "Finset.coe_smul_finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Pointwise.lean", "def_pos": [1599, 9], "def_end_pos": [1599, 24]}, {"full_name": "Set.pairwiseDisjoint_smul_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [868, 9], "def_end_pos": [868, 34]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : LeftCancelSemigroup \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u271d t\u271d : Finset \u03b1\na : \u03b1\ns : Set \u03b1\nt : Finset \u03b1\n\u22a2 (Set.PairwiseDisjoint s fun x => x \u2022 t) \u2194 Set.InjOn (fun p => p.1 * p.2) (s \u00d7\u02e2 \u2191t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Fintype.lean", "full_name": "Equiv.extendSubtype_apply_of_mem", "start": [117, 1], "end": [121, 74], "traced_tactics": [{"tactic": "dsimp only [extendSubtype]", "annotated_tactic": ["dsimp only [<a>extendSubtype</a>]", [{"full_name": "Equiv.extendSubtype", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Fintype.lean", "def_pos": [113, 22], "def_end_pos": [113, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b2\ne\u271d : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 \u2191(extendSubtype e) x = \u2191(\u2191e { val := x, property := hx })", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b2\ne\u271d : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 \u2191(subtypeCongr e (toCompl e)) x = \u2191(\u2191e { val := x, property := hx })"}, {"tactic": "simp only [subtypeCongr, Equiv.trans_apply, Equiv.sumCongr_apply]", "annotated_tactic": ["simp only [<a>subtypeCongr</a>, <a>Equiv.trans_apply</a>, <a>Equiv.sumCongr_apply</a>]", [{"full_name": "Equiv.subtypeCongr", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [599, 5], "def_end_pos": [599, 17]}, {"full_name": "Equiv.trans_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [272, 17], "def_end_pos": [272, 28]}, {"full_name": "Equiv.sumCongr_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [296, 9], "def_end_pos": [296, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b2\ne\u271d : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 \u2191(subtypeCongr e (toCompl e)) x = \u2191(\u2191e { val := x, property := hx })", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b2\ne\u271d : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 \u2191(sumCompl fun x => q x) (Sum.map (\u2191e) (\u2191(toCompl e)) (\u2191(sumCompl fun x => p x).symm x)) =\n    \u2191(\u2191e { val := x, property := hx })"}, {"tactic": "rw [sumCompl_apply_symm_of_pos _ _ hx, Sum.map_inl, sumCompl_apply_inl]", "annotated_tactic": ["rw [<a>sumCompl_apply_symm_of_pos</a> _ _ hx, <a>Sum.map_inl</a>, <a>sumCompl_apply_inl</a>]", [{"full_name": "Equiv.sumCompl_apply_symm_of_pos", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [586, 9], "def_end_pos": [586, 35]}, {"full_name": "Sum.map_inl", "def_path": "lake-packages/std/Std/Data/Sum/Basic.lean", "def_pos": [107, 17], "def_end_pos": [107, 24]}, {"full_name": "Equiv.sumCompl_apply_inl", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [574, 9], "def_end_pos": [574, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b2\ne\u271d : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\ne : { x // p x } \u2243 { x // q x }\nx : \u03b1\nhx : p x\n\u22a2 \u2191(sumCompl fun x => q x) (Sum.map (\u2191e) (\u2191(toCompl e)) (\u2191(sumCompl fun x => p x).symm x)) =\n    \u2191(\u2191e { val := x, property := hx })", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "or_not", "start": [199, 1], "end": [199, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/Abel.lean", "full_name": "Mathlib.Tactic.Abel.unfold_smul", "start": [256, 1], "end": [257, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BotHom.sup_apply", "start": [554, 1], "end": [555, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Hom/Basic.lean", "full_name": "le_map_add_map_div", "start": [135, 1], "end": [137, 74], "traced_tactics": [{"tactic": "simpa only [add_comm, div_mul_cancel'] using map_mul_le_add f (a / b) b", "annotated_tactic": ["simpa only [<a>add_comm</a>, <a>div_mul_cancel'</a>] using <a>map_mul_le_add</a> f (a / b) b", [{"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}, {"full_name": "div_mul_cancel'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [729, 9], "def_end_pos": [729, 24]}, {"full_name": "MulLEAddHomClass.map_mul_le_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Hom/Basic.lean", "def_pos": [105, 3], "def_end_pos": [105, 17]}]], "state_before": "\u03b9 : Type u_1\nF : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b2\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : MulLEAddHomClass F \u03b1 \u03b2\nf : F\na b : \u03b1\n\u22a2 \u2191f a \u2264 \u2191f b + \u2191f (a / b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.sup_def", "start": [574, 1], "end": [574, 89], "traced_tactics": [{"tactic": "rw [sup_eq_conGen]", "annotated_tactic": ["rw [<a>sup_eq_conGen</a>]", [{"full_name": "Con.sup_eq_conGen", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Congruence.lean", "def_pos": [563, 9], "def_end_pos": [563, 22]}]], "state_before": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\ninst\u271d : Mul P\nc\u271d c d : Con M\n\u22a2 c \u2294 d = conGen (r \u2294 r)", "state_after": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\ninst\u271d : Mul P\nc\u271d c d : Con M\n\u22a2 (conGen fun x y => \u2191c x y \u2228 \u2191d x y) = conGen (r \u2294 r)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "M : Type u_1\nN : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : Mul M\ninst\u271d\u00b9 : Mul N\ninst\u271d : Mul P\nc\u271d c d : Con M\n\u22a2 (conGen fun x y => \u2191c x y \u2228 \u2191d x y) = conGen (r \u2294 r)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.untop_le_iff", "start": [899, 1], "end": [901, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Submonoid.LocalizationMap.lift_comp", "start": [1022, 1], "end": [1022, 81], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "M : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\n\u22a2 MonoidHom.comp (lift f hg) (toMap f) = g", "state_after": "case h\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nx\u271d : M\n\u22a2 \u2191(MonoidHom.comp (lift f hg) (toMap f)) x\u271d = \u2191g x\u271d"}, {"tactic": "exact f.lift_eq hg _", "annotated_tactic": ["exact f.lift_eq hg _", []], "state_before": "case h\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nx\u271d : M\n\u22a2 \u2191(MonoidHom.comp (lift f hg) (toMap f)) x\u271d = \u2191g x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/ULift.lean", "full_name": "PLift.up_bijective", "start": [49, 1], "end": [50, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.derivative_mul", "start": [295, 1], "end": [328, 27], "traced_tactics": [{"tactic": "rw [mul_eq_sum_sum, derivative_sum]", "annotated_tactic": ["rw [<a>mul_eq_sum_sum</a>, <a>derivative_sum</a>]", [{"full_name": "Polynomial.mul_eq_sum_sum", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [989, 9], "def_end_pos": [989, 23]}, {"full_name": "Polynomial.derivative_sum", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [164, 9], "def_end_pos": [164, 23]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2191derivative (f * g) = sum f fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 b in support f, \u2191derivative (sum g fun j a => \u2191(monomial (b + j)) (coeff f b * a)) =\n    sum f fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))"}, {"tactic": "trans", "annotated_tactic": ["trans", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 b in support f, \u2191derivative (sum g fun j a => \u2191(monomial (b + j)) (coeff f b * a)) =\n    sum f fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 b in support f, \u2191derivative (sum g fun j a => \u2191(monomial (b + j)) (coeff f b * a)) = ?m.404442\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 ?m.404442 = sum f fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 R[X]"}, {"tactic": "apply Finset.sum_congr rfl", "annotated_tactic": ["apply <a>Finset.sum_congr</a> <a>rfl</a>", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 x in support f, \u2211 b in support g, \u2191derivative ((fun j a => \u2191(monomial (x + j)) (coeff f x * a)) b (coeff g b)) =\n    sum f fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2200 x \u2208 support f,\n    \u2211 b in support g, \u2191derivative ((fun j a => \u2191(monomial (x + j)) (coeff f x * a)) b (coeff g b)) =\n      (fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))) x (coeff f x)"}, {"tactic": "intro n _", "annotated_tactic": ["intro n _", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2200 x \u2208 support f,\n    \u2211 b in support g, \u2191derivative ((fun j a => \u2191(monomial (x + j)) (coeff f x * a)) b (coeff g b)) =\n      (fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))) x (coeff f x)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d : n \u2208 support f\n\u22a2 \u2211 b in support g, \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) b (coeff g b)) =\n    (fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))) n (coeff f n)"}, {"tactic": "apply Finset.sum_congr rfl", "annotated_tactic": ["apply <a>Finset.sum_congr</a> <a>rfl</a>", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d : n \u2208 support f\n\u22a2 \u2211 b in support g, \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) b (coeff g b)) =\n    (fun n a => sum g fun m b => (n + m) \u2022 (\u2191C (a * b) * X ^ (n + m - 1))) n (coeff f n)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d : n \u2208 support f\n\u22a2 \u2200 x \u2208 support g,\n    \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) x (coeff g x)) =\n      (fun m b => (n + m) \u2022 (\u2191C (coeff f n * b) * X ^ (n + m - 1))) x (coeff g x)"}, {"tactic": "intro m _", "annotated_tactic": ["intro m _", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d : n \u2208 support f\n\u22a2 \u2200 x \u2208 support g,\n    \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) x (coeff g x)) =\n      (fun m b => (n + m) \u2022 (\u2191C (coeff f n * b) * X ^ (n + m - 1))) x (coeff g x)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) m (coeff g m)) =\n    (fun m b => (n + m) \u2022 (\u2191C (coeff f n * b) * X ^ (n + m - 1))) m (coeff g m)"}, {"tactic": "trans", "annotated_tactic": ["trans", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) m (coeff g m)) =\n    (fun m b => (n + m) \u2022 (\u2191C (coeff f n * b) * X ^ (n + m - 1))) m (coeff g m)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) m (coeff g m)) = ?m.404942\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 ?m.404942 = (fun m b => (n + m) \u2022 (\u2191C (coeff f n * b) * X ^ (n + m - 1))) m (coeff g m)\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 (fun x => R[X]) ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) m (coeff g m))"}, {"tactic": "dsimp", "annotated_tactic": ["dsimp", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative (\u2191C (coeff f n * coeff g m) * X ^ (n + m)) =\n    (fun m b => (n + m) \u2022 (\u2191C (coeff f n * b) * X ^ (n + m - 1))) m (coeff g m)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative (\u2191C (coeff f n * coeff g m) * X ^ (n + m)) = (n + m) \u2022 (\u2191C (coeff f n * coeff g m) * X ^ (n + m - 1))"}, {"tactic": "rw [\u2190 smul_mul_assoc, smul_C, nsmul_eq_mul']", "annotated_tactic": ["rw [\u2190 <a>smul_mul_assoc</a>, <a>smul_C</a>, <a>nsmul_eq_mul'</a>]", [{"full_name": "smul_mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [429, 9], "def_end_pos": [429, 23]}, {"full_name": "Polynomial.smul_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 15]}, {"full_name": "nsmul_eq_mul'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [502, 9], "def_end_pos": [502, 22]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative (\u2191C (coeff f n * coeff g m) * X ^ (n + m)) = (n + m) \u2022 (\u2191C (coeff f n * coeff g m) * X ^ (n + m - 1))", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative (\u2191C (coeff f n * coeff g m) * X ^ (n + m)) = \u2191C (coeff f n * coeff g m * \u2191(n + m)) * X ^ (n + m - 1)"}, {"tactic": "exact derivative_C_mul_X_pow _ _", "annotated_tactic": ["exact <a>derivative_C_mul_X_pow</a> _ _", [{"full_name": "Polynomial.derivative_C_mul_X_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [99, 9], "def_end_pos": [99, 31]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative (\u2191C (coeff f n * coeff g m) * X ^ (n + m)) = \u2191C (coeff f n * coeff g m * \u2191(n + m)) * X ^ (n + m - 1)", "state_after": "no goals"}, {"tactic": "apply Finset.sum_congr rfl", "annotated_tactic": ["apply <a>Finset.sum_congr</a> <a>rfl</a>", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 b in support f, \u2191derivative (sum g fun j a => \u2191(monomial (b + j)) (coeff f b * a)) = ?m.404442", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2200 x \u2208 support f, \u2191derivative (sum g fun j a => \u2191(monomial (x + j)) (coeff f x * a)) = ?m.404492 x\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2115 \u2192 R[X]"}, {"tactic": "intro x _", "annotated_tactic": ["intro x _", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2200 x \u2208 support f, \u2191derivative (sum g fun j a => \u2191(monomial (x + j)) (coeff f x * a)) = ?m.404492 x\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2115 \u2192 R[X]", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nx : \u2115\na\u271d : x \u2208 support f\n\u22a2 \u2191derivative (sum g fun j a => \u2191(monomial (x + j)) (coeff f x * a)) = ?m.404492 x\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2115 \u2192 R[X]"}, {"tactic": "exact derivative_sum", "annotated_tactic": ["exact <a>derivative_sum</a>", [{"full_name": "Polynomial.derivative_sum", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [164, 9], "def_end_pos": [164, 23]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nx : \u2115\na\u271d : x \u2208 support f\n\u22a2 \u2191derivative (sum g fun j a => \u2191(monomial (x + j)) (coeff f x * a)) = ?m.404492 x\n\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2115 \u2192 R[X]", "state_after": "no goals"}, {"tactic": "exact congr_arg _ C_mul_X_pow_eq_monomial.symm", "annotated_tactic": ["exact <a>congr_arg</a> _ C_mul_X_pow_eq_monomial.symm", [{"full_name": "congr_arg", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [43, 7], "def_end_pos": [43, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\na\u271d\u00b9 : n \u2208 support f\nm : \u2115\na\u271d : m \u2208 support g\n\u22a2 \u2191derivative ((fun j a => \u2191(monomial (n + j)) (coeff f n * a)) m (coeff g m)) = ?m.404942", "state_after": "no goals"}, {"tactic": "cases n <;> cases m <;>\n  simp_rw [add_smul, mul_smul_comm, smul_mul_assoc, X_pow_mul_assoc, \u2190 mul_assoc, \u2190\n    C_mul, mul_assoc, \u2190 pow_add] <;>\n  simp [Nat.add_succ, Nat.succ_add, Nat.succ_sub_one, zero_smul, add_comm]", "annotated_tactic": ["cases n <;> cases m <;>\n            simp_rw [<a>add_smul</a>, <a>mul_smul_comm</a>, <a>smul_mul_assoc</a>, <a>X_pow_mul_assoc</a>, \u2190 <a>mul_assoc</a>, \u2190\n              <a>C_mul</a>, <a>mul_assoc</a>, \u2190 <a>pow_add</a>] <;>\n            simp [<a>Nat.add_succ</a>, <a>Nat.succ_add</a>, <a>Nat.succ_sub_one</a>, <a>zero_smul</a>, <a>add_comm</a>]", [{"full_name": "add_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [91, 9], "def_end_pos": [91, 17]}, {"full_name": "mul_smul_comm", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [420, 9], "def_end_pos": [420, 22]}, {"full_name": "smul_mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [429, 9], "def_end_pos": [429, 23]}, {"full_name": "Polynomial.X_pow_mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [618, 9], "def_end_pos": [618, 24]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "Polynomial.C_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [522, 9], "def_end_pos": [522, 14]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "pow_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 16]}, {"full_name": "Nat.add_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}, {"full_name": "Nat.succ_add", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 17]}, {"full_name": "Nat.succ_sub_one", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [443, 9], "def_end_pos": [443, 21]}, {"full_name": "zero_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}, {"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d : Semiring R\nf g : R[X]\nn : \u2115\nhn : n \u2208 support f\nm : \u2115\nhm : m \u2208 support g\n\u22a2 (fun m b => (n + m) \u2022 (\u2191C (coeff f n * b) * X ^ (n + m - 1))) m (coeff g m) =\n    (fun m b => n \u2022 (\u2191C (coeff f n) * X ^ (n - 1)) * (\u2191C b * X ^ m) + \u2191C (coeff f n) * X ^ n * m \u2022 (\u2191C b * X ^ (m - 1)))\n      m (coeff g m)", "state_after": "no goals"}, {"tactic": "simp only [sum, sum_add_distrib, Finset.mul_sum, Finset.sum_mul, derivative_apply]", "annotated_tactic": ["simp only [<a>sum</a>, <a>sum_add_distrib</a>, <a>Finset.mul_sum</a>, <a>Finset.sum_mul</a>, <a>derivative_apply</a>]", [{"full_name": "Polynomial.sum", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [973, 5], "def_end_pos": [973, 8]}, {"full_name": "Finset.sum_add_distrib", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [663, 3], "def_end_pos": [663, 14]}, {"full_name": "Finset.mul_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [55, 9], "def_end_pos": [55, 16]}, {"full_name": "Finset.sum_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [51, 9], "def_end_pos": [51, 16]}, {"full_name": "Polynomial.derivative_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [52, 9], "def_end_pos": [52, 25]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 (sum f fun n a =>\n      sum g fun m b => n \u2022 (\u2191C a * X ^ (n - 1)) * (\u2191C b * X ^ m) + \u2191C a * X ^ n * m \u2022 (\u2191C b * X ^ (m - 1))) =\n    (\u2191derivative f * sum g fun n a => \u2191C a * X ^ n) + (sum f fun n a => \u2191C a * X ^ n) * \u2191derivative g", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 x in support f, \u2211 x_1 in support g, x \u2022 (\u2191C (coeff f x) * X ^ (x - 1)) * (\u2191C (coeff g x_1) * X ^ x_1) +\n      \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * x_1 \u2022 (\u2191C (coeff g x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1 * \u2191x_1) * X ^ (x_1 - 1) * (\u2191C (coeff g x) * X ^ x) +\n      \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))"}, {"tactic": "simp_rw [\u2190 smul_mul_assoc, smul_C, nsmul_eq_mul']", "annotated_tactic": ["simp_rw [\u2190 <a>smul_mul_assoc</a>, <a>smul_C</a>, <a>nsmul_eq_mul'</a>]", [{"full_name": "smul_mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [429, 9], "def_end_pos": [429, 23]}, {"full_name": "Polynomial.smul_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 15]}, {"full_name": "nsmul_eq_mul'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [502, 9], "def_end_pos": [502, 22]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 x in support f, \u2211 x_1 in support g, x \u2022 (\u2191C (coeff f x) * X ^ (x - 1)) * (\u2191C (coeff g x_1) * X ^ x_1) +\n      \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * x_1 \u2022 (\u2191C (coeff g x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1 * \u2191x_1) * X ^ (x_1 - 1) * (\u2191C (coeff g x) * X ^ x) +\n      \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x * \u2191x) * X ^ (x - 1) * (\u2191C (coeff g x_1) * X ^ x_1) +\n      \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * (\u2191C (coeff g x_1 * \u2191x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1 * \u2191x_1) * X ^ (x_1 - 1) * (\u2191C (coeff g x) * X ^ x) +\n      \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))"}, {"tactic": "rw [Finset.sum_comm]", "annotated_tactic": ["rw [<a>Finset.sum_comm</a>]", [{"full_name": "Finset.sum_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [718, 3], "def_end_pos": [718, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x * \u2191x) * X ^ (x - 1) * (\u2191C (coeff g x_1) * X ^ x_1) +\n      \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * (\u2191C (coeff g x_1 * \u2191x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1 * \u2191x_1) * X ^ (x_1 - 1) * (\u2191C (coeff g x) * X ^ x) +\n      \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 y in support g, \u2211 x in support f, \u2191C (coeff f x * \u2191x) * X ^ (x - 1) * (\u2191C (coeff g y) * X ^ y) +\n      \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * (\u2191C (coeff g x_1 * \u2191x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1 * \u2191x_1) * X ^ (x_1 - 1) * (\u2191C (coeff g x) * X ^ x) +\n      \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 y in support g, \u2211 x in support f, \u2191C (coeff f x * \u2191x) * X ^ (x - 1) * (\u2191C (coeff g y) * X ^ y) +\n      \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * (\u2191C (coeff g x_1 * \u2191x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1 * \u2191x_1) * X ^ (x_1 - 1) * (\u2191C (coeff g x) * X ^ x) +\n      \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))", "state_after": "case e_a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * (\u2191C (coeff g x_1 * \u2191x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))"}, {"tactic": "rw [Finset.sum_comm]", "annotated_tactic": ["rw [<a>Finset.sum_comm</a>]", [{"full_name": "Finset.sum_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [718, 3], "def_end_pos": [718, 14]}]], "state_before": "case e_a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\nf g : R[X]\n\u22a2 \u2211 x in support f, \u2211 x_1 in support g, \u2191C (coeff f x) * X ^ x * (\u2191C (coeff g x_1 * \u2191x_1) * X ^ (x_1 - 1)) =\n    \u2211 x in support g, \u2211 x_1 in support f, \u2191C (coeff f x_1) * X ^ x_1 * (\u2191C (coeff g x * \u2191x) * X ^ (x - 1))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Congruence.lean", "full_name": "RingCon.rel_mk", "start": [121, 1], "end": [122, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Submonoid.LocalizationMap.mk'_eq_iff_mk'_eq", "start": [804, 1], "end": [806, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.zipWithAll_cons_cons", "start": [1490, 9], "end": [1491, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "irreducible_mul_isUnit", "start": [281, 1], "end": [283, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "himp_top", "start": [369, 1], "end": [370, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "mul_le_iff_le_one_right'", "start": [474, 1], "end": [477, 54], "traced_tactics": [{"tactic": "rw [mul_one]", "annotated_tactic": ["rw [<a>mul_one</a>]", [{"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\ninst\u271d : ContravariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na b : \u03b1\n\u22a2 a * b \u2264 a \u2194 a * b \u2264 a * 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "RingHom.ext", "start": [531, 1], "end": [532, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.length_dropLast", "start": [646, 1], "end": [651, 9], "traced_tactics": [{"tactic": "rw [dropLast, length_cons, length_cons, length_dropLast (b::l), succ_sub_one, length_cons,\n  succ_sub_one]", "annotated_tactic": ["rw [<a>dropLast</a>, <a>length_cons</a>, <a>length_cons</a>, length_dropLast (b::l), <a>succ_sub_one</a>, <a>length_cons</a>,\n      <a>succ_sub_one</a>]", [{"full_name": "List.dropLast", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [762, 5], "def_end_pos": [762, 13]}, {"full_name": "List.length_cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2263, 17], "def_end_pos": [2263, 33]}, {"full_name": "List.length_cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2263, 17], "def_end_pos": [2263, 33]}, {"full_name": "Nat.succ_sub_one", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [443, 9], "def_end_pos": [443, 21]}, {"full_name": "List.length_cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2263, 17], "def_end_pos": [2263, 33]}, {"full_name": "Nat.succ_sub_one", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [443, 9], "def_end_pos": [443, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\n\u22a2 length (dropLast (a :: b :: l)) = length (a :: b :: l) - 1", "state_after": "case x_2\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\n\u22a2 b :: l = [] \u2192 False"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case x_2\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\n\u22a2 b :: l = [] \u2192 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.subsingleton_of_image", "start": [1242, 1], "end": [1244, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Nodup.lean", "full_name": "List.nthLe_index_of", "start": [173, 1], "end": [175, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.succ_le_succ_iff", "start": [296, 1], "end": [296, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "RingHom.mapMatrix_id", "start": [1553, 1], "end": [1554, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.castLE_of_eq", "start": [307, 1], "end": [307, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Option/Basic.lean", "full_name": "Option.none_bind'", "start": [92, 1], "end": [93, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.rootMultiplicity_pos", "start": [621, 1], "end": [623, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "inv_ne_one", "start": [435, 1], "end": [436, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.splitOnP_spec", "start": [2858, 1], "end": [2875, 57], "traced_tactics": [{"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\n\u22a2 join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p []) (map (fun x => [x]) (filter p []) ++ [[]])) = []", "state_after": "no goals"}, {"tactic": "rw [splitOnP_cons, filter]", "annotated_tactic": ["rw [<a>splitOnP_cons</a>, <a>filter</a>]", [{"full_name": "List.splitOnP_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [2850, 9], "def_end_pos": [2850, 22]}, {"full_name": "List.filter", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [227, 5], "def_end_pos": [227, 11]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\n\u22a2 join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p (a :: as')) (map (fun x => [x]) (filter p (a :: as')) ++ [[]])) =\n    a :: as'", "state_after": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1)\n        (if p a = true then [] :: splitOnP p as' else modifyHead (cons a) (splitOnP p as'))\n        (map (fun x => [x])\n            (match p a with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    a :: as'"}, {"tactic": "by_cases h : p a", "annotated_tactic": ["by_cases h : p a", []], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1)\n        (if p a = true then [] :: splitOnP p as' else modifyHead (cons a) (splitOnP p as'))\n        (map (fun x => [x])\n            (match p a with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    a :: as'", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : p a = true\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1)\n        (if p a = true then [] :: splitOnP p as' else modifyHead (cons a) (splitOnP p as'))\n        (map (fun x => [x])\n            (match p a with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    a :: as'\n\ncase neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : \u00acp a = true\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1)\n        (if p a = true then [] :: splitOnP p as' else modifyHead (cons a) (splitOnP p as'))\n        (map (fun x => [x])\n            (match p a with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    a :: as'"}, {"tactic": "rw [if_pos h, h, map, cons_append, zipWith, nil_append, join, cons_append, cons_inj]", "annotated_tactic": ["rw [<a>if_pos</a> h, h, <a>map</a>, <a>cons_append</a>, <a>zipWith</a>, <a>nil_append</a>, <a>join</a>, <a>cons_append</a>, <a>cons_inj</a>]", [{"full_name": "if_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [790, 9], "def_end_pos": [790, 15]}, {"full_name": "List.map", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [151, 19], "def_end_pos": [151, 22]}, {"full_name": "List.cons_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [99, 17], "def_end_pos": [99, 28]}, {"full_name": "List.zipWith", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [548, 19], "def_end_pos": [548, 26]}, {"full_name": "List.nil_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [92, 17], "def_end_pos": [92, 27]}, {"full_name": "List.join", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [200, 5], "def_end_pos": [200, 9]}, {"full_name": "List.cons_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [99, 17], "def_end_pos": [99, 28]}, {"full_name": "List.cons_inj", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [29, 9], "def_end_pos": [29, 17]}]], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : p a = true\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1)\n        (if p a = true then [] :: splitOnP p as' else modifyHead (cons a) (splitOnP p as'))\n        (map (fun x => [x])\n            (match p a with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    a :: as'", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : p a = true\n\u22a2 [] ++ join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'"}, {"tactic": "exact ih", "annotated_tactic": ["exact ih", []], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : p a = true\n\u22a2 [] ++ join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'", "state_after": "no goals"}, {"tactic": "rw [if_neg h, eq_false_of_ne_true h, join_zipWith (splitOnP_ne_nil _ _)\n  (append_ne_nil_of_ne_nil_right _ [[]] (cons_ne_nil [] [])), cons_inj]", "annotated_tactic": ["rw [<a>if_neg</a> h, <a>eq_false_of_ne_true</a> h, join_zipWith (<a>splitOnP_ne_nil</a> _ _)\n        (<a>append_ne_nil_of_ne_nil_right</a> _ [[]] (<a>cons_ne_nil</a> [] [])), <a>cons_inj</a>]", [{"full_name": "if_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [795, 9], "def_end_pos": [795, 15]}, {"full_name": "eq_false_of_ne_true", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [643, 9], "def_end_pos": [643, 28]}, {"full_name": "List.splitOnP_ne_nil", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [2846, 9], "def_end_pos": [2846, 24]}, {"full_name": "List.append_ne_nil_of_ne_nil_right", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [110, 9], "def_end_pos": [110, 38]}, {"full_name": "List.cons_ne_nil", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [21, 9], "def_end_pos": [21, 20]}, {"full_name": "List.cons_inj", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [29, 9], "def_end_pos": [29, 17]}]], "state_before": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : \u00acp a = true\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1)\n        (if p a = true then [] :: splitOnP p as' else modifyHead (cons a) (splitOnP p as'))\n        (map (fun x => [x])\n            (match p a with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    a :: as'", "state_after": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : \u00acp a = true\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as')\n        (map (fun x => [x])\n            (match false with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    as'"}, {"tactic": "exact ih", "annotated_tactic": ["exact ih", []], "state_before": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\na : \u03b1\nas' : List \u03b1\nih : join (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as') (map (fun x => [x]) (filter p as') ++ [[]])) = as'\nh : \u00acp a = true\n\u22a2 join\n      (zipWith (fun x x_1 => x ++ x_1) (splitOnP p as')\n        (map (fun x => [x])\n            (match false with\n            | true => a :: filter p as'\n            | false => filter p as') ++\n          [[]])) =\n    as'", "state_after": "no goals"}, {"tactic": "cases xs with | nil => contradiction | cons =>\n  cases ys with | nil => contradiction | cons => rfl", "annotated_tactic": ["cases xs with | <a>nil</a> => contradiction | <a>cons</a> =>\n      cases ys with | <a>nil</a> => contradiction | <a>cons</a> => rfl", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs\u271d ys\u271d : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\nas : List \u03b1\nxs ys : List (List \u03b1)\na : \u03b1\nhxs : xs \u2260 []\nhys : ys \u2260 []\n\u22a2 join (zipWith (fun x x_1 => x ++ x_1) (modifyHead (cons a) xs) ys) = a :: join (zipWith (fun x x_1 => x ++ x_1) xs ys)", "state_after": "no goals"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys\u271d : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\nas : List \u03b1\nys : List (List \u03b1)\na : \u03b1\nhys : ys \u2260 []\nhxs : [] \u2260 []\n\u22a2 join (zipWith (fun x x_1 => x ++ x_1) (modifyHead (cons a) []) ys) = a :: join (zipWith (fun x x_1 => x ++ x_1) [] ys)", "state_after": "no goals"}, {"tactic": "cases ys with | nil => contradiction | cons => rfl", "annotated_tactic": ["cases ys with | <a>nil</a> => contradiction | <a>cons</a> => rfl", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys\u271d : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\nas : List \u03b1\nys : List (List \u03b1)\na : \u03b1\nhys : ys \u2260 []\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\nhxs : head\u271d :: tail\u271d \u2260 []\n\u22a2 join (zipWith (fun x x_1 => x ++ x_1) (modifyHead (cons a) (head\u271d :: tail\u271d)) ys) =\n    a :: join (zipWith (fun x x_1 => x ++ x_1) (head\u271d :: tail\u271d) ys)", "state_after": "no goals"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "case cons.nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\nas : List \u03b1\na : \u03b1\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\nhxs : head\u271d :: tail\u271d \u2260 []\nhys : [] \u2260 []\n\u22a2 join (zipWith (fun x x_1 => x ++ x_1) (modifyHead (cons a) (head\u271d :: tail\u271d)) []) =\n    a :: join (zipWith (fun x x_1 => x ++ x_1) (head\u271d :: tail\u271d) [])", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case cons.cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nxs ys : List \u03b1\nls : List (List \u03b1)\nf : List \u03b1 \u2192 List \u03b1\nas : List \u03b1\na : \u03b1\nhead\u271d\u00b9 : List \u03b1\ntail\u271d\u00b9 : List (List \u03b1)\nhxs : head\u271d\u00b9 :: tail\u271d\u00b9 \u2260 []\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\nhys : head\u271d :: tail\u271d \u2260 []\n\u22a2 join (zipWith (fun x x_1 => x ++ x_1) (modifyHead (cons a) (head\u271d\u00b9 :: tail\u271d\u00b9)) (head\u271d :: tail\u271d)) =\n    a :: join (zipWith (fun x x_1 => x ++ x_1) (head\u271d\u00b9 :: tail\u271d\u00b9) (head\u271d :: tail\u271d))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.dropSlice_eq_dropSliceTR", "start": [1322, 10], "end": [1331, 30], "traced_tactics": [{"tactic": "funext \u03b1 n m l", "annotated_tactic": ["funext \u03b1 n m l", []], "state_before": "\u22a2 @dropSlice = @dropSliceTR", "state_after": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l = dropSliceTR n m l"}, {"tactic": "simp [dropSliceTR]", "annotated_tactic": ["simp [<a>dropSliceTR</a>]", [{"full_name": "List.dropSliceTR", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1306, 15], "def_end_pos": [1306, 26]}]], "state_before": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l = dropSliceTR n m l", "state_after": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l =\n    match m with\n    | 0 => l\n    | succ m => dropSliceTR.go l m l n #[]"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "case h.h.h.h\n\u03b1 : Type u_1\nn m : Nat\nl : List \u03b1\n\u22a2 dropSlice n m l =\n    match m with\n    | 0 => l\n    | succ m => dropSliceTR.go l m l n #[]", "state_after": "case h.h.h.h.h_1\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d : Nat\n\u22a2 dropSlice n 0 l = l\n\ncase h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]"}, {"tactic": "{ rw [dropSlice_zero\u2082] }", "annotated_tactic": ["{ rw [<a>dropSlice_zero\u2082</a>] }", [{"full_name": "List.dropSlice_zero\u2082", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1318, 9], "def_end_pos": [1318, 24]}]], "state_before": "case h.h.h.h.h_1\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d : Nat\n\u22a2 dropSlice n 0 l = l\n\ncase h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]", "state_after": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]"}, {"tactic": "rename_i m", "annotated_tactic": ["rename_i m", []], "state_before": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d\u00b9 m\u271d : Nat\n\u22a2 dropSlice n (succ m\u271d) l = dropSliceTR.go l m\u271d l n #[]", "state_after": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d m : Nat\n\u22a2 dropSlice n (succ m) l = dropSliceTR.go l m l n #[]"}, {"tactic": "exact (go #[] _ _ rfl).symm", "annotated_tactic": ["exact (go #[] _ _ <a>rfl</a>).<a>symm</a>", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case h.h.h.h.h_2\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d m : Nat\n\u22a2 dropSlice n (succ m) l = dropSliceTR.go l m l n #[]", "state_after": "no goals"}, {"tactic": "rw [dropSlice_zero\u2082]", "annotated_tactic": ["rw [<a>dropSlice_zero\u2082</a>]", [{"full_name": "List.dropSlice_zero\u2082", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1318, 9], "def_end_pos": [1318, 24]}]], "state_before": "case h.h.h.h.h_1\n\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d : Nat\n\u22a2 dropSlice n 0 l = l", "state_after": "no goals"}, {"tactic": "simp [dropSliceTR.go, dropSlice, h]", "annotated_tactic": ["simp [<a>dropSliceTR.go</a>, <a>dropSlice</a>, h]", [{"full_name": "List.dropSliceTR.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1313, 3], "def_end_pos": [1313, 5]}, {"full_name": "List.dropSlice", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1300, 13], "def_end_pos": [1300, 22]}]], "state_before": "\u03b1 : Type u_1\nn : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nhead\u271d : \u03b1\nxs : List \u03b1\nh : l = acc.data ++ head\u271d :: xs\n\u22a2 dropSliceTR.go l m (head\u271d :: xs) 0 acc = acc.data ++ dropSlice 0 (m + 1) (head\u271d :: xs)", "state_after": "no goals"}, {"tactic": "simp [dropSliceTR.go, dropSlice]", "annotated_tactic": ["simp [<a>dropSliceTR.go</a>, <a>dropSlice</a>]", [{"full_name": "List.dropSliceTR.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1313, 3], "def_end_pos": [1313, 5]}, {"full_name": "List.dropSlice", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1300, 13], "def_end_pos": [1300, 22]}]], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\n\u22a2 l = acc.data ++ x :: xs \u2192 dropSliceTR.go l m (x :: xs) (n + 1) acc = acc.data ++ dropSlice (n + 1) (m + 1) (x :: xs)", "state_after": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\n\u22a2 l = acc.data ++ x :: xs \u2192 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\n\u22a2 l = acc.data ++ x :: xs \u2192 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs", "state_after": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs"}, {"tactic": "rw [go _ xs]", "annotated_tactic": ["rw [go _ xs]", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 dropSliceTR.go l m xs n (Array.push acc x) = acc.data ++ x :: dropSlice n (m + 1) xs", "state_after": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 (Array.push acc x).data ++ dropSlice n (m + 1) xs = acc.data ++ x :: dropSlice n (m + 1) xs\n\ncase a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs"}, {"tactic": "{simp}", "annotated_tactic": ["{simp}", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 (Array.push acc x).data ++ dropSlice n (m + 1) xs = acc.data ++ x :: dropSlice n (m + 1) xs\n\ncase a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs", "state_after": "case a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case a\n\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 l = (Array.push acc x).data ++ xs", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nn\u271d : Nat\nl : List \u03b1\nm\u271d m : Nat\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\nn : Nat\nh : l = acc.data ++ x :: xs\n\u22a2 (Array.push acc x).data ++ dropSlice n (m + 1) xs = acc.data ++ x :: dropSlice n (m + 1) xs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Lemmas.lean", "full_name": "pow_bit1_neg_iff", "start": [714, 1], "end": [715, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean", "full_name": "Nat.pow_sub_le_descFactorial", "start": [438, 1], "end": [444, 42], "traced_tactics": [{"tactic": "rw [descFactorial_zero, pow_zero]", "annotated_tactic": ["rw [<a>descFactorial_zero</a>, <a>pow_zero</a>]", [{"full_name": "Nat.descFactorial_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [348, 9], "def_end_pos": [348, 27]}, {"full_name": "Nat.pow_zero", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [476, 9], "def_end_pos": [476, 17]}]], "state_before": "n : \u2115\n\u22a2 (n + 1 - 0) ^ 0 \u2264 descFactorial n 0", "state_after": "no goals"}, {"tactic": "rw [descFactorial_succ, pow_succ, succ_sub_succ, mul_comm]", "annotated_tactic": ["rw [<a>descFactorial_succ</a>, <a>pow_succ</a>, <a>succ_sub_succ</a>, <a>mul_comm</a>]", [{"full_name": "Nat.descFactorial_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [353, 9], "def_end_pos": [353, 27]}, {"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}, {"full_name": "Nat.succ_sub_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [247, 9], "def_end_pos": [247, 22]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "n k : \u2115\n\u22a2 (n + 1 - (k + 1)) ^ (k + 1) \u2264 descFactorial n (k + 1)", "state_after": "n k : \u2115\n\u22a2 (n - k) * (n - k) ^ k \u2264 (n - k) * descFactorial n k"}, {"tactic": "apply Nat.mul_le_mul_of_nonneg_left", "annotated_tactic": ["apply <a>Nat.mul_le_mul_of_nonneg_left</a>", [{"full_name": "Nat.mul_le_mul_of_nonneg_left", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [720, 19], "def_end_pos": [720, 44]}]], "state_before": "n k : \u2115\n\u22a2 (n - k) * (n - k) ^ k \u2264 (n - k) * descFactorial n k", "state_after": "case h\u2081\nn k : \u2115\n\u22a2 (n - k) ^ k \u2264 descFactorial n k"}, {"tactic": "exact   (le_trans (Nat.pow_le_pow_of_le_left (tsub_le_tsub_right (le_succ _) _) k)\n      (pow_sub_le_descFactorial n k))", "annotated_tactic": ["exact   (<a>le_trans</a> (<a>Nat.pow_le_pow_of_le_left</a> (<a>tsub_le_tsub_right</a> (<a>le_succ</a> _) _) k)\n          (pow_sub_le_descFactorial n k))", [{"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}, {"full_name": "Nat.pow_le_pow_of_le_left", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [478, 9], "def_end_pos": [478, 30]}, {"full_name": "tsub_le_tsub_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [106, 19], "def_end_pos": [106, 37]}, {"full_name": "Nat.le_succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1599, 9], "def_end_pos": [1599, 20]}]], "state_before": "case h\u2081\nn k : \u2115\n\u22a2 (n - k) ^ k \u2264 descFactorial n k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.nonempty", "start": [234, 11], "end": [234, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/TFAE.lean", "full_name": "List.tfae_cons_self", "start": [54, 1], "end": [55, 24], "traced_tactics": [{"tactic": "simp [tfae_cons_cons]", "annotated_tactic": ["simp [<a>tfae_cons_cons</a>]", [{"full_name": "List.tfae_cons_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/TFAE.lean", "def_pos": [49, 9], "def_end_pos": [49, 23]}]], "state_before": "a : Prop\nl : List Prop\n\u22a2 TFAE (a :: a :: l) \u2194 TFAE (a :: l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.get_reverse", "start": [1398, 9], "end": [1400, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.mul_le_mul_right", "start": [240, 1], "end": [241, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Invertible.lean", "full_name": "invOf_nonpos", "start": [27, 1], "end": [27, 92], "traced_tactics": [{"tactic": "simp only [\u2190 not_lt, invOf_pos]", "annotated_tactic": ["simp only [\u2190 <a>not_lt</a>, <a>invOf_pos</a>]", [{"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}, {"full_name": "invOf_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Invertible.lean", "def_pos": [21, 9], "def_end_pos": [21, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\na : \u03b1\ninst\u271d : Invertible a\n\u22a2 \u215fa \u2264 0 \u2194 a \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "isAntichain_and_greatest_iff", "start": [227, 1], "end": [230, 61], "traced_tactics": [{"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns t : Set \u03b1\na b : \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 s = {a} \u2192 IsAntichain (fun x x_1 => x \u2264 x_1) s \u2227 IsGreatest s a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : Set \u03b1\na b : \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 IsAntichain (fun x x_1 => x \u2264 x_1) {a} \u2227 IsGreatest {a} a"}, {"tactic": "exact \u27e8isAntichain_singleton _ _, isGreatest_singleton\u27e9", "annotated_tactic": ["exact \u27e8<a>isAntichain_singleton</a> _ _, <a>isGreatest_singleton</a>\u27e9", [{"full_name": "isAntichain_singleton", "def_path": "lake-packages/mathlib/Mathlib/Order/Antichain.lean", "def_pos": [205, 9], "def_end_pos": [205, 30]}, {"full_name": "isGreatest_singleton", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [616, 9], "def_end_pos": [616, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\nt : Set \u03b1\na b : \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 IsAntichain (fun x x_1 => x \u2264 x_1) {a} \u2227 IsGreatest {a} a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Submodule.IsPrincipal.span_singleton_generator", "start": [102, 1], "end": [103, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "IsSquare_sq", "start": [156, 1], "end": [157, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/NonZeroDivisors.lean", "full_name": "mul_cancel_left_coe_nonZeroDivisors", "start": [79, 1], "end": [80, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.SameCycle.symm", "start": [90, 1], "end": [91, 47], "traced_tactics": [{"tactic": "rw [zpow_neg, \u2190 hi, inv_apply_self]", "annotated_tactic": ["rw [<a>zpow_neg</a>, \u2190 hi, <a>inv_apply_self</a>]", [{"full_name": "zpow_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [332, 9], "def_end_pos": [332, 17]}, {"full_name": "Equiv.Perm.inv_apply_self", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\np : \u03b1 \u2192 Prop\nx y z : \u03b1\nx\u271d : SameCycle f x y\ni : \u2124\nhi : \u2191(f ^ i) x = y\n\u22a2 \u2191(f ^ (-i)) y = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "Composition.one_le_blocksFun", "start": [184, 1], "end": [185, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Pairing.lean", "full_name": "Nat.pair_eq_pair", "start": [90, 1], "end": [91, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "Subsemigroup.comap_inf_map_of_injective", "start": [405, 1], "end": [406, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Rename.lean", "full_name": "MvPolynomial.rename_C", "start": [61, 1], "end": [62, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Control/Functor.lean", "full_name": "Functor.Comp.id_map", "start": [205, 11], "end": [206, 57], "traced_tactics": [{"tactic": "simp [Comp.map, Functor.map_id]", "annotated_tactic": ["simp [<a>Comp.map</a>, <a>Functor.map_id</a>]", [{"full_name": "Functor.Comp.map", "def_path": "lake-packages/mathlib/Mathlib/Control/Functor.lean", "def_pos": [184, 15], "def_end_pos": [184, 18]}, {"full_name": "Functor.map_id", "def_path": "lake-packages/mathlib/Mathlib/Control/Functor.lean", "def_pos": [41, 9], "def_end_pos": [41, 23]}]], "state_before": "F : Type u \u2192 Type w\nG : Type v \u2192 Type u\ninst\u271d\u00b3 : Functor F\ninst\u271d\u00b2 : Functor G\ninst\u271d\u00b9 : LawfulFunctor F\ninst\u271d : LawfulFunctor G\n\u03b1 \u03b2 \u03b3 : Type v\nx : F (G \u03b1)\n\u22a2 Comp.map id (mk x) = mk x", "state_after": "F : Type u \u2192 Type w\nG : Type v \u2192 Type u\ninst\u271d\u00b3 : Functor F\ninst\u271d\u00b2 : Functor G\ninst\u271d\u00b9 : LawfulFunctor F\ninst\u271d : LawfulFunctor G\n\u03b1 \u03b2 \u03b3 : Type v\nx : F (G \u03b1)\n\u22a2 mk (mk x) = mk x"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "F : Type u \u2192 Type w\nG : Type v \u2192 Type u\ninst\u271d\u00b3 : Functor F\ninst\u271d\u00b2 : Functor G\ninst\u271d\u00b9 : LawfulFunctor F\ninst\u271d : LawfulFunctor G\n\u03b1 \u03b2 \u03b3 : Type v\nx : F (G \u03b1)\n\u22a2 mk (mk x) = mk x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Star/Basic.lean", "full_name": "star_neg", "start": [289, 1], "end": [290, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Bool.lean", "full_name": "Bool.and_left_comm", "start": [49, 1], "end": [49, 89], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u2200 (x y z : Bool), (x && (y && z)) = (y && (x && z))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.mem_map_of_injective", "start": [130, 1], "end": [132, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Set.lean", "full_name": "Equiv.range_eq_univ", "start": [36, 1], "end": [37, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GeomSum.lean", "full_name": "Commute.geom_sum\u2082_mul", "start": [168, 11], "end": [172, 30], "traced_tactics": [{"tactic": "have := (h.sub_left (Commute.refl y)).geom_sum\u2082_mul_add n", "annotated_tactic": ["have := (h.sub_left (<a>Commute.refl</a> y)).<a>geom_sum\u2082_mul_add</a> n", [{"full_name": "Commute.refl", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [54, 19], "def_end_pos": [54, 23]}, {"full_name": "Commute.geom_sum\u2082_mul_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GeomSum.lean", "def_pos": [103, 19], "def_end_pos": [103, 44]}]], "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\n\u22a2 (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n", "state_after": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\nthis : (\u2211 i in range n, (x - y + y) ^ i * y ^ (n - 1 - i)) * (x - y) + y ^ n = (x - y + y) ^ n\n\u22a2 (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n"}, {"tactic": "rw [sub_add_cancel] at this", "annotated_tactic": ["rw [<a>sub_add_cancel</a>] at this", [{"full_name": "sub_add_cancel", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [728, 30], "def_end_pos": [728, 44]}]], "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\nthis : (\u2211 i in range n, (x - y + y) ^ i * y ^ (n - 1 - i)) * (x - y) + y ^ n = (x - y + y) ^ n\n\u22a2 (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n", "state_after": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\nthis : (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) + y ^ n = x ^ n\n\u22a2 (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n"}, {"tactic": "rw [\u2190 this, add_sub_cancel]", "annotated_tactic": ["rw [\u2190 this, <a>add_sub_cancel</a>]", [{"full_name": "add_sub_cancel", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [739, 30], "def_end_pos": [739, 44]}]], "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\nthis : (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) + y ^ n = x ^ n\n\u22a2 (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Reverse.lean", "full_name": "Polynomial.eval\u2082_reflect_mul_pow", "start": [222, 1], "end": [233, 22], "traced_tactics": [{"tactic": "refine'\n  induction_with_natDegree_le (fun f => eval\u2082 i (\u215f x) (reflect N f) * x ^ N = eval\u2082 i x f) _ _ _\n    _ f hf", "annotated_tactic": ["refine'\n    <a>induction_with_natDegree_le</a> (fun f => <a>eval\u2082</a> i (\u215f x) (<a>reflect</a> N f) * x ^ N = <a>eval\u2082</a> i x f) _ _ _\n      _ f hf", [{"full_name": "Polynomial.induction_with_natDegree_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/EraseLead.lean", "def_pos": [217, 9], "def_end_pos": [217, 36]}, {"full_name": "Polynomial.eval\u2082", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [45, 17], "def_end_pos": [45, 22]}, {"full_name": "Polynomial.reflect", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [102, 19], "def_end_pos": [102, 26]}, {"full_name": "Polynomial.eval\u2082", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [45, 17], "def_end_pos": [45, 22]}]], "state_before": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\n\u22a2 eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f", "state_after": "case refine'_1\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\n\u22a2 (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) 0\n\ncase refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\n\u22a2 \u2200 (n : \u2115) (r : R), r \u2260 0 \u2192 n \u2264 N \u2192 (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) (\u2191C r * X ^ n)\n\ncase refine'_3\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\n\u22a2 \u2200 (f g : R[X]),\n    natDegree f < natDegree g \u2192\n      natDegree g \u2264 N \u2192\n        (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) f \u2192\n          (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) g \u2192\n            (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) (f + g)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case refine'_1\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\n\u22a2 (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) 0", "state_after": "no goals"}, {"tactic": "intro n r _ hnN", "annotated_tactic": ["intro n r _ hnN", []], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\n\u22a2 \u2200 (n : \u2115) (r : R), r \u2260 0 \u2192 n \u2264 N \u2192 (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) (\u2191C r * X ^ n)", "state_after": "case refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nn : \u2115\nr : R\na\u271d : r \u2260 0\nhnN : n \u2264 N\n\u22a2 eval\u2082 i (\u215fx) (reflect N (\u2191C r * X ^ n)) * x ^ N = eval\u2082 i x (\u2191C r * X ^ n)"}, {"tactic": "simp only [revAt_le hnN, reflect_C_mul_X_pow, eval\u2082_X_pow, eval\u2082_C, eval\u2082_mul]", "annotated_tactic": ["simp only [<a>revAt_le</a> hnN, <a>reflect_C_mul_X_pow</a>, <a>eval\u2082_X_pow</a>, <a>eval\u2082_C</a>, <a>eval\u2082_mul</a>]", [{"full_name": "Polynomial.revAt_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [77, 9], "def_end_pos": [77, 17]}, {"full_name": "Polynomial.reflect_C_mul_X_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [147, 9], "def_end_pos": [147, 28]}, {"full_name": "Polynomial.eval\u2082_X_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [83, 9], "def_end_pos": [83, 20]}, {"full_name": "Polynomial.eval\u2082_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [70, 9], "def_end_pos": [70, 16]}, {"full_name": "Polynomial.eval\u2082_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [262, 9], "def_end_pos": [262, 18]}]], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nn : \u2115\nr : R\na\u271d : r \u2260 0\nhnN : n \u2264 N\n\u22a2 eval\u2082 i (\u215fx) (reflect N (\u2191C r * X ^ n)) * x ^ N = eval\u2082 i x (\u2191C r * X ^ n)", "state_after": "case refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nn : \u2115\nr : R\na\u271d : r \u2260 0\nhnN : n \u2264 N\n\u22a2 \u2191i r * \u215fx ^ (N - n) * x ^ N = \u2191i r * x ^ n"}, {"tactic": "conv in x ^ N => rw [\u2190 Nat.sub_add_cancel hnN]", "annotated_tactic": ["conv in x ^ N => rw [\u2190 <a>Nat.sub_add_cancel</a> hnN]", [{"full_name": "Nat.sub_add_cancel", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [583, 19], "def_end_pos": [583, 33]}]], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nn : \u2115\nr : R\na\u271d : r \u2260 0\nhnN : n \u2264 N\n\u22a2 \u2191i r * \u215fx ^ (N - n) * x ^ N = \u2191i r * x ^ n", "state_after": "case refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nn : \u2115\nr : R\na\u271d : r \u2260 0\nhnN : n \u2264 N\n\u22a2 \u2191i r * \u215fx ^ (N - n) * x ^ (N - n + n) = \u2191i r * x ^ n"}, {"tactic": "rw [pow_add, \u2190 mul_assoc, mul_assoc (i r), \u2190 mul_pow, invOf_mul_self, one_pow, mul_one]", "annotated_tactic": ["rw [<a>pow_add</a>, \u2190 <a>mul_assoc</a>, <a>mul_assoc</a> (i r), \u2190 <a>mul_pow</a>, <a>invOf_mul_self</a>, <a>one_pow</a>, <a>mul_one</a>]", [{"full_name": "pow_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 16]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [257, 9], "def_end_pos": [257, 16]}, {"full_name": "invOf_mul_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Invertible/Defs.lean", "def_pos": [104, 9], "def_end_pos": [104, 23]}, {"full_name": "one_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case refine'_2\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nn : \u2115\nr : R\na\u271d : r \u2260 0\nhnN : n \u2264 N\n\u22a2 \u2191i r * \u215fx ^ (N - n) * x ^ (N - n + n) = \u2191i r * x ^ n", "state_after": "no goals"}, {"tactic": "intros", "annotated_tactic": ["intros", []], "state_before": "case refine'_3\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\n\u22a2 \u2200 (f g : R[X]),\n    natDegree f < natDegree g \u2192\n      natDegree g \u2264 N \u2192\n        (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) f \u2192\n          (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) g \u2192\n            (fun f => eval\u2082 i (\u215fx) (reflect N f) * x ^ N = eval\u2082 i x f) (f + g)", "state_after": "case refine'_3\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d\u00b9 : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nf\u271d g\u271d : R[X]\na\u271d\u00b3 : natDegree f\u271d < natDegree g\u271d\na\u271d\u00b2 : natDegree g\u271d \u2264 N\na\u271d\u00b9 : eval\u2082 i (\u215fx) (reflect N f\u271d) * x ^ N = eval\u2082 i x f\u271d\na\u271d : eval\u2082 i (\u215fx) (reflect N g\u271d) * x ^ N = eval\u2082 i x g\u271d\n\u22a2 eval\u2082 i (\u215fx) (reflect N (f\u271d + g\u271d)) * x ^ N = eval\u2082 i x (f\u271d + g\u271d)"}, {"tactic": "simp [*, add_mul]", "annotated_tactic": ["simp [*, <a>add_mul</a>]", [{"full_name": "add_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}]], "state_before": "case refine'_3\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\nf\u271d\u00b9 : R[X]\nS : Type u_2\ninst\u271d\u00b9 : CommSemiring S\ni : R \u2192+* S\nx : S\ninst\u271d : Invertible x\nN : \u2115\nf : R[X]\nhf : natDegree f \u2264 N\nf\u271d g\u271d : R[X]\na\u271d\u00b3 : natDegree f\u271d < natDegree g\u271d\na\u271d\u00b2 : natDegree g\u271d \u2264 N\na\u271d\u00b9 : eval\u2082 i (\u215fx) (reflect N f\u271d) * x ^ N = eval\u2082 i x f\u271d\na\u271d : eval\u2082 i (\u215fx) (reflect N g\u271d) * x ^ N = eval\u2082 i x g\u271d\n\u22a2 eval\u2082 i (\u215fx) (reflect N (f\u271d + g\u271d)) * x ^ N = eval\u2082 i x (f\u271d + g\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Synonym.lean", "full_name": "OrderDual.le_toDual", "start": [109, 1], "end": [110, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean", "full_name": "Bool.bool_iff_false", "start": [128, 1], "end": [128, 85], "traced_tactics": [{"tactic": "cases b <;> exact by decide", "annotated_tactic": ["cases b <;> exact by decide", []], "state_before": "b : Bool\n\u22a2 \u00acb = true \u2194 b = false", "state_after": "no goals"}, {"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u00actrue = true \u2194 true = false", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.pi_subset_pi_iff", "start": [960, 1], "end": [966, 45], "traced_tactics": [{"tactic": "refine'\n  \u27e8fun h => or_iff_not_imp_right.2 _, fun h => h.elim pi_mono fun h' => h'.symm \u25b8 empty_subset _\u27e9", "annotated_tactic": ["refine'\n    \u27e8fun h => <a>or_iff_not_imp_right</a>.2 _, fun h => h.elim <a>pi_mono</a> fun h' => h'.symm \u25b8 <a>empty_subset</a> _\u27e9", [{"full_name": "Classical.or_iff_not_imp_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [708, 9], "def_end_pos": [708, 29]}, {"full_name": "Set.pi_mono", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [781, 9], "def_end_pos": [781, 16]}, {"full_name": "Set.empty_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [567, 9], "def_end_pos": [567, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\n\u22a2 pi s t\u2081 \u2286 pi s t\u2082 \u2194 (\u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i) \u2228 pi s t\u2081 = \u2205", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 \u00acpi s t\u2081 = \u2205 \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i"}, {"tactic": "rw [\u2190 Ne.def, \u2190 nonempty_iff_ne_empty]", "annotated_tactic": ["rw [\u2190 <a>Ne.def</a>, \u2190 <a>nonempty_iff_ne_empty</a>]", [{"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Set.nonempty_iff_ne_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [603, 9], "def_end_pos": [603, 30]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 \u00acpi s t\u2081 = \u2205 \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 Set.Nonempty (pi s t\u2081) \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i"}, {"tactic": "intro hne i hi", "annotated_tactic": ["intro hne i hi", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\n\u22a2 Set.Nonempty (pi s t\u2081) \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni\u271d : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\nhne : Set.Nonempty (pi s t\u2081)\ni : \u03b9\nhi : i \u2208 s\n\u22a2 t\u2081 i \u2286 t\u2082 i"}, {"tactic": "simpa only [eval_image_pi hi hne, eval_image_pi hi (hne.mono h)] using\n  image_subset (fun f : \u2200 i, \u03b1 i => f i) h", "annotated_tactic": ["simpa only [<a>eval_image_pi</a> hi hne, <a>eval_image_pi</a> hi (hne.mono h)] using\n    <a>image_subset</a> (fun f : \u2200 i, \u03b1 i => f i) h", [{"full_name": "Set.eval_image_pi", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [950, 9], "def_end_pos": [950, 22]}, {"full_name": "Set.eval_image_pi", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [950, 9], "def_end_pos": [950, 22]}, {"full_name": "Set.image_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [321, 9], "def_end_pos": [321, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ns s\u2081 s\u2082 : Set \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ni\u271d : \u03b9\nh : pi s t\u2081 \u2286 pi s t\u2082\nhne : Set.Nonempty (pi s t\u2081)\ni : \u03b9\nhi : i \u2208 s\n\u22a2 t\u2081 i \u2286 t\u2082 i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "RingHom.coe_monoidHom_injective", "start": [549, 1], "end": [550, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.card_support_eq_zero", "start": [425, 1], "end": [425, 69], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 Finset.card (support p) = 0 \u2194 p = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GeomSum.lean", "full_name": "geom_sum_pos", "start": [464, 1], "end": [466, 76], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nn : \u2115\nx : \u03b1\ninst\u271d : StrictOrderedSemiring \u03b1\nhx : 0 \u2264 x\nhn : n \u2260 0\n\u22a2 0 < x ^ 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Int/Basic.lean", "full_name": "Int.exists_unit_of_abs", "start": [172, 1], "end": [178, 33], "traced_tactics": [{"tactic": "cases' natAbs_eq a with h h", "annotated_tactic": ["cases' <a>natAbs_eq</a> a with h h", [{"full_name": "Int.natAbs_eq", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [162, 9], "def_end_pos": [162, 18]}]], "state_before": "a : \u2124\n\u22a2 \u2203 u, \u2203 (_ : IsUnit u), \u2191(natAbs a) = u * a", "state_after": "case inl\na : \u2124\nh : a = \u2191(natAbs a)\n\u22a2 \u2203 u, \u2203 (_ : IsUnit u), \u2191(natAbs a) = u * a\n\ncase inr\na : \u2124\nh : a = -\u2191(natAbs a)\n\u22a2 \u2203 u, \u2203 (_ : IsUnit u), \u2191(natAbs a) = u * a"}, {"tactic": "use 1, isUnit_one", "annotated_tactic": ["use 1, <a>isUnit_one</a>", [{"full_name": "isUnit_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [621, 9], "def_end_pos": [621, 19]}]], "state_before": "case inl\na : \u2124\nh : a = \u2191(natAbs a)\n\u22a2 \u2203 u, \u2203 (_ : IsUnit u), \u2191(natAbs a) = u * a", "state_after": "case h\na : \u2124\nh : a = \u2191(natAbs a)\n\u22a2 \u2191(natAbs a) = 1 * a"}, {"tactic": "rw [\u2190 h, one_mul]", "annotated_tactic": ["rw [\u2190 h, <a>one_mul</a>]", [{"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "case h\na : \u2124\nh : a = \u2191(natAbs a)\n\u22a2 \u2191(natAbs a) = 1 * a", "state_after": "no goals"}, {"tactic": "use -1, isUnit_one.neg", "annotated_tactic": ["use -1, isUnit_one.neg", []], "state_before": "case inr\na : \u2124\nh : a = -\u2191(natAbs a)\n\u22a2 \u2203 u, \u2203 (_ : IsUnit u), \u2191(natAbs a) = u * a", "state_after": "case h\na : \u2124\nh : a = -\u2191(natAbs a)\n\u22a2 \u2191(natAbs a) = -1 * a"}, {"tactic": "rw [\u2190 neg_eq_iff_eq_neg.mpr h]", "annotated_tactic": ["rw [\u2190 neg_eq_iff_eq_neg.mpr h]", []], "state_before": "case h\na : \u2124\nh : a = -\u2191(natAbs a)\n\u22a2 \u2191(natAbs a) = -1 * a", "state_after": "case h\na : \u2124\nh : a = -\u2191(natAbs a)\n\u22a2 -a = -1 * a"}, {"tactic": "simp only [neg_mul, one_mul]", "annotated_tactic": ["simp only [<a>neg_mul</a>, <a>one_mul</a>]", [{"full_name": "neg_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [289, 9], "def_end_pos": [289, 16]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "case h\na : \u2124\nh : a = -\u2191(natAbs a)\n\u22a2 -a = -1 * a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/LinearMap.lean", "full_name": "LinearMap.comp_sub", "start": [969, 1], "end": [971, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.single_apply_eq_zero", "start": [381, 1], "end": [382, 33], "traced_tactics": [{"tactic": "simp [single_eq_set_indicator]", "annotated_tactic": ["simp [<a>single_eq_set_indicator</a>]", [{"full_name": "Finsupp.single_eq_set_indicator", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [317, 9], "def_end_pos": [317, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\na\u271d a' : \u03b1\nb\u271d : M\na x : \u03b1\nb : M\n\u22a2 \u2191(single a b) x = 0 \u2194 x = a \u2192 b = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.pred_injective", "start": [835, 1], "end": [835, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.image_vsub_prod", "start": [606, 1], "end": [607, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "Int.cast_ite", "start": [60, 1], "end": [62, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.not_mem_empty", "start": [425, 1], "end": [426, 5], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "sq_pos_of_pos", "start": [182, 1], "end": [184, 22], "traced_tactics": [{"tactic": "rw [sq]", "annotated_tactic": ["rw [<a>sq</a>]", [{"full_name": "sq", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [106, 7], "def_end_pos": [106, 9]}]], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : StrictOrderedSemiring R\na x y : R\nn m : \u2115\nha : 0 < a\n\u22a2 0 < a ^ 2", "state_after": "M : Type u_1\nR : Type u_2\ninst\u271d : StrictOrderedSemiring R\na x y : R\nn m : \u2115\nha : 0 < a\n\u22a2 0 < a * a"}, {"tactic": "exact mul_pos ha ha", "annotated_tactic": ["exact <a>mul_pos</a> ha ha", [{"full_name": "mul_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [345, 7], "def_end_pos": [345, 14]}]], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : StrictOrderedSemiring R\na x y : R\nn m : \u2115\nha : 0 < a\n\u22a2 0 < a * a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "smul_finsum'", "start": [708, 1], "end": [710, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "Algebra.algebraMap_ofSubring", "start": [534, 1], "end": [536, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Control/Traversable/Instances.lean", "full_name": "List.traverse_eq_map_id", "start": [86, 11], "end": [88, 47], "traced_tactics": [{"tactic": "induction x <;> simp! [*, functor_norm]", "annotated_tactic": ["induction x <;> simp! [*, functor_norm]", []], "state_before": "F G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx : List \u03b1\n\u22a2 List.traverse (pure \u2218 f) x = pure (f <$> x)", "state_after": "case cons\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : List.traverse (pure \u2218 f) tail\u271d = pure (f <$> tail\u271d)\n\u22a2 (Seq.seq (cons (f head\u271d)) fun x => map f tail\u271d) = f head\u271d :: map f tail\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case cons\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : List.traverse (pure \u2218 f) tail\u271d = pure (f <$> tail\u271d)\n\u22a2 (Seq.seq (cons (f head\u271d)) fun x => map f tail\u271d) = f head\u271d :: map f tail\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.toRingEquiv_eq_coe", "start": [197, 1], "end": [198, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "List.prod_erase_of_comm", "start": [555, 1], "end": [562, 91], "traced_tactics": [{"tactic": "induction' l with b l ih", "annotated_tactic": ["induction' l with b l ih", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na : M\nl : List M\nha : a \u2208 l\ncomm : \u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x\n\u22a2 a * prod (List.erase l a) = prod l", "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na : M\nha : a \u2208 []\ncomm : \u2200 (x : M), x \u2208 [] \u2192 \u2200 (y : M), y \u2208 [] \u2192 x * y = y * x\n\u22a2 a * prod (List.erase [] a) = prod []\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)"}, {"tactic": "simp at ha", "annotated_tactic": ["simp at ha", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na : M\nha : a \u2208 []\ncomm : \u2200 (x : M), x \u2208 [] \u2192 \u2200 (y : M), y \u2208 [] \u2192 x * y = y * x\n\u22a2 a * prod (List.erase [] a) = prod []\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)", "state_after": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)"}, {"tactic": "obtain rfl | \u27e8ne, h\u27e9 := Decidable.List.eq_or_ne_mem_of_mem ha", "annotated_tactic": ["obtain rfl | \u27e8ne, h\u27e9 := <a>Decidable.List.eq_or_ne_mem_of_mem</a> ha", [{"full_name": "Decidable.List.eq_or_ne_mem_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [87, 9], "def_end_pos": [87, 50]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)", "state_after": "case cons.inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 a :: l\ncomm : \u2200 (x : M), x \u2208 a :: l \u2192 \u2200 (y : M), y \u2208 a :: l \u2192 x * y = y * x\n\u22a2 a * prod (List.erase (a :: l) a) = prod (a :: l)\n\ncase cons.inr.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\nne : a \u2260 b\nh : a \u2208 l\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case cons.inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 a :: l\ncomm : \u2200 (x : M), x \u2208 a :: l \u2192 \u2200 (y : M), y \u2208 a :: l \u2192 x * y = y * x\n\u22a2 a * prod (List.erase (a :: l) a) = prod (a :: l)\n\ncase cons.inr.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\nne : a \u2260 b\nh : a \u2208 l\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)", "state_after": "case cons.inr.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\nne : a \u2260 b\nh : a \u2208 l\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)"}, {"tactic": "rw [List.erase, beq_false_of_ne ne.symm, List.prod_cons, List.prod_cons, \u2190 mul_assoc,\n  comm a ha b (l.mem_cons_self b), mul_assoc,\n  ih h fun x hx y hy \u21a6 comm _ (List.mem_cons_of_mem b hx) _ (List.mem_cons_of_mem b hy)]", "annotated_tactic": ["rw [<a>List.erase</a>, <a>beq_false_of_ne</a> ne.symm, <a>List.prod_cons</a>, <a>List.prod_cons</a>, \u2190 <a>mul_assoc</a>,\n    comm a ha b (l.mem_cons_self b), <a>mul_assoc</a>,\n    ih h fun x hx y hy \u21a6 comm _ (<a>List.mem_cons_of_mem</a> b hx) _ (<a>List.mem_cons_of_mem</a> b hy)]", [{"full_name": "List.erase", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [120, 15], "def_end_pos": [120, 20]}, {"full_name": "beq_false_of_ne", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [604, 9], "def_end_pos": [604, 24]}, {"full_name": "List.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 18]}, {"full_name": "List.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 18]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "List.mem_cons_of_mem", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [63, 9], "def_end_pos": [63, 24]}, {"full_name": "List.mem_cons_of_mem", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [63, 9], "def_end_pos": [63, 24]}]], "state_before": "case cons.inr.intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u00b9 : DecidableEq M\ninst\u271d : Monoid M\na b : M\nl : List M\nih : a \u2208 l \u2192 (\u2200 (x : M), x \u2208 l \u2192 \u2200 (y : M), y \u2208 l \u2192 x * y = y * x) \u2192 a * prod (List.erase l a) = prod l\nha : a \u2208 b :: l\ncomm : \u2200 (x : M), x \u2208 b :: l \u2192 \u2200 (y : M), y \u2208 b :: l \u2192 x * y = y * x\nne : a \u2260 b\nh : a \u2208 l\n\u22a2 a * prod (List.erase (b :: l) a) = prod (b :: l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Finset.prod_eq_one_iff'", "start": [398, 1], "end": [399, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Equiv.lean", "full_name": "MvPolynomial.mapEquiv_symm", "start": [110, 1], "end": [112, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "xor_iff_iff_not", "start": [488, 1], "end": [488, 92], "traced_tactics": [{"tactic": "simp only [\u2190 @xor_not_right a, not_not]", "annotated_tactic": ["simp only [\u2190 @<a>xor_not_right</a> a, <a>not_not</a>]", [{"full_name": "xor_not_right", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [301, 17], "def_end_pos": [301, 30]}, {"full_name": "Classical.not_not", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [689, 24], "def_end_pos": [689, 31]}]], "state_before": "a b : Prop\n\u22a2 Xor' a b \u2194 (a \u2194 \u00acb)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "full_name": "Matrix.det_eq_of_forall_row_eq_smul_add_const_aux", "start": [469, 1], "end": [499, 84], "traced_tactics": [{"tactic": "rintro c hs k - A_eq", "annotated_tactic": ["rintro c hs k - A_eq", []], "state_before": "case empty\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\n\u22a2 \u2200 (c : n \u2192 R), (\u2200 i \u2209 \u2205, c i = 0) \u2192 \u2200 k \u2209 \u2205, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B", "state_after": "case empty\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\n\u22a2 det A = det B"}, {"tactic": "have : \u2200 i, c i = 0 := by\n  intro i\n  specialize hs i\n  contrapose! hs\n  simp [hs]", "annotated_tactic": ["have : \u2200 i, c i = 0 := by\n      intro i\n      specialize hs i\n      contrapose! hs\n      simp [hs]", []], "state_before": "case empty\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\n\u22a2 det A = det B", "state_after": "case empty\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nthis : \u2200 (i : n), c i = 0\n\u22a2 det A = det B"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case empty\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nthis : \u2200 (i : n), c i = 0\n\u22a2 det A = det B", "state_after": "case empty.e_M\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nthis : \u2200 (i : n), c i = 0\n\u22a2 A = B"}, {"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "case empty.e_M\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nthis : \u2200 (i : n), c i = 0\n\u22a2 A = B", "state_after": "case empty.e_M.a.h\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nthis : \u2200 (i : n), c i = 0\ni j : n\n\u22a2 A i j = B i j"}, {"tactic": "rw [A_eq, this, zero_mul, add_zero]", "annotated_tactic": ["rw [A_eq, this, <a>zero_mul</a>, <a>add_zero</a>]", [{"full_name": "MulZeroClass.zero_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [36, 3], "def_end_pos": [36, 11]}, {"full_name": "add_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [469, 3], "def_end_pos": [469, 14]}]], "state_before": "case empty.e_M.a.h\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nthis : \u2200 (i : n), c i = 0\ni j : n\n\u22a2 A i j = B i j", "state_after": "no goals"}, {"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\n\u22a2 \u2200 (i : n), c i = 0", "state_after": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\ni : n\n\u22a2 c i = 0"}, {"tactic": "specialize hs i", "annotated_tactic": ["specialize hs i", []], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i \u2209 \u2205, c i = 0\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\ni : n\n\u22a2 c i = 0", "state_after": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\ni : n\nhs : i \u2209 \u2205 \u2192 c i = 0\n\u22a2 c i = 0"}, {"tactic": "contrapose! hs", "annotated_tactic": ["contrapose! hs", []], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\ni : n\nhs : i \u2209 \u2205 \u2192 c i = 0\n\u22a2 c i = 0", "state_after": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\ni : n\nhs : c i \u2260 0\n\u22a2 i \u2209 \u2205 \u2227 c i \u2260 0"}, {"tactic": "simp [hs]", "annotated_tactic": ["simp [hs]", []], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA B : Matrix n n R\nc : n \u2192 R\nk : n\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\ni : n\nhs : c i \u2260 0\n\u22a2 i \u2209 \u2205 \u2227 c i \u2260 0", "state_after": "no goals"}, {"tactic": "intro c hs k hk A_eq", "annotated_tactic": ["intro c hs k hk A_eq", []], "state_before": "case insert\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\n\u22a2 \u2200 (c : n \u2192 R),\n    (\u2200 i_1 \u2209 insert i s, c i_1 = 0) \u2192 \u2200 k \u2209 insert i s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B", "state_after": "case insert\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\n\u22a2 det A = det B"}, {"tactic": "have hAi : A i = B i + c i \u2022 B k := funext (A_eq i)", "annotated_tactic": ["have hAi : A i = B i + c i \u2022 B k := <a>funext</a> (A_eq i)", [{"full_name": "funext", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [1555, 9], "def_end_pos": [1555, 15]}]], "state_before": "case insert\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\n\u22a2 det A = det B", "state_after": "case insert\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 det A = det B"}, {"tactic": "rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]", "annotated_tactic": ["rw [@ih (<a>updateRow</a> B i (A i)) (<a>Function.update</a> c i 0), hAi, <a>det_updateRow_add_smul_self</a>]", [{"full_name": "Matrix.updateRow", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/RowCol.lean", "def_pos": [164, 5], "def_end_pos": [164, 14]}, {"full_name": "Function.update", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [561, 5], "def_end_pos": [561, 11]}, {"full_name": "Matrix.det_updateRow_add_smul_self", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [457, 9], "def_end_pos": [457, 36]}]], "state_before": "case insert\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 det A = det B", "state_after": "case insert.hij\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 i \u2260 k\n\ncase insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 \u2200 i_1 \u2209 s, update c i 0 i_1 = 0\n\ncase insert.k\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 n\n\ncase insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 ?insert.k \u2209 s\n\ncase insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 \u2200 (i_1 j : n), A i_1 j = updateRow B i (A i) i_1 j + update c i 0 i_1 * updateRow B i (A i) ?insert.k j"}, {"tactic": "exact mt (fun h => show k \u2208 insert i s from h \u25b8 Finset.mem_insert_self _ _) hk", "annotated_tactic": ["exact <a>mt</a> (fun h => show k \u2208 <a>insert</a> i s from h \u25b8 <a>Finset.mem_insert_self</a> _ _) hk", [{"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "Insert.insert", "def_path": "lake-packages/std/Std/Classes/SetNotation.lean", "def_pos": [69, 3], "def_end_pos": [69, 9]}, {"full_name": "Finset.mem_insert_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1103, 9], "def_end_pos": [1103, 24]}]], "state_before": "case insert.hij\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 i \u2260 k", "state_after": "no goals"}, {"tactic": "intro i' hi'", "annotated_tactic": ["intro i' hi'", []], "state_before": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 \u2200 i_1 \u2209 s, update c i 0 i_1 = 0", "state_after": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\n\u22a2 update c i 0 i' = 0"}, {"tactic": "rw [Function.update_apply]", "annotated_tactic": ["rw [<a>Function.update_apply</a>]", [{"full_name": "Function.update_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [576, 9], "def_end_pos": [576, 21]}]], "state_before": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\n\u22a2 update c i 0 i' = 0", "state_after": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\n\u22a2 (if i' = i then 0 else c i') = 0"}, {"tactic": "split_ifs with hi'i", "annotated_tactic": ["split_ifs with hi'i", []], "state_before": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\n\u22a2 (if i' = i then 0 else c i') = 0", "state_after": "case pos\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\nhi'i : i' = i\n\u22a2 0 = 0\n\ncase neg\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\nhi'i : \u00aci' = i\n\u22a2 c i' = 0"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case pos\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\nhi'i : i' = i\n\u22a2 0 = 0", "state_after": "no goals"}, {"tactic": "exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)", "annotated_tactic": ["exact hs i' fun h => hi' ((Finset.mem_insert.mp h).<a>resolve_left</a> hi'i)", [{"full_name": "Or.resolve_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [274, 9], "def_end_pos": [274, 24]}]], "state_before": "case neg\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' : n\nhi' : i' \u2209 s\nhi'i : \u00aci' = i\n\u22a2 c i' = 0", "state_after": "no goals"}, {"tactic": "exact k", "annotated_tactic": ["exact k", []], "state_before": "case insert.k\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 n", "state_after": "no goals"}, {"tactic": "exact fun h => hk (Finset.mem_insert_of_mem h)", "annotated_tactic": ["exact fun h => hk (<a>Finset.mem_insert_of_mem</a> h)", [{"full_name": "Finset.mem_insert_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1107, 9], "def_end_pos": [1107, 26]}]], "state_before": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 k \u2209 s", "state_after": "no goals"}, {"tactic": "intro i' j'", "annotated_tactic": ["intro i' j'", []], "state_before": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\n\u22a2 \u2200 (i_1 j : n), A i_1 j = updateRow B i (A i) i_1 j + update c i 0 i_1 * updateRow B i (A i) k j", "state_after": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\n\u22a2 A i' j' = updateRow B i (A i) i' j' + update c i 0 i' * updateRow B i (A i) k j'"}, {"tactic": "rw [updateRow_apply, Function.update_apply]", "annotated_tactic": ["rw [<a>updateRow_apply</a>, <a>Function.update_apply</a>]", [{"full_name": "Matrix.updateRow_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/RowCol.lean", "def_pos": [200, 9], "def_end_pos": [200, 24]}, {"full_name": "Function.update_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [576, 9], "def_end_pos": [576, 21]}]], "state_before": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\n\u22a2 A i' j' = updateRow B i (A i) i' j' + update c i 0 i' * updateRow B i (A i) k j'", "state_after": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\n\u22a2 A i' j' = (if i' = i then A i j' else B i' j') + (if i' = i then 0 else c i') * updateRow B i (A i) k j'"}, {"tactic": "split_ifs with hi'i", "annotated_tactic": ["split_ifs with hi'i", []], "state_before": "case insert.x\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\n\u22a2 A i' j' = (if i' = i then A i j' else B i' j') + (if i' = i then 0 else c i') * updateRow B i (A i) k j'", "state_after": "case pos\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\nhi'i : i' = i\n\u22a2 A i' j' = A i j' + 0 * updateRow B i (A i) k j'\n\ncase neg\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\nhi'i : \u00aci' = i\n\u22a2 A i' j' = B i' j' + c i' * updateRow B i (A i) k j'"}, {"tactic": "rw [A_eq, updateRow_ne fun h : k = i => hk <| h \u25b8 Finset.mem_insert_self k s]", "annotated_tactic": ["rw [A_eq, <a>updateRow_ne</a> fun h : k = i => hk <| h \u25b8 <a>Finset.mem_insert_self</a> k s]", [{"full_name": "Matrix.updateRow_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/RowCol.lean", "def_pos": [188, 9], "def_end_pos": [188, 21]}, {"full_name": "Finset.mem_insert_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1103, 9], "def_end_pos": [1103, 24]}]], "state_before": "case neg\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\nhi'i : \u00aci' = i\n\u22a2 A i' j' = B i' j' + c i' * updateRow B i (A i) k j'", "state_after": "no goals"}, {"tactic": "simp [hi'i]", "annotated_tactic": ["simp [hi'i]", []], "state_before": "case pos\nm : Type u_1\nn : Type u_2\ninst\u271d\u2074 : DecidableEq n\ninst\u271d\u00b3 : Fintype n\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : Fintype m\nR : Type v\ninst\u271d : CommRing R\nA : Matrix n n R\ni : n\ns : Finset n\n_hi : i \u2209 s\nih :\n  \u2200 {B : Matrix n n R} (c : n \u2192 R),\n    (\u2200 i \u2209 s, c i = 0) \u2192 \u2200 k \u2209 s, (\u2200 (i j : n), A i j = B i j + c i * B k j) \u2192 det A = det B\nB : Matrix n n R\nc : n \u2192 R\nhs : \u2200 i_1 \u2209 insert i s, c i_1 = 0\nk : n\nhk : k \u2209 insert i s\nA_eq : \u2200 (i j : n), A i j = B i j + c i * B k j\nhAi : A i = B i + c i \u2022 B k\ni' j' : n\nhi'i : i' = i\n\u22a2 A i' j' = A i j' + 0 * updateRow B i (A i) k j'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Abs.lean", "full_name": "abs_dvd_abs", "start": [112, 1], "end": [113, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "List.prev_singleton", "start": [151, 1], "end": [152, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iUnion_eq_univ_iff", "start": [1326, 1], "end": [1327, 45], "traced_tactics": [{"tactic": "simp only [eq_univ_iff_forall, mem_iUnion]", "annotated_tactic": ["simp only [<a>eq_univ_iff_forall</a>, <a>mem_iUnion</a>]", [{"full_name": "Set.eq_univ_iff_forall", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [694, 9], "def_end_pos": [694, 27]}, {"full_name": "Set.mem_iUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [201, 9], "def_end_pos": [201, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b9 \u2192 Set \u03b1\n\u22a2 \u22c3 i, f i = univ \u2194 \u2200 (x : \u03b1), \u2203 i, x \u2208 f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "eq_compl_comm", "start": [629, 1], "end": [630, 59], "traced_tactics": [{"tactic": "rw [eq_comm, compl_eq_iff_isCompl, eq_compl_iff_isCompl]", "annotated_tactic": ["rw [<a>eq_comm</a>, <a>compl_eq_iff_isCompl</a>, <a>eq_compl_iff_isCompl</a>]", [{"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}, {"full_name": "compl_eq_iff_isCompl", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [619, 9], "def_end_pos": [619, 29]}, {"full_name": "eq_compl_iff_isCompl", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [613, 9], "def_end_pos": [613, 29]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : BooleanAlgebra \u03b1\n\u22a2 x = y\u1d9c \u2194 y = x\u1d9c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.closure_le", "start": [1131, 1], "end": [1132, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.dvd_count_pow", "start": [1797, 1], "end": [1800, 22], "traced_tactics": [{"tactic": "rw [count_pow ha hp]", "annotated_tactic": ["rw [<a>count_pow</a> ha hp]", [{"full_name": "Associates.count_pow", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1789, 9], "def_end_pos": [1789, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\na : Associates \u03b1\nha : a \u2260 0\np : Associates \u03b1\nhp : Irreducible p\nk : \u2115\n\u22a2 k \u2223 count p (factors (a ^ k))", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\na : Associates \u03b1\nha : a \u2260 0\np : Associates \u03b1\nhp : Irreducible p\nk : \u2115\n\u22a2 k \u2223 k * count p (factors a)"}, {"tactic": "apply dvd_mul_right", "annotated_tactic": ["apply <a>dvd_mul_right</a>", [{"full_name": "dvd_mul_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\na : Associates \u03b1\nha : a \u2260 0\np : Associates \u03b1\nhp : Irreducible p\nk : \u2115\n\u22a2 k \u2223 k * count p (factors a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "min_mul_of_nonneg", "start": [974, 1], "end": [975, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Nodup.lean", "full_name": "Multiset.Nodup.pmap", "start": [159, 1], "end": [161, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.coe_nat_lcm", "start": [243, 11], "end": [244, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.cyclicPermutations_of_ne_nil", "start": [581, 1], "end": [584, 36], "traced_tactics": [{"tactic": "obtain \u27e8hd, tl, rfl\u27e9 := exists_cons_of_ne_nil h", "annotated_tactic": ["obtain \u27e8hd, tl, rfl\u27e9 := <a>exists_cons_of_ne_nil</a> h", [{"full_name": "List.exists_cons_of_ne_nil", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [32, 9], "def_end_pos": [32, 30]}]], "state_before": "\u03b1 : Type u\nl\u271d l' l : List \u03b1\nh : l \u2260 []\n\u22a2 cyclicPermutations l = dropLast (zipWith (fun x x_1 => x ++ x_1) (tails l) (inits l))", "state_after": "case intro.intro\n\u03b1 : Type u\nl l' : List \u03b1\nhd : \u03b1\ntl : List \u03b1\nh : hd :: tl \u2260 []\n\u22a2 cyclicPermutations (hd :: tl) = dropLast (zipWith (fun x x_1 => x ++ x_1) (tails (hd :: tl)) (inits (hd :: tl)))"}, {"tactic": "exact cyclicPermutations_cons _ _", "annotated_tactic": ["exact <a>cyclicPermutations_cons</a> _ _", [{"full_name": "List.cyclicPermutations_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [576, 9], "def_end_pos": [576, 32]}]], "state_before": "case intro.intro\n\u03b1 : Type u\nl l' : List \u03b1\nhd : \u03b1\ntl : List \u03b1\nh : hd :: tl \u2260 []\n\u22a2 cyclicPermutations (hd :: tl) = dropLast (zipWith (fun x x_1 => x ++ x_1) (tails (hd :: tl)) (inits (hd :: tl)))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pairwise/Lattice.lean", "full_name": "Set.PairwiseDisjoint.subset_of_biUnion_subset_biUnion", "start": [147, 1], "end": [153, 42], "traced_tactics": [{"tactic": "rintro i hi", "annotated_tactic": ["rintro i hi", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03ba : Sort u_6\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : PairwiseDisjoint (s \u222a t) f\nh\u2081 : \u2200 i \u2208 s, Set.Nonempty (f i)\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\n\u22a2 s \u2286 t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03ba : Sort u_6\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : PairwiseDisjoint (s \u222a t) f\nh\u2081 : \u2200 i \u2208 s, Set.Nonempty (f i)\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\n\u22a2 i \u2208 t"}, {"tactic": "obtain \u27e8a, hai\u27e9 := h\u2081 i hi", "annotated_tactic": ["obtain \u27e8a, hai\u27e9 := h\u2081 i hi", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03ba : Sort u_6\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : PairwiseDisjoint (s \u222a t) f\nh\u2081 : \u2200 i \u2208 s, Set.Nonempty (f i)\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\n\u22a2 i \u2208 t", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03ba : Sort u_6\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : PairwiseDisjoint (s \u222a t) f\nh\u2081 : \u2200 i \u2208 s, Set.Nonempty (f i)\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\na : \u03b1\nhai : a \u2208 f i\n\u22a2 i \u2208 t"}, {"tactic": "obtain \u27e8j, hj, haj\u27e9 := mem_iUnion\u2082.1 (h <| mem_iUnion\u2082_of_mem hi hai)", "annotated_tactic": ["obtain \u27e8j, hj, haj\u27e9 := <a>mem_iUnion\u2082</a>.1 (h <| <a>mem_iUnion\u2082_of_mem</a> hi hai)", [{"full_name": "Set.mem_iUnion\u2082", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [212, 9], "def_end_pos": [212, 20]}, {"full_name": "Set.mem_iUnion\u2082_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [226, 9], "def_end_pos": [226, 27]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03ba : Sort u_6\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : PairwiseDisjoint (s \u222a t) f\nh\u2081 : \u2200 i \u2208 s, Set.Nonempty (f i)\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\na : \u03b1\nhai : a \u2208 f i\n\u22a2 i \u2208 t", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03ba : Sort u_6\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : PairwiseDisjoint (s \u222a t) f\nh\u2081 : \u2200 i \u2208 s, Set.Nonempty (f i)\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\na : \u03b1\nhai : a \u2208 f i\nj : \u03b9\nhj : j \u2208 t\nhaj : a \u2208 f j\n\u22a2 i \u2208 t"}, {"tactic": "rwa [h\u2080.eq (subset_union_left _ _ hi) (subset_union_right _ _ hj)\n    (not_disjoint_iff.2 \u27e8a, hai, haj\u27e9)]", "annotated_tactic": ["rwa [h\u2080.eq (<a>subset_union_left</a> _ _ hi) (<a>subset_union_right</a> _ _ hj)\n      (<a>not_disjoint_iff</a>.2 \u27e8a, hai, haj\u27e9)]", [{"full_name": "Set.subset_union_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [822, 9], "def_end_pos": [822, 26]}, {"full_name": "Set.subset_union_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [826, 9], "def_end_pos": [826, 27]}, {"full_name": "Set.not_disjoint_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1546, 7], "def_end_pos": [1546, 23]}]], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\n\u03ba : Sort u_6\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : PairwiseDisjoint (s \u222a t) f\nh\u2081 : \u2200 i \u2208 s, Set.Nonempty (f i)\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\na : \u03b1\nhai : a \u2208 f i\nj : \u03b9\nhj : j \u2208 t\nhaj : a \u2208 f j\n\u22a2 i \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "RingHom.ker_isMaximal_of_surjective", "start": [2170, 1], "end": [2180, 95], "traced_tactics": [{"tactic": "refine'\n  Ideal.isMaximal_iff.mpr\n    \u27e8fun h1 => one_ne_zero' K <| map_one f \u25b8 (mem_ker f).mp h1, fun J x hJ hxf hxJ => _\u27e9", "annotated_tactic": ["refine'\n    Ideal.isMaximal_iff.mpr\n      \u27e8fun h1 => <a>one_ne_zero'</a> K <| <a>map_one</a> f \u25b8 (<a>mem_ker</a> f).<a>mp</a> h1, fun J x hJ hxf hxJ => _\u27e9", [{"full_name": "one_ne_zero'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [81, 7], "def_end_pos": [81, 19]}, {"full_name": "map_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 9], "def_end_pos": [202, 16]}, {"full_name": "RingHom.mem_ker", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2089, 9], "def_end_pos": [2089, 16]}, {"full_name": "Iff.mp", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [90, 3], "def_end_pos": [90, 5]}]], "state_before": "R\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\n\u22a2 Ideal.IsMaximal (ker f)", "state_after": "R\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\n\u22a2 1 \u2208 J"}, {"tactic": "obtain \u27e8y, hy\u27e9 := hf (f x)\u207b\u00b9", "annotated_tactic": ["obtain \u27e8y, hy\u27e9 := hf (f x)\u207b\u00b9", []], "state_before": "R\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\n\u22a2 1 \u2208 J", "state_after": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\n\u22a2 1 \u2208 J"}, {"tactic": "have H : 1 = y * x - (y * x - 1) := (sub_sub_cancel _ _).symm", "annotated_tactic": ["have H : 1 = y * x - (y * x - 1) := (<a>sub_sub_cancel</a> _ _).<a>symm</a>", [{"full_name": "sub_sub_cancel", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [927, 3], "def_end_pos": [927, 14]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\n\u22a2 1 \u2208 J", "state_after": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 1 \u2208 J"}, {"tactic": "rw [H]", "annotated_tactic": ["rw [H]", []], "state_before": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 1 \u2208 J", "state_after": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 y * x - (y * x - 1) \u2208 J"}, {"tactic": "refine' J.sub_mem (J.mul_mem_left _ hxJ) (hJ _)", "annotated_tactic": ["refine' J.sub_mem (J.mul_mem_left _ hxJ) (hJ _)", []], "state_before": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 y * x - (y * x - 1) \u2208 J", "state_after": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 y * x - 1 \u2208 ker f"}, {"tactic": "rw [mem_ker]", "annotated_tactic": ["rw [<a>mem_ker</a>]", [{"full_name": "RingHom.mem_ker", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2089, 9], "def_end_pos": [2089, 16]}]], "state_before": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 y * x - 1 \u2208 ker f", "state_after": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 \u2191f (y * x - 1) = 0"}, {"tactic": "simp only [hy, map_sub, map_one, map_mul, inv_mul_cancel (mt (mem_ker f).mpr hxf), sub_self]", "annotated_tactic": ["simp only [hy, <a>map_sub</a>, <a>map_one</a>, <a>map_mul</a>, <a>inv_mul_cancel</a> (<a>mt</a> (<a>mem_ker</a> f).<a>mpr</a> hxf), <a>sub_self</a>]", [{"full_name": "map_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [428, 3], "def_end_pos": [428, 14]}, {"full_name": "map_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 9], "def_end_pos": [202, 16]}, {"full_name": "map_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [299, 9], "def_end_pos": [299, 16]}, {"full_name": "inv_mul_cancel", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean", "def_pos": [55, 9], "def_end_pos": [55, 23]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "RingHom.mem_ker", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2089, 9], "def_end_pos": [2089, 16]}, {"full_name": "Iff.mpr", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [92, 3], "def_end_pos": [92, 6]}, {"full_name": "sub_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [734, 30], "def_end_pos": [734, 38]}]], "state_before": "case intro\nR\u271d : Type u\nS : Type v\nT : Type w\nR : Type u_1\nK : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Field K\ninst\u271d : RingHomClass F R K\nf : F\nhf : Function.Surjective \u2191f\nJ : Ideal R\nx : R\nhJ : ker f \u2264 J\nhxf : x \u2209 ker f\nhxJ : x \u2208 J\ny : R\nhy : \u2191f y = (\u2191f x)\u207b\u00b9\nH : 1 = y * x - (y * x - 1)\n\u22a2 \u2191f (y * x - 1) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.prod_mem", "start": [182, 11], "end": [185, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.toLinearEquiv_symm", "start": [581, 1], "end": [582, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.map_involutive", "start": [412, 1], "end": [414, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.wcovby_succ", "start": [242, 1], "end": [243, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Basic.lean", "full_name": "Submodule.coe_add", "start": [314, 1], "end": [315, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Iterate.lean", "full_name": "Function.iterate_fixed", "start": [97, 1], "end": [98, 65], "traced_tactics": [{"tactic": "rw [iterate_succ_apply, h, ihn]", "annotated_tactic": ["rw [<a>iterate_succ_apply</a>, h, ihn]", [{"full_name": "Function.iterate_succ_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [66, 9], "def_end_pos": [66, 27]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b1\nx : \u03b1\nh : f x = x\nn\u271d n : \u2115\nihn : f^[n] x = x\n\u22a2 f^[Nat.succ n] x = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_comm'", "start": [703, 1], "end": [714, 99], "traced_tactics": [{"tactic": "classical\n  have : \u2200 z : \u03b3 \u00d7 \u03b1, (z \u2208 s.biUnion fun x => (t x).map <| Function.Embedding.sectr x _) \u2194\n    z.1 \u2208 s \u2227 z.2 \u2208 t z.1 := by\n    rintro \u27e8x, y\u27e9\n    simp only [mem_biUnion, mem_map, Function.Embedding.sectr_apply, Prod.mk.injEq,\n      exists_eq_right, \u2190 and_assoc]\n  exact\n    (prod_finset_product' _ _ _ this).symm.trans\n      ((prod_finset_product_right' _ _ _) fun \u27e8x, y\u27e9 => (this _).trans ((h x y).trans and_comm))", "annotated_tactic": ["classical\n    have : \u2200 z : \u03b3 \u00d7 \u03b1, (z \u2208 s.biUnion fun x => (t x).<a>map</a> <| <a>Function.Embedding.sectr</a> x _) \u2194\n      z.1 \u2208 s \u2227 z.2 \u2208 t z.1 := by\n      rintro \u27e8x, y\u27e9\n      simp only [<a>mem_biUnion</a>, <a>mem_map</a>, <a>Function.Embedding.sectr_apply</a>, Prod.mk.injEq,\n        <a>exists_eq_right</a>, \u2190 <a>and_assoc</a>]\n    exact\n      (<a>prod_finset_product'</a> _ _ _ this).symm.trans\n        ((<a>prod_finset_product_right'</a> _ _ _) fun \u27e8x, y\u27e9 => (this _).<a>trans</a> ((h x y).<a>trans</a> <a>and_comm</a>))", [{"full_name": "Finset.map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [51, 5], "def_end_pos": [51, 8]}, {"full_name": "Function.Embedding.sectr", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [264, 5], "def_end_pos": [264, 10]}, {"full_name": "Finset.mem_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3636, 9], "def_end_pos": [3636, 20]}, {"full_name": "Finset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Function.Embedding.sectr_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [263, 3], "def_end_pos": [263, 8]}, {"full_name": "exists_eq_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [468, 17], "def_end_pos": [468, 32]}, {"full_name": "and_assoc", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [180, 9], "def_end_pos": [180, 18]}, {"full_name": "Finset.prod_finset_product'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [615, 9], "def_end_pos": [615, 29]}, {"full_name": "Finset.prod_finset_product_right'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [635, 9], "def_end_pos": [635, 35]}, {"full_name": "Iff.trans", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [666, 9], "def_end_pos": [666, 18]}, {"full_name": "Iff.trans", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [666, 9], "def_end_pos": [666, 18]}, {"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 \u220f x in s, \u220f y in t x, f x y = \u220f y in t', \u220f x in s' y, f x y", "state_after": "no goals"}, {"tactic": "have : \u2200 z : \u03b3 \u00d7 \u03b1, (z \u2208 s.biUnion fun x => (t x).map <| Function.Embedding.sectr x _) \u2194\n  z.1 \u2208 s \u2227 z.2 \u2208 t z.1 := by\n  rintro \u27e8x, y\u27e9\n  simp only [mem_biUnion, mem_map, Function.Embedding.sectr_apply, Prod.mk.injEq,\n    exists_eq_right, \u2190 and_assoc]", "annotated_tactic": ["have : \u2200 z : \u03b3 \u00d7 \u03b1, (z \u2208 s.biUnion fun x => (t x).<a>map</a> <| <a>Function.Embedding.sectr</a> x _) \u2194\n      z.1 \u2208 s \u2227 z.2 \u2208 t z.1 := by\n      rintro \u27e8x, y\u27e9\n      simp only [<a>mem_biUnion</a>, <a>mem_map</a>, <a>Function.Embedding.sectr_apply</a>, Prod.mk.injEq,\n        <a>exists_eq_right</a>, \u2190 <a>and_assoc</a>]", [{"full_name": "Finset.map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [51, 5], "def_end_pos": [51, 8]}, {"full_name": "Function.Embedding.sectr", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [264, 5], "def_end_pos": [264, 10]}, {"full_name": "Finset.mem_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3636, 9], "def_end_pos": [3636, 20]}, {"full_name": "Finset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Function.Embedding.sectr_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [263, 3], "def_end_pos": [263, 8]}, {"full_name": "exists_eq_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [468, 17], "def_end_pos": [468, 32]}, {"full_name": "and_assoc", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [180, 9], "def_end_pos": [180, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 \u220f x in s, \u220f y in t x, f x y = \u220f y in t', \u220f x in s' y, f x y", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\nthis : \u2200 (z : \u03b3 \u00d7 \u03b1), (z \u2208 Finset.biUnion s fun x => map (Function.Embedding.sectr x \u03b1) (t x)) \u2194 z.1 \u2208 s \u2227 z.2 \u2208 t z.1\n\u22a2 \u220f x in s, \u220f y in t x, f x y = \u220f y in t', \u220f x in s' y, f x y"}, {"tactic": "exact\n  (prod_finset_product' _ _ _ this).symm.trans\n    ((prod_finset_product_right' _ _ _) fun \u27e8x, y\u27e9 => (this _).trans ((h x y).trans and_comm))", "annotated_tactic": ["exact\n      (<a>prod_finset_product'</a> _ _ _ this).symm.trans\n        ((<a>prod_finset_product_right'</a> _ _ _) fun \u27e8x, y\u27e9 => (this _).<a>trans</a> ((h x y).<a>trans</a> <a>and_comm</a>))", [{"full_name": "Finset.prod_finset_product'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [615, 9], "def_end_pos": [615, 29]}, {"full_name": "Finset.prod_finset_product_right'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [635, 9], "def_end_pos": [635, 35]}, {"full_name": "Iff.trans", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [666, 9], "def_end_pos": [666, 18]}, {"full_name": "Iff.trans", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [666, 9], "def_end_pos": [666, 18]}, {"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\nthis : \u2200 (z : \u03b3 \u00d7 \u03b1), (z \u2208 Finset.biUnion s fun x => map (Function.Embedding.sectr x \u03b1) (t x)) \u2194 z.1 \u2208 s \u2227 z.2 \u2208 t z.1\n\u22a2 \u220f x in s, \u220f y in t x, f x y = \u220f y in t', \u220f x in s' y, f x y", "state_after": "no goals"}, {"tactic": "rintro \u27e8x, y\u27e9", "annotated_tactic": ["rintro \u27e8x, y\u27e9", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (z : \u03b3 \u00d7 \u03b1), (z \u2208 Finset.biUnion s fun x => map (Function.Embedding.sectr x \u03b1) (t x)) \u2194 z.1 \u2208 s \u2227 z.2 \u2208 t z.1", "state_after": "case mk\n\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\nx : \u03b3\ny : \u03b1\n\u22a2 ((x, y) \u2208 Finset.biUnion s fun x => map (Function.Embedding.sectr x \u03b1) (t x)) \u2194 (x, y).1 \u2208 s \u2227 (x, y).2 \u2208 t (x, y).1"}, {"tactic": "simp only [mem_biUnion, mem_map, Function.Embedding.sectr_apply, Prod.mk.injEq,\n  exists_eq_right, \u2190 and_assoc]", "annotated_tactic": ["simp only [<a>mem_biUnion</a>, <a>mem_map</a>, <a>Function.Embedding.sectr_apply</a>, Prod.mk.injEq,\n        <a>exists_eq_right</a>, \u2190 <a>and_assoc</a>]", [{"full_name": "Finset.mem_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3636, 9], "def_end_pos": [3636, 20]}, {"full_name": "Finset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Function.Embedding.sectr_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [263, 3], "def_end_pos": [263, 8]}, {"full_name": "exists_eq_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [468, 17], "def_end_pos": [468, 32]}, {"full_name": "and_assoc", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [180, 9], "def_end_pos": [180, 18]}]], "state_before": "case mk\n\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\nx : \u03b3\ny : \u03b1\n\u22a2 ((x, y) \u2208 Finset.biUnion s fun x => map (Function.Embedding.sectr x \u03b1) (t x)) \u2194 (x, y).1 \u2208 s \u2227 (x, y).2 \u2208 t (x, y).1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Group.lean", "full_name": "smul_zpow", "start": [125, 1], "end": [128, 28], "traced_tactics": [{"tactic": "cases p <;>\nsimp [smul_pow, smul_inv]", "annotated_tactic": ["cases p <;>\n  simp [<a>smul_pow</a>, <a>smul_inv</a>]", [{"full_name": "smul_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [111, 9], "def_end_pos": [111, 17]}, {"full_name": "smul_inv", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [120, 9], "def_end_pos": [120, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : MulAction \u03b1 \u03b2\ninst\u271d\u00b2 : Group \u03b2\ninst\u271d\u00b9 : SMulCommClass \u03b1 \u03b2 \u03b2\ninst\u271d : IsScalarTower \u03b1 \u03b2 \u03b2\nc : \u03b1\nx : \u03b2\np : \u2124\n\u22a2 (c \u2022 x) ^ p = c ^ p \u2022 x ^ p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Cast/Order.lean", "full_name": "Nat.abs_cast", "start": [132, 1], "end": [133, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "Submodule.map_subtype_range_ofLe", "start": [1173, 1], "end": [1174, 81], "traced_tactics": [{"tactic": "simp [range_ofLe, map_comap_eq, h]", "annotated_tactic": ["simp [<a>range_ofLe</a>, <a>map_comap_eq</a>, h]", [{"full_name": "Submodule.range_ofLe", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [1168, 9], "def_end_pos": [1168, 19]}, {"full_name": "Submodule.map_comap_eq", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [884, 9], "def_end_pos": [884, 38]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : Semiring R\u2082\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R\u2082 M\u2082\np\u271d p'\u271d : Submodule R M\nq : Submodule R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\nF : Type u_20\nsc : SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082\np p' : Submodule R M\nh : p \u2264 p'\n\u22a2 map (Submodule.subtype p') (range (ofLe h)) = p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Submodule.IsPrincipal.generator_map_dvd_of_mem", "start": [144, 1], "end": [147, 21], "traced_tactics": [{"tactic": "rw [\u2190 mem_iff_generator_dvd, Submodule.mem_map]", "annotated_tactic": ["rw [\u2190 <a>mem_iff_generator_dvd</a>, <a>Submodule.mem_map</a>]", [{"full_name": "Submodule.IsPrincipal.mem_iff_generator_dvd", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [132, 9], "def_end_pos": [132, 30]}, {"full_name": "Submodule.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [91, 9], "def_end_pos": [91, 16]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nN : Submodule R M\n\u03d5 : M \u2192\u2097[R] R\ninst\u271d : IsPrincipal (map \u03d5 N)\nx : M\nhx : x \u2208 N\n\u22a2 generator (map \u03d5 N) \u2223 \u2191\u03d5 x", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nN : Submodule R M\n\u03d5 : M \u2192\u2097[R] R\ninst\u271d : IsPrincipal (map \u03d5 N)\nx : M\nhx : x \u2208 N\n\u22a2 \u2203 y \u2208 N, \u2191\u03d5 y = \u2191\u03d5 x"}, {"tactic": "exact \u27e8x, hx, rfl\u27e9", "annotated_tactic": ["exact \u27e8x, hx, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Module R M\nN : Submodule R M\n\u03d5 : M \u2192\u2097[R] R\ninst\u271d : IsPrincipal (map \u03d5 N)\nx : M\nhx : x \u2208 N\n\u22a2 \u2203 y \u2208 N, \u2191\u03d5 y = \u2191\u03d5 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Nontrivial/Defs.lean", "full_name": "nontrivial_iff", "start": [34, 1], "end": [35, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.comap_unop_pow", "start": [523, 1], "end": [526, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "LinearMap.map_comp_rTensor", "start": [1182, 1], "end": [1184, 61], "traced_tactics": [{"tactic": "simp only [lTensor, rTensor, \u2190 map_comp, id_comp, comp_id]", "annotated_tactic": ["simp only [<a>lTensor</a>, <a>rTensor</a>, \u2190 <a>map_comp</a>, <a>id_comp</a>, <a>comp_id</a>]", [{"full_name": "LinearMap.lTensor", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [1020, 5], "def_end_pos": [1020, 12]}, {"full_name": "LinearMap.rTensor", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [1025, 5], "def_end_pos": [1025, 12]}, {"full_name": "TensorProduct.map_comp", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [798, 9], "def_end_pos": [798, 17]}, {"full_name": "LinearMap.id_comp", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [564, 9], "def_end_pos": [564, 16]}, {"full_name": "LinearMap.comp_id", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [559, 9], "def_end_pos": [559, 16]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2074 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u00b3 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : AddCommMonoid P\ninst\u271d\u2078 : AddCommMonoid Q\ninst\u271d\u2077 : AddCommMonoid S\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : Module R Q\ninst\u271d\u00b2 : Module R S\ninst\u271d\u00b9 : DistribMulAction R' M\ninst\u271d : Module R'' M\ng\u271d : P \u2192\u2097[R] Q\nf\u271d : N \u2192\u2097[R] P\nf : M \u2192\u2097[R] P\ng : N \u2192\u2097[R] Q\nf' : S \u2192\u2097[R] M\n\u22a2 comp (map f g) (rTensor N f') = map (comp f f') g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Equiv.lean", "full_name": "MvPolynomial.iterToSum_C_X", "start": [205, 1], "end": [206, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "LatticeHom.symm_dual_comp", "start": [1532, 1], "end": [1535, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/MinMax.lean", "full_name": "List.not_lt_maximum_of_mem'", "start": [330, 1], "end": [333, 94], "traced_tactics": [{"tactic": "cases h : l.maximum", "annotated_tactic": ["cases h : l.maximum", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\n\u22a2 \u00acmaximum l < \u2191a", "state_after": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\nh : maximum l = none\n\u22a2 \u00acnone < \u2191a\n\ncase some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\nval\u271d : \u03b1\nh : maximum l = some val\u271d\n\u22a2 \u00acsome val\u271d < \u2191a"}, {"tactic": "simp_all", "annotated_tactic": ["simp_all", []], "state_before": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\nh : maximum l = none\n\u22a2 \u00acnone < \u2191a", "state_after": "no goals"}, {"tactic": "simp [WithBot.some_eq_coe, WithBot.coe_lt_coe, not_lt_maximum_of_mem ha h, not_false_iff]", "annotated_tactic": ["simp [<a>WithBot.some_eq_coe</a>, <a>WithBot.coe_lt_coe</a>, <a>not_lt_maximum_of_mem</a> ha h, <a>not_false_iff</a>]", [{"full_name": "WithBot.some_eq_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [81, 9], "def_end_pos": [81, 20]}, {"full_name": "WithBot.coe_lt_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [280, 9], "def_end_pos": [280, 19]}, {"full_name": "List.not_lt_maximum_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/List/MinMax.lean", "def_pos": [322, 9], "def_end_pos": [322, 30]}, {"full_name": "not_false_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [82, 9], "def_end_pos": [82, 22]}]], "state_before": "case some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\nval\u271d : \u03b1\nh : maximum l = some val\u271d\n\u22a2 \u00acsome val\u271d < \u2191a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Finite.lean", "full_name": "Set.Finite.smul_set", "start": [104, 1], "end": [105, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Bits.lean", "full_name": "Nat.bit1_bits", "start": [227, 1], "end": [228, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.Nonempty.toList_ne_nil", "start": [3469, 1], "end": [3470, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "ScottContinuous.monotone", "start": [1659, 11], "end": [1665, 20], "traced_tactics": [{"tactic": "refine' fun a b hab =>\n  (h (insert_nonempty _ _) (directedOn_pair le_refl hab) _).1\n    (mem_image_of_mem _ <| mem_insert _ _)", "annotated_tactic": ["refine' fun a b hab =>\n    (h (<a>insert_nonempty</a> _ _) (<a>directedOn_pair</a> <a>le_refl</a> hab) _).1\n      (<a>mem_image_of_mem</a> _ <| <a>mem_insert</a> _ _)", [{"full_name": "Set.insert_nonempty", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1210, 9], "def_end_pos": [1210, 24]}, {"full_name": "directedOn_pair", "def_path": "lake-packages/mathlib/Mathlib/Order/Directed.lean", "def_pos": [246, 9], "def_end_pos": [246, 24]}, {"full_name": "le_refl", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [50, 9], "def_end_pos": [50, 16]}, {"full_name": "Set.mem_image_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [240, 9], "def_end_pos": [240, 25]}, {"full_name": "Set.mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1119, 9], "def_end_pos": [1119, 19]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nh : ScottContinuous f\n\u22a2 Monotone f", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na\u271d : \u03b1\nh : ScottContinuous f\na b : \u03b1\nhab : a \u2264 b\n\u22a2 IsLUB {a, b} b"}, {"tactic": "rw [IsLUB, upperBounds_insert, upperBounds_singleton,\n  inter_eq_self_of_subset_right (Ici_subset_Ici.2 hab)]", "annotated_tactic": ["rw [<a>IsLUB</a>, <a>upperBounds_insert</a>, <a>upperBounds_singleton</a>,\n    <a>inter_eq_self_of_subset_right</a> (<a>Ici_subset_Ici</a>.2 hab)]", [{"full_name": "IsLUB", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [76, 5], "def_end_pos": [76, 10]}, {"full_name": "upperBounds_insert", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [971, 9], "def_end_pos": [971, 27]}, {"full_name": "upperBounds_singleton", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [641, 9], "def_end_pos": [641, 30]}, {"full_name": "Set.inter_eq_self_of_subset_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [984, 9], "def_end_pos": [984, 38]}, {"full_name": "Set.Ici_subset_Ici", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [415, 9], "def_end_pos": [415, 23]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na\u271d : \u03b1\nh : ScottContinuous f\na b : \u03b1\nhab : a \u2264 b\n\u22a2 IsLUB {a, b} b", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na\u271d : \u03b1\nh : ScottContinuous f\na b : \u03b1\nhab : a \u2264 b\n\u22a2 IsLeast (Ici b) b"}, {"tactic": "exact isLeast_Ici", "annotated_tactic": ["exact <a>isLeast_Ici</a>", [{"full_name": "isLeast_Ici", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [510, 9], "def_end_pos": [510, 20]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\na\u271d : \u03b1\nh : ScottContinuous f\na b : \u03b1\nhab : a \u2264 b\n\u22a2 IsLeast (Ici b) b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "bot_unique", "start": [359, 1], "end": [360, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.ceil_pos", "start": [1283, 1], "end": [1283, 65], "traced_tactics": [{"tactic": "rw [lt_ceil, cast_zero]", "annotated_tactic": ["rw [<a>lt_ceil</a>, <a>cast_zero</a>]", [{"full_name": "Int.lt_ceil", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1184, 9], "def_end_pos": [1184, 16]}, {"full_name": "Int.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 18]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\n\u22a2 0 < \u2308a\u2309 \u2194 0 < a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.append_eq_cons_iff", "start": [366, 1], "end": [370, 97], "traced_tactics": [{"tactic": "cases a <;>\n  simp only [and_assoc, @eq_comm _ c, nil_append, cons_append, cons.injEq, true_and_iff,\n    false_and_iff, exists_false, false_or_iff, or_false_iff, exists_and_left, exists_eq_left']", "annotated_tactic": ["cases a <;>\n    simp only [<a>and_assoc</a>, @<a>eq_comm</a> _ c, <a>nil_append</a>, <a>cons_append</a>, cons.injEq, <a>true_and_iff</a>,\n      <a>false_and_iff</a>, <a>exists_false</a>, <a>false_or_iff</a>, <a>or_false_iff</a>, <a>exists_and_left</a>, <a>exists_eq_left'</a>]", [{"full_name": "and_assoc", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [180, 9], "def_end_pos": [180, 18]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}, {"full_name": "List.nil_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [92, 17], "def_end_pos": [92, 27]}, {"full_name": "List.cons_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [99, 17], "def_end_pos": [99, 28]}, {"full_name": "true_and_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [147, 9], "def_end_pos": [147, 21]}, {"full_name": "false_and_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [151, 9], "def_end_pos": [151, 22]}, {"full_name": "exists_false", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [439, 17], "def_end_pos": [439, 29]}, {"full_name": "false_or_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [185, 9], "def_end_pos": [185, 21]}, {"full_name": "or_false_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [187, 9], "def_end_pos": [187, 21]}, {"full_name": "exists_and_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [471, 17], "def_end_pos": [471, 32]}, {"full_name": "exists_eq_left'", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [476, 17], "def_end_pos": [476, 32]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 a b c : List \u03b1\nx : \u03b1\n\u22a2 a ++ b = x :: c \u2194 a = [] \u2227 b = x :: c \u2228 \u2203 a', a = x :: a' \u2227 c = a' ++ b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_neg_iff", "start": [682, 1], "end": [683, 35], "traced_tactics": [{"tactic": "simp [division_def, mul_neg_iff]", "annotated_tactic": ["simp [<a>division_def</a>, <a>mul_neg_iff</a>]", [{"full_name": "division_def", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [982, 7], "def_end_pos": [982, 19]}, {"full_name": "mul_neg_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [1051, 9], "def_end_pos": [1051, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\n\u22a2 a / b < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Lattice.lean", "full_name": "Nat.iSup_le_succ", "start": [202, 1], "end": [203, 44], "traced_tactics": [{"tactic": "simp_rw [\u2190 Nat.lt_succ_iff, iSup_lt_succ]", "annotated_tactic": ["simp_rw [\u2190 <a>Nat.lt_succ_iff</a>, <a>iSup_lt_succ</a>]", [{"full_name": "Nat.lt_succ_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [200, 9], "def_end_pos": [200, 20]}, {"full_name": "Nat.iSup_lt_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Lattice.lean", "def_pos": [185, 9], "def_end_pos": [185, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nu : \u2115 \u2192 \u03b1\nn : \u2115\n\u22a2 \u2a06 k, \u2a06 (_ : k \u2264 n + 1), u k = (\u2a06 k, \u2a06 (_ : k \u2264 n), u k) \u2294 u (n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.periodicOrbit_eq_nil_of_not_periodic_pt", "start": [511, 1], "end": [513, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.sum_smul_index'", "start": [1625, 1], "end": [1627, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ico_union_Ici'", "start": [1297, 1], "end": [1303, 30], "traced_tactics": [{"tactic": "ext1 x", "annotated_tactic": ["ext1 x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\n\u22a2 Ico a b \u222a Ici c = Ici (min a c)", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\n\u22a2 x \u2208 Ico a b \u222a Ici c \u2194 x \u2208 Ici (min a c)"}, {"tactic": "simp_rw [mem_union, mem_Ico, mem_Ici, min_le_iff]", "annotated_tactic": ["simp_rw [<a>mem_union</a>, <a>mem_Ico</a>, <a>mem_Ici</a>, <a>min_le_iff</a>]", [{"full_name": "Set.mem_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}, {"full_name": "Set.mem_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [121, 9], "def_end_pos": [121, 16]}, {"full_name": "Set.mem_Ici", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [146, 9], "def_end_pos": [146, 16]}, {"full_name": "min_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [43, 9], "def_end_pos": [43, 19]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\n\u22a2 x \u2208 Ico a b \u222a Ici c \u2194 x \u2208 Ici (min a c)", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x"}, {"tactic": "by_cases hc : c \u2264 x", "annotated_tactic": ["by_cases hc : c \u2264 x", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : c \u2264 x\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x"}, {"tactic": "simp only [hc, or_true]", "annotated_tactic": ["simp only [hc, <a>or_true</a>]", [{"full_name": "or_true", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [94, 17], "def_end_pos": [94, 24]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : c \u2264 x\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x", "state_after": "no goals"}, {"tactic": "have hxb : x < b := (lt_of_not_ge hc).trans_le h\u2081", "annotated_tactic": ["have hxb : x < b := (<a>lt_of_not_ge</a> hc).<a>trans_le</a> h\u2081", [{"full_name": "lt_of_not_ge", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [332, 9], "def_end_pos": [332, 21]}, {"full_name": "LT.lt.trans_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [148, 7], "def_end_pos": [148, 21]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\nhxb : x < b\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x"}, {"tactic": "simp only [hxb, and_true]", "annotated_tactic": ["simp only [hxb, <a>and_true</a>]", [{"full_name": "and_true", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [89, 17], "def_end_pos": [89, 25]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c \u2264 b\nx : \u03b1\nhc : \u00acc \u2264 x\nhxb : x < b\n\u22a2 a \u2264 x \u2227 x < b \u2228 c \u2264 x \u2194 a \u2264 x \u2228 c \u2264 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.tendsto_map", "start": [3061, 1], "end": [3062, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "AddValuation.of_apply", "start": [641, 1], "end": [641, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/WF.lean", "full_name": "Std.RBNode.balance1_All", "start": [58, 9], "end": [60, 61], "traced_tactics": [{"tactic": "unfold balance1", "annotated_tactic": ["unfold <a>balance1</a>", [{"full_name": "Std.RBNode.balance1", "def_path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [260, 15], "def_end_pos": [260, 23]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 All p (balance1 l v r) \u2194 p v \u2227 All p l \u2227 All p r", "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 All p\n      (match l, v, r with\n      | node red (node red a x b) y c, z, d => node red (node black a x b) y (node black c z d)\n      | node red a x (node red b y c), z, d => node red (node black a x b) y (node black c z d)\n      | a, x, b => node black a x b) \u2194\n    p v \u2227 All p l \u2227 All p r"}, {"tactic": "split <;> simp [and_assoc, and_left_comm]", "annotated_tactic": ["split <;> simp [<a>and_assoc</a>, <a>and_left_comm</a>]", [{"full_name": "and_assoc", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [180, 9], "def_end_pos": [180, 18]}, {"full_name": "and_left_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [183, 9], "def_end_pos": [183, 22]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 All p\n      (match l, v, r with\n      | node red (node red a x b) y c, z, d => node red (node black a x b) y (node black c z d)\n      | node red a x (node red b y c), z, d => node red (node black a x b) y (node black c z d)\n      | a, x, b => node black a x b) \u2194\n    p v \u2227 All p l \u2227 All p r", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.filter_false_of_mem", "start": [2789, 1], "end": [2789, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.inter_right_comm", "start": [1672, 1], "end": [1673, 56], "traced_tactics": [{"tactic": "simp only [mem_inter, and_right_comm]", "annotated_tactic": ["simp only [<a>mem_inter</a>, <a>and_right_comm</a>]", [{"full_name": "Finset.mem_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1618, 9], "def_end_pos": [1618, 18]}, {"full_name": "and_right_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [186, 9], "def_end_pos": [186, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns s\u2081\u271d s\u2082\u271d t t\u2081 t\u2082 u v : Finset \u03b1\na b : \u03b1\ns\u2081 s\u2082 s\u2083 : Finset \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 s\u2081 \u2229 s\u2082 \u2229 s\u2083 \u2194 x\u271d \u2208 s\u2081 \u2229 s\u2083 \u2229 s\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "full_name": "IsUnit.ne_zero", "start": [52, 1], "end": [54, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/List.lean", "full_name": "Set.range_list_map", "start": [25, 1], "end": [32, 33], "traced_tactics": [{"tactic": "refine'\n  antisymm (range_subset_iff.2 fun l => forall_mem_map_iff.2 fun y _ => mem_range_self _)\n    fun l hl => _", "annotated_tactic": ["refine'\n    <a>antisymm</a> (<a>range_subset_iff</a>.2 fun l => <a>forall_mem_map_iff</a>.2 fun y _ => <a>mem_range_self</a> _)\n      fun l hl => _", [{"full_name": "antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [316, 9], "def_end_pos": [316, 17]}, {"full_name": "Set.range_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [749, 9], "def_end_pos": [749, 25]}, {"full_name": "List.forall_mem_map_iff", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [162, 9], "def_end_pos": [162, 27]}, {"full_name": "Set.mem_range_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [680, 9], "def_end_pos": [680, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 range (map f) = {l | \u2200 x \u2208 l, x \u2208 range f}", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\nl : List \u03b2\nhl : l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 l \u2208 range (map f)"}, {"tactic": "induction' l with a l ihl", "annotated_tactic": ["induction' l with a l ihl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\nl : List \u03b2\nhl : l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 l \u2208 range (map f)", "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\nhl : [] \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 [] \u2208 range (map f)\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b2\nl : List \u03b2\nihl : l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f} \u2192 l \u2208 range (map f)\nhl : a :: l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 a :: l \u2208 range (map f)"}, {"tactic": "rcases ihl fun x hx => hl x <| subset_cons _ _ hx with \u27e8l, rfl\u27e9", "annotated_tactic": ["rcases ihl fun x hx => hl x <| <a>subset_cons</a> _ _ hx with \u27e8l, rfl\u27e9", [{"full_name": "List.subset_cons", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [306, 17], "def_end_pos": [306, 28]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b2\nl : List \u03b2\nihl : l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f} \u2192 l \u2208 range (map f)\nhl : a :: l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 a :: l \u2208 range (map f)", "state_after": "case cons.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b2\nl : List \u03b1\nihl : map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f} \u2192 map f l \u2208 range (map f)\nhl : a :: map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 a :: map f l \u2208 range (map f)"}, {"tactic": "rcases hl a (mem_cons_self _ _) with \u27e8a, rfl\u27e9", "annotated_tactic": ["rcases hl a (<a>mem_cons_self</a> _ _) with \u27e8a, rfl\u27e9", [{"full_name": "List.mem_cons_self", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [61, 9], "def_end_pos": [61, 22]}]], "state_before": "case cons.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b2\nl : List \u03b1\nihl : map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f} \u2192 map f l \u2208 range (map f)\nhl : a :: map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 a :: map f l \u2208 range (map f)", "state_after": "case cons.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\nl : List \u03b1\nihl : map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f} \u2192 map f l \u2208 range (map f)\na : \u03b1\nhl : f a :: map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 f a :: map f l \u2208 range (map f)"}, {"tactic": "exact \u27e8a :: l, map_cons _ _ _\u27e9", "annotated_tactic": ["exact \u27e8a :: l, <a>map_cons</a> _ _ _\u27e9", [{"full_name": "List.map_cons", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [99, 17], "def_end_pos": [99, 25]}]], "state_before": "case cons.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d : List \u03b1\nf : \u03b1 \u2192 \u03b2\nl : List \u03b1\nihl : map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f} \u2192 map f l \u2208 range (map f)\na : \u03b1\nhl : f a :: map f l \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 f a :: map f l \u2208 range (map f)", "state_after": "no goals"}, {"tactic": "exact \u27e8[], rfl\u27e9", "annotated_tactic": ["exact \u27e8[], <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\nhl : [] \u2208 {l | \u2200 x \u2208 l, x \u2208 range f}\n\u22a2 [] \u2208 range (map f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.comap_iInf", "start": [2278, 1], "end": [2279, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Star/SelfAdjoint.lean", "full_name": "IsSelfAdjoint.mul", "start": [226, 1], "end": [227, 67], "traced_tactics": [{"tactic": "simp only [isSelfAdjoint_iff, star_mul', hx.star_eq, hy.star_eq]", "annotated_tactic": ["simp only [<a>isSelfAdjoint_iff</a>, <a>star_mul'</a>, hx.star_eq, hy.star_eq]", [{"full_name": "isSelfAdjoint_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Star/SelfAdjoint.lean", "def_pos": [75, 9], "def_end_pos": [75, 33]}, {"full_name": "star_mul'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Star/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 18]}]], "state_before": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b9 : CommSemigroup R\ninst\u271d : StarMul R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n\u22a2 IsSelfAdjoint (x * y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "sq_abs", "start": [335, 1], "end": [335, 88], "traced_tactics": [{"tactic": "simpa only [sq] using abs_mul_abs_self x", "annotated_tactic": ["simpa only [<a>sq</a>] using <a>abs_mul_abs_self</a> x", [{"full_name": "sq", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [106, 7], "def_end_pos": [106, 9]}, {"full_name": "abs_mul_abs_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Abs.lean", "def_pos": [49, 9], "def_end_pos": [49, 25]}]], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : LinearOrderedRing R\nx\u271d y x : R\n\u22a2 |x| ^ 2 = x ^ 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.prod_mono_right", "start": [86, 1], "end": [87, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.Nonempty.preimage", "start": [485, 1], "end": [489, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "extensional_of_trichotomous_of_irrefl", "start": [179, 1], "end": [182, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeq.lean", "full_name": "CauSeq.exists_gt", "start": [799, 1], "end": [803, 39], "traced_tactics": [{"tactic": "rw [sub_apply, const_apply, le_sub_iff_add_le', add_le_add_iff_right]", "annotated_tactic": ["rw [<a>sub_apply</a>, <a>const_apply</a>, <a>le_sub_iff_add_le'</a>, <a>add_le_add_iff_right</a>]", [{"full_name": "CauSeq.sub_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/CauSeq.lean", "def_pos": [336, 9], "def_end_pos": [336, 18]}, {"full_name": "CauSeq.const_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/CauSeq.lean", "def_pos": [234, 9], "def_end_pos": [234, 20]}, {"full_name": "le_sub_iff_add_le'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [803, 3], "def_end_pos": [803, 14]}, {"full_name": "add_le_add_iff_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [90, 3], "def_end_pos": [90, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nf : CauSeq \u03b1 abs\nK : \u03b1\nH : \u2200 (i : \u2115), |\u2191f i| < K\ni : \u2115\nx\u271d : i \u2265 0\n\u22a2 1 \u2264 \u2191(const (K + 1) - f) i", "state_after": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nf : CauSeq \u03b1 abs\nK : \u03b1\nH : \u2200 (i : \u2115), |\u2191f i| < K\ni : \u2115\nx\u271d : i \u2265 0\n\u22a2 \u2191f i \u2264 K"}, {"tactic": "exact le_of_lt (abs_lt.1 (H _)).2", "annotated_tactic": ["exact <a>le_of_lt</a> (<a>abs_lt</a>.1 (H _)).2", [{"full_name": "le_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [110, 9], "def_end_pos": [110, 17]}, {"full_name": "abs_lt", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [196, 9], "def_end_pos": [196, 15]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedField \u03b1\nf : CauSeq \u03b1 abs\nK : \u03b1\nH : \u2200 (i : \u2115), |\u2191f i| < K\ni : \u2115\nx\u271d : i \u2265 0\n\u22a2 \u2191f i \u2264 K", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "full_name": "Set.Nonempty.cInf_mem", "start": [63, 1], "end": [64, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "full_name": "Ring.inverse_mul_eq_iff_eq_mul", "start": [131, 1], "end": [133, 55], "traced_tactics": [{"tactic": "rw [\u2190 h1, mul_inverse_cancel_left _ _ h]", "annotated_tactic": ["rw [\u2190 h1, <a>mul_inverse_cancel_left</a> _ _ h]", [{"full_name": "Ring.mul_inverse_cancel_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [123, 9], "def_end_pos": [123, 32]}]], "state_before": "\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d : MonoidWithZero M\u2080\nx y z : M\u2080\nh : IsUnit x\nh1 : inverse x * y = z\n\u22a2 y = x * z", "state_after": "no goals"}, {"tactic": "rw [h1, inverse_mul_cancel_left _ _ h]", "annotated_tactic": ["rw [h1, <a>inverse_mul_cancel_left</a> _ _ h]", [{"full_name": "Ring.inverse_mul_cancel_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "def_pos": [127, 9], "def_end_pos": [127, 32]}]], "state_before": "\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d : MonoidWithZero M\u2080\nx y z : M\u2080\nh : IsUnit x\nh1 : y = x * z\n\u22a2 inverse x * y = z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "full_name": "Finset.Nonempty.cSup_eq_max'", "start": [41, 1], "end": [42, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/NormNum/Pow.lean", "full_name": "Mathlib.Meta.NormNum.IsNatPowT.bit0", "start": [43, 1], "end": [44, 47], "traced_tactics": [{"tactic": "simp [two_mul, pow_add, \u2190 h1]", "annotated_tactic": ["simp [<a>two_mul</a>, <a>pow_add</a>, \u2190 h1]", [{"full_name": "two_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [177, 9], "def_end_pos": [177, 16]}, {"full_name": "pow_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 16]}]], "state_before": "a b : \u2115\nc : \u2115\nh1 : Nat.pow a b = c\n\u22a2 Nat.pow a (2 * b) = Nat.mul c c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.prod_pprod", "start": [897, 1], "end": [899, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.support_map_subset", "start": [1203, 1], "end": [1207, 42], "traced_tactics": [{"tactic": "intro x", "annotated_tactic": ["intro x", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : R[X]\n\u22a2 support (map f p) \u2286 support p", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : R[X]\nx : \u2115\n\u22a2 x \u2208 support (map f p) \u2192 x \u2208 support p"}, {"tactic": "contrapose!", "annotated_tactic": ["contrapose!", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : R[X]\nx : \u2115\n\u22a2 x \u2208 support (map f p) \u2192 x \u2208 support p", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : R[X]\nx : \u2115\n\u22a2 x \u2209 support p \u2192 x \u2209 support (map f p)"}, {"tactic": "simp (config := { contextual := true })", "annotated_tactic": ["simp (config := { contextual := <a>true</a> })", [{"full_name": "Bool.true", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [549, 5], "def_end_pos": [549, 9]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nf : R \u2192+* S\np : R[X]\nx : \u2115\n\u22a2 x \u2209 support p \u2192 x \u2209 support (map f p)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Fold.lean", "full_name": "Multiset.fold_union_inter", "start": [109, 1], "end": [111, 51], "traced_tactics": [{"tactic": "rw [\u2190 fold_add op, union_add_inter, fold_add op]", "annotated_tactic": ["rw [\u2190 <a>fold_add</a> op, <a>union_add_inter</a>, <a>fold_add</a> op]", [{"full_name": "Multiset.fold_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Fold.lean", "def_pos": [76, 9], "def_end_pos": [76, 17]}, {"full_name": "Multiset.union_add_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1898, 9], "def_end_pos": [1898, 24]}, {"full_name": "Multiset.fold_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Fold.lean", "def_pos": [76, 9], "def_end_pos": [76, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nhc : IsCommutative \u03b1 op\nha : IsAssociative \u03b1 op\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\nb\u2081 b\u2082 : \u03b1\n\u22a2 op (fold op b\u2081 (s\u2081 \u222a s\u2082)) (fold op b\u2082 (s\u2081 \u2229 s\u2082)) = op (fold op b\u2081 s\u2081) (fold op b\u2082 s\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "NeZero.of_noZeroSMulDivisors", "start": [787, 1], "end": [791, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "MulSemiringAction.toAlgEquiv_injective", "start": [834, 1], "end": [836, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "isCoprime_of_irreducible_dvd", "start": [408, 1], "end": [415, 17], "traced_tactics": [{"tactic": "apply isCoprime_of_dvd x y nonzero", "annotated_tactic": ["apply <a>isCoprime_of_dvd</a> x y nonzero", [{"full_name": "isCoprime_of_dvd", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [389, 9], "def_end_pos": [389, 25]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\n\u22a2 IsCoprime x y", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\n\u22a2 \u2200 z \u2208 nonunits R, z \u2260 0 \u2192 z \u2223 x \u2192 \u00acz \u2223 y"}, {"tactic": "intro z znu znz zx zy", "annotated_tactic": ["intro z znu znz zx zy", []], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\n\u22a2 \u2200 z \u2208 nonunits R, z \u2260 0 \u2192 z \u2223 x \u2192 \u00acz \u2223 y", "state_after": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\nz : R\nznu : z \u2208 nonunits R\nznz : z \u2260 0\nzx : z \u2223 x\nzy : z \u2223 y\n\u22a2 False"}, {"tactic": "obtain \u27e8i, h1, h2\u27e9 := WfDvdMonoid.exists_irreducible_factor znu znz", "annotated_tactic": ["obtain \u27e8i, h1, h2\u27e9 := <a>WfDvdMonoid.exists_irreducible_factor</a> znu znz", [{"full_name": "WfDvdMonoid.exists_irreducible_factor", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [76, 9], "def_end_pos": [76, 34]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\nz : R\nznu : z \u2208 nonunits R\nznz : z \u2260 0\nzx : z \u2223 x\nzy : z \u2223 y\n\u22a2 False", "state_after": "case intro.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\nz : R\nznu : z \u2208 nonunits R\nznz : z \u2260 0\nzx : z \u2223 x\nzy : z \u2223 y\ni : R\nh1 : Irreducible i\nh2 : i \u2223 z\n\u22a2 False"}, {"tactic": "apply dvd_trans h2", "annotated_tactic": ["apply <a>dvd_trans</a> h2", [{"full_name": "dvd_trans", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [71, 9], "def_end_pos": [71, 18]}]], "state_before": "case intro.intro.a\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\nz : R\nznu : z \u2208 nonunits R\nznz : z \u2260 0\nzx : z \u2223 x\nzy : z \u2223 y\ni : R\nh1 : Irreducible i\nh2 : i \u2223 z\n\u22a2 i \u2223 y", "state_after": "case intro.intro.a\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\nz : R\nznu : z \u2208 nonunits R\nznz : z \u2260 0\nzx : z \u2223 x\nzy : z \u2223 y\ni : R\nh1 : Irreducible i\nh2 : i \u2223 z\n\u22a2 z \u2223 y"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "case intro.intro.a\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\nnonzero : \u00ac(x = 0 \u2227 y = 0)\nH : \u2200 (z : R), Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y\nz : R\nznu : z \u2208 nonunits R\nznz : z \u2260 0\nzx : z \u2223 x\nzy : z \u2223 y\ni : R\nh1 : Irreducible i\nh2 : i \u2223 z\n\u22a2 z \u2223 y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.map_const", "start": [2161, 1], "end": [2163, 34], "traced_tactics": [{"tactic": "ext s", "annotated_tactic": ["ext s", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\ninst\u271d : NeBot f\nc : \u03b2\n\u22a2 map (fun x => c) f = pure c", "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt : Set \u03b2\ninst\u271d : NeBot f\nc : \u03b2\ns : Set \u03b2\n\u22a2 s \u2208 map (fun x => c) f \u2194 s \u2208 pure c"}, {"tactic": "by_cases h : c \u2208 s <;> simp [h]", "annotated_tactic": ["by_cases h : c \u2208 s <;> simp [h]", []], "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt : Set \u03b2\ninst\u271d : NeBot f\nc : \u03b2\ns : Set \u03b2\n\u22a2 s \u2208 map (fun x => c) f \u2194 s \u2208 pure c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Opposites.lean", "full_name": "MulOpposite.op_surjective", "start": [157, 1], "end": [158, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.rootMultiplicity_C", "start": [627, 1], "end": [628, 80], "traced_tactics": [{"tactic": "simp only [rootMultiplicity_eq_zero_iff, IsRoot, eval_C, C_eq_zero, imp_self]", "annotated_tactic": ["simp only [<a>rootMultiplicity_eq_zero_iff</a>, <a>IsRoot</a>, <a>eval_C</a>, <a>C_eq_zero</a>, <a>imp_self</a>]", [{"full_name": "Polynomial.rootMultiplicity_eq_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [605, 9], "def_end_pos": [605, 37]}, {"full_name": "Polynomial.IsRoot", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [492, 5], "def_end_pos": [492, 11]}, {"full_name": "Polynomial.eval_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [359, 9], "def_end_pos": [359, 15]}, {"full_name": "Polynomial.C_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [803, 9], "def_end_pos": [803, 18]}, {"full_name": "imp_self", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [122, 17], "def_end_pos": [122, 25]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nr a : R\n\u22a2 rootMultiplicity a (\u2191C r) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.leadingCoeff_mul'", "start": [975, 1], "end": [979, 6], "traced_tactics": [{"tactic": "unfold leadingCoeff", "annotated_tactic": ["unfold <a>leadingCoeff</a>", [{"full_name": "Polynomial.leadingCoeff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [70, 5], "def_end_pos": [70, 17]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u03b9 : Type u_1\nh : leadingCoeff p * leadingCoeff q \u2260 0\n\u22a2 leadingCoeff (p * q) = leadingCoeff p * leadingCoeff q", "state_after": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u03b9 : Type u_1\nh : leadingCoeff p * leadingCoeff q \u2260 0\n\u22a2 coeff (p * q) (natDegree (p * q)) = coeff p (natDegree p) * coeff q (natDegree q)"}, {"tactic": "rw [natDegree_mul' h, coeff_mul_degree_add_degree]", "annotated_tactic": ["rw [<a>natDegree_mul'</a> h, <a>coeff_mul_degree_add_degree</a>]", [{"full_name": "Polynomial.natDegree_mul'", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [967, 9], "def_end_pos": [967, 23]}, {"full_name": "Polynomial.coeff_mul_degree_add_degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [915, 9], "def_end_pos": [915, 36]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u03b9 : Type u_1\nh : leadingCoeff p * leadingCoeff q \u2260 0\n\u22a2 coeff (p * q) (natDegree (p * q)) = coeff p (natDegree p) * coeff q (natDegree q)", "state_after": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u03b9 : Type u_1\nh : leadingCoeff p * leadingCoeff q \u2260 0\n\u22a2 leadingCoeff p * leadingCoeff q = coeff p (natDegree p) * coeff q (natDegree q)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u03b9 : Type u_1\nh : leadingCoeff p * leadingCoeff q \u2260 0\n\u22a2 leadingCoeff p * leadingCoeff q = coeff p (natDegree p) * coeff q (natDegree q)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.lt_add_one_of_le", "start": [1257, 1], "end": [1257, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Pi.lean", "full_name": "Pi.mulSingle_inv", "start": [507, 1], "end": [509, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.two_mul", "start": [707, 11], "end": [707, 78], "traced_tactics": [{"tactic": "simp [Nat.succ_mul]", "annotated_tactic": ["simp [<a>Nat.succ_mul</a>]", [{"full_name": "Nat.succ_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [169, 9], "def_end_pos": [169, 17]}]], "state_before": "n : Nat\n\u22a2 2 * n = n + n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.vsub_union", "start": [690, 1], "end": [691, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "one_div_le_of_neg", "start": [817, 1], "end": [818, 34], "traced_tactics": [{"tactic": "simpa using inv_le_of_neg ha hb", "annotated_tactic": ["simpa using <a>inv_le_of_neg</a> ha hb", [{"full_name": "inv_le_of_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [761, 9], "def_end_pos": [761, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedField \u03b1\na b c d : \u03b1\nn : \u2124\nha : a < 0\nhb : b < 0\n\u22a2 1 / a \u2264 b \u2194 1 / b \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_eq_nat_iff", "start": [1472, 1], "end": [1473, 51], "traced_tactics": [{"tactic": "rw [\u2190 lift_mk_fin, \u2190 lift_uzero #\u03b1, lift_mk_eq']", "annotated_tactic": ["rw [\u2190 <a>lift_mk_fin</a>, \u2190 <a>lift_uzero</a> #\u03b1, <a>lift_mk_eq'</a>]", [{"full_name": "Cardinal.lift_mk_fin", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 20]}, {"full_name": "Cardinal.lift_uzero", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [231, 9], "def_end_pos": [231, 19]}, {"full_name": "Cardinal.lift_mk_eq'", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [335, 9], "def_end_pos": [335, 20]}]], "state_before": "\u03b1\u271d \u03b2 \u03b1 : Type u\nn : \u2115\n\u22a2 #\u03b1 = \u2191n \u2194 Nonempty (\u03b1 \u2243 Fin n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Power.lean", "full_name": "zpow_lt_iff_lt", "start": [79, 1], "end": [80, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.prod_mono_left", "start": [1966, 1], "end": [1966, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.disjoint_cons_left", "start": [1600, 9], "end": [1601, 75], "traced_tactics": [{"tactic": "simp [singleton_disjoint]", "annotated_tactic": ["simp [<a>singleton_disjoint</a>]", [{"full_name": "List.singleton_disjoint", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1589, 22], "def_end_pos": [1589, 40]}]], "state_before": "\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl\u2081 l\u2082 : List \u03b1\u271d\n\u22a2 Disjoint [a] l\u2082 \u2227 Disjoint l\u2081 l\u2082 \u2194 \u00aca \u2208 l\u2082 \u2227 Disjoint l\u2081 l\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.bddAbove", "start": [1616, 11], "end": [1617, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Option/Init/Lemmas.lean", "full_name": "Option.getD_some", "start": [17, 9], "end": [17, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.vecMulVec_apply", "start": [1677, 1], "end": [1678, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.card_le_diff_of_interleaved", "start": [1700, 1], "end": [1707, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "StrictAnti.mul_const_of_neg", "start": [749, 1], "end": [751, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/WF.lean", "full_name": "Std.RBNode.Ordered.ins", "start": [98, 11], "end": [113, 76], "traced_tactics": [{"tactic": "unfold ins", "annotated_tactic": ["unfold <a>ins</a>", [{"full_name": "Std.RBNode.ins", "def_path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [298, 19], "def_end_pos": [298, 22]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\n\u22a2 Ordered cmp (ins cmp x (node red a y b))", "state_after": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\n\u22a2 Ordered cmp\n    (match cmp x y with\n    | Ordering.lt => node red (ins cmp x a) y b\n    | Ordering.gt => node red a y (ins cmp x b)\n    | Ordering.eq => node red a x b)"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\n\u22a2 Ordered cmp\n    (match cmp x y with\n    | Ordering.lt => node red (ins cmp x a) y b\n    | Ordering.gt => node red a y (ins cmp x b)\n    | Ordering.eq => node red a x b)", "state_after": "case h_1\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.lt\n\u22a2 Ordered cmp (node red (ins cmp x a) y b)\n\ncase h_2\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.gt\n\u22a2 Ordered cmp (node red a y (ins cmp x b))\n\ncase h_3\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.eq\n\u22a2 Ordered cmp (node red a x b)"}, {"tactic": "next h => exact \u27e8ay.ins \u27e8h\u27e9, yb, ha.ins, hb\u27e9", "annotated_tactic": ["next h => exact \u27e8ay.ins \u27e8h\u27e9, yb, ha.ins, hb\u27e9", []], "state_before": "case h_1\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.lt\n\u22a2 Ordered cmp (node red (ins cmp x a) y b)", "state_after": "no goals"}, {"tactic": "exact \u27e8ay.ins \u27e8h\u27e9, yb, ha.ins, hb\u27e9", "annotated_tactic": ["exact \u27e8ay.ins \u27e8h\u27e9, yb, ha.ins, hb\u27e9", []], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nh : cmp x y = Ordering.lt\n\u22a2 Ordered cmp (node red (ins cmp x a) y b)", "state_after": "no goals"}, {"tactic": "next h => exact \u27e8ay, yb.ins \u27e8OrientedCmp.cmp_eq_gt.1 h\u27e9, ha, hb.ins\u27e9", "annotated_tactic": ["next h => exact \u27e8ay, yb.ins \u27e8<a>OrientedCmp.cmp_eq_gt</a>.1 h\u27e9, ha, hb.ins\u27e9", [{"full_name": "Std.OrientedCmp.cmp_eq_gt", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [31, 9], "def_end_pos": [31, 18]}]], "state_before": "case h_2\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.gt\n\u22a2 Ordered cmp (node red a y (ins cmp x b))", "state_after": "no goals"}, {"tactic": "exact \u27e8ay, yb.ins \u27e8OrientedCmp.cmp_eq_gt.1 h\u27e9, ha, hb.ins\u27e9", "annotated_tactic": ["exact \u27e8ay, yb.ins \u27e8<a>OrientedCmp.cmp_eq_gt</a>.1 h\u27e9, ha, hb.ins\u27e9", [{"full_name": "Std.OrientedCmp.cmp_eq_gt", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [31, 9], "def_end_pos": [31, 18]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nh : cmp x y = Ordering.gt\n\u22a2 Ordered cmp (node red a y (ins cmp x b))", "state_after": "no goals"}, {"tactic": "next h => exact (\u27e8\n  ay.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_right h).trans h'\u27e9,\n  yb.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_left h).trans h'\u27e9, ha, hb\u27e9)", "annotated_tactic": ["next h => exact (\u27e8\n        ay.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_right</a> h).<a>trans</a> h'\u27e9,\n        yb.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_left</a> h).<a>trans</a> h'\u27e9, ha, hb\u27e9)", [{"full_name": "Std.TransCmp.cmp_congr_right", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [88, 9], "def_end_pos": [88, 24]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}, {"full_name": "Std.TransCmp.cmp_congr_left", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}]], "state_before": "case h_3\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.eq\n\u22a2 Ordered cmp (node red a x b)", "state_after": "no goals"}, {"tactic": "exact (\u27e8\nay.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_right h).trans h'\u27e9,\nyb.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_left h).trans h'\u27e9, ha, hb\u27e9)", "annotated_tactic": ["exact (\u27e8\n        ay.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_right</a> h).<a>trans</a> h'\u27e9,\n        yb.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_left</a> h).<a>trans</a> h'\u27e9, ha, hb\u27e9)", [{"full_name": "Std.TransCmp.cmp_congr_right", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [88, 9], "def_end_pos": [88, 24]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}, {"full_name": "Std.TransCmp.cmp_congr_left", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nh : cmp x y = Ordering.eq\n\u22a2 Ordered cmp (node red a x b)", "state_after": "no goals"}, {"tactic": "unfold ins", "annotated_tactic": ["unfold <a>ins</a>", [{"full_name": "Std.RBNode.ins", "def_path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [298, 19], "def_end_pos": [298, 22]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\n\u22a2 Ordered cmp (ins cmp x (node black a y b))", "state_after": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\n\u22a2 Ordered cmp\n    (match cmp x y with\n    | Ordering.lt => balance1 (ins cmp x a) y b\n    | Ordering.gt => balance2 a y (ins cmp x b)\n    | Ordering.eq => node black a x b)"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\n\u22a2 Ordered cmp\n    (match cmp x y with\n    | Ordering.lt => balance1 (ins cmp x a) y b\n    | Ordering.gt => balance2 a y (ins cmp x b)\n    | Ordering.eq => node black a x b)", "state_after": "case h_1\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.lt\n\u22a2 Ordered cmp (balance1 (ins cmp x a) y b)\n\ncase h_2\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.gt\n\u22a2 Ordered cmp (balance2 a y (ins cmp x b))\n\ncase h_3\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.eq\n\u22a2 Ordered cmp (node black a x b)"}, {"tactic": "next h => exact ha.ins.balance1 (ay.ins \u27e8h\u27e9) yb hb", "annotated_tactic": ["next h => exact ha.ins.balance1 (ay.ins \u27e8h\u27e9) yb hb", []], "state_before": "case h_1\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.lt\n\u22a2 Ordered cmp (balance1 (ins cmp x a) y b)", "state_after": "no goals"}, {"tactic": "exact ha.ins.balance1 (ay.ins \u27e8h\u27e9) yb hb", "annotated_tactic": ["exact ha.ins.balance1 (ay.ins \u27e8h\u27e9) yb hb", []], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nh : cmp x y = Ordering.lt\n\u22a2 Ordered cmp (balance1 (ins cmp x a) y b)", "state_after": "no goals"}, {"tactic": "next h => exact ha.balance2 ay (yb.ins \u27e8OrientedCmp.cmp_eq_gt.1 h\u27e9) hb.ins", "annotated_tactic": ["next h => exact ha.balance2 ay (yb.ins \u27e8<a>OrientedCmp.cmp_eq_gt</a>.1 h\u27e9) hb.ins", [{"full_name": "Std.OrientedCmp.cmp_eq_gt", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [31, 9], "def_end_pos": [31, 18]}]], "state_before": "case h_2\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.gt\n\u22a2 Ordered cmp (balance2 a y (ins cmp x b))", "state_after": "no goals"}, {"tactic": "exact ha.balance2 ay (yb.ins \u27e8OrientedCmp.cmp_eq_gt.1 h\u27e9) hb.ins", "annotated_tactic": ["exact ha.balance2 ay (yb.ins \u27e8<a>OrientedCmp.cmp_eq_gt</a>.1 h\u27e9) hb.ins", [{"full_name": "Std.OrientedCmp.cmp_eq_gt", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [31, 9], "def_end_pos": [31, 18]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nh : cmp x y = Ordering.gt\n\u22a2 Ordered cmp (balance2 a y (ins cmp x b))", "state_after": "no goals"}, {"tactic": "next h => exact (\u27e8\n  ay.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_right h).trans h'\u27e9,\n  yb.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_left h).trans h'\u27e9, ha, hb\u27e9)", "annotated_tactic": ["next h => exact (\u27e8\n        ay.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_right</a> h).<a>trans</a> h'\u27e9,\n        yb.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_left</a> h).<a>trans</a> h'\u27e9, ha, hb\u27e9)", [{"full_name": "Std.TransCmp.cmp_congr_right", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [88, 9], "def_end_pos": [88, 24]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}, {"full_name": "Std.TransCmp.cmp_congr_left", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}]], "state_before": "case h_3\n\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nheq\u271d : cmp x y = Ordering.eq\n\u22a2 Ordered cmp (node black a x b)", "state_after": "no goals"}, {"tactic": "exact (\u27e8\nay.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_right h).trans h'\u27e9,\nyb.imp fun \u27e8h'\u27e9 => \u27e8(TransCmp.cmp_congr_left h).trans h'\u27e9, ha, hb\u27e9)", "annotated_tactic": ["exact (\u27e8\n        ay.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_right</a> h).<a>trans</a> h'\u27e9,\n        yb.imp fun \u27e8h'\u27e9 => \u27e8(<a>TransCmp.cmp_congr_left</a> h).<a>trans</a> h'\u27e9, ha, hb\u27e9)", [{"full_name": "Std.TransCmp.cmp_congr_right", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [88, 9], "def_end_pos": [88, 24]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}, {"full_name": "Std.TransCmp.cmp_congr_left", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [76, 9], "def_end_pos": [76, 23]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nx : \u03b1\na : RBNode \u03b1\ny : \u03b1\nb : RBNode \u03b1\nay : All (fun x => cmpLT cmp x y) a\nyb : All (fun x => cmpLT cmp y x) b\nha : Ordered cmp a\nhb : Ordered cmp b\nx\u271d : Ordering\nh : cmp x y = Ordering.eq\n\u22a2 Ordered cmp (node black a x b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "LinearMap.disjoint_inl_inr", "start": [461, 1], "end": [462, 86], "traced_tactics": [{"tactic": "simp (config := { contextual := true }) [disjoint_def, @eq_comm M 0, @eq_comm M\u2082 0]", "annotated_tactic": ["simp (config := { contextual := <a>true</a> }) [<a>disjoint_def</a>, @<a>eq_comm</a> M 0, @<a>eq_comm</a> M\u2082 0]", [{"full_name": "Bool.true", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [549, 5], "def_end_pos": [549, 9]}, {"full_name": "Submodule.disjoint_def", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [376, 9], "def_end_pos": [376, 21]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : AddCommMonoid M\u2082\ninst\u271d\u2075 : AddCommMonoid M\u2083\ninst\u271d\u2074 : AddCommMonoid M\u2084\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\ninst\u271d\u00b9 : Module R M\u2083\ninst\u271d : Module R M\u2084\n\u22a2 Disjoint (range (inl R M M\u2082)) (range (inr R M M\u2082))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NoncommProd.lean", "full_name": "Multiset.noncommProd_cons'", "start": [150, 1], "end": [163, 30], "traced_tactics": [{"tactic": "induction' s using Quotient.inductionOn with s", "annotated_tactic": ["induction' s using <a>Quotient.inductionOn</a> with s", [{"full_name": "Quotient.inductionOn", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [1367, 19], "def_end_pos": [1367, 30]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\ns : Multiset \u03b1\na : \u03b1\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 s} Commute\n\u22a2 noncommProd (a ::\u2098 s) comm = noncommProd s (_ : Set.Pairwise {x | x \u2208 s} Commute) * a", "state_after": "case h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na : \u03b1\ns : List \u03b1\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6s\u27e7} Commute\n\u22a2 noncommProd (a ::\u2098 \u27e6s\u27e7) comm = noncommProd \u27e6s\u27e7 (_ : Set.Pairwise {x | x \u2208 \u27e6s\u27e7} Commute) * a"}, {"tactic": "simp only [quot_mk_to_coe, cons_coe, noncommProd_coe, List.prod_cons]", "annotated_tactic": ["simp only [<a>quot_mk_to_coe</a>, <a>cons_coe</a>, <a>noncommProd_coe</a>, <a>List.prod_cons</a>]", [{"full_name": "Multiset.quot_mk_to_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [43, 9], "def_end_pos": [43, 23]}, {"full_name": "Multiset.cons_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [136, 9], "def_end_pos": [136, 17]}, {"full_name": "Multiset.noncommProd_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/NoncommProd.lean", "def_pos": [124, 9], "def_end_pos": [124, 24]}, {"full_name": "List.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 18]}]], "state_before": "case h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na : \u03b1\ns : List \u03b1\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6s\u27e7} Commute\n\u22a2 noncommProd (a ::\u2098 \u27e6s\u27e7) comm = noncommProd \u27e6s\u27e7 (_ : Set.Pairwise {x | x \u2208 \u27e6s\u27e7} Commute) * a", "state_after": "case h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na : \u03b1\ns : List \u03b1\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6s\u27e7} Commute\n\u22a2 a * List.prod s = List.prod s * a"}, {"tactic": "induction' s with hd tl IH", "annotated_tactic": ["induction' s with hd tl IH", []], "state_before": "case h\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na : \u03b1\ns : List \u03b1\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6s\u27e7} Commute\n\u22a2 a * List.prod s = List.prod s * a", "state_after": "case h.nil\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na : \u03b1\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6[]\u27e7} Commute\n\u22a2 a * List.prod [] = List.prod [] * a\n\ncase h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 a * List.prod (hd :: tl) = List.prod (hd :: tl) * a"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.nil\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na : \u03b1\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6[]\u27e7} Commute\n\u22a2 a * List.prod [] = List.prod [] * a", "state_after": "no goals"}, {"tactic": "rw [List.prod_cons, mul_assoc, \u2190 IH, \u2190 mul_assoc, \u2190 mul_assoc]", "annotated_tactic": ["rw [<a>List.prod_cons</a>, <a>mul_assoc</a>, \u2190 IH, \u2190 <a>mul_assoc</a>, \u2190 <a>mul_assoc</a>]", [{"full_name": "List.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 18]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}]], "state_before": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 a * List.prod (hd :: tl) = List.prod (hd :: tl) * a", "state_after": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 a * hd * List.prod tl = hd * a * List.prod tl\n\ncase h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 a * hd * List.prod tl = hd * a * List.prod tl", "state_after": "case h.cons.e_a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 a * hd = hd * a"}, {"tactic": "apply comm.of_refl <;> simp", "annotated_tactic": ["apply comm.of_refl <;> simp", []], "state_before": "case h.cons.e_a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 a * hd = hd * a", "state_after": "no goals"}, {"tactic": "intro x hx y hy", "annotated_tactic": ["intro x hx y hy", []], "state_before": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\n\u22a2 Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute", "state_after": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx : \u03b1\nhx : x \u2208 {x | x \u2208 a ::\u2098 \u27e6tl\u27e7}\ny : \u03b1\nhy : y \u2208 {x | x \u2208 a ::\u2098 \u27e6tl\u27e7}\n\u22a2 x \u2260 y \u2192 Commute x y"}, {"tactic": "simp only [quot_mk_to_coe, List.mem_cons, mem_coe, cons_coe] at hx hy", "annotated_tactic": ["simp only [<a>quot_mk_to_coe</a>, <a>List.mem_cons</a>, <a>mem_coe</a>, <a>cons_coe</a>] at hx hy", [{"full_name": "Multiset.quot_mk_to_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [43, 9], "def_end_pos": [43, 23]}, {"full_name": "List.mem_cons", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [59, 17], "def_end_pos": [59, 25]}, {"full_name": "Multiset.mem_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 16]}, {"full_name": "Multiset.cons_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [136, 9], "def_end_pos": [136, 17]}]], "state_before": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx : \u03b1\nhx : x \u2208 {x | x \u2208 a ::\u2098 \u27e6tl\u27e7}\ny : \u03b1\nhy : y \u2208 {x | x \u2208 a ::\u2098 \u27e6tl\u27e7}\n\u22a2 x \u2260 y \u2192 Commute x y", "state_after": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx y : \u03b1\nhx : x \u2208 {x | x = a \u2228 x \u2208 tl}\nhy : y \u2208 {x | x = a \u2228 x \u2208 tl}\n\u22a2 x \u2260 y \u2192 Commute x y"}, {"tactic": "apply comm", "annotated_tactic": ["apply comm", []], "state_before": "case h.cons\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx y : \u03b1\nhx : x \u2208 {x | x = a \u2228 x \u2208 tl}\nhy : y \u2208 {x | x = a \u2228 x \u2208 tl}\n\u22a2 x \u2260 y \u2192 Commute x y", "state_after": "case h.cons.a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx y : \u03b1\nhx : x \u2208 {x | x = a \u2228 x \u2208 tl}\nhy : y \u2208 {x | x = a \u2228 x \u2208 tl}\n\u22a2 x \u2208 {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7}\n\ncase h.cons.a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx y : \u03b1\nhx : x \u2208 {x | x = a \u2228 x \u2208 tl}\nhy : y \u2208 {x | x = a \u2228 x \u2208 tl}\n\u22a2 y \u2208 {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7}"}, {"tactic": "cases hx <;> simp [*]", "annotated_tactic": ["cases hx <;> simp [*]", []], "state_before": "case h.cons.a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx y : \u03b1\nhx : x \u2208 {x | x = a \u2228 x \u2208 tl}\nhy : y \u2208 {x | x = a \u2228 x \u2208 tl}\n\u22a2 x \u2208 {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7}", "state_after": "no goals"}, {"tactic": "cases hy <;> simp [*]", "annotated_tactic": ["cases hy <;> simp [*]", []], "state_before": "case h.cons.a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na hd : \u03b1\ntl : List \u03b1\nIH : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6tl\u27e7} Commute \u2192 a * List.prod tl = List.prod tl * a\ncomm : Set.Pairwise {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7} Commute\nx y : \u03b1\nhx : x \u2208 {x | x = a \u2228 x \u2208 tl}\nhy : y \u2208 {x | x = a \u2228 x \u2208 tl}\n\u22a2 y \u2208 {x | x \u2208 a ::\u2098 \u27e6hd :: tl\u27e7}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.map_comap_map", "start": [1525, 1], "end": [1526, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get?_set_of_lt'", "start": [940, 1], "end": [942, 68], "traced_tactics": [{"tactic": "simp [get?_set]", "annotated_tactic": ["simp [<a>get?_set</a>]", [{"full_name": "List.get?_set", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [932, 9], "def_end_pos": [932, 17]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\nm n : Nat\nl : List \u03b1\nh : m < length l\n\u22a2 get? (set l m a) n = if m = n then some a else get? l n", "state_after": "\u03b1 : Type u_1\na : \u03b1\nm n : Nat\nl : List \u03b1\nh : m < length l\n\u22a2 (if m = n then Option.map (fun x => a) (get? l n) else get? l n) = if m = n then some a else get? l n"}, {"tactic": "split <;> subst_vars <;> simp [*, get?_eq_get h]", "annotated_tactic": ["split <;> subst_vars <;> simp [*, <a>get?_eq_get</a> h]", [{"full_name": "List.get?_eq_get", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 20]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\nm n : Nat\nl : List \u03b1\nh : m < length l\n\u22a2 (if m = n then Option.map (fun x => a) (get? l n) else get? l n) = if m = n then some a else get? l n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.Perm.sigmaCongrRight_symm", "start": [779, 9], "end": [781, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.get?_set_eq", "start": [95, 9], "end": [96, 57], "traced_tactics": [{"tactic": "simp [getElem?_pos, i.2]", "annotated_tactic": ["simp [<a>getElem?_pos</a>, i.2]", [{"full_name": "getElem?_pos", "def_path": "lake-packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [23, 9], "def_end_pos": [23, 21]}]], "state_before": "\u03b1 : Type u_1\na : Array \u03b1\ni : Fin (size a)\nv : \u03b1\n\u22a2 (set a i v)[i.val]? = some v", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/PropInstances.lean", "full_name": "Prop.codisjoint_iff", "start": [105, 1], "end": [106, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Countable.lean", "full_name": "Set.Countable.exists_eq_range", "start": [121, 1], "end": [125, 40], "traced_tactics": [{"tactic": "rcases hc.exists_surjective hs with \u27e8f, hf\u27e9", "annotated_tactic": ["rcases hc.exists_surjective hs with \u27e8f, hf\u27e9", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : Set.Countable s\nhs : Set.Nonempty s\n\u22a2 \u2203 f, s = range f", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : Set.Countable s\nhs : Set.Nonempty s\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 \u2203 f, s = range f"}, {"tactic": "refine' \u27e8(\u2191) \u2218 f, _\u27e9", "annotated_tactic": ["refine' \u27e8(\u2191) \u2218 f, _\u27e9", []], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : Set.Countable s\nhs : Set.Nonempty s\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 \u2203 f, s = range f", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : Set.Countable s\nhs : Set.Nonempty s\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 s = range (Subtype.val \u2218 f)"}, {"tactic": "rw [hf.range_comp, Subtype.range_coe]", "annotated_tactic": ["rw [hf.range_comp, <a>Subtype.range_coe</a>]", [{"full_name": "Subtype.range_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1409, 9], "def_end_pos": [1409, 18]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : Set.Countable s\nhs : Set.Nonempty s\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 s = range (Subtype.val \u2218 f)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Init/Lemmas.lean", "full_name": "Nat.lt_min", "start": [72, 11], "end": [72, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Sort.lean", "full_name": "Multiset.sort_singleton", "start": [64, 1], "end": [65, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.invFun_eq_symm", "start": [300, 1], "end": [300, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Atoms.lean", "full_name": "isAtomic_dual_iff_isCoatomic", "start": [286, 1], "end": [288, 54], "traced_tactics": [{"tactic": "apply h.eq_bot_or_exists_atom_le", "annotated_tactic": ["apply h.eq_bot_or_exists_atom_le", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderTop \u03b1\nh : IsAtomic \u03b1\u1d52\u1d48\nb : \u03b1\n\u22a2 b = \u22a4 \u2228 \u2203 a, IsCoatom a \u2227 b \u2264 a", "state_after": "no goals"}, {"tactic": "apply h.eq_top_or_exists_le_coatom", "annotated_tactic": ["apply h.eq_top_or_exists_le_coatom", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderTop \u03b1\nh : IsCoatomic \u03b1\nb : \u03b1\u1d52\u1d48\n\u22a2 b = \u22a5 \u2228 \u2203 a, IsAtom a \u2227 a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "lt_mul_of_lt_of_one_lt_of_pos", "start": [808, 1], "end": [810, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Iterate.lean", "full_name": "Function.involutive_iff_iter_2_eq_id", "start": [251, 1], "end": [252, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "Units.coeHom_apply", "start": [113, 1], "end": [113, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atTop_atBot", "start": [1345, 1], "end": [1347, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.factors_one", "start": [1774, 1], "end": [1777, 27], "traced_tactics": [{"tactic": "apply eq_of_prod_eq_prod", "annotated_tactic": ["apply <a>eq_of_prod_eq_prod</a>", [{"full_name": "Associates.eq_of_prod_eq_prod", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1468, 9], "def_end_pos": [1468, 27]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\n\u22a2 factors 1 = 0", "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\n\u22a2 FactorSet.prod (factors 1) = FactorSet.prod 0"}, {"tactic": "rw [Associates.factors_prod]", "annotated_tactic": ["rw [<a>Associates.factors_prod</a>]", [{"full_name": "Associates.factors_prod", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/UniqueFactorizationDomain.lean", "def_pos": [1433, 9], "def_end_pos": [1433, 21]}]], "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\n\u22a2 FactorSet.prod (factors 1) = FactorSet.prod 0", "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\n\u22a2 1 = FactorSet.prod 0"}, {"tactic": "exact Multiset.prod_zero", "annotated_tactic": ["exact <a>Multiset.prod_zero</a>", [{"full_name": "Multiset.prod_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [77, 9], "def_end_pos": [77, 18]}]], "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ndec_irr : (p : Associates \u03b1) \u2192 Decidable (Irreducible p)\ninst\u271d\u00b9 : UniqueFactorizationMonoid \u03b1\ndec : DecidableEq \u03b1\ndec' : DecidableEq (Associates \u03b1)\ninst\u271d : Nontrivial \u03b1\n\u22a2 1 = FactorSet.prod 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_linear_lt_degree_C_mul_X_sq", "start": [1228, 1], "end": [1230, 62], "traced_tactics": [{"tactic": "simpa only [degree_C_mul_X_pow 2 ha] using degree_linear_lt", "annotated_tactic": ["simpa only [<a>degree_C_mul_X_pow</a> 2 ha] using <a>degree_linear_lt</a>", [{"full_name": "Polynomial.degree_C_mul_X_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [292, 9], "def_end_pos": [292, 27]}, {"full_name": "Polynomial.degree_linear_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1191, 9], "def_end_pos": [1191, 25]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u03b9 : Type u_1\nha : a \u2260 0\n\u22a2 degree (\u2191C b * X + \u2191C c) < degree (\u2191C a * X ^ 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean", "full_name": "Function.Commute.invOn_fixedPoints_comp", "start": [183, 1], "end": [185, 67], "traced_tactics": [{"tactic": "simpa only [h.comp_eq] using Function.invOn_fixedPoints_comp f g", "annotated_tactic": ["simpa only [h.comp_eq] using <a>Function.invOn_fixedPoints_comp</a> f g", [{"full_name": "Function.invOn_fixedPoints_comp", "def_path": "lake-packages/mathlib/Mathlib/Dynamics/FixedPoints/Basic.lean", "def_pos": [164, 9], "def_end_pos": [164, 31]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nf fa g : \u03b1 \u2192 \u03b1\nx y : \u03b1\nfb : \u03b2 \u2192 \u03b2\nm n k : \u2115\ne : Perm \u03b1\nh : Function.Commute f g\n\u22a2 Set.InvOn f g (fixedPoints (f \u2218 g)) (fixedPoints (f \u2218 g))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.div_zero", "start": [41, 19], "end": [43, 18], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "a\u271d : Nat\n\u22a2 ofNat (a\u271d / 0) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Chain.lean", "full_name": "ChainClosure.isChain", "start": [269, 1], "end": [275, 35], "traced_tactics": [{"tactic": "induction hc", "annotated_tactic": ["induction hc", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\nhc : ChainClosure r c\n\u22a2 IsChain r c", "state_after": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\ns\u271d : Set \u03b1\na\u271d : ChainClosure r s\u271d\na_ih\u271d : IsChain r s\u271d\n\u22a2 IsChain r (SuccChain r s\u271d)\n\ncase union\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\ns\u271d : Set (Set \u03b1)\na\u271d : \u2200 a \u2208 s\u271d, ChainClosure r a\na_ih\u271d : \u2200 a \u2208 s\u271d, IsChain r a\n\u22a2 IsChain r (\u22c3\u2080 s\u271d)"}, {"tactic": "case succ c _ h => exact h.succ", "annotated_tactic": ["case succ c _ h => exact h.succ", []], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\ns\u271d : Set \u03b1\na\u271d : ChainClosure r s\u271d\na_ih\u271d : IsChain r s\u271d\n\u22a2 IsChain r (SuccChain r s\u271d)\n\ncase union\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\ns\u271d : Set (Set \u03b1)\na\u271d : \u2200 a \u2208 s\u271d, ChainClosure r a\na_ih\u271d : \u2200 a \u2208 s\u271d, IsChain r a\n\u22a2 IsChain r (\u22c3\u2080 s\u271d)", "state_after": "case union\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\ns\u271d : Set (Set \u03b1)\na\u271d : \u2200 a \u2208 s\u271d, ChainClosure r a\na_ih\u271d : \u2200 a \u2208 s\u271d, IsChain r a\n\u22a2 IsChain r (\u22c3\u2080 s\u271d)"}, {"tactic": "case union s hs h =>\n  exact fun c\u2081 \u27e8t\u2081, ht\u2081, (hc\u2081 : c\u2081 \u2208 t\u2081)\u27e9 c\u2082 \u27e8t\u2082, ht\u2082, (hc\u2082 : c\u2082 \u2208 t\u2082)\u27e9 hneq =>\n    ((hs _ ht\u2081).total <| hs _ ht\u2082).elim (fun ht => h t\u2082 ht\u2082 (ht hc\u2081) hc\u2082 hneq) fun ht =>\n      h t\u2081 ht\u2081 hc\u2081 (ht hc\u2082) hneq", "annotated_tactic": ["case union s hs h =>\n    exact fun c\u2081 \u27e8t\u2081, ht\u2081, (hc\u2081 : c\u2081 \u2208 t\u2081)\u27e9 c\u2082 \u27e8t\u2082, ht\u2082, (hc\u2082 : c\u2082 \u2208 t\u2082)\u27e9 hneq =>\n      ((hs _ ht\u2081).<a>total</a> <| hs _ ht\u2082).<a>elim</a> (fun ht => h t\u2082 ht\u2082 (ht hc\u2081) hc\u2082 hneq) fun ht =>\n        h t\u2081 ht\u2081 hc\u2081 (ht hc\u2082) hneq", [{"full_name": "ChainClosure.total", "def_path": "lake-packages/mathlib/Mathlib/Order/Chain.lean", "def_pos": [250, 9], "def_end_pos": [250, 27]}, {"full_name": "Or.elim", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [533, 9], "def_end_pos": [533, 16]}]], "state_before": "case union\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\ns\u271d : Set (Set \u03b1)\na\u271d : \u2200 a \u2208 s\u271d, ChainClosure r a\na_ih\u271d : \u2200 a \u2208 s\u271d, IsChain r a\n\u22a2 IsChain r (\u22c3\u2080 s\u271d)", "state_after": "no goals"}, {"tactic": "exact h.succ", "annotated_tactic": ["exact h.succ", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc\u271d c\u2081 c\u2082 c\u2083 s t : Set \u03b1\na b x y : \u03b1\nc : Set \u03b1\na\u271d : ChainClosure r c\nh : IsChain r c\n\u22a2 IsChain r (SuccChain r c)", "state_after": "no goals"}, {"tactic": "exact fun c\u2081 \u27e8t\u2081, ht\u2081, (hc\u2081 : c\u2081 \u2208 t\u2081)\u27e9 c\u2082 \u27e8t\u2082, ht\u2082, (hc\u2082 : c\u2082 \u2208 t\u2082)\u27e9 hneq =>\n  ((hs _ ht\u2081).total <| hs _ ht\u2082).elim (fun ht => h t\u2082 ht\u2082 (ht hc\u2081) hc\u2082 hneq) fun ht =>\n    h t\u2081 ht\u2081 hc\u2081 (ht hc\u2082) hneq", "annotated_tactic": ["exact fun c\u2081 \u27e8t\u2081, ht\u2081, (hc\u2081 : c\u2081 \u2208 t\u2081)\u27e9 c\u2082 \u27e8t\u2082, ht\u2082, (hc\u2082 : c\u2082 \u2208 t\u2082)\u27e9 hneq =>\n      ((hs _ ht\u2081).<a>total</a> <| hs _ ht\u2082).<a>elim</a> (fun ht => h t\u2082 ht\u2082 (ht hc\u2081) hc\u2082 hneq) fun ht =>\n        h t\u2081 ht\u2081 hc\u2081 (ht hc\u2082) hneq", [{"full_name": "ChainClosure.total", "def_path": "lake-packages/mathlib/Mathlib/Order/Chain.lean", "def_pos": [250, 9], "def_end_pos": [250, 27]}, {"full_name": "Or.elim", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [533, 9], "def_end_pos": [533, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nc c\u2081 c\u2082 c\u2083 s\u271d t : Set \u03b1\na b x y : \u03b1\ns : Set (Set \u03b1)\nhs : \u2200 a \u2208 s, ChainClosure r a\nh : \u2200 a \u2208 s, IsChain r a\n\u22a2 IsChain r (\u22c3\u2080 s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Basic.lean", "full_name": "inv_mul_mul_self", "start": [321, 1], "end": [324, 35], "traced_tactics": [{"tactic": "by_cases h : a = 0", "annotated_tactic": ["by_cases h : a = 0", []], "state_before": "\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d : GroupWithZero G\u2080\na\u271d b c a : G\u2080\n\u22a2 a\u207b\u00b9 * a * a = a", "state_after": "case pos\n\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d : GroupWithZero G\u2080\na\u271d b c a : G\u2080\nh : a = 0\n\u22a2 a\u207b\u00b9 * a * a = a\n\ncase neg\n\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d : GroupWithZero G\u2080\na\u271d b c a : G\u2080\nh : \u00aca = 0\n\u22a2 a\u207b\u00b9 * a * a = a"}, {"tactic": "rw [h, inv_zero, mul_zero]", "annotated_tactic": ["rw [h, <a>inv_zero</a>, <a>mul_zero</a>]", [{"full_name": "GroupWithZero.inv_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [186, 3], "def_end_pos": [186, 11]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}]], "state_before": "case pos\n\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d : GroupWithZero G\u2080\na\u271d b c a : G\u2080\nh : a = 0\n\u22a2 a\u207b\u00b9 * a * a = a", "state_after": "no goals"}, {"tactic": "rw [inv_mul_cancel h, one_mul]", "annotated_tactic": ["rw [<a>inv_mul_cancel</a> h, <a>one_mul</a>]", [{"full_name": "inv_mul_cancel", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/NeZero.lean", "def_pos": [55, 9], "def_end_pos": [55, 23]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "case neg\n\u03b1 : Type u_1\nM\u2080 : Type u_2\nG\u2080 : Type u_3\nM\u2080' : Type u_4\nG\u2080' : Type u_5\nF : Type u_6\nF' : Type u_7\ninst\u271d : GroupWithZero G\u2080\na\u271d b c a : G\u2080\nh : \u00aca = 0\n\u22a2 a\u207b\u00b9 * a * a = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.set_biUnion_preimage_singleton", "start": [2104, 1], "end": [2106, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Basic.lean", "full_name": "Int.induction_on", "start": [193, 27], "end": [204, 66], "traced_tactics": [{"tactic": "induction i with\n| ofNat i =>\n  induction i with\n  | zero => exact hz\n  | succ i ih => exact hp _ ih\n| negSucc i =>\n  suffices \u2200 n : \u2115, p (-n) from this (i + 1)\n  intro n; induction n with\n  | zero => simp [hz, Nat.cast_zero]\n  | succ n ih => convert hn _ ih using 1; simp [sub_eq_neg_add]", "annotated_tactic": ["induction i with\n  | <a>ofNat</a> i =>\n    induction i with\n    | <a>zero</a> => exact hz\n    | <a>succ</a> i ih => exact hp _ ih\n  | <a>negSucc</a> i =>\n    suffices \u2200 n : \u2115, p (-n) from this (i + 1)\n    intro n; induction n with\n    | <a>zero</a> => simp [hz, <a>Nat.cast_zero</a>]\n    | <a>succ</a> n ih => convert hn _ ih using 1; simp [<a>sub_eq_neg_add</a>]", [{"full_name": "Int.ofNat", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [42, 5], "def_end_pos": [42, 10]}, {"full_name": "Nat.zero", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1041, 5], "def_end_pos": [1041, 9]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}, {"full_name": "Int.negSucc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [45, 5], "def_end_pos": [45, 12]}, {"full_name": "Nat.zero", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1041, 5], "def_end_pos": [1041, 9]}, {"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}, {"full_name": "sub_eq_neg_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [491, 3], "def_end_pos": [491, 14]}]], "state_before": "p : \u2124 \u2192 Prop\ni : \u2124\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\n\u22a2 p i", "state_after": "no goals"}, {"tactic": "induction i with\n| zero => exact hz\n| succ i ih => exact hp _ ih", "annotated_tactic": ["induction i with\n    | <a>zero</a> => exact hz\n    | <a>succ</a> i ih => exact hp _ ih", [{"full_name": "Nat.zero", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1041, 5], "def_end_pos": [1041, 9]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}]], "state_before": "case ofNat\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni : \u2115\n\u22a2 p (ofNat i)", "state_after": "no goals"}, {"tactic": "exact hz", "annotated_tactic": ["exact hz", []], "state_before": "case ofNat.zero\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\n\u22a2 p (ofNat zero)", "state_after": "no goals"}, {"tactic": "exact hp _ ih", "annotated_tactic": ["exact hp _ ih", []], "state_before": "case ofNat.succ\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni : \u2115\nih : p (ofNat i)\n\u22a2 p (ofNat (Nat.succ i))", "state_after": "no goals"}, {"tactic": "suffices \u2200 n : \u2115, p (-n) from this (i + 1)", "annotated_tactic": ["suffices \u2200 n : \u2115, p (-n) from this (i + 1)", []], "state_before": "case negSucc\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni : \u2115\n\u22a2 p -[i+1]", "state_after": "case negSucc\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni : \u2115\n\u22a2 \u2200 (n : \u2115), p (-\u2191n)"}, {"tactic": "intro n", "annotated_tactic": ["intro n", []], "state_before": "case negSucc\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni : \u2115\n\u22a2 \u2200 (n : \u2115), p (-\u2191n)", "state_after": "case negSucc\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni n : \u2115\n\u22a2 p (-\u2191n)"}, {"tactic": "induction n with\n| zero => simp [hz, Nat.cast_zero]\n| succ n ih => convert hn _ ih using 1; simp [sub_eq_neg_add]", "annotated_tactic": ["induction n with\n    | <a>zero</a> => simp [hz, <a>Nat.cast_zero</a>]\n    | <a>succ</a> n ih => convert hn _ ih using 1; simp [<a>sub_eq_neg_add</a>]", [{"full_name": "Nat.zero", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1041, 5], "def_end_pos": [1041, 9]}, {"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}, {"full_name": "sub_eq_neg_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [491, 3], "def_end_pos": [491, 14]}]], "state_before": "case negSucc\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni n : \u2115\n\u22a2 p (-\u2191n)", "state_after": "no goals"}, {"tactic": "simp [hz, Nat.cast_zero]", "annotated_tactic": ["simp [hz, <a>Nat.cast_zero</a>]", [{"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}]], "state_before": "case negSucc.zero\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni : \u2115\n\u22a2 p (-\u2191zero)", "state_after": "no goals"}, {"tactic": "convert hn _ ih using 1", "annotated_tactic": ["convert hn _ ih using 1", []], "state_before": "case negSucc.succ\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni n : \u2115\nih : p (-\u2191n)\n\u22a2 p (-\u2191(Nat.succ n))", "state_after": "case h.e'_1\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni n : \u2115\nih : p (-\u2191n)\n\u22a2 -\u2191(Nat.succ n) = -\u2191n - 1"}, {"tactic": "simp [sub_eq_neg_add]", "annotated_tactic": ["simp [<a>sub_eq_neg_add</a>]", [{"full_name": "sub_eq_neg_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [491, 3], "def_end_pos": [491, 14]}]], "state_before": "case h.e'_1\np : \u2124 \u2192 Prop\nhz : p 0\nhp : \u2200 (i : \u2115), p \u2191i \u2192 p (\u2191i + 1)\nhn : \u2200 (i : \u2115), p (-\u2191i) \u2192 p (-\u2191i - 1)\ni n : \u2115\nih : p (-\u2191n)\n\u22a2 -\u2191(Nat.succ n) = -\u2191n - 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ico_inter_Ici", "start": [1768, 1], "end": [1769, 75], "traced_tactics": [{"tactic": "rw [\u2190 Ici_inter_Iio, \u2190 Ici_inter_Iio, \u2190 Ici_inter_Ici, inter_right_comm]", "annotated_tactic": ["rw [\u2190 <a>Ici_inter_Iio</a>, \u2190 <a>Ici_inter_Iio</a>, \u2190 <a>Ici_inter_Ici</a>, <a>inter_right_comm</a>]", [{"full_name": "Set.Ici_inter_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [622, 9], "def_end_pos": [622, 22]}, {"full_name": "Set.Ici_inter_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [622, 9], "def_end_pos": [622, 22]}, {"full_name": "Set.Ici_inter_Ici", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1762, 9], "def_end_pos": [1762, 22]}, {"full_name": "Set.inter_right_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [953, 9], "def_end_pos": [953, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\na b c : \u03b1\n\u22a2 Ico a b \u2229 Ici c = Ico (a \u2294 c) b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.mem_domain_iff", "start": [875, 1], "end": [884, 7], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "R : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nx : E\n\u22a2 x \u2208 f.domain \u2194 \u2203 y, (x, y) \u2208 graph f", "state_after": "case mp\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nx : E\nh : x \u2208 f.domain\n\u22a2 \u2203 y, (x, y) \u2208 graph f\n\ncase mpr\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nx : E\nh : \u2203 y, (x, y) \u2208 graph f\n\u22a2 x \u2208 f.domain"}, {"tactic": "cases' h with y h", "annotated_tactic": ["cases' h with y h", []], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nx : E\nh : \u2203 y, (x, y) \u2208 graph f\n\u22a2 x \u2208 f.domain", "state_after": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nh : (x, y) \u2208 graph f\n\u22a2 x \u2208 f.domain"}, {"tactic": "rw [mem_graph_iff] at h", "annotated_tactic": ["rw [<a>mem_graph_iff</a>] at h", [{"full_name": "LinearPMap.mem_graph_iff", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/LinearPMap.lean", "def_pos": [776, 9], "def_end_pos": [776, 22]}]], "state_before": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nh : (x, y) \u2208 graph f\n\u22a2 x \u2208 f.domain", "state_after": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nh : \u2203 y_1, \u2191y_1 = (x, y).1 \u2227 \u2191f y_1 = (x, y).2\n\u22a2 x \u2208 f.domain"}, {"tactic": "cases' h with x' h", "annotated_tactic": ["cases' h with x' h", []], "state_before": "case mpr.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nh : \u2203 y_1, \u2191y_1 = (x, y).1 \u2227 \u2191f y_1 = (x, y).2\n\u22a2 x \u2208 f.domain", "state_after": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nx' : \u21a5f.domain\nh : \u2191x' = (x, y).1 \u2227 \u2191f x' = (x, y).2\n\u22a2 x \u2208 f.domain"}, {"tactic": "simp only at h", "annotated_tactic": ["simp only at h", []], "state_before": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nx' : \u21a5f.domain\nh : \u2191x' = (x, y).1 \u2227 \u2191f x' = (x, y).2\n\u22a2 x \u2208 f.domain", "state_after": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nx' : \u21a5f.domain\nh : \u2191x' = x \u2227 \u2191f x' = y\n\u22a2 x \u2208 f.domain"}, {"tactic": "rw [\u2190 h.1]", "annotated_tactic": ["rw [\u2190 h.1]", []], "state_before": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nx' : \u21a5f.domain\nh : \u2191x' = x \u2227 \u2191f x' = y\n\u22a2 x \u2208 f.domain", "state_after": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nx' : \u21a5f.domain\nh : \u2191x' = x \u2227 \u2191f x' = y\n\u22a2 \u2191x' \u2208 f.domain"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case mpr.intro.intro\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nx' : \u21a5f.domain\nh : \u2191x' = x \u2227 \u2191f x' = y\n\u22a2 \u2191x' \u2208 f.domain", "state_after": "no goals"}, {"tactic": "use f \u27e8x, h\u27e9", "annotated_tactic": ["use f \u27e8x, h\u27e9", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nx : E\nh : x \u2208 f.domain\n\u22a2 \u2203 y, (x, y) \u2208 graph f", "state_after": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nx : E\nh : x \u2208 f.domain\n\u22a2 (x, \u2191f { val := x, property := h }) \u2208 graph f"}, {"tactic": "exact f.mem_graph \u27e8x, h\u27e9", "annotated_tactic": ["exact f.mem_graph \u27e8x, h\u27e9", []], "state_before": "case h\nR : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny : M\nf : E \u2192\u2097.[R] F\nx : E\nh : x \u2208 f.domain\n\u22a2 (x, \u2191f { val := x, property := h }) \u2208 graph f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.nat_cast_comp", "start": [567, 1], "end": [567, 89], "traced_tactics": [{"tactic": "rw [\u2190 C_eq_nat_cast, C_comp]", "annotated_tactic": ["rw [\u2190 <a>C_eq_nat_cast</a>, <a>C_comp</a>]", [{"full_name": "Polynomial.C_eq_nat_cast", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [551, 9], "def_end_pos": [551, 22]}, {"full_name": "Polynomial.C_comp", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [562, 9], "def_end_pos": [562, 15]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\n\u22a2 comp (\u2191n) p = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Compare.lean", "full_name": "Ordering.Compares.cmp_eq", "start": [171, 1], "end": [173, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Closure.lean", "full_name": "LowerAdjoint.not_mem_of_not_mem_closure", "start": [501, 1], "end": [502, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Perm.countP_eq", "start": [467, 1], "end": [469, 86], "traced_tactics": [{"tactic": "rw [countP_eq_length_filter, countP_eq_length_filter]", "annotated_tactic": ["rw [<a>countP_eq_length_filter</a>, <a>countP_eq_length_filter</a>]", [{"full_name": "List.countP_eq_length_filter", "def_path": "lake-packages/std/Std/Data/List/Count.lean", "def_pos": [60, 9], "def_end_pos": [60, 32]}, {"full_name": "List.countP_eq_length_filter", "def_path": "lake-packages/std/Std/Data/List/Count.lean", "def_pos": [60, 9], "def_end_pos": [60, 32]}]], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081\u271d l\u2082\u271d : List \u03b1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 countP p l\u2081 = countP p l\u2082", "state_after": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081\u271d l\u2082\u271d : List \u03b1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 length (List.filter p l\u2081) = length (List.filter p l\u2082)"}, {"tactic": "exact (s.filter _).length_eq", "annotated_tactic": ["exact (s.filter _).<a>length_eq</a>", [{"full_name": "List.Perm.length_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [148, 9], "def_end_pos": [148, 23]}]], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081\u271d l\u2082\u271d : List \u03b1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 length (List.filter p l\u2081) = length (List.filter p l\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/OfFn.lean", "full_name": "List.last_ofFn_succ", "start": [140, 1], "end": [143, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.sInter_range", "start": [1322, 1], "end": [1323, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.iUnion_op_smul_set", "start": [427, 1], "end": [428, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csSup_singleton", "start": [666, 1], "end": [667, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.floor_eq_iff", "start": [830, 1], "end": [832, 14], "traced_tactics": [{"tactic": "rw [le_antisymm_iff, le_floor, \u2190 Int.lt_add_one_iff, floor_lt, Int.cast_add, Int.cast_one,\n  and_comm]", "annotated_tactic": ["rw [<a>le_antisymm_iff</a>, <a>le_floor</a>, \u2190 <a>Int.lt_add_one_iff</a>, <a>floor_lt</a>, <a>Int.cast_add</a>, <a>Int.cast_one</a>,\n    <a>and_comm</a>]", [{"full_name": "le_antisymm_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [192, 9], "def_end_pos": [192, 24]}, {"full_name": "Int.le_floor", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [680, 9], "def_end_pos": [680, 17]}, {"full_name": "Int.lt_add_one_iff", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [851, 9], "def_end_pos": [851, 23]}, {"full_name": "Int.floor_lt", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [684, 9], "def_end_pos": [684, 17]}, {"full_name": "Int.cast_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [108, 9], "def_end_pos": [108, 17]}, {"full_name": "Int.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [77, 9], "def_end_pos": [77, 17]}, {"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\n\u22a2 \u230aa\u230b = z \u2194 \u2191z \u2264 a \u2227 a < \u2191z + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isLUB_empty", "start": [895, 1], "end": [896, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Monic.lean", "full_name": "Polynomial.Monic.natDegree_eq_zero_iff_eq_one", "start": [153, 1], "end": [162, 59], "traced_tactics": [{"tactic": "constructor <;> intro h", "annotated_tactic": ["constructor <;> intro h", []], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\n\u22a2 natDegree p = 0 \u2194 p = 1", "state_after": "case mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\n\u22a2 p = 1\n\ncase mpr\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : p = 1\n\u22a2 natDegree p = 0"}, {"tactic": "swap", "annotated_tactic": ["swap", []], "state_before": "case mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\n\u22a2 p = 1\n\ncase mpr\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : p = 1\n\u22a2 natDegree p = 0", "state_after": "case mpr\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : p = 1\n\u22a2 natDegree p = 0\n\ncase mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\n\u22a2 p = 1"}, {"tactic": "have : p = C (p.coeff 0) := by\n  rw [\u2190 Polynomial.degree_le_zero_iff]\n  rwa [Polynomial.natDegree_eq_zero_iff_degree_le_zero] at h", "annotated_tactic": ["have : p = <a>C</a> (p.coeff 0) := by\n    rw [\u2190 <a>Polynomial.degree_le_zero_iff</a>]\n    rwa [<a>Polynomial.natDegree_eq_zero_iff_degree_le_zero</a>] at h", [{"full_name": "Polynomial.C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [498, 5], "def_end_pos": [498, 6]}, {"full_name": "Polynomial.degree_le_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [633, 9], "def_end_pos": [633, 27]}, {"full_name": "Polynomial.natDegree_eq_zero_iff_degree_le_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1115, 9], "def_end_pos": [1115, 45]}]], "state_before": "case mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\n\u22a2 p = 1", "state_after": "case mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\nthis : p = \u2191C (coeff p 0)\n\u22a2 p = 1"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "case mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\nthis : p = \u2191C (coeff p 0)\n\u22a2 p = 1", "state_after": "case mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\nthis : p = \u2191C (coeff p 0)\n\u22a2 \u2191C (coeff p 0) = 1"}, {"tactic": "rw [\u2190 h, \u2190 Polynomial.leadingCoeff, Monic.def.1 hp, C_1]", "annotated_tactic": ["rw [\u2190 h, \u2190 <a>Polynomial.leadingCoeff</a>, <a>Monic.def</a>.1 hp, <a>C_1</a>]", [{"full_name": "Polynomial.leadingCoeff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [70, 5], "def_end_pos": [70, 17]}, {"full_name": "Polynomial.Monic.def", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [84, 9], "def_end_pos": [84, 18]}, {"full_name": "Polynomial.C_1", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [518, 9], "def_end_pos": [518, 12]}]], "state_before": "case mp\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\nthis : p = \u2191C (coeff p 0)\n\u22a2 \u2191C (coeff p 0) = 1", "state_after": "no goals"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "case mpr\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : p = 1\n\u22a2 natDegree p = 0", "state_after": "case mpr\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : p = 1\n\u22a2 natDegree 1 = 0"}, {"tactic": "exact natDegree_one", "annotated_tactic": ["exact <a>natDegree_one</a>", [{"full_name": "Polynomial.natDegree_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [275, 9], "def_end_pos": [275, 22]}]], "state_before": "case mpr\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : p = 1\n\u22a2 natDegree 1 = 0", "state_after": "no goals"}, {"tactic": "rw [\u2190 Polynomial.degree_le_zero_iff]", "annotated_tactic": ["rw [\u2190 <a>Polynomial.degree_le_zero_iff</a>]", [{"full_name": "Polynomial.degree_le_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [633, 9], "def_end_pos": [633, 27]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\n\u22a2 p = \u2191C (coeff p 0)", "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\n\u22a2 degree p \u2264 0"}, {"tactic": "rwa [Polynomial.natDegree_eq_zero_iff_degree_le_zero] at h", "annotated_tactic": ["rwa [<a>Polynomial.natDegree_eq_zero_iff_degree_le_zero</a>] at h", [{"full_name": "Polynomial.natDegree_eq_zero_iff_degree_le_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1115, 9], "def_end_pos": [1115, 45]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nh : natDegree p = 0\n\u22a2 degree p \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Sym/Basic.lean", "full_name": "Sym.mem_fill_iff", "start": [532, 1], "end": [534, 62], "traced_tactics": [{"tactic": "rw [fill, mem_cast, mem_append_iff, or_comm, mem_replicate]", "annotated_tactic": ["rw [<a>fill</a>, <a>mem_cast</a>, <a>mem_append_iff</a>, <a>or_comm</a>, <a>mem_replicate</a>]", [{"full_name": "Sym.fill", "def_path": "lake-packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [523, 5], "def_end_pos": [523, 9]}, {"full_name": "Sym.mem_cast", "def_path": "lake-packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [486, 9], "def_end_pos": [486, 17]}, {"full_name": "Sym.mem_append_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [516, 9], "def_end_pos": [516, 23]}, {"full_name": "or_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [269, 9], "def_end_pos": [269, 16]}, {"full_name": "Sym.mem_replicate", "def_path": "lake-packages/mathlib/Mathlib/Data/Sym/Basic.lean", "def_pos": [288, 9], "def_end_pos": [288, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns\u271d : Sym \u03b1 n\na\u271d b\u271d a b : \u03b1\ni : Fin (n + 1)\ns : Sym \u03b1 (n - \u2191i)\n\u22a2 a \u2208 fill b i s \u2194 \u2191i \u2260 0 \u2227 a = b \u2228 a \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Equiv.finsetCongr_refl", "start": [844, 1], "end": [846, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u22a2 Equiv.finsetCongr (Equiv.refl \u03b1) = Equiv.refl (Finset \u03b1)", "state_after": "case H.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 \u2191(Equiv.finsetCongr (Equiv.refl \u03b1)) x\u271d \u2194 a\u271d \u2208 \u2191(Equiv.refl (Finset \u03b1)) x\u271d"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case H.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 \u2191(Equiv.finsetCongr (Equiv.refl \u03b1)) x\u271d \u2194 a\u271d \u2208 \u2191(Equiv.refl (Finset \u03b1)) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.lt_or_eq_of_le", "start": [189, 11], "end": [190, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.mul_mod_left", "start": [926, 9], "end": [927, 35], "traced_tactics": [{"tactic": "rw [Nat.mul_comm, mul_mod_right]", "annotated_tactic": ["rw [<a>Nat.mul_comm</a>, <a>mul_mod_right</a>]", [{"full_name": "Nat.mul_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [174, 19], "def_end_pos": [174, 27]}, {"full_name": "Nat.mul_mod_right", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [923, 17], "def_end_pos": [923, 30]}]], "state_before": "m n : Nat\n\u22a2 m * n % n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.isCompl", "start": [1374, 1], "end": [1375, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atBot_atTop", "start": [1350, 1], "end": [1352, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "imp_imp_imp", "start": [111, 1], "end": [111, 100], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.leftInverse_symm", "start": [352, 1], "end": [352, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.constantCoeff_comp_map", "start": [1374, 1], "end": [1376, 18], "traced_tactics": [{"tactic": "ext <;> simp", "annotated_tactic": ["ext <;> simp", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf\u271d f : R \u2192+* S\u2081\n\u22a2 RingHom.comp constantCoeff (map f) = RingHom.comp f constantCoeff", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.mapRange.addMonoidHom_id", "start": [2191, 1], "end": [2193, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iInter_mono", "start": [493, 1], "end": [494, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.tail_eq_of_cons_eq", "start": [27, 1], "end": [27, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/CancelDenoms/Core.lean", "full_name": "CancelDenoms.sub_subst", "start": [59, 1], "end": [60, 73], "traced_tactics": [{"tactic": "simp [left_distrib, *, sub_eq_add_neg]", "annotated_tactic": ["simp [<a>left_distrib</a>, *, <a>sub_eq_add_neg</a>]", [{"full_name": "left_distrib", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [78, 9], "def_end_pos": [78, 21]}, {"full_name": "sub_eq_add_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [975, 3], "def_end_pos": [975, 14]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\nn e1 e2 t1 t2 : \u03b1\nh1 : n * e1 = t1\nh2 : n * e2 = t2\n\u22a2 n * (e1 - e2) = t1 - t2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Image.lean", "full_name": "Function.Commute.finset_map", "start": [154, 1], "end": [156, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.toFinsupp_one", "start": [204, 1], "end": [205, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_mul_self_atTop", "start": [935, 1], "end": [936, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Coeff.lean", "full_name": "Polynomial.C_mul'", "start": [167, 1], "end": [169, 44], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u\nS : Type v\na\u271d b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\na : R\nf : R[X]\n\u22a2 \u2191C a * f = a \u2022 f", "state_after": "case a\nR : Type u\nS : Type v\na\u271d b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\na : R\nf : R[X]\nn\u271d : \u2115\n\u22a2 coeff (\u2191C a * f) n\u271d = coeff (a \u2022 f) n\u271d"}, {"tactic": "rw [coeff_C_mul, coeff_smul, smul_eq_mul]", "annotated_tactic": ["rw [<a>coeff_C_mul</a>, <a>coeff_smul</a>, <a>smul_eq_mul</a>]", [{"full_name": "Polynomial.coeff_C_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [161, 9], "def_end_pos": [161, 20]}, {"full_name": "Polynomial.coeff_smul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [54, 9], "def_end_pos": [54, 19]}, {"full_name": "smul_eq_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}]], "state_before": "case a\nR : Type u\nS : Type v\na\u271d b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\na : R\nf : R[X]\nn\u271d : \u2115\n\u22a2 coeff (\u2191C a * f) n\u271d = coeff (a \u2022 f) n\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.snd_sumFinsuppAddEquivProdFinsupp", "start": [1380, 1], "end": [1382, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "LinearEquiv.mapMatrix_refl", "start": [1518, 1], "end": [1519, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.map_Iio", "start": [1292, 1], "end": [1294, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : LowerSet \u03b1\na\u271d b : \u03b1\nf : \u03b1 \u2243o \u03b2\na : \u03b1\n\u22a2 \u2191(map f) (Iio a) = Iio (\u2191f a)", "state_after": "case a.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : LowerSet \u03b1\na\u271d b : \u03b1\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 \u2191(\u2191(map f) (Iio a)) \u2194 x\u271d \u2208 \u2191(Iio (\u2191f a))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns : LowerSet \u03b1\na\u271d b : \u03b1\nf : \u03b1 \u2243o \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 \u2191(\u2191(map f) (Iio a)) \u2194 x\u271d \u2208 \u2191(Iio (\u2191f a))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Sum.lean", "full_name": "Finset.disj_sum_strictMono_right", "start": [112, 1], "end": [114, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Field/Basic.lean", "full_name": "neg_div_self", "start": [146, 1], "end": [146, 86], "traced_tactics": [{"tactic": "rw [neg_div, div_self h]", "annotated_tactic": ["rw [<a>neg_div</a>, <a>div_self</a> h]", [{"full_name": "neg_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [113, 9], "def_end_pos": [113, 16]}, {"full_name": "div_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "def_pos": [29, 9], "def_end_pos": [29, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nK : Type u_3\ninst\u271d : DivisionRing K\na\u271d b c d a : K\nh : a \u2260 0\n\u22a2 -a / a = -1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "LE.le.ge", "start": [268, 11], "end": [269, 4], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.Prime.minFac_eq", "start": [371, 1], "end": [372, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Prod.lean", "full_name": "MonoidHom.coprod_comp_inr", "start": [646, 1], "end": [647, 38], "traced_tactics": [{"tactic": "simp [coprod_apply]", "annotated_tactic": ["simp [<a>coprod_apply</a>]", [{"full_name": "MonoidHom.coprod_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Prod.lean", "def_pos": [634, 9], "def_end_pos": [634, 21]}]], "state_before": "A : Type u_1\nB : Type u_2\nG : Type u_3\nH : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : MulOneClass N\ninst\u271d : CommMonoid P\nf : M \u2192* P\ng : N \u2192* P\nx : N\n\u22a2 \u2191(comp (coprod f g) (inr M N)) x = \u2191g x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.replaceF_eq_replaceFTR", "start": [407, 10], "end": [414, 24], "traced_tactics": [{"tactic": "funext \u03b1 p l", "annotated_tactic": ["funext \u03b1 p l", []], "state_before": "\u22a2 @replaceF = @replaceFTR", "state_after": "case h.h.h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\n\u22a2 replaceF p l = replaceFTR p l"}, {"tactic": "simp [replaceFTR]", "annotated_tactic": ["simp [<a>replaceFTR</a>]", [{"full_name": "List.replaceFTR", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [399, 15], "def_end_pos": [399, 25]}]], "state_before": "case h.h.h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\n\u22a2 replaceF p l = replaceFTR p l", "state_after": "case h.h.h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\n\u22a2 replaceF p l = replaceFTR.go p l #[]"}, {"tactic": "exact (go #[] _).symm", "annotated_tactic": ["exact (go #[] _).<a>symm</a>", [{"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case h.h.h\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\n\u22a2 replaceF p l = replaceFTR.go p l #[]", "state_after": "no goals"}, {"tactic": "simp [replaceFTR.go, replaceF]", "annotated_tactic": ["simp [<a>replaceFTR.go</a>, <a>replaceF</a>]", [{"full_name": "List.replaceFTR.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [401, 17], "def_end_pos": [401, 19]}, {"full_name": "List.replaceF", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [392, 13], "def_end_pos": [392, 21]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\n\u22a2 replaceFTR.go p [] acc = acc.data ++ replaceF p []", "state_after": "no goals"}, {"tactic": "simp [replaceFTR.go, replaceF]", "annotated_tactic": ["simp [<a>replaceFTR.go</a>, <a>replaceF</a>]", [{"full_name": "List.replaceFTR.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [401, 17], "def_end_pos": [401, 19]}, {"full_name": "List.replaceF", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [392, 13], "def_end_pos": [392, 21]}]], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\n\u22a2 replaceFTR.go p (x :: xs) acc = acc.data ++ replaceF p (x :: xs)", "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\n\u22a2 (match p x with\n    | none => replaceFTR.go p xs (Array.push acc x)\n    | some a' => acc.data ++ a' :: xs) =\n    acc.data ++\n      match p x with\n      | none => x :: replaceF p xs\n      | some a => a :: xs"}, {"tactic": "cases p x <;> simp", "annotated_tactic": ["cases p x <;> simp", []], "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\n\u22a2 (match p x with\n    | none => replaceFTR.go p xs (Array.push acc x)\n    | some a' => acc.data ++ a' :: xs) =\n    acc.data ++\n      match p x with\n      | none => x :: replaceF p xs\n      | some a => a :: xs", "state_after": "case none\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\n\u22a2 replaceFTR.go p xs (Array.push acc x) = acc.data ++ x :: replaceF p xs"}, {"tactic": "rw [go _ xs]", "annotated_tactic": ["rw [go _ xs]", []], "state_before": "case none\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\n\u22a2 replaceFTR.go p xs (Array.push acc x) = acc.data ++ x :: replaceF p xs", "state_after": "case none\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\n\u22a2 (Array.push acc x).data ++ replaceF p xs = acc.data ++ x :: replaceF p xs"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case none\n\u03b1 : Type u_1\np : \u03b1 \u2192 Option \u03b1\nl : List \u03b1\nacc : Array \u03b1\nx : \u03b1\nxs : List \u03b1\n\u22a2 (Array.push acc x).data ++ replaceF p xs = acc.data ++ x :: replaceF p xs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.comap_iInf_map_of_injective", "start": [359, 1], "end": [361, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WellFoundedSet.lean", "full_name": "Finset.isPwo_bUnion", "start": [634, 1], "end": [636, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/Cast/Defs.lean", "full_name": "Rat.cast_sub_of_ne_zero", "start": [123, 1], "end": [126, 53], "traced_tactics": [{"tactic": "have : ((-n).den : \u03b1) \u2260 0 := by cases n; exact n0", "annotated_tactic": ["have : ((-n).<a>den</a> : \u03b1) \u2260 0 := by cases n; exact n0", [{"full_name": "Rat.den", "def_path": "lake-packages/std/Std/Data/Rat/Basic.lean", "def_pos": [23, 3], "def_end_pos": [23, 6]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\nm n : \u211a\nm0 : \u2191m.den \u2260 0\nn0 : \u2191n.den \u2260 0\n\u22a2 \u2191(m - n) = \u2191m - \u2191n", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\nm n : \u211a\nm0 : \u2191m.den \u2260 0\nn0 : \u2191n.den \u2260 0\nthis : \u2191(-n).den \u2260 0\n\u22a2 \u2191(m - n) = \u2191m - \u2191n"}, {"tactic": "simp [sub_eq_add_neg, cast_add_of_ne_zero m0 this]", "annotated_tactic": ["simp [<a>sub_eq_add_neg</a>, <a>cast_add_of_ne_zero</a> m0 this]", [{"full_name": "sub_eq_add_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [975, 3], "def_end_pos": [975, 14]}, {"full_name": "Rat.cast_add_of_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Cast/Defs.lean", "def_pos": [97, 9], "def_end_pos": [97, 28]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\nm n : \u211a\nm0 : \u2191m.den \u2260 0\nn0 : \u2191n.den \u2260 0\nthis : \u2191(-n).den \u2260 0\n\u22a2 \u2191(m - n) = \u2191m - \u2191n", "state_after": "no goals"}, {"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\nm n : \u211a\nm0 : \u2191m.den \u2260 0\nn0 : \u2191n.den \u2260 0\n\u22a2 \u2191(-n).den \u2260 0", "state_after": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\nm : \u211a\nm0 : \u2191m.den \u2260 0\nnum\u271d : \u2124\nden\u271d : \u2115\nden_nz\u271d : den\u271d \u2260 0\nreduced\u271d : Nat.Coprime (Int.natAbs num\u271d) den\u271d\nn0 : \u2191(mk' num\u271d den\u271d).den \u2260 0\n\u22a2 \u2191(-mk' num\u271d den\u271d).den \u2260 0"}, {"tactic": "exact n0", "annotated_tactic": ["exact n0", []], "state_before": "case mk'\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\nm : \u211a\nm0 : \u2191m.den \u2260 0\nnum\u271d : \u2124\nden\u271d : \u2115\nden_nz\u271d : den\u271d \u2260 0\nreduced\u271d : Nat.Coprime (Int.natAbs num\u271d) den\u271d\nn0 : \u2191(mk' num\u271d den\u271d).den \u2260 0\n\u22a2 \u2191(-mk' num\u271d den\u271d).den \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.int_cast_def", "start": [1480, 1], "end": [1482, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.imageFactorization_eq", "start": [613, 1], "end": [615, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Bool/Lemmas.lean", "full_name": "Bool.not_eq_false_eq_eq_true", "start": [101, 1], "end": [101, 97], "traced_tactics": [{"tactic": "cases a <;> simp", "annotated_tactic": ["cases a <;> simp", []], "state_before": "a : Bool\n\u22a2 ((!a) = false) = (a = true)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean", "full_name": "Finsupp.toDFinsupp_coe", "start": [79, 1], "end": [80, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.eq_of_mem_replicate", "start": [919, 1], "end": [920, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Basic.lean", "full_name": "Submodule.neg_mem", "start": [515, 11], "end": [516, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "LinearMap.toMatrixAlgEquiv_transpose_apply", "start": [754, 1], "end": [756, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.union_left_comm", "start": [795, 1], "end": [796, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.max_self", "start": [579, 19], "end": [579, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "inv_lt_iff_one_lt_mul", "start": [293, 1], "end": [294, 62], "traced_tactics": [{"tactic": "rw [inv_mul_self]", "annotated_tactic": ["rw [<a>inv_mul_self</a>]", [{"full_name": "inv_mul_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1125, 9], "def_end_pos": [1125, 21]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (swap fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c : \u03b1\n\u22a2 a\u207b\u00b9 * a < b * a \u2194 1 < b * a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.comap_principal", "start": [2217, 1], "end": [2219, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.zero_le", "start": [110, 9], "end": [110, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/FinsetOps.lean", "full_name": "Multiset.ndunion_le", "start": [176, 1], "end": [180, 20], "traced_tactics": [{"tactic": "simp [zero_ndunion]", "annotated_tactic": ["simp [<a>zero_ndunion</a>]", [{"full_name": "Multiset.zero_ndunion", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/FinsetOps.lean", "def_pos": [150, 9], "def_end_pos": [150, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d s t u : Multiset \u03b1\n\u22a2 ndunion 0 t \u2264 u \u2194 0 \u2286 u \u2227 t \u2264 u", "state_after": "no goals"}, {"tactic": "simp only [cons_ndunion, mem_ndunion, ndinsert_le, and_comm, cons_subset, and_left_comm, h,\nand_assoc]", "annotated_tactic": ["simp only [<a>cons_ndunion</a>, <a>mem_ndunion</a>, <a>ndinsert_le</a>, <a>and_comm</a>, <a>cons_subset</a>, <a>and_left_comm</a>, h,\n        and_assoc]", [{"full_name": "Multiset.cons_ndunion", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/FinsetOps.lean", "def_pos": [155, 9], "def_end_pos": [155, 21]}, {"full_name": "Multiset.mem_ndunion", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/FinsetOps.lean", "def_pos": [160, 9], "def_end_pos": [160, 20]}, {"full_name": "Multiset.ndinsert_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/FinsetOps.lean", "def_pos": [91, 9], "def_end_pos": [91, 20]}, {"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}, {"full_name": "Multiset.cons_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [419, 9], "def_end_pos": [419, 20]}, {"full_name": "and_left_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [183, 9], "def_end_pos": [183, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d s t u : Multiset \u03b1\nx\u271d\u00b9 : \u03b1\nx\u271d : Multiset \u03b1\nh : ndunion x\u271d t \u2264 u \u2194 x\u271d \u2286 u \u2227 t \u2264 u\n\u22a2 ndunion (x\u271d\u00b9 ::\u2098 x\u271d) t \u2264 u \u2194 x\u271d\u00b9 ::\u2098 x\u271d \u2286 u \u2227 t \u2264 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.prod_eq_prod_fintype", "start": [1873, 1], "end": [1881, 14], "traced_tactics": [{"tactic": "suffices (\u220f i in v.support, f i (v i)) = \u220f i, f i (v i) by simp [DFinsupp.prod, this]", "annotated_tactic": ["suffices (\u220f i in v.support, f i (v i)) = \u220f i, f i (v i) by simp [<a>DFinsupp.prod</a>, this]", [{"full_name": "DFinsupp.prod", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [1719, 5], "def_end_pos": [1719, 9]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\n\u22a2 prod v f = \u220f i : \u03b9, f i (\u2191equivFunOnFintype v i)", "state_after": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\n\u22a2 \u220f i in support v, f i (\u2191v i) = \u220f i : \u03b9, f i (\u2191v i)"}, {"tactic": "apply Finset.prod_subset v.support.subset_univ", "annotated_tactic": ["apply <a>Finset.prod_subset</a> v.support.subset_univ", [{"full_name": "Finset.prod_subset", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [751, 9], "def_end_pos": [751, 20]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\n\u22a2 \u220f i in support v, f i (\u2191v i) = \u220f i : \u03b9, f i (\u2191v i)", "state_after": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\n\u22a2 \u2200 x \u2208 Finset.univ, x \u2209 support v \u2192 f x (\u2191v x) = 1"}, {"tactic": "intro i _ hi", "annotated_tactic": ["intro i _ hi", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\n\u22a2 \u2200 x \u2208 Finset.univ, x \u2209 support v \u2192 f x (\u2191v x) = 1", "state_after": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\ni : \u03b9\na\u271d : i \u2208 Finset.univ\nhi : i \u2209 support v\n\u22a2 f i (\u2191v i) = 1"}, {"tactic": "rw [mem_support_iff, not_not] at hi", "annotated_tactic": ["rw [<a>mem_support_iff</a>, <a>not_not</a>] at hi", [{"full_name": "DFinsupp.mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [1171, 9], "def_end_pos": [1171, 24]}, {"full_name": "Classical.not_not", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [689, 24], "def_end_pos": [689, 31]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\ni : \u03b9\na\u271d : i \u2208 Finset.univ\nhi : i \u2209 support v\n\u22a2 f i (\u2191v i) = 1", "state_after": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\ni : \u03b9\na\u271d : i \u2208 Finset.univ\nhi : \u2191v i = 0\n\u22a2 f i (\u2191v i) = 1"}, {"tactic": "rw [hi, hf]", "annotated_tactic": ["rw [hi, hf]", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\ni : \u03b9\na\u271d : i \u2208 Finset.univ\nhi : \u2191v i = 0\n\u22a2 f i (\u2191v i) = 1", "state_after": "no goals"}, {"tactic": "simp [DFinsupp.prod, this]", "annotated_tactic": ["simp [<a>DFinsupp.prod</a>, this]", [{"full_name": "DFinsupp.prod", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [1719, 5], "def_end_pos": [1719, 9]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (x : \u03b2 i) \u2192 Decidable (x \u2260 0)\ninst\u271d : CommMonoid \u03b3\nv : \u03a0\u2080 (i : \u03b9), \u03b2 i\nf : (i : \u03b9) \u2192 \u03b2 i \u2192 \u03b3\nhf : \u2200 (i : \u03b9), f i 0 = 1\nthis : \u220f i in support v, f i (\u2191v i) = \u220f i : \u03b9, f i (\u2191v i)\n\u22a2 prod v f = \u220f i : \u03b9, f i (\u2191equivFunOnFintype v i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.mem_assert_iff", "start": [466, 1], "end": [469, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.find?_nil", "start": [313, 9], "end": [313, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Logic.lean", "full_name": "not_or_of_not", "start": [191, 1], "end": [191, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Power.lean", "full_name": "zpow_le_one_of_nonpos", "start": [40, 1], "end": [41, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.max_def", "start": [688, 11], "end": [688, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.pow_apply_mem_support", "start": [367, 1], "end": [368, 57], "traced_tactics": [{"tactic": "simp only [mem_support, ne_eq, apply_pow_apply_eq_iff]", "annotated_tactic": ["simp only [<a>mem_support</a>, <a>ne_eq</a>, <a>apply_pow_apply_eq_iff</a>]", [{"full_name": "Equiv.Perm.mem_support", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [290, 9], "def_end_pos": [290, 20]}, {"full_name": "ne_eq", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [82, 17], "def_end_pos": [82, 22]}, {"full_name": "Equiv.Perm.apply_pow_apply_eq_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [362, 9], "def_end_pos": [362, 31]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nn : \u2115\nx : \u03b1\n\u22a2 \u2191(f ^ n) x \u2208 support f \u2194 x \u2208 support f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Zip.lean", "full_name": "List.prod_mul_prod_eq_prod_zipWith_of_length_eq", "start": [487, 1], "end": [490, 68], "traced_tactics": [{"tactic": "apply (prod_mul_prod_eq_prod_zipWith_mul_prod_drop L L').trans", "annotated_tactic": ["apply (<a>prod_mul_prod_eq_prod_zipWith_mul_prod_drop</a> L L').<a>trans</a>", [{"full_name": "List.prod_mul_prod_eq_prod_zipWith_mul_prod_drop", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Zip.lean", "def_pos": [470, 9], "def_end_pos": [470, 52]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\ninst\u271d : CommMonoid \u03b1\nL L' : List \u03b1\nh : length L = length L'\n\u22a2 prod L * prod L' = prod (zipWith (fun x x_1 => x * x_1) L L')", "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\ninst\u271d : CommMonoid \u03b1\nL L' : List \u03b1\nh : length L = length L'\n\u22a2 prod (zipWith (fun x x_1 => x * x_1) L L') * prod (drop (length L') L) * prod (drop (length L) L') =\n    prod (zipWith (fun x x_1 => x * x_1) L L')"}, {"tactic": "rw [\u2190 h, drop_length, h, drop_length, prod_nil, mul_one, mul_one]", "annotated_tactic": ["rw [\u2190 h, <a>drop_length</a>, h, <a>drop_length</a>, <a>prod_nil</a>, <a>mul_one</a>, <a>mul_one</a>]", [{"full_name": "List.drop_length", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [190, 17], "def_end_pos": [190, 28]}, {"full_name": "List.drop_length", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [190, 17], "def_end_pos": [190, 28]}, {"full_name": "List.prod_nil", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [29, 9], "def_end_pos": [29, 17]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\ninst\u271d : CommMonoid \u03b1\nL L' : List \u03b1\nh : length L = length L'\n\u22a2 prod (zipWith (fun x x_1 => x * x_1) L L') * prod (drop (length L') L) * prod (drop (length L) L') =\n    prod (zipWith (fun x x_1 => x * x_1) L L')", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "Submonoid.subsemiringClosure_toAddSubmonoid", "start": [868, 1], "end": [870, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Hom.lean", "full_name": "AlgHom.comp_toRingHom", "start": [341, 1], "end": [343, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Subtype.lean", "full_name": "Subtype.val_prop", "start": [266, 1], "end": [267, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "toMul_sum", "start": [2351, 1], "end": [2353, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.map_id", "start": [1892, 1], "end": [1893, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "MonoidHom.liftOfRightInverse_comp_apply", "start": [3436, 1], "end": [3439, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Rat/Lemmas.lean", "full_name": "Rat.add_def'", "start": [188, 1], "end": [189, 35], "traced_tactics": [{"tactic": "rw [add_def, normalize_eq_mkRat]", "annotated_tactic": ["rw [<a>add_def</a>, <a>normalize_eq_mkRat</a>]", [{"full_name": "Rat.add_def", "def_path": "lake-packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [173, 9], "def_end_pos": [173, 16]}, {"full_name": "Rat.normalize_eq_mkRat", "def_path": "lake-packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [87, 9], "def_end_pos": [87, 27]}]], "state_before": "a b : Rat\n\u22a2 a + b = mkRat (a.num * \u2191b.den + b.num * \u2191a.den) (a.den * b.den)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidWithZeroHom.coe_inj", "start": [753, 1], "end": [754, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "wcovby_congr_right", "start": [92, 1], "end": [93, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/CompleteLattice.lean", "full_name": "FrameHom.ext", "start": [563, 1], "end": [564, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Pi.lean", "full_name": "Pi.mulSingle_mono", "start": [717, 1], "end": [718, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.basis_singleton_iff", "start": [834, 1], "end": [856, 30], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\n\u22a2 Nonempty (Basis \u03b9 R M) \u2194 \u2203 x, \u2203 (_ : x \u2260 0), \u2200 (y : M), \u2203 r, r \u2022 x = y", "state_after": "case mp\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\n\u22a2 Nonempty (Basis \u03b9 R M) \u2192 \u2203 x, \u2203 (_ : x \u2260 0), \u2200 (y : M), \u2203 r, r \u2022 x = y\n\ncase mpr\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\n\u22a2 (\u2203 x, \u2203 (_ : x \u2260 0), \u2200 (y : M), \u2203 r, r \u2022 x = y) \u2192 Nonempty (Basis \u03b9 R M)"}, {"tactic": "rintro \u27e8b\u27e9", "annotated_tactic": ["rintro \u27e8b\u27e9", []], "state_before": "case mp\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\n\u22a2 Nonempty (Basis \u03b9 R M) \u2192 \u2203 x, \u2203 (_ : x \u2260 0), \u2200 (y : M), \u2203 r, r \u2022 x = y", "state_after": "case mp.intro\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb\u271d b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nb : Basis \u03b9 R M\n\u22a2 \u2203 x, \u2203 (_ : x \u2260 0), \u2200 (y : M), \u2203 r, r \u2022 x = y"}, {"tactic": "refine' \u27e8b default, b.linearIndependent.ne_zero _, _\u27e9", "annotated_tactic": ["refine' \u27e8b <a>default</a>, b.linearIndependent.ne_zero _, _\u27e9", [{"full_name": "Inhabited.default", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [674, 3], "def_end_pos": [674, 10]}]], "state_before": "case mp.intro\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb\u271d b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nb : Basis \u03b9 R M\n\u22a2 \u2203 x, \u2203 (_ : x \u2260 0), \u2200 (y : M), \u2203 r, r \u2022 x = y", "state_after": "case mp.intro\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb\u271d b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nb : Basis \u03b9 R M\n\u22a2 \u2200 (y : M), \u2203 r, r \u2022 \u2191b default = y"}, {"tactic": "simpa [span_singleton_eq_top_iff, Set.range_unique] using b.span_eq", "annotated_tactic": ["simpa [<a>span_singleton_eq_top_iff</a>, <a>Set.range_unique</a>] using b.span_eq", [{"full_name": "Submodule.span_singleton_eq_top_iff", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [436, 9], "def_end_pos": [436, 34]}, {"full_name": "Set.range_unique", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1122, 9], "def_end_pos": [1122, 21]}]], "state_before": "case mp.intro\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb\u271d b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nb : Basis \u03b9 R M\n\u22a2 \u2200 (y : M), \u2203 r, r \u2022 \u2191b default = y", "state_after": "no goals"}, {"tactic": "rintro \u27e8x, nz, w\u27e9", "annotated_tactic": ["rintro \u27e8x, nz, w\u27e9", []], "state_before": "case mpr\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\n\u22a2 (\u2203 x, \u2203 (_ : x \u2260 0), \u2200 (y : M), \u2203 r, r \u2022 x = y) \u2192 Nonempty (Basis \u03b9 R M)", "state_after": "case mpr.intro.intro\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\n\u22a2 Nonempty (Basis \u03b9 R M)"}, {"tactic": "refine \u27e8ofRepr <| LinearEquiv.symm\n  { toFun := fun f => f default \u2022 x\n    invFun := fun y => Finsupp.single default (w y).choose\n    left_inv := fun f => Finsupp.unique_ext ?_\n    right_inv := fun y => ?_\n    map_add' := fun y z => ?_\n    map_smul' := fun c y => ?_ }\u27e9", "annotated_tactic": ["refine \u27e8<a>ofRepr</a> <| <a>LinearEquiv.symm</a>\n      { toFun := fun f => f <a>default</a> \u2022 x\n        invFun := fun y => <a>Finsupp.single</a> <a>default</a> (w y).<a>choose</a>\n        left_inv := fun f => <a>Finsupp.unique_ext</a> ?_\n        right_inv := fun y => ?_\n        map_add' := fun y z => ?_\n        map_smul' := fun c y => ?_ }\u27e9", [{"full_name": "Basis.ofRepr", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [93, 3], "def_end_pos": [93, 9]}, {"full_name": "LinearEquiv.symm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [271, 5], "def_end_pos": [271, 9]}, {"full_name": "Inhabited.default", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [674, 3], "def_end_pos": [674, 10]}, {"full_name": "Finsupp.single", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [289, 5], "def_end_pos": [289, 11]}, {"full_name": "Inhabited.default", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [674, 3], "def_end_pos": [674, 10]}, {"full_name": "Exists.choose", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [448, 32], "def_end_pos": [448, 45]}, {"full_name": "Finsupp.unique_ext", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [271, 9], "def_end_pos": [271, 19]}]], "state_before": "case mpr.intro.intro\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\n\u22a2 Nonempty (Basis \u03b9 R M)", "state_after": "case mpr.intro.intro.refine_1\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\ny z : \u03b9 \u2192\u2080 R\n\u22a2 (fun f => \u2191f default \u2022 x) (y + z) = (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z\n\ncase mpr.intro.intro.refine_2\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc\u271d : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nc : R\ny : \u03b9 \u2192\u2080 R\n\u22a2 AddHom.toFun\n      { toFun := fun f => \u2191f default \u2022 x,\n        map_add' :=\n          (_ :\n            \u2200 (y z : \u03b9 \u2192\u2080 R),\n              (fun f => \u2191f default \u2022 x) (y + z) = (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) }\n      (c \u2022 y) =\n    \u2191(RingHom.id R) c \u2022\n      AddHom.toFun\n        { toFun := fun f => \u2191f default \u2022 x,\n          map_add' :=\n            (_ :\n              \u2200 (y z : \u03b9 \u2192\u2080 R),\n                (fun f => \u2191f default \u2022 x) (y + z) = (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) }\n        y\n\ncase mpr.intro.intro.refine_3\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191((fun y => fun\u2080 | default => Exists.choose (_ : \u2203 r, r \u2022 x = y))\n          (AddHom.toFun\n            {\n                toAddHom :=\n                  { toFun := fun f => \u2191f default \u2022 x,\n                    map_add' :=\n                      (_ :\n                        \u2200 (y z : \u03b9 \u2192\u2080 R),\n                          (fun f => \u2191f default \u2022 x) (y + z) =\n                            (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) },\n                map_smul' :=\n                  (_ :\n                    \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                      AddHom.toFun\n                          { toFun := fun f => \u2191f default \u2022 x,\n                            map_add' :=\n                              (_ :\n                                \u2200 (y z : \u03b9 \u2192\u2080 R),\n                                  (fun f => \u2191f default \u2022 x) (y + z) =\n                                    (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) }\n                          (c \u2022 y) =\n                        \u2191(RingHom.id R) c \u2022\n                          AddHom.toFun\n                            { toFun := fun f => \u2191f default \u2022 x,\n                              map_add' :=\n                                (_ :\n                                  \u2200 (y z : \u03b9 \u2192\u2080 R),\n                                    (fun f => \u2191f default \u2022 x) (y + z) =\n                                      (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) }\n                            y) }.toAddHom\n            f))\n      default =\n    \u2191f default\n\ncase mpr.intro.intro.refine_4\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\ny : M\n\u22a2 AddHom.toFun\n      {\n          toAddHom :=\n            { toFun := fun f => \u2191f default \u2022 x,\n              map_add' :=\n                (_ :\n                  \u2200 (y z : \u03b9 \u2192\u2080 R),\n                    (fun f => \u2191f default \u2022 x) (y + z) = (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) },\n          map_smul' :=\n            (_ :\n              \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                AddHom.toFun\n                    { toFun := fun f => \u2191f default \u2022 x,\n                      map_add' :=\n                        (_ :\n                          \u2200 (y z : \u03b9 \u2192\u2080 R),\n                            (fun f => \u2191f default \u2022 x) (y + z) =\n                              (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) }\n                    (c \u2022 y) =\n                  \u2191(RingHom.id R) c \u2022\n                    AddHom.toFun\n                      { toFun := fun f => \u2191f default \u2022 x,\n                        map_add' :=\n                          (_ :\n                            \u2200 (y z : \u03b9 \u2192\u2080 R),\n                              (fun f => \u2191f default \u2022 x) (y + z) =\n                                (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z) }\n                      y) }.toAddHom\n      ((fun y => fun\u2080 | default => Exists.choose (_ : \u2203 r, r \u2022 x = y)) y) =\n    y"}, {"tactic": "simp [Finsupp.add_apply, add_smul]", "annotated_tactic": ["simp [<a>Finsupp.add_apply</a>, <a>add_smul</a>]", [{"full_name": "Finsupp.add_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [976, 9], "def_end_pos": [976, 18]}, {"full_name": "add_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [91, 9], "def_end_pos": [91, 17]}]], "state_before": "case mpr.intro.intro.refine_1\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\ny z : \u03b9 \u2192\u2080 R\n\u22a2 (fun f => \u2191f default \u2022 x) (y + z) = (fun f => \u2191f default \u2022 x) y + (fun f => \u2191f default \u2022 x) z", "state_after": "no goals"}, {"tactic": "simp only [Finsupp.coe_smul, Pi.smul_apply, RingHom.id_apply]", "annotated_tactic": ["simp only [<a>Finsupp.coe_smul</a>, <a>Pi.smul_apply</a>, <a>RingHom.id_apply</a>]", [{"full_name": "Finsupp.coe_smul", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1489, 9], "def_end_pos": [1489, 17]}, {"full_name": "Pi.smul_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Pi/Algebra.lean", "def_pos": [116, 60], "def_end_pos": [116, 70]}, {"full_name": "RingHom.id_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [640, 9], "def_end_pos": [640, 17]}]], "state_before": "case mpr.intro.intro.refine_2\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc\u271d : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nc : R\ny : \u03b9 \u2192\u2080 R\n\u22a2 AddHom.toFun\n      { toFun := fun f => \u2191f default \u2022 x,\n        map_add' := (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n      (c \u2022 y) =\n    \u2191(RingHom.id R) c \u2022\n      AddHom.toFun\n        { toFun := fun f => \u2191f default \u2022 x,\n          map_add' := (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n        y", "state_after": "case mpr.intro.intro.refine_2\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc\u271d : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nc : R\ny : \u03b9 \u2192\u2080 R\n\u22a2 (c \u2022 \u2191y default) \u2022 x = c \u2022 \u2191y default \u2022 x"}, {"tactic": "rw [\u2190 smul_assoc, smul_eq_mul]", "annotated_tactic": ["rw [\u2190 <a>smul_assoc</a>, <a>smul_eq_mul</a>]", [{"full_name": "smul_assoc", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 19]}, {"full_name": "smul_eq_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [93, 9], "def_end_pos": [93, 20]}]], "state_before": "case mpr.intro.intro.refine_2\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc\u271d : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nc : R\ny : \u03b9 \u2192\u2080 R\n\u22a2 (c \u2022 \u2191y default) \u2022 x = c \u2022 \u2191y default \u2022 x", "state_after": "no goals"}, {"tactic": "refine' smul_left_injective _ nz _", "annotated_tactic": ["refine' <a>smul_left_injective</a> _ nz _", [{"full_name": "smul_left_injective", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [718, 9], "def_end_pos": [718, 28]}]], "state_before": "case mpr.intro.intro.refine_3\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nf : \u03b9 \u2192\u2080 R\n\u22a2 \u2191((fun y => fun\u2080 | default => Exists.choose (_ : \u2203 r, r \u2022 x = y))\n          (AddHom.toFun\n            {\n                toAddHom :=\n                  { toFun := fun f => \u2191f default \u2022 x,\n                    map_add' :=\n                      (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) },\n                map_smul' :=\n                  (_ :\n                    \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                      AddHom.toFun\n                          { toFun := fun f => \u2191f default \u2022 x,\n                            map_add' :=\n                              (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                          (c \u2022 y) =\n                        \u2191(RingHom.id R) c \u2022\n                          AddHom.toFun\n                            { toFun := fun f => \u2191f default \u2022 x,\n                              map_add' :=\n                                (_ :\n                                  \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                            y) }.toAddHom\n            f))\n      default =\n    \u2191f default", "state_after": "case mpr.intro.intro.refine_3\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nf : \u03b9 \u2192\u2080 R\n\u22a2 (fun c => c \u2022 x)\n      (\u2191((fun y => fun\u2080 | default => Exists.choose (_ : \u2203 r, r \u2022 x = y))\n            (AddHom.toFun\n              {\n                  toAddHom :=\n                    { toFun := fun f => \u2191f default \u2022 x,\n                      map_add' :=\n                        (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) },\n                  map_smul' :=\n                    (_ :\n                      \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                        AddHom.toFun\n                            { toFun := fun f => \u2191f default \u2022 x,\n                              map_add' :=\n                                (_ :\n                                  \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                            (c \u2022 y) =\n                          \u2191(RingHom.id R) c \u2022\n                            AddHom.toFun\n                              { toFun := fun f => \u2191f default \u2022 x,\n                                map_add' :=\n                                  (_ :\n                                    \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                              y) }.toAddHom\n              f))\n        default) =\n    (fun c => c \u2022 x) (\u2191f default)"}, {"tactic": "simp only [Finsupp.single_eq_same]", "annotated_tactic": ["simp only [<a>Finsupp.single_eq_same</a>]", [{"full_name": "Finsupp.single_eq_same", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [324, 9], "def_end_pos": [324, 23]}]], "state_before": "case mpr.intro.intro.refine_3\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nf : \u03b9 \u2192\u2080 R\n\u22a2 (fun c => c \u2022 x)\n      (\u2191((fun y => fun\u2080 | default => Exists.choose (_ : \u2203 r, r \u2022 x = y))\n            (AddHom.toFun\n              {\n                  toAddHom :=\n                    { toFun := fun f => \u2191f default \u2022 x,\n                      map_add' :=\n                        (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) },\n                  map_smul' :=\n                    (_ :\n                      \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                        AddHom.toFun\n                            { toFun := fun f => \u2191f default \u2022 x,\n                              map_add' :=\n                                (_ :\n                                  \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                            (c \u2022 y) =\n                          \u2191(RingHom.id R) c \u2022\n                            AddHom.toFun\n                              { toFun := fun f => \u2191f default \u2022 x,\n                                map_add' :=\n                                  (_ :\n                                    \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                              y) }.toAddHom\n              f))\n        default) =\n    (fun c => c \u2022 x) (\u2191f default)", "state_after": "case mpr.intro.intro.refine_3\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nf : \u03b9 \u2192\u2080 R\n\u22a2 Exists.choose\n        (_ :\n          \u2203 r,\n            r \u2022 x =\n              AddHom.toFun\n                {\n                    toAddHom :=\n                      { toFun := fun f => \u2191f default \u2022 x,\n                        map_add' :=\n                          (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) },\n                    map_smul' :=\n                      (_ :\n                        \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                          AddHom.toFun\n                              { toFun := fun f => \u2191f default \u2022 x,\n                                map_add' :=\n                                  (_ :\n                                    \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                              (c \u2022 y) =\n                            \u2191(RingHom.id R) c \u2022\n                              AddHom.toFun\n                                { toFun := fun f => \u2191f default \u2022 x,\n                                  map_add' :=\n                                    (_ :\n                                      \u2200 (y z : \u03b9 \u2192\u2080 R),\n                                        (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                                y) }.toAddHom\n                f) \u2022\n      x =\n    \u2191f default \u2022 x"}, {"tactic": "exact (w (f default \u2022 x)).choose_spec", "annotated_tactic": ["exact (w (f <a>default</a> \u2022 x)).<a>choose_spec</a>", [{"full_name": "Inhabited.default", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [674, 3], "def_end_pos": [674, 10]}, {"full_name": "Exists.choose_spec", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [451, 9], "def_end_pos": [451, 27]}]], "state_before": "case mpr.intro.intro.refine_3\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\nf : \u03b9 \u2192\u2080 R\n\u22a2 Exists.choose\n        (_ :\n          \u2203 r,\n            r \u2022 x =\n              AddHom.toFun\n                {\n                    toAddHom :=\n                      { toFun := fun f => \u2191f default \u2022 x,\n                        map_add' :=\n                          (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) },\n                    map_smul' :=\n                      (_ :\n                        \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                          AddHom.toFun\n                              { toFun := fun f => \u2191f default \u2022 x,\n                                map_add' :=\n                                  (_ :\n                                    \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                              (c \u2022 y) =\n                            \u2191(RingHom.id R) c \u2022\n                              AddHom.toFun\n                                { toFun := fun f => \u2191f default \u2022 x,\n                                  map_add' :=\n                                    (_ :\n                                      \u2200 (y z : \u03b9 \u2192\u2080 R),\n                                        (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                                y) }.toAddHom\n                f) \u2022\n      x =\n    \u2191f default \u2022 x", "state_after": "no goals"}, {"tactic": "simp only [Finsupp.single_eq_same]", "annotated_tactic": ["simp only [<a>Finsupp.single_eq_same</a>]", [{"full_name": "Finsupp.single_eq_same", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [324, 9], "def_end_pos": [324, 23]}]], "state_before": "case mpr.intro.intro.refine_4\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\ny : M\n\u22a2 AddHom.toFun\n      {\n          toAddHom :=\n            { toFun := fun f => \u2191f default \u2022 x,\n              map_add' := (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) },\n          map_smul' :=\n            (_ :\n              \u2200 (c : R) (y : \u03b9 \u2192\u2080 R),\n                AddHom.toFun\n                    { toFun := fun f => \u2191f default \u2022 x,\n                      map_add' :=\n                        (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                    (c \u2022 y) =\n                  \u2191(RingHom.id R) c \u2022\n                    AddHom.toFun\n                      { toFun := fun f => \u2191f default \u2022 x,\n                        map_add' :=\n                          (_ : \u2200 (y z : \u03b9 \u2192\u2080 R), (\u2191y default + \u2191z default) \u2022 x = \u2191y default \u2022 x + \u2191z default \u2022 x) }\n                      y) }.toAddHom\n      ((fun y => fun\u2080 | default => Exists.choose (_ : \u2203 r, r \u2022 x = y)) y) =\n    y", "state_after": "case mpr.intro.intro.refine_4\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\ny : M\n\u22a2 Exists.choose (_ : \u2203 r, r \u2022 x = y) \u2022 x = y"}, {"tactic": "exact (w y).choose_spec", "annotated_tactic": ["exact (w y).<a>choose_spec</a>", [{"full_name": "Exists.choose_spec", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [451, 9], "def_end_pos": [451, 27]}]], "state_before": "case mpr.intro.intro.refine_4\n\u03b9\u271d : Type u_1\n\u03b9' : Type u_2\nR\u271d : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM\u271d : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u00b9\u2070 : Semiring R\u271d\ninst\u271d\u2079 : AddCommMonoid M\u271d\ninst\u271d\u2078 : Module R\u271d M\u271d\ninst\u271d\u2077 : AddCommMonoid M'\ninst\u271d\u2076 : Module R\u271d M'\nb b\u2081 : Basis \u03b9\u271d R\u271d M\u271d\ni : \u03b9\u271d\nc : R\u271d\nx\u271d : M\u271d\nR : Type u_10\nM : Type u_11\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : NoZeroSMulDivisors R M\n\u03b9 : Type u_12\ninst\u271d : Unique \u03b9\nx : M\nnz : x \u2260 0\nw : \u2200 (y : M), \u2203 r, r \u2022 x = y\ny : M\n\u22a2 Exists.choose (_ : \u2203 r, r \u2022 x = y) \u2022 x = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "himp_inf_himp_cancel", "start": [464, 1], "end": [465, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.sup'_inf_distrib_right", "start": [1146, 1], "end": [1147, 62], "traced_tactics": [{"tactic": "rw [inf_comm, sup'_inf_distrib_left]", "annotated_tactic": ["rw [<a>inf_comm</a>, <a>sup'_inf_distrib_left</a>]", [{"full_name": "inf_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [500, 9], "def_end_pos": [500, 17]}, {"full_name": "Finset.sup'_inf_distrib_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1139, 9], "def_end_pos": [1139, 30]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : DistribLattice \u03b1\ns : Finset \u03b9\nt : Finset \u03ba\nhs : Finset.Nonempty s\nht : Finset.Nonempty t\nf\u271d : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\na\u271d : \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 sup' s hs f \u2293 a = sup' s hs fun i => f i \u2293 a", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : DistribLattice \u03b1\ns : Finset \u03b9\nt : Finset \u03ba\nhs : Finset.Nonempty s\nht : Finset.Nonempty t\nf\u271d : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\na\u271d : \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 (sup' s hs fun i => a \u2293 f i) = sup' s hs fun i => f i \u2293 a"}, {"tactic": "simp_rw [inf_comm]", "annotated_tactic": ["simp_rw [<a>inf_comm</a>]", [{"full_name": "inf_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [500, 9], "def_end_pos": [500, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d : DistribLattice \u03b1\ns : Finset \u03b9\nt : Finset \u03ba\nhs : Finset.Nonempty s\nht : Finset.Nonempty t\nf\u271d : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\na\u271d : \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u03b1\n\u22a2 (sup' s hs fun i => a \u2293 f i) = sup' s hs fun i => f i \u2293 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Setoid/Basic.lean", "full_name": "Setoid.ker_apply_mk_out'", "start": [109, 1], "end": [111, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/PEquiv.lean", "full_name": "PEquiv.mem_trans", "start": [147, 1], "end": [149, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Injective.of_comp_iff'", "start": [146, 1], "end": [148, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Kleene.lean", "full_name": "kstar_one", "start": [258, 1], "end": [259, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WellFoundedSet.lean", "full_name": "Set.Subsingleton.wellFoundedOn", "start": [531, 11], "end": [532, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_ite", "start": [1440, 1], "end": [1442, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Finite.lean", "full_name": "Set.Finite.inv", "start": [37, 1], "end": [38, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "Decidable.not_not", "start": [519, 1], "end": [519, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.eq_top_iff'", "start": [769, 1], "end": [770, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "Associates.out_dvd_iff", "start": [239, 1], "end": [241, 81], "traced_tactics": [{"tactic": "simp [Associates.out_mk, Associates.quotient_mk_eq_mk, mk_le_mk_iff_dvd_iff]", "annotated_tactic": ["simp [<a>Associates.out_mk</a>, <a>Associates.quotient_mk_eq_mk</a>, <a>mk_le_mk_iff_dvd_iff</a>]", [{"full_name": "Associates.out_mk", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [220, 9], "def_end_pos": [220, 15]}, {"full_name": "Associates.quotient_mk_eq_mk", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [773, 9], "def_end_pos": [773, 26]}, {"full_name": "Associates.mk_le_mk_iff_dvd_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [962, 9], "def_end_pos": [962, 29]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\na : \u03b1\nb : Associates \u03b1\n\u22a2 \u2200 (a_1 : \u03b1), Associates.out \u27e6a_1\u27e7 \u2223 a \u2194 \u27e6a_1\u27e7 \u2264 Associates.mk a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Prod.lean", "full_name": "Filter.prod_pure_pure", "start": [412, 1], "end": [413, 72], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 pure a \u00d7\u02e2 pure b = pure (a, b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/PUnitInstances.lean", "full_name": "PUnit.mul_eq", "start": [53, 1], "end": [54, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Sign.lean", "full_name": "Equiv.Perm.sign_extendDomain", "start": [789, 1], "end": [791, 93], "traced_tactics": [{"tactic": "simp only [Equiv.Perm.extendDomain, sign_subtypeCongr, sign_permCongr, sign_refl, mul_one]", "annotated_tactic": ["simp only [<a>Equiv.Perm.extendDomain</a>, <a>sign_subtypeCongr</a>, <a>sign_permCongr</a>, <a>sign_refl</a>, <a>mul_one</a>]", [{"full_name": "Equiv.Perm.extendDomain", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1513, 5], "def_end_pos": [1513, 22]}, {"full_name": "Equiv.Perm.sign_subtypeCongr", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [783, 9], "def_end_pos": [783, 26]}, {"full_name": "Equiv.Perm.sign_permCongr", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [763, 9], "def_end_pos": [763, 23]}, {"full_name": "Equiv.Perm.sign_refl", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [561, 9], "def_end_pos": [561, 18]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : Fintype \u03b2\ne : Perm \u03b1\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2243 Subtype p\n\u22a2 \u2191sign (extendDomain e f) = \u2191sign e", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Finset.card_le_univ", "start": [263, 1], "end": [264, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.toMulHom_eq_coe", "start": [224, 1], "end": [225, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.foldrM_reverse", "start": [224, 9], "end": [226, 44], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_1\ninst\u271d : Monad m\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 m \u03b2\nb : \u03b2\n\u22a2 List.foldlM (fun y x => f x y) b (reverse (reverse l)) = List.foldlM (fun x y => f y x) b l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.comap", "start": [793, 1], "end": [798, 87], "traced_tactics": [{"tactic": "simp only [mem_comap', hl.mem_iff]", "annotated_tactic": ["simp only [<a>mem_comap'</a>, hl.mem_iff]", [{"full_name": "Filter.mem_comap'", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1939, 9], "def_end_pos": [1939, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nf : \u03b2 \u2192 \u03b1\nhl : HasBasis l p s\nt : Set \u03b2\n\u22a2 t \u2208 Filter.comap f l \u2194 \u2203 i, p i \u2227 f \u207b\u00b9' s i \u2286 t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nf : \u03b2 \u2192 \u03b1\nhl : HasBasis l p s\nt : Set \u03b2\n\u22a2 (\u2203 i, p i \u2227 s i \u2286 {y | \u2200 \u2983x : \u03b2\u2984, f x = y \u2192 x \u2208 t}) \u2194 \u2203 i, p i \u2227 f \u207b\u00b9' s i \u2286 t"}, {"tactic": "refine exists_congr (fun i => Iff.rfl.and ?_)", "annotated_tactic": ["refine <a>exists_congr</a> (fun i => Iff.rfl.and ?_)", [{"full_name": "exists_congr", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [385, 9], "def_end_pos": [385, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nf : \u03b2 \u2192 \u03b1\nhl : HasBasis l p s\nt : Set \u03b2\n\u22a2 (\u2203 i, p i \u2227 s i \u2286 {y | \u2200 \u2983x : \u03b2\u2984, f x = y \u2192 x \u2208 t}) \u2194 \u2203 i, p i \u2227 f \u207b\u00b9' s i \u2286 t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni\u271d : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nf : \u03b2 \u2192 \u03b1\nhl : HasBasis l p s\nt : Set \u03b2\ni : \u03b9\n\u22a2 s i \u2286 {y | \u2200 \u2983x : \u03b2\u2984, f x = y \u2192 x \u2208 t} \u2194 f \u207b\u00b9' s i \u2286 t"}, {"tactic": "exact \u27e8fun h x hx => h hx rfl, fun h y hy x hx => h <| by rwa [mem_preimage, hx]\u27e9", "annotated_tactic": ["exact \u27e8fun h x hx => h hx <a>rfl</a>, fun h y hy x hx => h <| by rwa [<a>mem_preimage</a>, hx]\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni\u271d : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nf : \u03b2 \u2192 \u03b1\nhl : HasBasis l p s\nt : Set \u03b2\ni : \u03b9\n\u22a2 s i \u2286 {y | \u2200 \u2983x : \u03b2\u2984, f x = y \u2192 x \u2208 t} \u2194 f \u207b\u00b9' s i \u2286 t", "state_after": "no goals"}, {"tactic": "rwa [mem_preimage, hx]", "annotated_tactic": ["rwa [<a>mem_preimage</a>, hx]", [{"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set \u03b1\nt\u271d : Set \u03b1\ni\u271d : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nf : \u03b2 \u2192 \u03b1\nhl : HasBasis l p s\nt : Set \u03b2\ni : \u03b9\nh : f \u207b\u00b9' s i \u2286 t\ny : \u03b1\nhy : y \u2208 s i\nx : \u03b2\nhx : f x = y\n\u22a2 x \u2208 f \u207b\u00b9' s i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Order/Basic.lean", "full_name": "Nat.find_pos", "start": [567, 1], "end": [568, 45], "traced_tactics": [{"tactic": "rw [pos_iff_ne_zero, Ne, Nat.find_eq_zero]", "annotated_tactic": ["rw [<a>pos_iff_ne_zero</a>, <a>Ne</a>, <a>Nat.find_eq_zero</a>]", [{"full_name": "pos_iff_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [243, 3], "def_end_pos": [243, 14]}, {"full_name": "Ne", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [560, 18], "def_end_pos": [560, 20]}, {"full_name": "Nat.find_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [869, 9], "def_end_pos": [869, 21]}]], "state_before": "m n k l : \u2115\np q : \u2115 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred q\nh : \u2203 n, p n\n\u22a2 0 < Nat.find h \u2194 \u00acp 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearMap.coeFn_sum", "start": [300, 1], "end": [306, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBSet.find?_congr", "start": [719, 1], "end": [720, 75], "traced_tactics": [{"tactic": "simp [find?, TransCmp.cmp_congr_left' h]", "annotated_tactic": ["simp [<a>find?</a>, <a>TransCmp.cmp_congr_left'</a> h]", [{"full_name": "Std.RBSet.find?", "def_path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [676, 15], "def_end_pos": [676, 20]}, {"full_name": "Std.TransCmp.cmp_congr_left'", "def_path": "lake-packages/std/Std/Classes/Order.lean", "def_pos": [85, 9], "def_end_pos": [85, 24]}]], "state_before": "\u03b1 : Type u_1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nv\u2081 v\u2082 : \u03b1\ninst\u271d : TransCmp cmp\nt : RBSet \u03b1 cmp\nh : cmp v\u2081 v\u2082 = Ordering.eq\n\u22a2 find? t v\u2081 = find? t v\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "smul_one_mul", "start": [679, 1], "end": [680, 63], "traced_tactics": [{"tactic": "rw [smul_mul_assoc, one_mul]", "annotated_tactic": ["rw [<a>smul_mul_assoc</a>, <a>one_mul</a>]", [{"full_name": "smul_mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [429, 9], "def_end_pos": [429, 23]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "M\u271d : Type u_1\nN\u271d : Type u_2\nG : Type u_3\nA : Type u_4\nB : Type u_5\n\u03b1 : Type u_6\n\u03b2 : Type u_7\n\u03b3 : Type u_8\n\u03b4 : Type u_9\nM : Type u_10\nN : Type u_11\ninst\u271d\u00b2 : MulOneClass N\ninst\u271d\u00b9 : SMul M N\ninst\u271d : IsScalarTower M N N\nx : M\ny : N\n\u22a2 x \u2022 1 * y = x \u2022 y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/AlgebraMap.lean", "full_name": "Polynomial.aeval_subalgebra_coe", "start": [313, 1], "end": [315, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/RestrictScalars.lean", "full_name": "RestrictScalars.ringEquiv_algebraMap", "start": [224, 1], "end": [227, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Classes/Order.lean", "full_name": "Std.TransCmp.cmp_congr_left", "start": [76, 1], "end": [83, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "Codisjoint.bihimp_right", "start": [703, 11], "end": [705, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "LE.le.lt_iff_ne", "start": [276, 1], "end": [277, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Sqrt.lean", "full_name": "Nat.sqrt_lt_self", "start": [132, 1], "end": [133, 96], "traced_tactics": [{"tactic": "have := Nat.mul_lt_mul_of_pos_left h (lt_of_succ_lt h)", "annotated_tactic": ["have := <a>Nat.mul_lt_mul_of_pos_left</a> h (<a>lt_of_succ_lt</a> h)", [{"full_name": "Nat.mul_lt_mul_of_pos_left", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [449, 19], "def_end_pos": [449, 41]}, {"full_name": "Nat.lt_of_succ_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [304, 9], "def_end_pos": [304, 22]}]], "state_before": "n : \u2115\nh : 1 < n\n\u22a2 n < n * n", "state_after": "n : \u2115\nh : 1 < n\nthis : n * 1 < n * n\n\u22a2 n < n * n"}, {"tactic": "rwa [mul_one] at this", "annotated_tactic": ["rwa [<a>mul_one</a>] at this", [{"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "n : \u2115\nh : 1 < n\nthis : n * 1 < n * n\n\u22a2 n < n * n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/LocallyFinite.lean", "full_name": "Finset.Ico_union_Ico", "start": [815, 1], "end": [817, 80], "traced_tactics": [{"tactic": "rw [\u2190 coe_inj, coe_union, coe_Ico, coe_Ico, coe_Ico, Set.Ico_union_Ico h\u2081 h\u2082]", "annotated_tactic": ["rw [\u2190 <a>coe_inj</a>, <a>coe_union</a>, <a>coe_Ico</a>, <a>coe_Ico</a>, <a>coe_Ico</a>, <a>Set.Ico_union_Ico</a> h\u2081 h\u2082]", [{"full_name": "Finset.coe_inj", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [245, 9], "def_end_pos": [245, 16]}, {"full_name": "Finset.coe_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1416, 9], "def_end_pos": [1416, 18]}, {"full_name": "Finset.coe_Ico", "def_path": "lake-packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [351, 9], "def_end_pos": [351, 16]}, {"full_name": "Finset.coe_Ico", "def_path": "lake-packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [351, 9], "def_end_pos": [351, 16]}, {"full_name": "Finset.coe_Ico", "def_path": "lake-packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [351, 9], "def_end_pos": [351, 16]}, {"full_name": "Set.Ico_union_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1547, 9], "def_end_pos": [1547, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na\u271d b\u271d a b c d : \u03b1\nh\u2081 : min a b \u2264 max c d\nh\u2082 : min c d \u2264 max a b\n\u22a2 Ico a b \u222a Ico c d = Ico (min a c) (max b d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.Disjoint.conj", "start": [121, 1], "end": [122, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "not_xor", "start": [481, 9], "end": [482, 76], "traced_tactics": [{"tactic": "simp only [not_and, Xor', not_or, not_not, \u2190 iff_iff_implies_and_implies]", "annotated_tactic": ["simp only [<a>not_and</a>, <a>Xor'</a>, <a>not_or</a>, <a>not_not</a>, \u2190 <a>iff_iff_implies_and_implies</a>]", [{"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}, {"full_name": "Xor'", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [103, 5], "def_end_pos": [103, 9]}, {"full_name": "not_or", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [346, 9], "def_end_pos": [346, 15]}, {"full_name": "Classical.not_not", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [689, 24], "def_end_pos": [689, 31]}, {"full_name": "iff_iff_implies_and_implies", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [657, 9], "def_end_pos": [657, 36]}]], "state_before": "P Q : Prop\n\u22a2 \u00acXor' P Q \u2194 (P \u2194 Q)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.disjoint_union_right", "start": [2998, 1], "end": [2999, 95], "traced_tactics": [{"tactic": "simp [Disjoint, or_imp, forall_and]", "annotated_tactic": ["simp [<a>Disjoint</a>, <a>or_imp</a>, <a>forall_and</a>]", [{"full_name": "Multiset.Disjoint", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2904, 5], "def_end_pos": [2904, 13]}, {"full_name": "or_imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [343, 9], "def_end_pos": [343, 15]}, {"full_name": "forall_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [432, 9], "def_end_pos": [432, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns t u : Multiset \u03b1\n\u22a2 Disjoint s (t \u222a u) \u2194 Disjoint s t \u2227 Disjoint s u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Bitwise.lean", "full_name": "Nat.bit_false", "start": [162, 1], "end": [163, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.add_mod_left", "start": [912, 9], "end": [913, 35], "traced_tactics": [{"tactic": "rw [Nat.add_comm, add_mod_right]", "annotated_tactic": ["rw [<a>Nat.add_comm</a>, <a>add_mod_right</a>]", [{"full_name": "Nat.add_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "Nat.add_mod_right", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [909, 17], "def_end_pos": [909, 30]}]], "state_before": "x z : Nat\n\u22a2 (x + z) % x = z % x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Iio_mem_atBot", "start": [74, 1], "end": [76, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.castSucc_castLT", "start": [366, 9], "end": [367, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_finset_subset_iff", "start": [1972, 1], "end": [1975, 32], "traced_tactics": [{"tactic": "simp_rw [\u2190 coe_subset]", "annotated_tactic": ["simp_rw [\u2190 <a>coe_subset</a>]", [{"full_name": "Finset.coe_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [377, 9], "def_end_pos": [377, 19]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns t : Finset \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 a \u2022 s \u2286 t \u2194 s \u2286 a\u207b\u00b9 \u2022 t", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns t : Finset \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 \u2191(a \u2022 s) \u2286 \u2191t \u2194 \u2191s \u2286 \u2191(a\u207b\u00b9 \u2022 t)"}, {"tactic": "push_cast", "annotated_tactic": ["push_cast", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns t : Finset \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 \u2191(a \u2022 s) \u2286 \u2191t \u2194 \u2191s \u2286 \u2191(a\u207b\u00b9 \u2022 t)", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns t : Finset \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 a \u2022 \u2191s \u2286 \u2191t \u2194 \u2191s \u2286 a\u207b\u00b9 \u2022 \u2191t"}, {"tactic": "exact Set.set_smul_subset_iff", "annotated_tactic": ["exact <a>Set.set_smul_subset_iff</a>", [{"full_name": "Set.set_smul_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/SMul.lean", "def_pos": [917, 9], "def_end_pos": [917, 28]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : MulAction \u03b1 \u03b2\ns t : Finset \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 a \u2022 \u2191s \u2286 \u2191t \u2194 \u2191s \u2286 a\u207b\u00b9 \u2022 \u2191t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.mk_preimage_prod_right", "start": [256, 1], "end": [258, 12], "traced_tactics": [{"tactic": "ext b", "annotated_tactic": ["ext b", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nha : a \u2208 s\n\u22a2 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = t", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb\u271d : \u03b2\nha : a \u2208 s\nb : \u03b2\n\u22a2 b \u2208 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t \u2194 b \u2208 t"}, {"tactic": "simp [ha]", "annotated_tactic": ["simp [ha]", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb\u271d : \u03b2\nha : a \u2208 s\nb : \u03b2\n\u22a2 b \u2208 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t \u2194 b \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.prod_repr_inr", "start": [724, 1], "end": [725, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Palindrome.lean", "full_name": "List.Palindrome.append_reverse", "start": [68, 1], "end": [70, 39], "traced_tactics": [{"tactic": "apply of_reverse_eq", "annotated_tactic": ["apply <a>of_reverse_eq</a>", [{"full_name": "List.Palindrome.of_reverse_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Palindrome.lean", "def_pos": [55, 9], "def_end_pos": [55, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l : List \u03b1\n\u22a2 Palindrome (l ++ reverse l)", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l : List \u03b1\n\u22a2 reverse (l ++ reverse l) = l ++ reverse l"}, {"tactic": "rw [reverse_append, reverse_reverse]", "annotated_tactic": ["rw [<a>reverse_append</a>, <a>reverse_reverse</a>]", [{"full_name": "List.reverse_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [178, 17], "def_end_pos": [178, 31]}, {"full_name": "List.reverse_reverse", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [67, 17], "def_end_pos": [67, 32]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l : List \u03b1\n\u22a2 reverse (l ++ reverse l) = l ++ reverse l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/PEquiv.lean", "full_name": "PEquiv.toMatrix_symm", "start": [71, 1], "end": [75, 8], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "k : Type u_1\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type v\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243. n\n\u22a2 toMatrix (PEquiv.symm f) = (toMatrix f)\u1d40", "state_after": "case a.h\nk : Type u_1\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type v\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243. n\ni\u271d : n\nx\u271d : m\n\u22a2 toMatrix (PEquiv.symm f) i\u271d x\u271d = (toMatrix f)\u1d40 i\u271d x\u271d"}, {"tactic": "simp only [transpose, mem_iff_mem f, toMatrix_apply]", "annotated_tactic": ["simp only [<a>transpose</a>, <a>mem_iff_mem</a> f, <a>toMatrix_apply</a>]", [{"full_name": "Matrix.transpose", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [169, 5], "def_end_pos": [169, 14]}, {"full_name": "PEquiv.mem_iff_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/PEquiv.lean", "def_pos": [107, 9], "def_end_pos": [107, 20]}, {"full_name": "PEquiv.toMatrix_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/PEquiv.lean", "def_pos": [58, 9], "def_end_pos": [58, 23]}]], "state_before": "case a.h\nk : Type u_1\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type v\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243. n\ni\u271d : n\nx\u271d : m\n\u22a2 toMatrix (PEquiv.symm f) i\u271d x\u271d = (toMatrix f)\u1d40 i\u271d x\u271d", "state_after": "case a.h\nk : Type u_1\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type v\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243. n\ni\u271d : n\nx\u271d : m\n\u22a2 (if i\u271d \u2208 \u2191f x\u271d then 1 else 0) = \u2191of (fun x y => if x \u2208 \u2191f y then 1 else 0) i\u271d x\u271d"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case a.h\nk : Type u_1\nl : Type u_2\nm : Type u_3\nn : Type u_4\n\u03b1 : Type v\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : DecidableEq n\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\nf : m \u2243. n\ni\u271d : n\nx\u271d : m\n\u22a2 (if i\u271d \u2208 \u2191f x\u271d then 1 else 0) = \u2191of (fun x y => if x \u2208 \u2191f y then 1 else 0) i\u271d x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/HashMap/WF.lean", "full_name": "Std.HashMap.Imp.mem_replaceF", "start": [189, 9], "end": [201, 46], "traced_tactics": [{"tactic": "exact .inr", "annotated_tactic": ["exact .inr", []], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\n\u22a2 x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) [] \u2192 x.fst = k \u2228 x \u2208 []", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\n\u22a2 x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) (a :: l) \u2192 x.fst = k \u2228 x \u2208 a :: l", "state_after": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\n\u22a2 (x \u2208\n      match bif p a then some (k, f a) else none with\n      | none => a :: List.replaceF (fun a => bif p a then some (k, f a) else none) l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "generalize e : cond .. = z", "annotated_tactic": ["generalize e : <a>cond</a> .. = z", [{"full_name": "cond", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [971, 21], "def_end_pos": [971, 25]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\n\u22a2 (x \u2208\n      match bif p a then some (k, f a) else none with\n      | none => a :: List.replaceF (fun a => bif p a then some (k, f a) else none) l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\ne : (bif p a then some (k, f a) else none) = z\n\u22a2 (x \u2208\n      match z with\n      | none => a :: List.replaceF (fun a => bif p a then some (k, f a) else none) l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "revert e", "annotated_tactic": ["revert e", []], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\ne : (bif p a then some (k, f a) else none) = z\n\u22a2 (x \u2208\n      match z with\n      | none => a :: List.replaceF (fun a => bif p a then some (k, f a) else none) l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\n\u22a2 (bif p a then some (k, f a) else none) = z \u2192\n    (x \u2208\n        match z with\n        | none => a :: List.replaceF (fun a => bif p a then some (k, f a) else none) l\n        | some a => a :: l) \u2192\n      x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "unfold cond", "annotated_tactic": ["unfold <a>cond</a>", [{"full_name": "cond", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [971, 21], "def_end_pos": [971, 25]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\n\u22a2 (bif p a then some (k, f a) else none) = z \u2192\n    (x \u2208\n        match z with\n        | none => a :: List.replaceF (fun a => bif p a then some (k, f a) else none) l\n        | some a => a :: l) \u2192\n      x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\n\u22a2 (match p a with\n      | true => some (k, f a)\n      | false => none) =\n      z \u2192\n    (x \u2208\n        match z with\n        | none =>\n          a ::\n            List.replaceF\n              (fun a =>\n                match p a with\n                | true => some (k, f a)\n                | false => none)\n              l\n        | some a => a :: l) \u2192\n      x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "split <;> (intro h; subst h; simp)", "annotated_tactic": ["split <;> (intro h; subst h; simp)", []], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\n\u22a2 (match p a with\n      | true => some (k, f a)\n      | false => none) =\n      z \u2192\n    (x \u2208\n        match z with\n        | none =>\n          a ::\n            List.replaceF\n              (fun a =>\n                match p a with\n                | true => some (k, f a)\n                | false => none)\n              l\n        | some a => a :: l) \u2192\n      x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "case cons.h_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = true\n\u22a2 x = (k, f a) \u2228 x \u2208 l \u2192 x.fst = k \u2228 x = a \u2228 x \u2208 l\n\ncase cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = false\n\u22a2 x = a \u2228\n      x \u2208\n        List.replaceF\n          (fun a =>\n            match p a with\n            | true => some (k, f a)\n            | false => none)\n          l \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\nc\u271d : Bool\nheq\u271d : p a = false\n\u22a2 none = z \u2192\n    (x \u2208\n        match z with\n        | none =>\n          a ::\n            List.replaceF\n              (fun a =>\n                match p a with\n                | true => some (k, f a)\n                | false => none)\n              l\n        | some a => a :: l) \u2192\n      x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "case cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\nc\u271d : Bool\nheq\u271d : p a = false\nh : none = z\n\u22a2 (x \u2208\n      match z with\n      | none =>\n        a ::\n          List.replaceF\n            (fun a =>\n              match p a with\n              | true => some (k, f a)\n              | false => none)\n            l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "case cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nz : Option (\u03b1 \u00d7 \u03b2)\nc\u271d : Bool\nheq\u271d : p a = false\nh : none = z\n\u22a2 (x \u2208\n      match z with\n      | none =>\n        a ::\n          List.replaceF\n            (fun a =>\n              match p a with\n              | true => some (k, f a)\n              | false => none)\n            l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "case cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = false\n\u22a2 (x \u2208\n      match none with\n      | none =>\n        a ::\n          List.replaceF\n            (fun a =>\n              match p a with\n              | true => some (k, f a)\n              | false => none)\n            l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = false\n\u22a2 (x \u2208\n      match none with\n      | none =>\n        a ::\n          List.replaceF\n            (fun a =>\n              match p a with\n              | true => some (k, f a)\n              | false => none)\n            l\n      | some a => a :: l) \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "case cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = false\n\u22a2 x = a \u2228\n      x \u2208\n        List.replaceF\n          (fun a =>\n            match p a with\n            | true => some (k, f a)\n            | false => none)\n          l \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l"}, {"tactic": "intro\n| .inl eq => exact eq \u25b8 .inl rfl\n| .inr h => exact .inr (.inr h)", "annotated_tactic": ["intro\n      | .inl eq => exact eq \u25b8 .inl <a>rfl</a>\n      | .inr h => exact .inr (.inr h)", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case cons.h_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = true\n\u22a2 x = (k, f a) \u2228 x \u2208 l \u2192 x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "no goals"}, {"tactic": "exact eq \u25b8 .inl rfl", "annotated_tactic": ["exact eq \u25b8 .inl <a>rfl</a>", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = true\nx\u271d : x = (k, f a) \u2228 x \u2208 l\neq : x = (k, f a)\n\u22a2 x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "no goals"}, {"tactic": "exact .inr (.inr h)", "annotated_tactic": ["exact .inr (.inr h)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = true\nx\u271d : x = (k, f a) \u2228 x \u2208 l\nh : x \u2208 l\n\u22a2 x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "no goals"}, {"tactic": "intro\n| .inl eq => exact .inr (.inl eq)\n| .inr h => exact (ih h).imp_right .inr", "annotated_tactic": ["intro\n      | .inl eq => exact .inr (.inl eq)\n      | .inr h => exact (ih h).<a>imp_right</a> .inr", [{"full_name": "Or.imp_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [259, 9], "def_end_pos": [259, 21]}]], "state_before": "case cons.h_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = false\n\u22a2 x = a \u2228\n      x \u2208\n        List.replaceF\n          (fun a =>\n            match p a with\n            | true => some (k, f a)\n            | false => none)\n          l \u2192\n    x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "no goals"}, {"tactic": "exact .inr (.inl eq)", "annotated_tactic": ["exact .inr (.inl eq)", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = false\nx\u271d :\n  x = a \u2228\n    x \u2208\n      List.replaceF\n        (fun a =>\n          match p a with\n          | true => some (k, f a)\n          | false => none)\n        l\neq : x = a\n\u22a2 x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "no goals"}, {"tactic": "exact (ih h).imp_right .inr", "annotated_tactic": ["exact (ih h).<a>imp_right</a> .inr", [{"full_name": "Or.imp_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [259, 9], "def_end_pos": [259, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : \u03b1\nx : \u03b1 \u00d7 \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Bool\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b2\na : \u03b1 \u00d7 \u03b2\nl : List (\u03b1 \u00d7 \u03b2)\nih : x \u2208 List.replaceF (fun a => bif p a then some (k, f a) else none) l \u2192 x.fst = k \u2228 x \u2208 l\nc\u271d : Bool\nheq\u271d : p a = false\nx\u271d :\n  x = a \u2228\n    x \u2208\n      List.replaceF\n        (fun a =>\n          match p a with\n          | true => some (k, f a)\n          | false => none)\n        l\nh :\n  x \u2208\n    List.replaceF\n      (fun a =>\n        match p a with\n        | true => some (k, f a)\n        | false => none)\n      l\n\u22a2 x.fst = k \u2228 x = a \u2228 x \u2208 l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "full_name": "Multiset.prod_toList", "start": [70, 1], "end": [72, 16], "traced_tactics": [{"tactic": "conv_rhs => rw [\u2190 coe_toList s]", "annotated_tactic": ["conv_rhs => rw [\u2190 <a>coe_toList</a> s]", [{"full_name": "Multiset.coe_toList", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [457, 9], "def_end_pos": [457, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : CommMonoid \u03b1\ns\u271d t : Multiset \u03b1\na : \u03b1\nm : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Multiset \u03b1\n\u22a2 List.prod (toList s) = prod s", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : CommMonoid \u03b1\ns\u271d t : Multiset \u03b1\na : \u03b1\nm : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Multiset \u03b1\n\u22a2 List.prod (toList s) = prod \u2191(toList s)"}, {"tactic": "rw [coe_prod]", "annotated_tactic": ["rw [<a>coe_prod</a>]", [{"full_name": "Multiset.coe_prod", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [64, 9], "def_end_pos": [64, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : CommMonoid \u03b1\ns\u271d t : Multiset \u03b1\na : \u03b1\nm : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\ns : Multiset \u03b1\n\u22a2 List.prod (toList s) = prod \u2191(toList s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.toList_ofList", "start": [60, 1], "end": [60, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.comap_radical", "start": [1876, 1], "end": [1878, 17], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u\nS : Type v\nF : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nrc : RingHomClass F R S\nf : F\nI J : Ideal R\nK L : Ideal S\n\u22a2 comap f (radical K) = radical (comap f K)", "state_after": "case h\nR : Type u\nS : Type v\nF : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nrc : RingHomClass F R S\nf : F\nI J : Ideal R\nK L : Ideal S\nx\u271d : R\n\u22a2 x\u271d \u2208 comap f (radical K) \u2194 x\u271d \u2208 radical (comap f K)"}, {"tactic": "simp [radical]", "annotated_tactic": ["simp [<a>radical</a>]", [{"full_name": "Ideal.radical", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [901, 5], "def_end_pos": [901, 12]}]], "state_before": "case h\nR : Type u\nS : Type v\nF : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nrc : RingHomClass F R S\nf : F\nI J : Ideal R\nK L : Ideal S\nx\u271d : R\n\u22a2 x\u271d \u2208 comap f (radical K) \u2194 x\u271d \u2208 radical (comap f K)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "full_name": "mul_eq_one_iff_eq_inv\u2080", "start": [57, 1], "end": [58, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.coeff_sum", "start": [643, 1], "end": [645, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "IsUnit.one_div_mul_cancel", "start": [387, 11], "end": [387, 83], "traced_tactics": [{"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "F : Type u_1\nG : Type u_2\n\u03b1 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d : DivisionMonoid \u03b1\na b c : \u03b1\nh : IsUnit a\n\u22a2 1 / a * a = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.eraseP_cons_of_neg", "start": [1089, 9], "end": [1090, 68], "traced_tactics": [{"tactic": "simp [eraseP_cons, h]", "annotated_tactic": ["simp [<a>eraseP_cons</a>, h]", [{"full_name": "List.eraseP_cons", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1083, 9], "def_end_pos": [1083, 20]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\np : \u03b1 \u2192 Bool\nh : \u00acp a = true\n\u22a2 eraseP p (a :: l) = a :: eraseP p l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "StrictMono.inv", "start": [1327, 1], "end": [1328, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "LinearMap.rTensor_comp", "start": [1128, 1], "end": [1130, 63], "traced_tactics": [{"tactic": "ext m n", "annotated_tactic": ["ext m n", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2074 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u00b3 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : AddCommMonoid P\ninst\u271d\u2078 : AddCommMonoid Q\ninst\u271d\u2077 : AddCommMonoid S\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : Module R Q\ninst\u271d\u00b2 : Module R S\ninst\u271d\u00b9 : DistribMulAction R' M\ninst\u271d : Module R'' M\ng : P \u2192\u2097[R] Q\nf : N \u2192\u2097[R] P\n\u22a2 rTensor M (comp g f) = comp (rTensor M g) (rTensor M f)", "state_after": "case H.h.h\nR : Type u_1\ninst\u271d\u00b9\u2074 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u00b3 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : AddCommMonoid P\ninst\u271d\u2078 : AddCommMonoid Q\ninst\u271d\u2077 : AddCommMonoid S\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : Module R Q\ninst\u271d\u00b2 : Module R S\ninst\u271d\u00b9 : DistribMulAction R' M\ninst\u271d : Module R'' M\ng : P \u2192\u2097[R] Q\nf : N \u2192\u2097[R] P\nm : N\nn : M\n\u22a2 \u2191(\u2191(compr\u2082 (TensorProduct.mk R N M) (rTensor M (comp g f))) m) n =\n    \u2191(\u2191(compr\u2082 (TensorProduct.mk R N M) (comp (rTensor M g) (rTensor M f))) m) n"}, {"tactic": "simp only [compr\u2082_apply, mk_apply, comp_apply, rTensor_tmul]", "annotated_tactic": ["simp only [<a>compr\u2082_apply</a>, <a>mk_apply</a>, <a>comp_apply</a>, <a>rTensor_tmul</a>]", [{"full_name": "LinearMap.compr\u2082_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/BilinearMap.lean", "def_pos": [382, 9], "def_end_pos": [382, 21]}, {"full_name": "TensorProduct.mk_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [395, 9], "def_end_pos": [395, 17]}, {"full_name": "LinearMap.comp_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [549, 9], "def_end_pos": [549, 19]}, {"full_name": "LinearMap.rTensor_tmul", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [1037, 9], "def_end_pos": [1037, 21]}]], "state_before": "case H.h.h\nR : Type u_1\ninst\u271d\u00b9\u2074 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u00b3 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u00b2 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid N\ninst\u271d\u2079 : AddCommMonoid P\ninst\u271d\u2078 : AddCommMonoid Q\ninst\u271d\u2077 : AddCommMonoid S\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Module R P\ninst\u271d\u00b3 : Module R Q\ninst\u271d\u00b2 : Module R S\ninst\u271d\u00b9 : DistribMulAction R' M\ninst\u271d : Module R'' M\ng : P \u2192\u2097[R] Q\nf : N \u2192\u2097[R] P\nm : N\nn : M\n\u22a2 \u2191(\u2191(compr\u2082 (TensorProduct.mk R N M) (rTensor M (comp g f))) m) n =\n    \u2191(\u2191(compr\u2082 (TensorProduct.mk R N M) (comp (rTensor M g) (rTensor M f))) m) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.rootMultiplicity_X_sub_C", "start": [470, 1], "end": [475, 68], "traced_tactics": [{"tactic": "split_ifs with hxy", "annotated_tactic": ["split_ifs with hxy", []], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : DecidableEq R\nx y : R\n\u22a2 rootMultiplicity x (X - \u2191C y) = if x = y then 1 else 0", "state_after": "case pos\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : DecidableEq R\nx y : R\nhxy : x = y\n\u22a2 rootMultiplicity x (X - \u2191C y) = 1\n\ncase neg\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : DecidableEq R\nx y : R\nhxy : \u00acx = y\n\u22a2 rootMultiplicity x (X - \u2191C y) = 0"}, {"tactic": "exact rootMultiplicity_eq_zero (mt root_X_sub_C.mp (Ne.symm hxy))", "annotated_tactic": ["exact <a>rootMultiplicity_eq_zero</a> (<a>mt</a> root_X_sub_C.mp (<a>Ne.symm</a> hxy))", [{"full_name": "Polynomial.rootMultiplicity_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [612, 9], "def_end_pos": [612, 33]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "Ne.symm", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [575, 9], "def_end_pos": [575, 16]}]], "state_before": "case neg\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : DecidableEq R\nx y : R\nhxy : \u00acx = y\n\u22a2 rootMultiplicity x (X - \u2191C y) = 0", "state_after": "no goals"}, {"tactic": "rw [hxy]", "annotated_tactic": ["rw [hxy]", []], "state_before": "case pos\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : DecidableEq R\nx y : R\nhxy : x = y\n\u22a2 rootMultiplicity x (X - \u2191C y) = 1", "state_after": "case pos\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : DecidableEq R\nx y : R\nhxy : x = y\n\u22a2 rootMultiplicity y (X - \u2191C y) = 1"}, {"tactic": "exact rootMultiplicity_X_sub_C_self", "annotated_tactic": ["exact <a>rootMultiplicity_X_sub_C_self</a>", [{"full_name": "Polynomial.rootMultiplicity_X_sub_C_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [462, 9], "def_end_pos": [462, 38]}]], "state_before": "case pos\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np q : R[X]\ninst\u271d : DecidableEq R\nx y : R\nhxy : x = y\n\u22a2 rootMultiplicity y (X - \u2191C y) = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "min_abs_abs_le_abs_min", "start": [333, 1], "end": [335, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.irreducible_iff_nat_prime", "start": [50, 1], "end": [51, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.val_le_iff", "start": [382, 1], "end": [383, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "upperBounds_union", "start": [360, 1], "end": [362, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Order/Lemmas.lean", "full_name": "Nat.dvd_iff_dvd_dvd", "start": [170, 1], "end": [171, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.pos_of_lt_add_right", "start": [391, 11], "end": [392, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "BEx.imp_right", "start": [1052, 1], "end": [1053, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.symm", "start": [147, 11], "end": [147, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.map_toSubsemiring", "start": [506, 1], "end": [508, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.eq_iff_fst_eq_snd_eq", "start": [218, 1], "end": [219, 34], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\np\u2081 : \u03b1\np\u2082 : \u03b2\nq\u2081 : \u03b1\nq\u2082 : \u03b2\n\u22a2 (p\u2081, p\u2082) = (q\u2081, q\u2082) \u2194 (p\u2081, p\u2082).fst = (q\u2081, q\u2082).fst \u2227 (p\u2081, p\u2082).snd = (q\u2081, q\u2082).snd", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SupIndep.lean", "full_name": "Finset.supIndep_singleton", "start": [80, 1], "end": [83, 29], "traced_tactics": [{"tactic": "rw [eq_empty_of_ssubset_singleton \u27e8hs, fun h => hj (h hji)\u27e9, sup_empty]", "annotated_tactic": ["rw [<a>eq_empty_of_ssubset_singleton</a> \u27e8hs, fun h => hj (h hji)\u27e9, <a>sup_empty</a>]", [{"full_name": "Finset.eq_empty_of_ssubset_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [799, 9], "def_end_pos": [799, 38]}, {"full_name": "Finset.sup_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [49, 9], "def_end_pos": [49, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf\u271d : \u03b9 \u2192 \u03b1\ni\u271d i : \u03b9\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nhs : s \u2286 {i}\nj : \u03b9\nhji : j \u2208 {i}\nhj : j \u2209 s\n\u22a2 Disjoint (f j) (sup s f)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf\u271d : \u03b9 \u2192 \u03b1\ni\u271d i : \u03b9\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nhs : s \u2286 {i}\nj : \u03b9\nhji : j \u2208 {i}\nhj : j \u2209 s\n\u22a2 Disjoint (f j) \u22a5"}, {"tactic": "exact disjoint_bot_right", "annotated_tactic": ["exact <a>disjoint_bot_right</a>", [{"full_name": "disjoint_bot_right", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [67, 9], "def_end_pos": [67, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : OrderBot \u03b1\ns\u271d t : Finset \u03b9\nf\u271d : \u03b9 \u2192 \u03b1\ni\u271d i : \u03b9\nf : \u03b9 \u2192 \u03b1\ns : Finset \u03b9\nhs : s \u2286 {i}\nj : \u03b9\nhji : j \u2208 {i}\nhj : j \u2209 s\n\u22a2 Disjoint (f j) \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "pow_lt_one_iff_of_nonneg", "start": [230, 1], "end": [231, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.lt_iff_ssubset", "start": [407, 1], "end": [408, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "max_bot_right", "start": [885, 1], "end": [886, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "MulAction.smul_orbit", "start": [235, 1], "end": [239, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "LinearIndependent.linearIndependent_extend", "start": [1387, 1], "end": [1390, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Propext.lean", "full_name": "imp_congr_ctx_eq", "start": [22, 1], "end": [23, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.drop_zero", "start": [186, 9], "end": [186, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.prod_mul", "start": [1816, 1], "end": [1819, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_mem_dvd", "start": [913, 1], "end": [918, 30], "traced_tactics": [{"tactic": "by_cases ha : a \u2208 mulSupport f", "annotated_tactic": ["by_cases ha : a \u2208 <a>mulSupport</a> f", [{"full_name": "Function.mulSupport", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Support.lean", "def_pos": [44, 5], "def_end_pos": [44, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\n\u22a2 f a \u2223 finprod f", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2208 mulSupport f\n\u22a2 f a \u2223 finprod f\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2209 mulSupport f\n\u22a2 f a \u2223 finprod f"}, {"tactic": "rw [finprod_eq_prod_of_mulSupport_toFinset_subset f hf (Set.Subset.refl _)]", "annotated_tactic": ["rw [<a>finprod_eq_prod_of_mulSupport_toFinset_subset</a> f hf (<a>Set.Subset.refl</a> _)]", [{"full_name": "finprod_eq_prod_of_mulSupport_toFinset_subset", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [396, 9], "def_end_pos": [396, 54]}, {"full_name": "Set.Subset.refl", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [355, 9], "def_end_pos": [355, 20]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2208 mulSupport f\n\u22a2 f a \u2223 finprod f", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2208 mulSupport f\n\u22a2 f a \u2223 \u220f i in Finite.toFinset hf, f i"}, {"tactic": "exact Finset.dvd_prod_of_mem f ((Finite.mem_toFinset hf).mpr ha)", "annotated_tactic": ["exact <a>Finset.dvd_prod_of_mem</a> f ((<a>Finite.mem_toFinset</a> hf).<a>mpr</a> ha)", [{"full_name": "Finset.dvd_prod_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1594, 9], "def_end_pos": [1594, 24]}, {"full_name": "Set.Finite.mem_toFinset", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [173, 19], "def_end_pos": [173, 31]}, {"full_name": "Iff.mpr", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [92, 3], "def_end_pos": [92, 6]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2208 mulSupport f\n\u22a2 f a \u2223 \u220f i in Finite.toFinset hf, f i", "state_after": "no goals"}, {"tactic": "rw [nmem_mulSupport.mp ha]", "annotated_tactic": ["rw [nmem_mulSupport.mp ha]", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2209 mulSupport f\n\u22a2 f a \u2223 finprod f", "state_after": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2209 mulSupport f\n\u22a2 1 \u2223 finprod f"}, {"tactic": "exact one_dvd (finprod f)", "annotated_tactic": ["exact <a>one_dvd</a> (<a>finprod</a> f)", [{"full_name": "one_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [131, 9], "def_end_pos": [131, 16]}, {"full_name": "finprod", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [101, 31], "def_end_pos": [101, 38]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf\u271d g : \u03b1 \u2192 M\na\u271d b : \u03b1\ns t : Set \u03b1\nf : \u03b1 \u2192 N\na : \u03b1\nhf : Set.Finite (mulSupport f)\nha : a \u2209 mulSupport f\n\u22a2 1 \u2223 finprod f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.le_pred_iff", "start": [710, 1], "end": [711, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderHom.comp_const", "start": [383, 1], "end": [385, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Units.lean", "full_name": "Units.divp_add_divp_same", "start": [60, 1], "end": [61, 28], "traced_tactics": [{"tactic": "simp only [divp, add_mul]", "annotated_tactic": ["simp only [<a>divp</a>, <a>add_mul</a>]", [{"full_name": "divp", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [434, 5], "def_end_pos": [434, 9]}, {"full_name": "add_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nR : Type x\ninst\u271d : Ring \u03b1\na\u271d b\u271d a b : \u03b1\nu : \u03b1\u02e3\n\u22a2 a /\u209a u + b /\u209a u = (a + b) /\u209a u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean", "full_name": "Set.Nonempty.pairwise_iff_exists_forall", "start": [100, 1], "end": [109, 84], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nhs : Set.Nonempty s\n\u22a2 Set.Pairwise s (r on f) \u2194 \u2203 z, \u2200 x \u2208 s, r (f x) z", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nhs : Set.Nonempty s\n\u22a2 Set.Pairwise s (r on f) \u2192 \u2203 z, \u2200 x \u2208 s, r (f x) z\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nhs : Set.Nonempty s\n\u22a2 (\u2203 z, \u2200 x \u2208 s, r (f x) z) \u2192 Set.Pairwise s (r on f)"}, {"tactic": "rcases hs with \u27e8y, hy\u27e9", "annotated_tactic": ["rcases hs with \u27e8y, hy\u27e9", []], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nhs : Set.Nonempty s\n\u22a2 Set.Pairwise s (r on f) \u2192 \u2203 z, \u2200 x \u2208 s, r (f x) z", "state_after": "case mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\ny : \u03b9\nhy : y \u2208 s\n\u22a2 Set.Pairwise s (r on f) \u2192 \u2203 z, \u2200 x \u2208 s, r (f x) z"}, {"tactic": "refine' fun H => \u27e8f y, fun x hx => _\u27e9", "annotated_tactic": ["refine' fun H => \u27e8f y, fun x hx => _\u27e9", []], "state_before": "case mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\ny : \u03b9\nhy : y \u2208 s\n\u22a2 Set.Pairwise s (r on f) \u2192 \u2203 z, \u2200 x \u2208 s, r (f x) z", "state_after": "case mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\ny : \u03b9\nhy : y \u2208 s\nH : Set.Pairwise s (r on f)\nx : \u03b9\nhx : x \u2208 s\n\u22a2 r (f x) (f y)"}, {"tactic": "rcases eq_or_ne x y with (rfl | hne)", "annotated_tactic": ["rcases <a>eq_or_ne</a> x y with (rfl | hne)", [{"full_name": "eq_or_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "case mp.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\ny : \u03b9\nhy : y \u2208 s\nH : Set.Pairwise s (r on f)\nx : \u03b9\nhx : x \u2208 s\n\u22a2 r (f x) (f y)", "state_after": "case mp.intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nH : Set.Pairwise s (r on f)\nx : \u03b9\nhx hy : x \u2208 s\n\u22a2 r (f x) (f x)\n\ncase mp.intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\ny : \u03b9\nhy : y \u2208 s\nH : Set.Pairwise s (r on f)\nx : \u03b9\nhx : x \u2208 s\nhne : x \u2260 y\n\u22a2 r (f x) (f y)"}, {"tactic": "apply IsRefl.refl", "annotated_tactic": ["apply <a>IsRefl.refl</a>", [{"full_name": "IsRefl.refl", "def_path": "lake-packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [181, 3], "def_end_pos": [181, 7]}]], "state_before": "case mp.intro.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nH : Set.Pairwise s (r on f)\nx : \u03b9\nhx hy : x \u2208 s\n\u22a2 r (f x) (f x)", "state_after": "no goals"}, {"tactic": "exact H hx hy hne", "annotated_tactic": ["exact H hx hy hne", []], "state_before": "case mp.intro.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\ny : \u03b9\nhy : y \u2208 s\nH : Set.Pairwise s (r on f)\nx : \u03b9\nhx : x \u2208 s\nhne : x \u2260 y\n\u22a2 r (f x) (f y)", "state_after": "no goals"}, {"tactic": "rintro \u27e8z, hz\u27e9 x hx y hy _", "annotated_tactic": ["rintro \u27e8z, hz\u27e9 x hx y hy _", []], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nhs : Set.Nonempty s\n\u22a2 (\u2203 z, \u2200 x \u2208 s, r (f x) z) \u2192 Set.Pairwise s (r on f)", "state_after": "case mpr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nhs : Set.Nonempty s\nz : \u03b1\nhz : \u2200 x \u2208 s, r (f x) z\nx : \u03b9\nhx : x \u2208 s\ny : \u03b9\nhy : y \u2208 s\na\u271d : x \u2260 y\n\u22a2 (r on f) x y"}, {"tactic": "exact @IsTrans.trans \u03b1 r _ (f x) z (f y) (hz _ hx) (IsSymm.symm _ _ <| hz _ hy)", "annotated_tactic": ["exact @<a>IsTrans.trans</a> \u03b1 r _ (f x) z (f y) (hz _ hx) (<a>IsSymm.symm</a> _ _ <| hz _ hy)", [{"full_name": "IsTrans.trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [207, 3], "def_end_pos": [207, 8]}, {"full_name": "IsSymm.symm", "def_path": "lake-packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [186, 3], "def_end_pos": [186, 7]}]], "state_before": "case mpr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns\u271d t u : Set \u03b1\na b : \u03b1\ninst\u271d : IsEquiv \u03b1 r\ns : Set \u03b9\nhs : Set.Nonempty s\nz : \u03b1\nhz : \u2200 x \u2208 s, r (f x) z\nx : \u03b9\nhx : x \u2208 s\ny : \u03b9\nhy : y \u2208 s\na\u271d : x \u2260 y\n\u22a2 (r on f) x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "TensorProduct.map_comp", "start": [798, 1], "end": [800, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "le_symmDiff_iff_right", "start": [451, 1], "end": [452, 58], "traced_tactics": [{"tactic": "rw [symmDiff_comm, le_symmDiff_iff_left, disjoint_comm]", "annotated_tactic": ["rw [<a>symmDiff_comm</a>, <a>le_symmDiff_iff_left</a>, <a>disjoint_comm</a>]", [{"full_name": "symmDiff_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [113, 9], "def_end_pos": [113, 22]}, {"full_name": "le_symmDiff_iff_left", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [444, 9], "def_end_pos": [444, 29]}, {"full_name": "disjoint_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [49, 9], "def_end_pos": [49, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\n\u22a2 b \u2264 a \u2206 b \u2194 Disjoint a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Lemmas.lean", "full_name": "MonoidHom.ext_mnat", "start": [899, 1], "end": [901, 63], "traced_tactics": [{"tactic": "rw [f.apply_mnat, g.apply_mnat, h]", "annotated_tactic": ["rw [f.apply_mnat, g.apply_mnat, h]", []], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : Monoid M\nf g : Multiplicative \u2115 \u2192* M\nh : \u2191f (\u2191Multiplicative.ofAdd 1) = \u2191g (\u2191Multiplicative.ofAdd 1)\nn : Multiplicative \u2115\n\u22a2 \u2191f n = \u2191g n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.eq_zero_of_ediv_eq_zero", "start": [798, 11], "end": [799, 49], "traced_tactics": [{"tactic": "rw [\u2190 Int.mul_ediv_cancel' h, H, Int.mul_zero]", "annotated_tactic": ["rw [\u2190 <a>Int.mul_ediv_cancel'</a> h, H, <a>Int.mul_zero</a>]", [{"full_name": "Int.mul_ediv_cancel'", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [717, 19], "def_end_pos": [717, 35]}, {"full_name": "Int.mul_zero", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [407, 27], "def_end_pos": [407, 35]}]], "state_before": "d n : Int\nh : d \u2223 n\nH : n / d = 0\n\u22a2 n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.gcd_one_right", "start": [290, 1], "end": [291, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Bool.lean", "full_name": "Bool.not_or", "start": [90, 1], "end": [90, 71], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u2200 (x y : Bool), (!(x || y)) = (!x && !y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ici_diff_Ici", "start": [1094, 1], "end": [1094, 92], "traced_tactics": [{"tactic": "rw [diff_eq, compl_Ici, Ici_inter_Iio]", "annotated_tactic": ["rw [<a>diff_eq</a>, <a>compl_Ici</a>, <a>Ici_inter_Iio</a>]", [{"full_name": "Set.diff_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1807, 9], "def_end_pos": [1807, 16]}, {"full_name": "Set.compl_Ici", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1079, 9], "def_end_pos": [1079, 18]}, {"full_name": "Set.Ici_inter_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [622, 9], "def_end_pos": [622, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\n\u22a2 Ici a \\ Ici b = Ico a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.IsMaximal.ne_top", "start": [298, 1], "end": [299, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.sdiff_insert_of_not_mem", "start": [2249, 1], "end": [2252, 49], "traced_tactics": [{"tactic": "refine' Subset.antisymm (sdiff_subset_sdiff (Subset.refl _) (subset_insert _ _)) fun y hy => _", "annotated_tactic": ["refine' <a>Subset.antisymm</a> (<a>sdiff_subset_sdiff</a> (<a>Subset.refl</a> _) (<a>subset_insert</a> _ _)) fun y hy => _", [{"full_name": "Finset.Subset.antisymm", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [368, 9], "def_end_pos": [368, 24]}, {"full_name": "Finset.sdiff_subset_sdiff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2165, 9], "def_end_pos": [2165, 27]}, {"full_name": "Finset.Subset.refl", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 20]}, {"full_name": "Finset.subset_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1206, 17], "def_end_pos": [1206, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t\u271d u v : Finset \u03b1\na b x : \u03b1\nh : x \u2209 s\nt : Finset \u03b1\n\u22a2 s \\ insert x t = s \\ t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t\u271d u v : Finset \u03b1\na b x : \u03b1\nh : x \u2209 s\nt : Finset \u03b1\ny : \u03b1\nhy : y \u2208 s \\ t\n\u22a2 y \u2208 s \\ insert x t"}, {"tactic": "simp only [mem_sdiff, mem_insert, not_or] at hy \u22a2", "annotated_tactic": ["simp only [<a>mem_sdiff</a>, <a>mem_insert</a>, <a>not_or</a>] at hy \u22a2", [{"full_name": "Finset.mem_sdiff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2097, 9], "def_end_pos": [2097, 18]}, {"full_name": "Finset.mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1099, 9], "def_end_pos": [1099, 19]}, {"full_name": "not_or", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [346, 9], "def_end_pos": [346, 15]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t\u271d u v : Finset \u03b1\na b x : \u03b1\nh : x \u2209 s\nt : Finset \u03b1\ny : \u03b1\nhy : y \u2208 s \\ t\n\u22a2 y \u2208 s \\ insert x t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t\u271d u v : Finset \u03b1\na b x : \u03b1\nh : x \u2209 s\nt : Finset \u03b1\ny : \u03b1\nhy : y \u2208 s \u2227 y \u2209 t\n\u22a2 y \u2208 s \u2227 \u00acy = x \u2227 y \u2209 t"}, {"tactic": "exact \u27e8hy.1, fun hxy => h <| hxy \u25b8 hy.1, hy.2\u27e9", "annotated_tactic": ["exact \u27e8hy.1, fun hxy => h <| hxy \u25b8 hy.1, hy.2\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t\u271d u v : Finset \u03b1\na b x : \u03b1\nh : x \u2209 s\nt : Finset \u03b1\ny : \u03b1\nhy : y \u2208 s \u2227 y \u2209 t\n\u22a2 y \u2208 s \u2227 \u00acy = x \u2227 y \u2209 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.compl_sInter", "start": [1388, 1], "end": [1389, 55], "traced_tactics": [{"tactic": "rw [sUnion_eq_compl_sInter_compl, compl_compl_image]", "annotated_tactic": ["rw [<a>sUnion_eq_compl_sInter_compl</a>, <a>compl_compl_image</a>]", [{"full_name": "Set.sUnion_eq_compl_sInter_compl", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [1383, 9], "def_end_pos": [1383, 37]}, {"full_name": "Set.compl_compl_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [404, 9], "def_end_pos": [404, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nS : Set (Set \u03b1)\n\u22a2 (\u22c2\u2080 S)\u1d9c = \u22c3\u2080 (compl '' S)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Group.lean", "full_name": "Set.sub_mem_Icc_iff_left", "start": [99, 1], "end": [100, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Meta/WellFoundedTactics.lean", "full_name": "Nat.zero_lt_one_add", "start": [19, 1], "end": [19, 75], "traced_tactics": [{"tactic": "simp [Nat.one_add]", "annotated_tactic": ["simp [<a>Nat.one_add</a>]", [{"full_name": "Nat.one_add", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [350, 9], "def_end_pos": [350, 16]}]], "state_before": "a : \u2115\n\u22a2 0 < 1 + a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "symmetric_disjoint", "start": [58, 1], "end": [59, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.IsMaximal.coprime_of_ne", "start": [324, 1], "end": [327, 89], "traced_tactics": [{"tactic": "contrapose! hne with h", "annotated_tactic": ["contrapose! hne with h", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nM M' : Ideal \u03b1\nhM : IsMaximal M\nhM' : IsMaximal M'\nhne : M \u2260 M'\n\u22a2 M \u2294 M' = \u22a4", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nM M' : Ideal \u03b1\nhM : IsMaximal M\nhM' : IsMaximal M'\nh : M \u2294 M' \u2260 \u22a4\n\u22a2 M = M'"}, {"tactic": "exact hM.eq_of_le hM'.ne_top (le_sup_left.trans_eq (hM'.eq_of_le h le_sup_right).symm)", "annotated_tactic": ["exact hM.eq_of_le hM'.ne_top (le_sup_left.trans_eq (hM'.eq_of_le h <a>le_sup_right</a>).<a>symm</a>)", [{"full_name": "le_sup_right", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [141, 9], "def_end_pos": [141, 21]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\nM M' : Ideal \u03b1\nhM : IsMaximal M\nhM' : IsMaximal M'\nh : M \u2294 M' \u2260 \u22a4\n\u22a2 M = M'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_extend_by_one", "start": [1043, 1], "end": [1045, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean", "full_name": "Polynomial.natDegree_sum_le", "start": [57, 1], "end": [59, 54], "traced_tactics": [{"tactic": "simpa using natDegree_multiset_sum_le (s.val.map f)", "annotated_tactic": ["simpa using <a>natDegree_multiset_sum_le</a> (s.val.map f)", [{"full_name": "Polynomial.natDegree_multiset_sum_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Polynomial/BigOperators.lean", "def_pos": [52, 9], "def_end_pos": [52, 34]}]], "state_before": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\nS : Type u_1\ninst\u271d : Semiring S\nf : \u03b9 \u2192 S[X]\n\u22a2 natDegree (\u2211 i in s, f i) \u2264 Finset.fold max 0 (natDegree \u2218 f) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "TensorProduct.tensorTensorTensorComm_tmul", "start": [971, 1], "end": [973, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Ring.lean", "full_name": "Commute.sq_eq_sq_iff_eq_or_eq_neg", "start": [254, 11], "end": [256, 93], "traced_tactics": [{"tactic": "rw [\u2190 sub_eq_zero, h.sq_sub_sq, mul_eq_zero, add_eq_zero_iff_eq_neg, sub_eq_zero, or_comm]", "annotated_tactic": ["rw [\u2190 <a>sub_eq_zero</a>, h.sq_sub_sq, <a>mul_eq_zero</a>, <a>add_eq_zero_iff_eq_neg</a>, <a>sub_eq_zero</a>, <a>or_comm</a>]", [{"full_name": "sub_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [801, 3], "def_end_pos": [801, 14]}, {"full_name": "mul_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [240, 9], "def_end_pos": [240, 20]}, {"full_name": "add_eq_zero_iff_eq_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [654, 3], "def_end_pos": [654, 14]}, {"full_name": "sub_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [801, 3], "def_end_pos": [801, 14]}, {"full_name": "or_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [269, 9], "def_end_pos": [269, 16]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : Ring R\na b : R\ninst\u271d : NoZeroDivisors R\nh : Commute a b\n\u22a2 a ^ 2 = b ^ 2 \u2194 a = b \u2228 a = -b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "bit0_zero", "start": [152, 1], "end": [153, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "full_name": "Submonoid.closure_eq_mrange", "start": [387, 1], "end": [388, 49], "traced_tactics": [{"tactic": "rw [FreeMonoid.mrange_lift, Subtype.range_coe]", "annotated_tactic": ["rw [<a>FreeMonoid.mrange_lift</a>, <a>Subtype.range_coe</a>]", [{"full_name": "FreeMonoid.mrange_lift", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [379, 9], "def_end_pos": [379, 38]}, {"full_name": "Subtype.range_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1409, 9], "def_end_pos": [1409, 18]}]], "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d : Monoid M\ns : Set M\n\u22a2 closure s = mrange (\u2191FreeMonoid.lift Subtype.val)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Atoms.lean", "full_name": "OrderEmbedding.isCoatom_of_map_top_of_image", "start": [791, 1], "end": [793, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "OrderIso.comap_atTop", "start": [452, 1], "end": [453, 41], "traced_tactics": [{"tactic": "simp [atTop, \u2190 e.surjective.iInf_comp]", "annotated_tactic": ["simp [<a>atTop</a>, \u2190 e.surjective.iInf_comp]", [{"full_name": "Filter.atTop", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [41, 5], "def_end_pos": [41, 10]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\n\u22a2 comap (\u2191e) atTop = atTop", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Init/Lemmas.lean", "full_name": "Nat.sub_le_sub_right", "start": [14, 11], "end": [16, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Subsingleton.atBot_eq", "start": [317, 1], "end": [318, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "full_name": "MulMemClass.mk_mul_mk", "start": [540, 1], "end": [542, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.cons_sub_of_le", "start": [1679, 1], "end": [1680, 64], "traced_tactics": [{"tactic": "rw [\u2190 singleton_add, \u2190 singleton_add, add_tsub_assoc_of_le h]", "annotated_tactic": ["rw [\u2190 <a>singleton_add</a>, \u2190 <a>singleton_add</a>, <a>add_tsub_assoc_of_le</a> h]", [{"full_name": "Multiset.singleton_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [627, 9], "def_end_pos": [627, 22]}, {"full_name": "Multiset.singleton_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [627, 9], "def_end_pos": [627, 22]}, {"full_name": "add_tsub_assoc_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [214, 9], "def_end_pos": [214, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns\u271d t\u271d u : Multiset \u03b1\na\u271d b a : \u03b1\ns t : Multiset \u03b1\nh : t \u2264 s\n\u22a2 a ::\u2098 s - t = a ::\u2098 (s - t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean", "full_name": "Set.Pairwise.mono", "start": [67, 1], "end": [68, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.succ_le", "start": [275, 1], "end": [275, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "Right.one_lt_mul'", "start": [1038, 1], "end": [1041, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "OrderIso.to_galoisConnection", "start": [66, 1], "end": [67, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.union_comm", "start": [1442, 1], "end": [1443, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iInf_sup_iInf_le", "start": [2027, 1], "end": [2028, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Closure.lean", "full_name": "LowerAdjoint.closure_eq_self_of_mem_closed", "start": [409, 1], "end": [410, 4], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Functor.lean", "full_name": "Set.eq_univ_of_coe_eq", "start": [90, 1], "end": [91, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Hom.lean", "full_name": "RingHom.toRatAlgHom_toRingHom", "start": [518, 1], "end": [520, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/CovariantClass.lean", "full_name": "pow_lt_one_iff", "start": [247, 1], "end": [248, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.aeval_X", "start": [1474, 1], "end": [1475, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.get_set_eq", "start": [87, 9], "end": [89, 56], "traced_tactics": [{"tactic": "simp [i.2]", "annotated_tactic": ["simp [i.2]", []], "state_before": "\u03b1 : Type ?u.13003\na : Array \u03b1\ni : Fin (size a)\nv : \u03b1\n\u22a2 i.val < size (set a i v)", "state_after": "no goals"}, {"tactic": "simp only [set, getElem_eq_data_get, List.get_set_eq]", "annotated_tactic": ["simp only [<a>set</a>, <a>getElem_eq_data_get</a>, <a>List.get_set_eq</a>]", [{"full_name": "Array.set", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2602, 5], "def_end_pos": [2602, 14]}, {"full_name": "Array.getElem_eq_data_get", "def_path": "lake-packages/std/Std/Data/Array/Init/Lemmas.lean", "def_pos": [29, 9], "def_end_pos": [29, 28]}, {"full_name": "List.get_set_eq", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [962, 17], "def_end_pos": [962, 27]}]], "state_before": "\u03b1 : Type u_1\na : Array \u03b1\ni : Fin (size a)\nv : \u03b1\n\u22a2 (set a i v)[i.val] = v", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/CompleteLattice.lean", "full_name": "CompleteLatticeHom.comp_assoc", "start": [751, 1], "end": [753, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.sub_eq_iff_eq_add", "start": [454, 11], "end": [456, 49], "traced_tactics": [{"tactic": "rw [c_eq.symm, Nat.sub_add_cancel ab]", "annotated_tactic": ["rw [c_eq.symm, <a>Nat.sub_add_cancel</a> ab]", [{"full_name": "Nat.sub_add_cancel", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [583, 19], "def_end_pos": [583, 33]}]], "state_before": "a b c : Nat\nab : b \u2264 a\nc_eq : a - b = c\n\u22a2 a = c + b", "state_after": "no goals"}, {"tactic": "rw [a_eq, Nat.add_sub_cancel]", "annotated_tactic": ["rw [a_eq, <a>Nat.add_sub_cancel</a>]", [{"full_name": "Nat.add_sub_cancel", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [594, 19], "def_end_pos": [594, 33]}]], "state_before": "a b c : Nat\nab : b \u2264 a\na_eq : a = c + b\n\u22a2 a - b = c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Submonoid.LocalizationMap.mk'_eq_of_eq'", "start": [831, 1], "end": [833, 53], "traced_tactics": [{"tactic": "simpa only [mul_comm] using H", "annotated_tactic": ["simpa only [<a>mul_comm</a>] using H", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "M : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\na\u2081 b\u2081 : M\na\u2082 b\u2082 : \u21a5S\nH : b\u2081 * \u2191a\u2082 = a\u2081 * \u2191b\u2082\n\u22a2 \u2191a\u2082 * b\u2081 = \u2191b\u2082 * a\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.mem_of_mem_nsmul", "start": [687, 1], "end": [692, 23], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nn : \u2115\nh : a \u2208 n \u2022 s\n\u22a2 a \u2208 s", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nh : a \u2208 zero \u2022 s\n\u22a2 a \u2208 s\n\ncase succ\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nn : \u2115\nih : a \u2208 n \u2022 s \u2192 a \u2208 s\nh : a \u2208 succ n \u2022 s\n\u22a2 a \u2208 s"}, {"tactic": "rw [zero_nsmul] at h", "annotated_tactic": ["rw [<a>zero_nsmul</a>] at h", [{"full_name": "zero_nsmul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [638, 15], "def_end_pos": [638, 25]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nh : a \u2208 zero \u2022 s\n\u22a2 a \u2208 s", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nh : a \u2208 0\n\u22a2 a \u2208 s"}, {"tactic": "exact absurd h (not_mem_zero _)", "annotated_tactic": ["exact <a>absurd</a> h (<a>not_mem_zero</a> _)", [{"full_name": "absurd", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [233, 21], "def_end_pos": [233, 27]}, {"full_name": "Multiset.not_mem_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [260, 9], "def_end_pos": [260, 21]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nh : a \u2208 0\n\u22a2 a \u2208 s", "state_after": "no goals"}, {"tactic": "rw [succ_nsmul, mem_add] at h", "annotated_tactic": ["rw [<a>succ_nsmul</a>, <a>mem_add</a>] at h", [{"full_name": "succ_nsmul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [644, 15], "def_end_pos": [644, 25]}, {"full_name": "Multiset.mem_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [683, 9], "def_end_pos": [683, 16]}]], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nn : \u2115\nih : a \u2208 n \u2022 s \u2192 a \u2208 s\nh : a \u2208 succ n \u2022 s\n\u22a2 a \u2208 s", "state_after": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nn : \u2115\nih : a \u2208 n \u2022 s \u2192 a \u2208 s\nh : a \u2208 s \u2228 a \u2208 n \u2022 s\n\u22a2 a \u2208 s"}, {"tactic": "exact h.elim id ih", "annotated_tactic": ["exact h.elim <a>id</a> ih", [{"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns : Multiset \u03b1\nn : \u2115\nih : a \u2208 n \u2022 s \u2192 a \u2208 s\nh : a \u2208 s \u2228 a \u2208 n \u2022 s\n\u22a2 a \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Logic.lean", "full_name": "false_and_iff", "start": [151, 1], "end": [151, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isLUB_le_iff", "start": [309, 1], "end": [311, 6], "traced_tactics": [{"tactic": "rw [h.upperBounds_eq]", "annotated_tactic": ["rw [h.upperBounds_eq]", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\nh : IsLUB s a\n\u22a2 a \u2264 b \u2194 b \u2208 upperBounds s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\nh : IsLUB s a\n\u22a2 a \u2264 b \u2194 b \u2208 Ici a"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\nh : IsLUB s a\n\u22a2 a \u2264 b \u2194 b \u2208 Ici a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "IsGreatest.mono", "start": [244, 1], "end": [245, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Powerset.lean", "full_name": "Multiset.powersetCardAux_cons", "start": [206, 1], "end": [209, 41], "traced_tactics": [{"tactic": "simp [powersetCardAux_eq_map_coe]", "annotated_tactic": ["simp [<a>powersetCardAux_eq_map_coe</a>]", [{"full_name": "Multiset.powersetCardAux_eq_map_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Powerset.lean", "def_pos": [180, 9], "def_end_pos": [180, 35]}]], "state_before": "\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 powersetCardAux (n + 1) (a :: l) = powersetCardAux (n + 1) l ++ List.map (cons a) (powersetCardAux n l)", "state_after": "\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 List.map (ofList \u2218 List.cons a) (sublistsLen n l) = List.map (cons a \u2218 ofList) (sublistsLen n l)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 List.map (ofList \u2218 List.cons a) (sublistsLen n l) = List.map (cons a \u2218 ofList) (sublistsLen n l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Prod.lean", "full_name": "Finset.product_biUnion", "start": [133, 1], "end": [135, 73], "traced_tactics": [{"tactic": "classical simp_rw [product_eq_biUnion, biUnion_biUnion, image_biUnion]", "annotated_tactic": ["classical simp_rw [<a>product_eq_biUnion</a>, <a>biUnion_biUnion</a>, <a>image_biUnion</a>]", [{"full_name": "Finset.product_eq_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [117, 9], "def_end_pos": [117, 27]}, {"full_name": "Finset.biUnion_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3689, 9], "def_end_pos": [3689, 24]}, {"full_name": "Finset.image_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [639, 9], "def_end_pos": [639, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d : DecidableEq \u03b3\ns : Finset \u03b1\nt : Finset \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 Finset \u03b3\n\u22a2 Finset.biUnion (s \u00d7\u02e2 t) f = Finset.biUnion s fun a => Finset.biUnion t fun b => f (a, b)", "state_after": "no goals"}, {"tactic": "simp_rw [product_eq_biUnion, biUnion_biUnion, image_biUnion]", "annotated_tactic": ["simp_rw [<a>product_eq_biUnion</a>, <a>biUnion_biUnion</a>, <a>image_biUnion</a>]", [{"full_name": "Finset.product_eq_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Prod.lean", "def_pos": [117, 9], "def_end_pos": [117, 27]}, {"full_name": "Finset.biUnion_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3689, 9], "def_end_pos": [3689, 24]}, {"full_name": "Finset.image_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [639, 9], "def_end_pos": [639, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d s' : Finset \u03b1\nt\u271d t' : Finset \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d : DecidableEq \u03b3\ns : Finset \u03b1\nt : Finset \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 Finset \u03b3\n\u22a2 Finset.biUnion (s \u00d7\u02e2 t) f = Finset.biUnion s fun a => Finset.biUnion t fun b => f (a, b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.exists_lower_bound_image", "start": [1461, 1], "end": [1466, 37], "traced_tactics": [{"tactic": "rcases s.eq_empty_or_nonempty with rfl | hs", "annotated_tactic": ["rcases s.eq_empty_or_nonempty with rfl | hs", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.Finite s\n\u22a2 \u2203 a, \u2200 b \u2208 s, f a \u2264 f b", "state_after": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Set.Finite \u2205\n\u22a2 \u2203 a, \u2200 b \u2208 \u2205, f a \u2264 f b\n\ncase inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.Finite s\nhs : Set.Nonempty s\n\u22a2 \u2203 a, \u2200 b \u2208 s, f a \u2264 f b"}, {"tactic": "exact \u2039Nonempty \u03b1\u203a.elim fun a => \u27e8a, fun _ => False.elim\u27e9", "annotated_tactic": ["exact \u2039Nonempty \u03b1\u203a.<a>elim</a> fun a => \u27e8a, fun _ => <a>False.elim</a>\u27e9", [{"full_name": "Nonempty.elim", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [720, 15], "def_end_pos": [720, 28]}, {"full_name": "False.elim", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [223, 21], "def_end_pos": [223, 31]}]], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Set.Finite \u2205\n\u22a2 \u2203 a, \u2200 b \u2208 \u2205, f a \u2264 f b", "state_after": "no goals"}, {"tactic": "rcases Set.exists_min_image s f h hs with \u27e8x\u2080, _, hx\u2080\u27e9", "annotated_tactic": ["rcases <a>Set.exists_min_image</a> s f h hs with \u27e8x\u2080, _, hx\u2080\u27e9", [{"full_name": "Set.exists_min_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1447, 9], "def_end_pos": [1447, 25]}]], "state_before": "case inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.Finite s\nhs : Set.Nonempty s\n\u22a2 \u2203 a, \u2200 b \u2208 s, f a \u2264 f b", "state_after": "case inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.Finite s\nhs : Set.Nonempty s\nx\u2080 : \u03b1\nleft\u271d : x\u2080 \u2208 s\nhx\u2080 : \u2200 b \u2208 s, f x\u2080 \u2264 f b\n\u22a2 \u2203 a, \u2200 b \u2208 s, f a \u2264 f b"}, {"tactic": "exact \u27e8x\u2080, fun x hx => hx\u2080 x hx\u27e9", "annotated_tactic": ["exact \u27e8x\u2080, fun x hx => hx\u2080 x hx\u27e9", []], "state_before": "case inr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.Finite s\nhs : Set.Nonempty s\nx\u2080 : \u03b1\nleft\u271d : x\u2080 \u2208 s\nhx\u2080 : \u2200 b \u2208 s, f x\u2080 \u2264 f b\n\u22a2 \u2203 a, \u2200 b \u2208 s, f a \u2264 f b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "fg_of_ker_bot", "start": [191, 1], "end": [194, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Tower.lean", "full_name": "IsScalarTower.toAlgHom_apply", "start": [144, 1], "end": [144, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/TypeTags.lean", "full_name": "ofAdd_zero", "start": [236, 1], "end": [237, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioc_subset_Ioc_left", "start": [484, 1], "end": [485, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "inf_symmDiff_distrib_left", "start": [402, 1], "end": [404, 31], "traced_tactics": [{"tactic": "rw [symmDiff_eq_sup_sdiff_inf, inf_sdiff_distrib_left, inf_sup_left, inf_inf_distrib_left,\n  symmDiff_eq_sup_sdiff_inf]", "annotated_tactic": ["rw [<a>symmDiff_eq_sup_sdiff_inf</a>, <a>inf_sdiff_distrib_left</a>, <a>inf_sup_left</a>, <a>inf_inf_distrib_left</a>,\n    <a>symmDiff_eq_sup_sdiff_inf</a>]", [{"full_name": "symmDiff_eq_sup_sdiff_inf", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [158, 9], "def_end_pos": [158, 34]}, {"full_name": "inf_sdiff_distrib_left", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [450, 9], "def_end_pos": [450, 31]}, {"full_name": "inf_sup_left", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [773, 9], "def_end_pos": [773, 21]}, {"full_name": "inf_inf_distrib_left", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [540, 9], "def_end_pos": [540, 29]}, {"full_name": "symmDiff_eq_sup_sdiff_inf", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [158, 9], "def_end_pos": [158, 34]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\n\u22a2 a \u2293 b \u2206 c = (a \u2293 b) \u2206 (a \u2293 c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "DoubleQuot.quotQuotEquivQuotSup_symm_quotQuotMk", "start": [690, 1], "end": [692, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithBot.unbot'_eq_self_iff", "start": [137, 9], "end": [138, 23], "traced_tactics": [{"tactic": "simp [unbot'_eq_iff]", "annotated_tactic": ["simp [<a>unbot'_eq_iff</a>]", [{"full_name": "WithBot.unbot'_eq_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [133, 9], "def_end_pos": [133, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\na b d : \u03b1\nx : WithBot \u03b1\n\u22a2 unbot' d x = d \u2194 x = \u2191d \u2228 x = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "le_csSup_of_le", "start": [473, 1], "end": [474, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "comm", "start": [33, 1], "end": [34, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "full_name": "Multiset.prod_map_pow", "start": [208, 1], "end": [209, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.bit0_div_bit0", "start": [251, 1], "end": [252, 65], "traced_tactics": [{"tactic": "rw [bit0_eq_two_mul m, \u2190 Nat.div_div_eq_div_mul, bit0_div_two]", "annotated_tactic": ["rw [<a>bit0_eq_two_mul</a> m, \u2190 <a>Nat.div_div_eq_div_mul</a>, <a>bit0_div_two</a>]", [{"full_name": "bit0_eq_two_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [183, 9], "def_end_pos": [183, 24]}, {"full_name": "Nat.div_div_eq_div_mul", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [873, 19], "def_end_pos": [873, 37]}, {"full_name": "Nat.bit0_div_two", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Parity.lean", "def_pos": [242, 9], "def_end_pos": [242, 21]}]], "state_before": "m n : \u2115\n\u22a2 bit0 n / bit0 m = n / m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.prod_sdiff_diagonal", "start": [697, 1], "end": [698, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.toFinite", "start": [82, 1], "end": [83, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.HasBasis.to_hasBasis", "start": [352, 1], "end": [356, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.Ici_succ", "start": [373, 1], "end": [374, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.iInf_neBot_of_directed'", "start": [918, 1], "end": [921, 38], "traced_tactics": [{"tactic": "simpa only [not_forall, not_neBot, \u2190 empty_mem_iff_bot,\nmem_iInf_of_directed hd] using id", "annotated_tactic": ["simpa only [<a>not_forall</a>, <a>not_neBot</a>, \u2190 <a>empty_mem_iff_bot</a>,\n    <a>mem_iInf_of_directed</a> hd] using <a>id</a>", [{"full_name": "Classical.not_forall", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [692, 9], "def_end_pos": [692, 19]}, {"full_name": "Filter.not_neBot", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [507, 17], "def_end_pos": [507, 26]}, {"full_name": "Filter.empty_mem_iff_bot", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [693, 9], "def_end_pos": [693, 26]}, {"full_name": "Filter.mem_iInf_of_directed", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [830, 9], "def_end_pos": [830, 29]}, {"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\ninst\u271d : Nonempty \u03b9\nhd : Directed (fun x x_1 => x \u2265 x_1) f\n\u22a2 \u00acNeBot (iInf f) \u2192 \u00ac\u2200 (i : \u03b9), NeBot (f i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.mul_ediv_cancel_left", "start": [219, 9], "end": [220, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.image_subset_range", "start": [723, 1], "end": [724, 58], "traced_tactics": [{"tactic": "rw [\u2190 image_univ]", "annotated_tactic": ["rw [\u2190 <a>image_univ</a>]", [{"full_name": "Set.image_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [718, 9], "def_end_pos": [718, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns\u271d t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 f '' s \u2286 range f", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns\u271d t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 f '' s \u2286 f '' univ"}, {"tactic": "exact image_subset _ (subset_univ _)", "annotated_tactic": ["exact <a>image_subset</a> _ (<a>subset_univ</a> _)", [{"full_name": "Set.image_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [321, 9], "def_end_pos": [321, 21]}, {"full_name": "Set.subset_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [684, 9], "def_end_pos": [684, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns\u271d t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 f '' s \u2286 f '' univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "sSup_image2_eq_sSup_sSup", "start": [395, 1], "end": [397, 58], "traced_tactics": [{"tactic": "simp_rw [sSup_image2, \u2190 (h\u2082 _).l_sSup, \u2190 (h\u2081 _).l_sSup]", "annotated_tactic": ["simp_rw [<a>sSup_image2</a>, \u2190 (h\u2082 _).<a>l_sSup</a>, \u2190 (h\u2081 _).<a>l_sSup</a>]", [{"full_name": "sSup_image2", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1695, 9], "def_end_pos": [1695, 20]}, {"full_name": "GaloisConnection.l_sSup", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [304, 9], "def_end_pos": [304, 15]}, {"full_name": "GaloisConnection.l_sSup", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [304, 9], "def_end_pos": [304, 15]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\n\u03ba : \u03b9 \u2192 Sort u_1\na a\u2081 a\u2082 : \u03b1\nb b\u2081 b\u2082 : \u03b2\ninst\u271d\u00b2 : CompleteLattice \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b2\ninst\u271d : CompleteLattice \u03b3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nl u : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nl\u2081 u\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03b1\nl\u2082 u\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b2\nh\u2081 : \u2200 (b : \u03b2), GaloisConnection (swap l b) (u\u2081 b)\nh\u2082 : \u2200 (a : \u03b1), GaloisConnection (l a) (u\u2082 a)\n\u22a2 sSup (image2 l s t) = l (sSup s) (sSup t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Commute/Units.lean", "full_name": "isUnit_mul_self_iff", "start": [96, 1], "end": [97, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "exists_unique_eq'", "start": [772, 9], "end": [773, 61], "traced_tactics": [{"tactic": "simp only [ExistsUnique, and_self, forall_eq', exists_eq']", "annotated_tactic": ["simp only [<a>ExistsUnique</a>, <a>and_self</a>, <a>forall_eq'</a>, <a>exists_eq'</a>]", [{"full_name": "ExistsUnique", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [221, 5], "def_end_pos": [221, 17]}, {"full_name": "and_self", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [88, 17], "def_end_pos": [88, 25]}, {"full_name": "forall_eq'", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [459, 17], "def_end_pos": [459, 27]}, {"full_name": "exists_eq'", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [463, 17], "def_end_pos": [463, 27]}]], "state_before": "\u03b9 : Sort ?u.15535\n\u03b1 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_1\np q : \u03b1 \u2192 Prop\na' : \u03b1\n\u22a2 \u2203! a, a' = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Set.iInter_eq_iInter_finset", "start": [1958, 1], "end": [1959, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isGreatest_Ioc", "start": [711, 1], "end": [712, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Chain.lean", "full_name": "List.Chain'.imp_head", "start": [335, 1], "end": [337, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Finite.lean", "full_name": "Set.finite_one", "start": [25, 1], "end": [26, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_nsmul", "start": [1227, 1], "end": [1228, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.add_eq_top_iff", "start": [523, 1], "end": [527, 67], "traced_tactics": [{"tactic": "refine PartENat.casesOn a ?_ ?_\n<;> refine PartENat.casesOn b ?_ ?_\n<;> simp [top_add, add_top]", "annotated_tactic": ["refine <a>PartENat.casesOn</a> a ?_ ?_\n  <;> refine <a>PartENat.casesOn</a> b ?_ ?_\n  <;> simp [<a>top_add</a>, <a>add_top</a>]", [{"full_name": "PartENat.casesOn", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [148, 19], "def_end_pos": [148, 26]}, {"full_name": "PartENat.casesOn", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [148, 19], "def_end_pos": [148, 26]}, {"full_name": "PartENat.top_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [153, 9], "def_end_pos": [153, 16]}, {"full_name": "PartENat.add_top", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [158, 9], "def_end_pos": [158, 16]}]], "state_before": "a b : PartENat\n\u22a2 a + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4", "state_after": "case refine_2.refine_2\na b : PartENat\n\u22a2 \u2200 (n n_1 : \u2115), \u00ac\u2191n_1 + \u2191n = \u22a4"}, {"tactic": "simp only [\u2190Nat.cast_add, PartENat.natCast_ne_top, forall_const]", "annotated_tactic": ["simp only [\u2190<a>Nat.cast_add</a>, <a>PartENat.natCast_ne_top</a>, <a>forall_const</a>]", [{"full_name": "Nat.cast_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [152, 9], "def_end_pos": [152, 17]}, {"full_name": "PartENat.natCast_ne_top", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [348, 9], "def_end_pos": [348, 23]}, {"full_name": "forall_const", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [441, 17], "def_end_pos": [441, 29]}]], "state_before": "case refine_2.refine_2\na b : PartENat\n\u22a2 \u2200 (n n_1 : \u2115), \u00ac\u2191n_1 + \u2191n = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Aut.lean", "full_name": "MulAut.inv_def", "start": [84, 1], "end": [85, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Prop.compl_singleton", "start": [3021, 9], "end": [3022, 51], "traced_tactics": [{"tactic": "simpa [@Iff.comm q] using not_iff", "annotated_tactic": ["simpa [@<a>Iff.comm</a> q] using <a>not_iff</a>", [{"full_name": "Iff.comm", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [674, 9], "def_end_pos": [674, 17]}, {"full_name": "not_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [442, 9], "def_end_pos": [442, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t u : Set \u03b1\nf : \u03b1 \u2192 \u03b2\np q : Prop\n\u22a2 q \u2208 {p}\u1d9c \u2194 q \u2208 {\u00acp}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.restrictScalars_eq_bot_iff", "start": [83, 1], "end": [84, 25], "traced_tactics": [{"tactic": "simp [SetLike.ext_iff]", "annotated_tactic": ["simp [<a>SetLike.ext_iff</a>]", [{"full_name": "SetLike.ext_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/SetLike/Basic.lean", "def_pos": [175, 9], "def_end_pos": [175, 16]}]], "state_before": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module S M\ninst\u271d\u00b9 : SMul S R\ninst\u271d : IsScalarTower S R M\np\u271d q p : Submodule R M\n\u22a2 restrictScalars S p = \u22a5 \u2194 p = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.closure_eq_bot_iff", "start": [1278, 1], "end": [1280, 21], "traced_tactics": [{"tactic": "rw [\u2190 le_bot_iff]", "annotated_tactic": ["rw [\u2190 <a>le_bot_iff</a>]", [{"full_name": "le_bot_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [355, 9], "def_end_pos": [355, 19]}]], "state_before": "G\u271d : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\u271d\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\u271d\nk : Set G\u271d\nG : Type u_5\ninst\u271d : Group G\nS : Set G\n\u22a2 closure S = \u22a5 \u2194 S \u2286 {1}", "state_after": "G\u271d : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\u271d\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\u271d\nk : Set G\u271d\nG : Type u_5\ninst\u271d : Group G\nS : Set G\n\u22a2 closure S \u2264 \u22a5 \u2194 S \u2286 {1}"}, {"tactic": "exact closure_le _", "annotated_tactic": ["exact <a>closure_le</a> _", [{"full_name": "Subgroup.closure_le", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1131, 9], "def_end_pos": [1131, 19]}]], "state_before": "G\u271d : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\u271d\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nH K : Subgroup G\u271d\nk : Set G\u271d\nG : Type u_5\ninst\u271d : Group G\nS : Set G\n\u22a2 closure S \u2264 \u22a5 \u2194 S \u2286 {1}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.forall_subtype_range_iff", "start": [687, 1], "end": [691, 13], "traced_tactics": [{"tactic": "subst hi", "annotated_tactic": ["subst hi", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u2191(range f) \u2192 Prop\nH : \u2200 (i : \u03b9), p { val := f i, property := (_ : f i \u2208 range f) }\nx\u271d : \u2191(range f)\ny : \u03b1\ni : \u03b9\nhi : f i = y\n\u22a2 p { val := y, property := (_ : \u2203 y_1, f y_1 = y) }", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u2191(range f) \u2192 Prop\nH : \u2200 (i : \u03b9), p { val := f i, property := (_ : f i \u2208 range f) }\nx\u271d : \u2191(range f)\ni : \u03b9\n\u22a2 p { val := f i, property := (_ : \u2203 y, f y = f i) }"}, {"tactic": "apply H", "annotated_tactic": ["apply H", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u2191(range f) \u2192 Prop\nH : \u2200 (i : \u03b9), p { val := f i, property := (_ : f i \u2208 range f) }\nx\u271d : \u2191(range f)\ni : \u03b9\n\u22a2 p { val := f i, property := (_ : \u2203 y, f y = f i) }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.ite_val", "start": [70, 1], "end": [72, 26], "traced_tactics": [{"tactic": "by_cases c <;> simp [*]", "annotated_tactic": ["by_cases c <;> simp [*]", []], "state_before": "n : Nat\nc : Prop\ninst\u271d : Decidable c\nx : c \u2192 Fin n\ny : \u00acc \u2192 Fin n\n\u22a2 \u2191(if h : c then x h else y h) = if h : c then \u2191(x h) else \u2191(y h)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "lt_tsub_iff_right", "start": [417, 1], "end": [418, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/TypeTags.lean", "full_name": "toAdd_one", "start": [246, 1], "end": [247, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycleOn.conj", "start": [792, 1], "end": [795, 84], "traced_tactics": [{"tactic": "rw [\u2190 preimage_inv] at hx hy", "annotated_tactic": ["rw [\u2190 <a>preimage_inv</a>] at hx hy", [{"full_name": "Equiv.Perm.preimage_inv", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [126, 15], "def_end_pos": [126, 27]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x\u271d y\u271d : \u03b1\nh : IsCycleOn f s\nx : \u03b1\nhx : x \u2208 \u2191g '' s\ny : \u03b1\nhy : y \u2208 \u2191g '' s\n\u22a2 SameCycle (g * f * g\u207b\u00b9) x y", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x\u271d y\u271d : \u03b1\nh : IsCycleOn f s\nx : \u03b1\nhx : x \u2208 \u2191g\u207b\u00b9 \u207b\u00b9' s\ny : \u03b1\nhy : y \u2208 \u2191g\u207b\u00b9 \u207b\u00b9' s\n\u22a2 SameCycle (g * f * g\u207b\u00b9) x y"}, {"tactic": "convert Equiv.Perm.SameCycle.conj (h.2 hx hy) (g := g) <;> rw [apply_inv_self]", "annotated_tactic": ["convert <a>Equiv.Perm.SameCycle.conj</a> (h.2 hx hy) (g := g) <;> rw [<a>apply_inv_self</a>]", [{"full_name": "Equiv.Perm.SameCycle.conj", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "def_pos": [129, 9], "def_end_pos": [129, 23]}, {"full_name": "Equiv.Perm.apply_inv_self", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [81, 9], "def_end_pos": [81, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\ns t : Set \u03b1\na b x\u271d y\u271d : \u03b1\nh : IsCycleOn f s\nx : \u03b1\nhx : x \u2208 \u2191g\u207b\u00b9 \u207b\u00b9' s\ny : \u03b1\nhy : y \u2208 \u2191g\u207b\u00b9 \u207b\u00b9' s\n\u22a2 SameCycle (g * f * g\u207b\u00b9) x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.image2_mul", "start": [330, 1], "end": [331, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "full_name": "AddSubmonoid.natCast_mem_one", "start": [501, 1], "end": [502, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_pmap", "start": [1538, 1], "end": [1540, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.coe_singletonOneHom", "start": [149, 1], "end": [150, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "Submodule.mem_sInf", "start": [279, 1], "end": [280, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Field/Basic.lean", "full_name": "neg_inv", "start": [124, 1], "end": [124, 94], "traced_tactics": [{"tactic": "rw [inv_eq_one_div, inv_eq_one_div, div_neg_eq_neg_div]", "annotated_tactic": ["rw [<a>inv_eq_one_div</a>, <a>inv_eq_one_div</a>, <a>div_neg_eq_neg_div</a>]", [{"full_name": "inv_eq_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [295, 9], "def_end_pos": [295, 23]}, {"full_name": "inv_eq_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [295, 9], "def_end_pos": [295, 23]}, {"full_name": "div_neg_eq_neg_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Field/Basic.lean", "def_pos": [105, 9], "def_end_pos": [105, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nK : Type u_3\ninst\u271d\u00b9 : DivisionMonoid K\ninst\u271d : HasDistribNeg K\na b : K\n\u22a2 -a\u207b\u00b9 = (-a)\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Pi.lean", "full_name": "Multiset.pi.cons_eta", "start": [62, 1], "end": [68, 24], "traced_tactics": [{"tactic": "ext a' h'", "annotated_tactic": ["ext a' h'", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\n\u22a2 (Pi.cons m a (f a (_ : a \u2208 a ::\u2098 m)) fun a' ha' => f a' (_ : a' \u2208 a ::\u2098 m)) = f", "state_after": "case h.h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\n\u22a2 Pi.cons m a (f a (_ : a \u2208 a ::\u2098 m)) (fun a' ha' => f a' (_ : a' \u2208 a ::\u2098 m)) a' h' = f a' h'"}, {"tactic": "by_cases h : a' = a", "annotated_tactic": ["by_cases h : a' = a", []], "state_before": "case h.h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\n\u22a2 Pi.cons m a (f a (_ : a \u2208 a ::\u2098 m)) (fun a' ha' => f a' (_ : a' \u2208 a ::\u2098 m)) a' h' = f a' h'", "state_after": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\nh : a' = a\n\u22a2 Pi.cons m a (f a (_ : a \u2208 a ::\u2098 m)) (fun a' ha' => f a' (_ : a' \u2208 a ::\u2098 m)) a' h' = f a' h'\n\ncase neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\nh : \u00aca' = a\n\u22a2 Pi.cons m a (f a (_ : a \u2208 a ::\u2098 m)) (fun a' ha' => f a' (_ : a' \u2208 a ::\u2098 m)) a' h' = f a' h'"}, {"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\nh : a' = a\n\u22a2 Pi.cons m a (f a (_ : a \u2208 a ::\u2098 m)) (fun a' ha' => f a' (_ : a' \u2208 a ::\u2098 m)) a' h' = f a' h'", "state_after": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na' : \u03b1\nf : (a'_1 : \u03b1) \u2192 a'_1 \u2208 a' ::\u2098 m \u2192 \u03b4 a'_1\nh' : a' \u2208 a' ::\u2098 m\n\u22a2 Pi.cons m a' (f a' (_ : a' \u2208 a' ::\u2098 m)) (fun a'_1 ha' => f a'_1 (_ : a'_1 \u2208 a' ::\u2098 m)) a' h' = f a' h'"}, {"tactic": "rw [Pi.cons_same]", "annotated_tactic": ["rw [<a>Pi.cons_same</a>]", [{"full_name": "Multiset.Pi.cons_same", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Pi.lean", "def_pos": [39, 9], "def_end_pos": [39, 21]}]], "state_before": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na' : \u03b1\nf : (a'_1 : \u03b1) \u2192 a'_1 \u2208 a' ::\u2098 m \u2192 \u03b4 a'_1\nh' : a' \u2208 a' ::\u2098 m\n\u22a2 Pi.cons m a' (f a' (_ : a' \u2208 a' ::\u2098 m)) (fun a'_1 ha' => f a'_1 (_ : a'_1 \u2208 a' ::\u2098 m)) a' h' = f a' h'", "state_after": "no goals"}, {"tactic": "rw [Pi.cons_ne _ h]", "annotated_tactic": ["rw [<a>Pi.cons_ne</a> _ h]", [{"full_name": "Multiset.Pi.cons_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Pi.lean", "def_pos": [44, 9], "def_end_pos": [44, 19]}]], "state_before": "case neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\nh : \u00aca' = a\n\u22a2 Pi.cons m a (f a (_ : a \u2208 a ::\u2098 m)) (fun a' ha' => f a' (_ : a' \u2208 a ::\u2098 m)) a' h' = f a' h'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.ext_iff", "start": [163, 11], "end": [164, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.isCompl_iff", "start": [1378, 1], "end": [1379, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_eq_dif", "start": [234, 1], "end": [240, 31], "traced_tactics": [{"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "G : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\n\u22a2 \u220f\u1da0 (i : p), f i = if h : p then f h else 1", "state_after": "case pos\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : p\n\u22a2 \u220f\u1da0 (i : p), f i = f h\n\ncase neg\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : \u00acp\n\u22a2 \u220f\u1da0 (i : p), f i = 1"}, {"tactic": "haveI : Unique p := \u27e8\u27e8h\u27e9, fun _ => rfl\u27e9", "annotated_tactic": ["haveI : <a>Unique</a> p := \u27e8\u27e8h\u27e9, fun _ => <a>rfl</a>\u27e9", [{"full_name": "Unique", "def_path": "lake-packages/mathlib/Mathlib/Logic/Unique.lean", "def_pos": [55, 11], "def_end_pos": [55, 17]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case pos\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : p\n\u22a2 \u220f\u1da0 (i : p), f i = f h", "state_after": "case pos\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : p\nthis : Unique p\n\u22a2 \u220f\u1da0 (i : p), f i = f h"}, {"tactic": "exact finprod_unique f", "annotated_tactic": ["exact <a>finprod_unique</a> f", [{"full_name": "finprod_unique", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [222, 9], "def_end_pos": [222, 23]}]], "state_before": "case pos\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : p\nthis : Unique p\n\u22a2 \u220f\u1da0 (i : p), f i = f h", "state_after": "no goals"}, {"tactic": "haveI : IsEmpty p := \u27e8h\u27e9", "annotated_tactic": ["haveI : <a>IsEmpty</a> p := \u27e8h\u27e9", [{"full_name": "IsEmpty", "def_path": "lake-packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [26, 7], "def_end_pos": [26, 14]}]], "state_before": "case neg\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : \u00acp\n\u22a2 \u220f\u1da0 (i : p), f i = 1", "state_after": "case neg\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : \u00acp\nthis : IsEmpty p\n\u22a2 \u220f\u1da0 (i : p), f i = 1"}, {"tactic": "exact finprod_of_isEmpty f", "annotated_tactic": ["exact <a>finprod_of_isEmpty</a> f", [{"full_name": "finprod_of_isEmpty", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [197, 9], "def_end_pos": [197, 27]}]], "state_before": "case neg\nG : Type u_1\nM : Type u_2\nN : Type u_3\n\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u03b9 : Sort u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : CommMonoid N\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : \u00acp\nthis : IsEmpty p\n\u22a2 \u220f\u1da0 (i : p), f i = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "sdiff_top", "start": [1000, 1], "end": [1001, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "IsStrongAntichain.image", "start": [313, 1], "end": [317, 76], "traced_tactics": [{"tactic": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 hab c", "annotated_tactic": ["rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 hab c", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns t : Set \u03b1\na b : \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\n\u22a2 IsStrongAntichain r' (f '' s)", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns t : Set \u03b1\na\u271d b\u271d : \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : f a \u2260 f b\nc : \u03b2\n\u22a2 \u00acr' (f a) c \u2228 \u00acr' (f b) c"}, {"tactic": "obtain \u27e8c, rfl\u27e9 := hf c", "annotated_tactic": ["obtain \u27e8c, rfl\u27e9 := hf c", []], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns t : Set \u03b1\na\u271d b\u271d : \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : f a \u2260 f b\nc : \u03b2\n\u22a2 \u00acr' (f a) c \u2228 \u00acr' (f b) c", "state_after": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns t : Set \u03b1\na\u271d b\u271d : \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : f a \u2260 f b\nc : \u03b1\n\u22a2 \u00acr' (f a) (f c) \u2228 \u00acr' (f b) (f c)"}, {"tactic": "exact (hs ha hb (ne_of_apply_ne _ hab) _).imp (mt <| h _ _) (mt <| h _ _)", "annotated_tactic": ["exact (hs ha hb (<a>ne_of_apply_ne</a> _ hab) _).<a>imp</a> (<a>mt</a> <| h _ _) (<a>mt</a> <| h _ _)", [{"full_name": "ne_of_apply_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [517, 9], "def_end_pos": [517, 23]}, {"full_name": "Or.imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [255, 9], "def_end_pos": [255, 15]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}]], "state_before": "case intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr' : \u03b2 \u2192 \u03b2 \u2192 Prop\ns t : Set \u03b1\na\u271d b\u271d : \u03b1\nhs : IsStrongAntichain r s\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nh : \u2200 (a b : \u03b1), r' (f a) (f b) \u2192 r a b\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : f a \u2260 f b\nc : \u03b1\n\u22a2 \u00acr' (f a) (f c) \u2228 \u00acr' (f b) (f c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "himp_bihimp_left", "start": [588, 1], "end": [589, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.mem_support_derivative", "start": [367, 1], "end": [372, 45], "traced_tactics": [{"tactic": "suffices \u00acp.coeff (n + 1) * (n + 1 : \u2115) = 0 \u2194 coeff p (n + 1) \u2260 0 by\n  simpa only [mem_support_iff, coeff_derivative, Ne.def, Nat.cast_succ]", "annotated_tactic": ["suffices \u00acp.coeff (n + 1) * (n + 1 : \u2115) = 0 \u2194 <a>coeff</a> p (n + 1) \u2260 0 by\n    simpa only [<a>mem_support_iff</a>, <a>coeff_derivative</a>, <a>Ne.def</a>, <a>Nat.cast_succ</a>]", [{"full_name": "Polynomial.coeff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [665, 5], "def_end_pos": [665, 10]}, {"full_name": "Polynomial.mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [732, 9], "def_end_pos": [732, 24]}, {"full_name": "Polynomial.coeff_derivative", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [56, 9], "def_end_pos": [56, 25]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Nat.cast_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [128, 9], "def_end_pos": [128, 18]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nn : \u2115\n\u22a2 n \u2208 support (\u2191derivative p) \u2194 n + 1 \u2208 support p", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nn : \u2115\n\u22a2 \u00accoeff p (n + 1) * \u2191(n + 1) = 0 \u2194 coeff p (n + 1) \u2260 0"}, {"tactic": "rw [\u2190 nsmul_eq_mul', smul_eq_zero]", "annotated_tactic": ["rw [\u2190 <a>nsmul_eq_mul'</a>, <a>smul_eq_zero</a>]", [{"full_name": "nsmul_eq_mul'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [502, 9], "def_end_pos": [502, 22]}, {"full_name": "smul_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [614, 9], "def_end_pos": [614, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nn : \u2115\n\u22a2 \u00accoeff p (n + 1) * \u2191(n + 1) = 0 \u2194 coeff p (n + 1) \u2260 0", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nn : \u2115\n\u22a2 \u00ac(n + 1 = 0 \u2228 coeff p (n + 1) = 0) \u2194 coeff p (n + 1) \u2260 0"}, {"tactic": "simp only [Nat.succ_ne_zero, false_or_iff]", "annotated_tactic": ["simp only [<a>Nat.succ_ne_zero</a>, <a>false_or_iff</a>]", [{"full_name": "Nat.succ_ne_zero", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [432, 9], "def_end_pos": [432, 21]}, {"full_name": "false_or_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [185, 9], "def_end_pos": [185, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nn : \u2115\n\u22a2 \u00ac(n + 1 = 0 \u2228 coeff p (n + 1) = 0) \u2194 coeff p (n + 1) \u2260 0", "state_after": "no goals"}, {"tactic": "simpa only [mem_support_iff, coeff_derivative, Ne.def, Nat.cast_succ]", "annotated_tactic": ["simpa only [<a>mem_support_iff</a>, <a>coeff_derivative</a>, <a>Ne.def</a>, <a>Nat.cast_succ</a>]", [{"full_name": "Polynomial.mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [732, 9], "def_end_pos": [732, 24]}, {"full_name": "Polynomial.coeff_derivative", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [56, 9], "def_end_pos": [56, 25]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Nat.cast_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [128, 9], "def_end_pos": [128, 18]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nn : \u2115\nthis : \u00accoeff p (n + 1) * \u2191(n + 1) = 0 \u2194 coeff p (n + 1) \u2260 0\n\u22a2 n \u2208 support (\u2191derivative p) \u2194 n + 1 \u2208 support p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "BEx.imp_left", "start": [1060, 1], "end": [1061, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "irreducible_units_mul", "start": [254, 1], "end": [262, 53], "traced_tactics": [{"tactic": "simp only [irreducible_iff, Units.isUnit_units_mul, and_congr_right_iff]", "annotated_tactic": ["simp only [<a>irreducible_iff</a>, <a>Units.isUnit_units_mul</a>, <a>and_congr_right_iff</a>]", [{"full_name": "irreducible_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [190, 9], "def_end_pos": [190, 24]}, {"full_name": "Units.isUnit_units_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [680, 9], "def_end_pos": [680, 31]}, {"full_name": "and_congr_right_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [222, 17], "def_end_pos": [222, 36]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\n\u22a2 Irreducible (\u2191a * b) \u2194 Irreducible b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\n\u22a2 \u00acIsUnit b \u2192\n    ((\u2200 (a_2 b_1 : \u03b1), \u2191a * b = a_2 * b_1 \u2192 IsUnit a_2 \u2228 IsUnit b_1) \u2194\n      \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1)"}, {"tactic": "refine' fun _ => \u27e8fun h A B HAB => _, fun h A B HAB => _\u27e9", "annotated_tactic": ["refine' fun _ => \u27e8fun h A B HAB => _, fun h A B HAB => _\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\n\u22a2 \u00acIsUnit b \u2192\n    ((\u2200 (a_2 b_1 : \u03b1), \u2191a * b = a_2 * b_1 \u2192 IsUnit a_2 \u2228 IsUnit b_1) \u2194\n      \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1)", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a_1 b_1 : \u03b1), \u2191a * b = a_1 * b_1 \u2192 IsUnit a_1 \u2228 IsUnit b_1\nA B : \u03b1\nHAB : b = A * B\n\u22a2 IsUnit A \u2228 IsUnit B\n\ncase refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1\nA B : \u03b1\nHAB : \u2191a * b = A * B\n\u22a2 IsUnit A \u2228 IsUnit B"}, {"tactic": "rw [\u2190 a.isUnit_units_mul]", "annotated_tactic": ["rw [\u2190 a.isUnit_units_mul]", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a_1 b_1 : \u03b1), \u2191a * b = a_1 * b_1 \u2192 IsUnit a_1 \u2228 IsUnit b_1\nA B : \u03b1\nHAB : b = A * B\n\u22a2 IsUnit A \u2228 IsUnit B", "state_after": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a_1 b_1 : \u03b1), \u2191a * b = a_1 * b_1 \u2192 IsUnit a_1 \u2228 IsUnit b_1\nA B : \u03b1\nHAB : b = A * B\n\u22a2 IsUnit (\u2191a * A) \u2228 IsUnit B"}, {"tactic": "apply h", "annotated_tactic": ["apply h", []], "state_before": "case refine'_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a_1 b_1 : \u03b1), \u2191a * b = a_1 * b_1 \u2192 IsUnit a_1 \u2228 IsUnit b_1\nA B : \u03b1\nHAB : b = A * B\n\u22a2 IsUnit (\u2191a * A) \u2228 IsUnit B", "state_after": "case refine'_1.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a_1 b_1 : \u03b1), \u2191a * b = a_1 * b_1 \u2192 IsUnit a_1 \u2228 IsUnit b_1\nA B : \u03b1\nHAB : b = A * B\n\u22a2 \u2191a * b = \u2191a * A * B"}, {"tactic": "rw [mul_assoc, \u2190 HAB]", "annotated_tactic": ["rw [<a>mul_assoc</a>, \u2190 HAB]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}]], "state_before": "case refine'_1.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a_1 b_1 : \u03b1), \u2191a * b = a_1 * b_1 \u2192 IsUnit a_1 \u2228 IsUnit b_1\nA B : \u03b1\nHAB : b = A * B\n\u22a2 \u2191a * b = \u2191a * A * B", "state_after": "no goals"}, {"tactic": "rw [\u2190 a\u207b\u00b9.isUnit_units_mul]", "annotated_tactic": ["rw [\u2190 a\u207b\u00b9.<a>isUnit_units_mul</a>]", [{"full_name": "Units.isUnit_units_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [680, 9], "def_end_pos": [680, 31]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1\nA B : \u03b1\nHAB : \u2191a * b = A * B\n\u22a2 IsUnit A \u2228 IsUnit B", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1\nA B : \u03b1\nHAB : \u2191a * b = A * B\n\u22a2 IsUnit (\u2191a\u207b\u00b9 * A) \u2228 IsUnit B"}, {"tactic": "apply h", "annotated_tactic": ["apply h", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1\nA B : \u03b1\nHAB : \u2191a * b = A * B\n\u22a2 IsUnit (\u2191a\u207b\u00b9 * A) \u2228 IsUnit B", "state_after": "case refine'_2.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1\nA B : \u03b1\nHAB : \u2191a * b = A * B\n\u22a2 b = \u2191a\u207b\u00b9 * A * B"}, {"tactic": "rw [mul_assoc, \u2190 HAB, Units.inv_mul_cancel_left]", "annotated_tactic": ["rw [<a>mul_assoc</a>, \u2190 HAB, <a>Units.inv_mul_cancel_left</a>]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "Units.inv_mul_cancel_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [290, 9], "def_end_pos": [290, 28]}]], "state_before": "case refine'_2.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\na : \u03b1\u02e3\nb : \u03b1\nx\u271d : \u00acIsUnit b\nh : \u2200 (a b_1 : \u03b1), b = a * b_1 \u2192 IsUnit a \u2228 IsUnit b_1\nA B : \u03b1\nHAB : \u2191a * b = A * B\n\u22a2 b = \u2191a\u207b\u00b9 * A * B", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.map_top'", "start": [1183, 1], "end": [1185, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.Ioi_pred", "start": [735, 1], "end": [736, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.SurjOn.image_eq_of_mapsTo", "start": [890, 1], "end": [891, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/NonUnitalHom.lean", "full_name": "NonUnitalAlgHom.map_add", "start": [241, 11], "end": [242, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Perm.fold_op_eq", "start": [548, 1], "end": [549, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Encodable/Basic.lean", "full_name": "Encodable.encode_false", "start": [312, 1], "end": [313, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Fold.lean", "full_name": "Finset.fold_const", "start": [84, 1], "end": [92, 16], "traced_tactics": [{"tactic": "induction' s using Finset.induction_on with x s hx IH generalizing hd", "annotated_tactic": ["induction' s using <a>Finset.induction_on</a> with x s hx IH generalizing hd", [{"full_name": "Finset.induction_on", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1263, 19], "def_end_pos": [1263, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\nhd : Decidable (s = \u2205)\nc : \u03b2\nh : op c (op b c) = op b c\n\u22a2 fold op b (fun x => c) s = if s = \u2205 then b else op b c", "state_after": "case empty\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nhd : Decidable (\u2205 = \u2205)\n\u22a2 fold op b (fun x => c) \u2205 = if \u2205 = \u2205 then b else op b c\n\ncase insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\n\u22a2 fold op b (fun x => c) (insert x s) = if insert x s = \u2205 then b else op b c"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case empty\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nhd : Decidable (\u2205 = \u2205)\n\u22a2 fold op b (fun x => c) \u2205 = if \u2205 = \u2205 then b else op b c", "state_after": "no goals"}, {"tactic": "simp only [Finset.fold_insert hx, IH, if_false, Finset.insert_ne_empty]", "annotated_tactic": ["simp only [<a>Finset.fold_insert</a> hx, IH, <a>if_false</a>, <a>Finset.insert_ne_empty</a>]", [{"full_name": "Finset.fold_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Fold.lean", "def_pos": [52, 9], "def_end_pos": [52, 20]}, {"full_name": "if_false", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [741, 17], "def_end_pos": [741, 25]}, {"full_name": "Finset.insert_ne_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1186, 9], "def_end_pos": [1186, 24]}]], "state_before": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\n\u22a2 fold op b (fun x => c) (insert x s) = if insert x s = \u2205 then b else op b c", "state_after": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\n\u22a2 op c (if s = \u2205 then b else op b c) = op b c"}, {"tactic": "split_ifs", "annotated_tactic": ["split_ifs", []], "state_before": "case insert\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\n\u22a2 op c (if s = \u2205 then b else op b c) = op b c", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\nh\u271d : s = \u2205\n\u22a2 op c b = op b c\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\nh\u271d : \u00acs = \u2205\n\u22a2 op c (op b c) = op b c"}, {"tactic": "rw [hc.comm]", "annotated_tactic": ["rw [hc.comm]", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\nh\u271d : s = \u2205\n\u22a2 op c b = op b c", "state_after": "no goals"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns\u271d : Finset \u03b1\na : \u03b1\nc : \u03b2\nh : op c (op b c) = op b c\nx : \u03b1\ns : Finset \u03b1\nhx : x \u2209 s\nIH : \u2200 [hd : Decidable (s = \u2205)], fold op b (fun x => c) s = if s = \u2205 then b else op b c\nhd : Decidable (insert x s = \u2205)\nh\u271d : \u00acs = \u2205\n\u22a2 op c (op b c) = op b c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "le_of_eq_of_le", "start": [183, 1], "end": [184, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Pow.lean", "full_name": "Nat.one_lt_pow'", "start": [74, 1], "end": [75, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "inf_congr_left", "start": [548, 1], "end": [549, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.coord_unitsSMul", "start": [1250, 1], "end": [1260, 34], "traced_tactics": [{"tactic": "apply e.ext", "annotated_tactic": ["apply e.ext", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni : \u03b9\n\u22a2 coord (unitsSMul e w) i = (w i)\u207b\u00b9 \u2022 coord e i", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni : \u03b9\n\u22a2 \u2200 (i_1 : \u03b9), \u2191(coord (unitsSMul e w) i) (\u2191e i_1) = \u2191((w i)\u207b\u00b9 \u2022 coord e i) (\u2191e i_1)"}, {"tactic": "intro j", "annotated_tactic": ["intro j", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni : \u03b9\n\u22a2 \u2200 (i_1 : \u03b9), \u2191(coord (unitsSMul e w) i) (\u2191e i_1) = \u2191((w i)\u207b\u00b9 \u2022 coord e i) (\u2191e i_1)", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(coord (unitsSMul e w) i) (\u2191e j) = \u2191((w i)\u207b\u00b9 \u2022 coord e i) (\u2191e j)"}, {"tactic": "trans ((unitsSMul e w).coord i) ((w j)\u207b\u00b9 \u2022 (unitsSMul e w) j)", "annotated_tactic": ["trans ((<a>unitsSMul</a> e w).<a>coord</a> i) ((w j)\u207b\u00b9 \u2022 (<a>unitsSMul</a> e w) j)", [{"full_name": "Basis.unitsSMul", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [1239, 5], "def_end_pos": [1239, 14]}, {"full_name": "Basis.coord", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [215, 5], "def_end_pos": [215, 10]}, {"full_name": "Basis.unitsSMul", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [1239, 5], "def_end_pos": [1239, 14]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(coord (unitsSMul e w) i) (\u2191e j) = \u2191((w i)\u207b\u00b9 \u2022 coord e i) (\u2191e j)", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(coord (unitsSMul e w) i) (\u2191e j) = \u2191(coord (unitsSMul e w) i) ((w j)\u207b\u00b9 \u2022 \u2191(unitsSMul e w) j)\n\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(coord (unitsSMul e w) i) ((w j)\u207b\u00b9 \u2022 \u2191(unitsSMul e w) j) = \u2191((w i)\u207b\u00b9 \u2022 coord e i) (\u2191e j)"}, {"tactic": "simp only [Basis.coord_apply, LinearMap.smul_apply, Basis.repr_self, Units.smul_def,\n  SMulHomClass.map_smul, Finsupp.single_apply]", "annotated_tactic": ["simp only [<a>Basis.coord_apply</a>, <a>LinearMap.smul_apply</a>, <a>Basis.repr_self</a>, <a>Units.smul_def</a>,\n      <a>SMulHomClass.map_smul</a>, <a>Finsupp.single_apply</a>]", [{"full_name": "Basis.coord_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [214, 3], "def_end_pos": [214, 9]}, {"full_name": "LinearMap.smul_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [841, 9], "def_end_pos": [841, 19]}, {"full_name": "Basis.repr_self", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [148, 9], "def_end_pos": [148, 18]}, {"full_name": "Units.smul_def", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Units.lean", "def_pos": [36, 9], "def_end_pos": [36, 17]}, {"full_name": "SMulHomClass.map_smul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Hom.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}, {"full_name": "Finsupp.single_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [307, 9], "def_end_pos": [307, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(coord (unitsSMul e w) i) ((w j)\u207b\u00b9 \u2022 \u2191(unitsSMul e w) j) = \u2191((w i)\u207b\u00b9 \u2022 coord e i) (\u2191e j)", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(\u2191(w j)\u207b\u00b9 \u2022 fun\u2080 | j => 1) i = \u2191(w i)\u207b\u00b9 \u2022 if j = i then 1 else 0"}, {"tactic": "split_ifs with h <;> simp [h]", "annotated_tactic": ["split_ifs with h <;> simp [h]", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(\u2191(w j)\u207b\u00b9 \u2022 fun\u2080 | j => 1) i = \u2191(w i)\u207b\u00b9 \u2022 if j = i then 1 else 0", "state_after": "no goals"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191(coord (unitsSMul e w) i) (\u2191e j) = \u2191(coord (unitsSMul e w) i) ((w j)\u207b\u00b9 \u2022 \u2191(unitsSMul e w) j)", "state_after": "case h.e_6.h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191e j = (w j)\u207b\u00b9 \u2022 \u2191(unitsSMul e w) j"}, {"tactic": "simp [Basis.unitsSMul, \u2190 mul_smul]", "annotated_tactic": ["simp [<a>Basis.unitsSMul</a>, \u2190 <a>mul_smul</a>]", [{"full_name": "Basis.unitsSMul", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [1239, 5], "def_end_pos": [1239, 14]}, {"full_name": "MulAction.mul_smul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}]], "state_before": "case h.e_6.h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\nv : \u03b9 \u2192 M\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : CommRing R\u2082\ninst\u271d\u2076 : AddCommGroup M\ninst\u271d\u2075 : AddCommGroup M'\ninst\u271d\u2074 : AddCommGroup M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\nc d : R\nx y : M\nb : Basis \u03b9 R M\ne : Basis \u03b9 R\u2082 M\nw : \u03b9 \u2192 R\u2082\u02e3\ni j : \u03b9\n\u22a2 \u2191e j = (w j)\u207b\u00b9 \u2022 \u2191(unitsSMul e w) j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.reverse_foldl", "start": [2389, 1], "end": [2390, 83], "traced_tactics": [{"tactic": "rw [\u2190 foldr_reverse]", "annotated_tactic": ["rw [\u2190 <a>foldr_reverse</a>]", [{"full_name": "List.foldr_reverse", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [241, 17], "def_end_pos": [241, 30]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\n\u22a2 reverse (foldl (fun t h => h :: t) [] l) = l", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\n\u22a2 reverse (foldr (fun h t => h :: t) [] (reverse l)) = l"}, {"tactic": "simp only [foldr_self_append, append_nil, reverse_reverse]", "annotated_tactic": ["simp only [<a>foldr_self_append</a>, <a>append_nil</a>, <a>reverse_reverse</a>]", [{"full_name": "List.foldr_self_append", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [263, 17], "def_end_pos": [263, 34]}, {"full_name": "List.append_nil", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [93, 17], "def_end_pos": [93, 27]}, {"full_name": "List.reverse_reverse", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [67, 17], "def_end_pos": [67, 32]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\n\u22a2 reverse (foldr (fun h t => h :: t) [] (reverse l)) = l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "Commute.list_prod_left", "start": [261, 1], "end": [263, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "full_name": "Equiv.Perm.cycleType_le_of_mem_cycleFactorsFinset", "start": [221, 1], "end": [226, 75], "traced_tactics": [{"tactic": "have hf' := mem_cycleFactorsFinset_iff.1 hf", "annotated_tactic": ["have hf' := <a>mem_cycleFactorsFinset_iff</a>.1 hf", [{"full_name": "Equiv.Perm.mem_cycleFactorsFinset_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "def_pos": [1413, 9], "def_end_pos": [1413, 35]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf g : Perm \u03b1\nhf : f \u2208 cycleFactorsFinset g\n\u22a2 cycleType f \u2264 cycleType g", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf g : Perm \u03b1\nhf : f \u2208 cycleFactorsFinset g\nhf' : IsCycle f \u2227 \u2200 a \u2208 support f, \u2191f a = \u2191g a\n\u22a2 cycleType f \u2264 cycleType g"}, {"tactic": "rw [cycleType_def, cycleType_def, hf'.left.cycleFactorsFinset_eq_singleton]", "annotated_tactic": ["rw [<a>cycleType_def</a>, <a>cycleType_def</a>, hf'.left.cycleFactorsFinset_eq_singleton]", [{"full_name": "Equiv.Perm.cycleType_def", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "def_pos": [51, 9], "def_end_pos": [51, 22]}, {"full_name": "Equiv.Perm.cycleType_def", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "def_pos": [51, 9], "def_end_pos": [51, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf g : Perm \u03b1\nhf : f \u2208 cycleFactorsFinset g\nhf' : IsCycle f \u2227 \u2200 a \u2208 support f, \u2191f a = \u2191g a\n\u22a2 cycleType f \u2264 cycleType g", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf g : Perm \u03b1\nhf : f \u2208 cycleFactorsFinset g\nhf' : IsCycle f \u2227 \u2200 a \u2208 support f, \u2191f a = \u2191g a\n\u22a2 map (Finset.card \u2218 support) {f}.val \u2264 map (Finset.card \u2218 support) (cycleFactorsFinset g).val"}, {"tactic": "refine map_le_map ?_", "annotated_tactic": ["refine <a>map_le_map</a> ?_", [{"full_name": "Multiset.map_le_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1316, 9], "def_end_pos": [1316, 19]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf g : Perm \u03b1\nhf : f \u2208 cycleFactorsFinset g\nhf' : IsCycle f \u2227 \u2200 a \u2208 support f, \u2191f a = \u2191g a\n\u22a2 map (Finset.card \u2218 support) {f}.val \u2264 map (Finset.card \u2218 support) (cycleFactorsFinset g).val", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf g : Perm \u03b1\nhf : f \u2208 cycleFactorsFinset g\nhf' : IsCycle f \u2227 \u2200 a \u2208 support f, \u2191f a = \u2191g a\n\u22a2 {f}.val \u2264 (cycleFactorsFinset g).val"}, {"tactic": "simpa only [Finset.singleton_val, singleton_le, Finset.mem_val] using hf", "annotated_tactic": ["simpa only [<a>Finset.singleton_val</a>, <a>singleton_le</a>, <a>Finset.mem_val</a>] using hf", [{"full_name": "Finset.singleton_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [674, 9], "def_end_pos": [674, 22]}, {"full_name": "Multiset.singleton_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [599, 9], "def_end_pos": [599, 21]}, {"full_name": "Finset.mem_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [184, 9], "def_end_pos": [184, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf g : Perm \u03b1\nhf : f \u2208 cycleFactorsFinset g\nhf' : IsCycle f \u2227 \u2200 a \u2208 support f, \u2191f a = \u2191g a\n\u22a2 {f}.val \u2264 (cycleFactorsFinset g).val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.sub_min_sub_right", "start": [657, 11], "end": [659, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Set.lean", "full_name": "dite_comp_equiv_update", "start": [705, 1], "end": [722, 19], "traced_tactics": [{"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\n\u22a2 (fun i => if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x", "state_after": "case h\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i"}, {"tactic": "by_cases h : p i", "annotated_tactic": ["by_cases h : p i", []], "state_before": "case h\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i", "state_after": "case pos\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : p i\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i\n\ncase neg\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : \u00acp i\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i"}, {"tactic": "rw [dif_pos h, Function.update_apply_equiv_apply, Equiv.symm_symm,\n  Function.update_apply, Function.update_apply, dif_pos h]", "annotated_tactic": ["rw [<a>dif_pos</a> h, <a>Function.update_apply_equiv_apply</a>, <a>Equiv.symm_symm</a>,\n      <a>Function.update_apply</a>, <a>Function.update_apply</a>, <a>dif_pos</a> h]", [{"full_name": "dif_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [807, 9], "def_end_pos": [807, 16]}, {"full_name": "Function.update_apply_equiv_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [2053, 9], "def_end_pos": [2053, 33]}, {"full_name": "Equiv.symm_symm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [330, 17], "def_end_pos": [330, 26]}, {"full_name": "Function.update_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [576, 9], "def_end_pos": [576, 21]}, {"full_name": "Function.update_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [576, 9], "def_end_pos": [576, 21]}, {"full_name": "dif_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [807, 9], "def_end_pos": [807, 16]}]], "state_before": "case pos\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : p i\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i", "state_after": "case pos\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : p i\n\u22a2 (if { val := i, property := h } = \u2191e j then x else (v \u2218 \u2191e.symm) { val := i, property := h }) =\n    if i = \u2191(\u2191e j) then x else v (\u2191e.symm { val := i, property := h })"}, {"tactic": "have h_coe : (\u27e8i, h\u27e9 : Subtype p) = e j \u2194 i = e j :=\n  Subtype.ext_iff.trans (by rw [Subtype.coe_mk])", "annotated_tactic": ["have h_coe : (\u27e8i, h\u27e9 : <a>Subtype</a> p) = e j \u2194 i = e j :=\n      Subtype.ext_iff.trans (by rw [<a>Subtype.coe_mk</a>])", [{"full_name": "Subtype", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [560, 11], "def_end_pos": [560, 18]}, {"full_name": "Subtype.coe_mk", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}]], "state_before": "case pos\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : p i\n\u22a2 (if { val := i, property := h } = \u2191e j then x else (v \u2218 \u2191e.symm) { val := i, property := h }) =\n    if i = \u2191(\u2191e j) then x else v (\u2191e.symm { val := i, property := h })", "state_after": "case pos\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : p i\nh_coe : { val := i, property := h } = \u2191e j \u2194 i = \u2191(\u2191e j)\n\u22a2 (if { val := i, property := h } = \u2191e j then x else (v \u2218 \u2191e.symm) { val := i, property := h }) =\n    if i = \u2191(\u2191e j) then x else v (\u2191e.symm { val := i, property := h })"}, {"tactic": "simp [h_coe]", "annotated_tactic": ["simp [h_coe]", []], "state_before": "case pos\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : p i\nh_coe : { val := i, property := h } = \u2191e j \u2194 i = \u2191(\u2191e j)\n\u22a2 (if { val := i, property := h } = \u2191e j then x else (v \u2218 \u2191e.symm) { val := i, property := h }) =\n    if i = \u2191(\u2191e j) then x else v (\u2191e.symm { val := i, property := h })", "state_after": "no goals"}, {"tactic": "rw [Subtype.coe_mk]", "annotated_tactic": ["rw [<a>Subtype.coe_mk</a>]", [{"full_name": "Subtype.coe_mk", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}]], "state_before": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : p i\n\u22a2 \u2191{ val := i, property := h } = \u2191(\u2191e j) \u2194 i = \u2191(\u2191e j)", "state_after": "no goals"}, {"tactic": "have : i \u2260 e j := by\n  contrapose! h\n  have : p (e j : \u03b1) := (e j).2\n  rwa [\u2190 h] at this", "annotated_tactic": ["have : i \u2260 e j := by\n      contrapose! h\n      have : p (e j : \u03b1) := (e j).2\n      rwa [\u2190 h] at this", []], "state_before": "case neg\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : \u00acp i\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i", "state_after": "case neg\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : \u00acp i\nthis : i \u2260 \u2191(\u2191e j)\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i"}, {"tactic": "simp [h, this]", "annotated_tactic": ["simp [h, this]", []], "state_before": "case neg\n\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : \u00acp i\nthis : i \u2260 \u2191(\u2191e j)\n\u22a2 (if h : p i then update v j x (\u2191e.symm { val := i, property := h }) else w i) =\n    update (fun i => if h : p i then v (\u2191e.symm { val := i, property := h }) else w i) (\u2191(\u2191e j)) x i", "state_after": "no goals"}, {"tactic": "contrapose! h", "annotated_tactic": ["contrapose! h", []], "state_before": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : \u00acp i\n\u22a2 i \u2260 \u2191(\u2191e j)", "state_after": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : i = \u2191(\u2191e j)\n\u22a2 p i"}, {"tactic": "have : p (e j : \u03b1) := (e j).2", "annotated_tactic": ["have : p (e j : \u03b1) := (e j).2", []], "state_before": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : i = \u2191(\u2191e j)\n\u22a2 p i", "state_after": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : i = \u2191(\u2191e j)\nthis : p \u2191(\u2191e j)\n\u22a2 p i"}, {"tactic": "rwa [\u2190 h] at this", "annotated_tactic": ["rwa [\u2190 h] at this", []], "state_before": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\np : \u03b1 \u2192 Prop\ne : \u03b2 \u2243 Subtype p\nv : \u03b2 \u2192 \u03b3\nw : \u03b1 \u2192 \u03b3\nj : \u03b2\nx : \u03b3\ninst\u271d\u00b2 : DecidableEq \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (p j)\ni : \u03b1\nh : i = \u2191(\u2191e j)\nthis : p \u2191(\u2191e j)\n\u22a2 p i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.pred_le_of_le_succ", "start": [318, 1], "end": [318, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.mk'_eq_iff_eq", "start": [319, 1], "end": [321, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "Monotone.const_mul", "start": [281, 1], "end": [282, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "full_name": "PUnit.sInf_eq", "start": [616, 1], "end": [617, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Vector/Basic.lean", "full_name": "Vector.get_map", "start": [133, 1], "end": [135, 46], "traced_tactics": [{"tactic": "cases v", "annotated_tactic": ["cases v", []], "state_before": "n : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nv : Vector \u03b1 n\nf : \u03b1 \u2192 \u03b2\ni : Fin n\n\u22a2 get (map f v) i = f (get v i)", "state_after": "case mk\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ni : Fin n\nval\u271d : List \u03b1\nproperty\u271d : List.length val\u271d = n\n\u22a2 get (map f { val := val\u271d, property := property\u271d }) i = f (get { val := val\u271d, property := property\u271d } i)"}, {"tactic": "simp [Vector.map, get_eq_get]", "annotated_tactic": ["simp [<a>Vector.map</a>, <a>get_eq_get</a>]", [{"full_name": "Vector.map", "def_path": "lake-packages/mathlib/Mathlib/Data/Vector.lean", "def_pos": [128, 5], "def_end_pos": [128, 8]}, {"full_name": "Vector.get_eq_get", "def_path": "lake-packages/mathlib/Mathlib/Data/Vector/Basic.lean", "def_pos": [116, 9], "def_end_pos": [116, 19]}]], "state_before": "case mk\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ni : Fin n\nval\u271d : List \u03b1\nproperty\u271d : List.length val\u271d = n\n\u22a2 get (map f { val := val\u271d, property := property\u271d }) i = f (get { val := val\u271d, property := property\u271d } i)", "state_after": "case mk\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ni : Fin n\nval\u271d : List \u03b1\nproperty\u271d : List.length val\u271d = n\n\u22a2 f (List.get val\u271d { val := \u2191i, isLt := (_ : \u2191i < List.length val\u271d) }) =\n    f (List.get val\u271d (Fin.cast (_ : n = List.length (toList { val := val\u271d, property := property\u271d })) i))"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ni : Fin n\nval\u271d : List \u03b1\nproperty\u271d : List.length val\u271d = n\n\u22a2 f (List.get val\u271d { val := \u2191i, isLt := (_ : \u2191i < List.length val\u271d) }) =\n    f (List.get val\u271d (Fin.cast (_ : n = List.length (toList { val := val\u271d, property := property\u271d })) i))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Star/Basic.lean", "full_name": "commute_star_star", "start": [159, 1], "end": [160, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_smul_le", "start": [1134, 1], "end": [1137, 21], "traced_tactics": [{"tactic": "refine (degree_le_iff_coeff_zero _ _).2 fun m hm => ?_", "annotated_tactic": ["refine (<a>degree_le_iff_coeff_zero</a> _ _).2 fun m hm => ?_", [{"full_name": "Polynomial.degree_le_iff_coeff_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1121, 9], "def_end_pos": [1121, 33]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\n\u22a2 degree (a \u2022 p) \u2264 degree p", "state_after": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : degree p < \u2191m\n\u22a2 coeff (a \u2022 p) m = 0"}, {"tactic": "rw [degree_lt_iff_coeff_zero] at hm", "annotated_tactic": ["rw [<a>degree_lt_iff_coeff_zero</a>] at hm", [{"full_name": "Polynomial.degree_lt_iff_coeff_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1128, 9], "def_end_pos": [1128, 33]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : degree p < \u2191m\n\u22a2 coeff (a \u2022 p) m = 0", "state_after": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : \u2200 (m_1 : \u2115), m \u2264 m_1 \u2192 coeff p m_1 = 0\n\u22a2 coeff (a \u2022 p) m = 0"}, {"tactic": "simp [hm m le_rfl]", "annotated_tactic": ["simp [hm m <a>le_rfl</a>]", [{"full_name": "le_rfl", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [170, 9], "def_end_pos": [170, 15]}]], "state_before": "R : Type u\nS : Type v\na\u271d b c d : R\nn m\u271d : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\n\u03b9 : Type u_1\na : R\np : R[X]\nm : \u2115\nhm : \u2200 (m_1 : \u2115), m \u2264 m_1 \u2192 coeff p m_1 = 0\n\u22a2 coeff (a \u2022 p) m = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/PNat/Basic.lean", "full_name": "PNat.div_add_mod", "start": [362, 1], "end": [363, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.inter_subset_inter_right", "start": [1754, 1], "end": [1755, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BotHom.cancel_right", "start": [476, 1], "end": [478, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Bits.lean", "full_name": "Nat.bit_add", "start": [90, 1], "end": [92, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/LocallyFinite.lean", "full_name": "Finset.Ico_filter_lt_of_right_le", "start": [329, 1], "end": [331, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/AbsoluteValue.lean", "full_name": "AbsoluteValue.map_sub", "start": [237, 11], "end": [237, 98], "traced_tactics": [{"tactic": "rw [\u2190 neg_sub, abv.map_neg]", "annotated_tactic": ["rw [\u2190 <a>neg_sub</a>, abv.map_neg]", [{"full_name": "neg_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [400, 3], "def_end_pos": [400, 14]}]], "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : OrderedCommRing S\nabv : AbsoluteValue R S\ninst\u271d : NoZeroDivisors S\na b : R\n\u22a2 \u2191abv (a - b) = \u2191abv (b - a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.floor_le_sub_one_iff", "start": [696, 1], "end": [696, 89], "traced_tactics": [{"tactic": "rw [\u2190 floor_lt, le_sub_one_iff]", "annotated_tactic": ["rw [\u2190 <a>floor_lt</a>, <a>le_sub_one_iff</a>]", [{"full_name": "Int.floor_lt", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [684, 9], "def_end_pos": [684, 17]}, {"full_name": "Int.le_sub_one_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [115, 9], "def_end_pos": [115, 23]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\n\u22a2 \u230aa\u230b \u2264 z - 1 \u2194 a < \u2191z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.sum_add_distrib", "start": [891, 1], "end": [894, 13], "traced_tactics": [{"tactic": "have := mk_congr (Equiv.sigmaSumDistrib (Quotient.out \u2218 f) (Quotient.out \u2218 g))", "annotated_tactic": ["have := <a>mk_congr</a> (<a>Equiv.sigmaSumDistrib</a> (<a>Quotient.out</a> \u2218 f) (<a>Quotient.out</a> \u2218 g))", [{"full_name": "Cardinal.mk_congr", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}, {"full_name": "Equiv.sigmaSumDistrib", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1038, 5], "def_end_pos": [1038, 20]}, {"full_name": "Quotient.out", "def_path": "lake-packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [374, 19], "def_end_pos": [374, 31]}, {"full_name": "Quotient.out", "def_path": "lake-packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [374, 19], "def_end_pos": [374, 31]}]], "state_before": "\u03b1 \u03b2 : Type u\n\u03b9 : Type u_1\nf g : \u03b9 \u2192 Cardinal.{u_2}\n\u22a2 sum (f + g) = sum f + sum g", "state_after": "\u03b1 \u03b2 : Type u\n\u03b9 : Type u_1\nf g : \u03b9 \u2192 Cardinal.{u_2}\nthis :\n  #((i : \u03b9) \u00d7 ((Quotient.out \u2218 f) i \u2295 (Quotient.out \u2218 g) i)) =\n    #((i : \u03b9) \u00d7 (Quotient.out \u2218 f) i \u2295 (i : \u03b9) \u00d7 (Quotient.out \u2218 g) i)\n\u22a2 sum (f + g) = sum f + sum g"}, {"tactic": "simp only [comp_apply, mk_sigma, mk_sum, mk_out, lift_id] at this", "annotated_tactic": ["simp only [<a>comp_apply</a>, <a>mk_sigma</a>, <a>mk_sum</a>, <a>mk_out</a>, <a>lift_id</a>] at this", [{"full_name": "Function.comp_apply", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [33, 17], "def_end_pos": [33, 36]}, {"full_name": "Cardinal.mk_sigma", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [873, 9], "def_end_pos": [873, 17]}, {"full_name": "Cardinal.mk_sum", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [445, 9], "def_end_pos": [445, 15]}, {"full_name": "Cardinal.mk_out", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [153, 9], "def_end_pos": [153, 15]}, {"full_name": "Cardinal.lift_id", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 16]}]], "state_before": "\u03b1 \u03b2 : Type u\n\u03b9 : Type u_1\nf g : \u03b9 \u2192 Cardinal.{u_2}\nthis :\n  #((i : \u03b9) \u00d7 ((Quotient.out \u2218 f) i \u2295 (Quotient.out \u2218 g) i)) =\n    #((i : \u03b9) \u00d7 (Quotient.out \u2218 f) i \u2295 (i : \u03b9) \u00d7 (Quotient.out \u2218 g) i)\n\u22a2 sum (f + g) = sum f + sum g", "state_after": "\u03b1 \u03b2 : Type u\n\u03b9 : Type u_1\nf g : \u03b9 \u2192 Cardinal.{u_2}\nthis : (sum fun i => f i + g i) = (sum fun i => f i) + sum fun i => g i\n\u22a2 sum (f + g) = sum f + sum g"}, {"tactic": "exact this", "annotated_tactic": ["exact this", []], "state_before": "\u03b1 \u03b2 : Type u\n\u03b9 : Type u_1\nf g : \u03b9 \u2192 Cardinal.{u_2}\nthis : (sum fun i => f i + g i) = (sum fun i => f i) + sum fun i => g i\n\u22a2 sum (f + g) = sum f + sum g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finite/Card.lean", "full_name": "Finite.card_eq_zero_of_embedding", "start": [162, 1], "end": [163, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/CharP/Basic.lean", "full_name": "CharP.exists_unique", "start": [188, 1], "end": [190, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Variables.lean", "full_name": "MvPolynomial.mem_degrees", "start": [187, 1], "end": [190, 100], "traced_tactics": [{"tactic": "classical\nsimp only [degrees_def, Multiset.mem_sup, \u2190 mem_support_iff, Finsupp.mem_toMultiset, exists_prop]", "annotated_tactic": ["classical\n  simp only [<a>degrees_def</a>, <a>Multiset.mem_sup</a>, \u2190 <a>mem_support_iff</a>, <a>Finsupp.mem_toMultiset</a>, <a>exists_prop</a>]", [{"full_name": "MvPolynomial.degrees_def", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [92, 9], "def_end_pos": [92, 20]}, {"full_name": "Multiset.mem_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1844, 9], "def_end_pos": [1844, 16]}, {"full_name": "MvPolynomial.mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [587, 9], "def_end_pos": [587, 24]}, {"full_name": "Finsupp.mem_toMultiset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [129, 9], "def_end_pos": [129, 23]}, {"full_name": "exists_prop", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [491, 17], "def_end_pos": [491, 28]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q p : MvPolynomial \u03c3 R\ni : \u03c3\n\u22a2 i \u2208 degrees p \u2194 \u2203 d, coeff d p \u2260 0 \u2227 i \u2208 d.support", "state_after": "no goals"}, {"tactic": "simp only [degrees_def, Multiset.mem_sup, \u2190 mem_support_iff, Finsupp.mem_toMultiset, exists_prop]", "annotated_tactic": ["simp only [<a>degrees_def</a>, <a>Multiset.mem_sup</a>, \u2190 <a>mem_support_iff</a>, <a>Finsupp.mem_toMultiset</a>, <a>exists_prop</a>]", [{"full_name": "MvPolynomial.degrees_def", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [92, 9], "def_end_pos": [92, 20]}, {"full_name": "Multiset.mem_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1844, 9], "def_end_pos": [1844, 16]}, {"full_name": "MvPolynomial.mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [587, 9], "def_end_pos": [587, 24]}, {"full_name": "Finsupp.mem_toMultiset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [129, 9], "def_end_pos": [129, 23]}, {"full_name": "exists_prop", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [491, 17], "def_end_pos": [491, 28]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q p : MvPolynomial \u03c3 R\ni : \u03c3\n\u22a2 i \u2208 degrees p \u2194 \u2203 d, coeff d p \u2260 0 \u2227 i \u2208 d.support", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.of_mul_add_left_right", "start": [224, 1], "end": [226, 32], "traced_tactics": [{"tactic": "rw [add_comm] at h", "annotated_tactic": ["rw [<a>add_comm</a>] at h", [{"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}]], "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (x * z + y)\n\u22a2 IsCoprime x y", "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y"}, {"tactic": "exact h.of_add_mul_left_right", "annotated_tactic": ["exact h.of_add_mul_left_right", []], "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "Ideal.Quotient.alg_map_eq", "start": [310, 1], "end": [312, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.eq_zero_of_gcd_eq_zero_right", "start": [109, 1], "end": [111, 38], "traced_tactics": [{"tactic": "rw [gcd_comm] at H", "annotated_tactic": ["rw [<a>gcd_comm</a>] at H", [{"full_name": "Nat.gcd_comm", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [59, 9], "def_end_pos": [59, 17]}]], "state_before": "m n : Nat\nH : gcd m n = 0\n\u22a2 n = 0", "state_after": "m n : Nat\nH : gcd n m = 0\n\u22a2 n = 0"}, {"tactic": "exact eq_zero_of_gcd_eq_zero_left H", "annotated_tactic": ["exact <a>eq_zero_of_gcd_eq_zero_left</a> H", [{"full_name": "Nat.eq_zero_of_gcd_eq_zero_left", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [104, 9], "def_end_pos": [104, 36]}]], "state_before": "m n : Nat\nH : gcd n m = 0\n\u22a2 n = 0", "state_after": "no goals"}]}, {"url": "https://github.com/Moyvbai/Theorem", "commit": "2fad0ff51bf93233afcde842768074b0c8b33efa", "file_path": "Theorem/example_separate/sum_mul_choose_eq_mul_sub.lean", "full_name": "sum_mul_choose_eq_mul_sub", "start": [12, 1], "end": [13, 67], "traced_tactics": [{"tactic": "rw[bot_sum_mul_congr, mul_sum_choose, mul_sum_choose_sub_choose]", "annotated_tactic": ["rw[<a>bot_sum_mul_congr</a>, <a>mul_sum_choose</a>, <a>mul_sum_choose_sub_choose</a>]", [{"full_name": "bot_sum_mul_congr", "def_path": "Theorem/example_separate/bot_sum_mul_congr.lean", "def_pos": [10, 9], "def_end_pos": [10, 26]}, {"full_name": "mul_sum_choose", "def_path": "Theorem/example_separate/mul_sum_choose.lean", "def_pos": [11, 9], "def_end_pos": [11, 23]}, {"full_name": "mul_sum_choose_sub_choose", "def_path": "Theorem/example_separate/mul_sum_choose_sub_choose.lean", "def_pos": [9, 9], "def_end_pos": [9, 34]}]], "state_before": "n : \u2115\n\u22a2 \u2211 k in range (n + 1), \u2191k * \u2191(Nat.choose (2 * n + 1) k) =\n    (2 * \u2191n + 1) * (2 ^ (2 * n - 1) - \u2191(Nat.choose (2 * n) n) / 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Relation.lean", "full_name": "reflexive_ne_imp_iff", "start": [76, 1], "end": [77, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Nodup.lean", "full_name": "Multiset.Nodup.erase_eq_filter", "start": [168, 1], "end": [171, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.EventuallyEq.inv", "start": [1544, 1], "end": [1546, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BoundedOrderHom.coe_comp", "start": [647, 1], "end": [648, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "AlgEquiv.mapMatrix_refl", "start": [1648, 1], "end": [1649, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.drop_succ_cons", "start": [188, 9], "end": [188, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "Subtype.mk_sup_mk", "start": [1442, 1], "end": [1446, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.sub_le_sub_left", "start": [461, 11], "end": [463, 55], "traced_tactics": [{"tactic": "rw [\u2190 Nat.sub_sub]", "annotated_tactic": ["rw [\u2190 <a>Nat.sub_sub</a>]", [{"full_name": "Nat.sub_sub", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [706, 19], "def_end_pos": [706, 26]}]], "state_before": "n m k a : Nat\nh : n \u2264 n + a\n\u22a2 k - (n + a) \u2264 k - n", "state_after": "n m k a : Nat\nh : n \u2264 n + a\n\u22a2 k - n - a \u2264 k - n"}, {"tactic": "apply sub_le", "annotated_tactic": ["apply <a>sub_le</a>", [{"full_name": "Nat.sub_le", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [231, 9], "def_end_pos": [231, 15]}]], "state_before": "n m k a : Nat\nh : n \u2264 n + a\n\u22a2 k - n - a \u2264 k - n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Bitwise.lean", "full_name": "Int.zero_shiftLeft", "start": [452, 1], "end": [454, 48], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n : \u2115\n\u22a2 Nat.shiftLeft' false 0 n = 0", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "a\u271d : \u2115\n\u22a2 0 >>> Nat.succ a\u271d = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "RingHom.coe_coe", "start": [454, 1], "end": [455, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/CompleteLattice.lean", "full_name": "CompleteLatticeHom.cancel_left", "start": [773, 1], "end": [775, 81], "traced_tactics": [{"tactic": "rw [\u2190 comp_apply, h, comp_apply]", "annotated_tactic": ["rw [\u2190 <a>comp_apply</a>, h, <a>comp_apply</a>]", [{"full_name": "CompleteLatticeHom.comp_apply", "def_path": "lake-packages/mathlib/Mathlib/Order/Hom/CompleteLattice.lean", "def_pos": [745, 9], "def_end_pos": [745, 19]}, {"full_name": "CompleteLatticeHom.comp_apply", "def_path": "lake-packages/mathlib/Mathlib/Order/Hom/CompleteLattice.lean", "def_pos": [745, 9], "def_end_pos": [745, 19]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\n\u03b9 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\ninst\u271d\u00b3 : CompleteLattice \u03b1\ninst\u271d\u00b2 : CompleteLattice \u03b2\ninst\u271d\u00b9 : CompleteLattice \u03b3\ninst\u271d : CompleteLattice \u03b4\ng : CompleteLatticeHom \u03b2 \u03b3\nf\u2081 f\u2082 : CompleteLatticeHom \u03b1 \u03b2\nhg : Injective \u2191g\nh : comp g f\u2081 = comp g f\u2082\na : \u03b1\n\u22a2 \u2191g (\u2191f\u2081 a) = \u2191g (\u2191f\u2082 a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Range.lean", "full_name": "Multiset.range_zero", "start": [30, 1], "end": [31, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.span_singleton_mul_left_mono", "start": [574, 1], "end": [576, 77], "traced_tactics": [{"tactic": "simpa only [mul_comm I, mul_comm J] using span_singleton_mul_right_mono hx", "annotated_tactic": ["simpa only [<a>mul_comm</a> I, <a>mul_comm</a> J] using <a>span_singleton_mul_right_mono</a> hx", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "Ideal.span_singleton_mul_right_mono", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [568, 9], "def_end_pos": [568, 38]}]], "state_before": "R : Type u\n\u03b9 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nI J K L : Ideal R\ninst\u271d : IsDomain R\nx : R\nhx : x \u2260 0\n\u22a2 I * span {x} \u2264 J * span {x} \u2194 I \u2264 J", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/ULift.lean", "full_name": "ULift.ext_iff", "start": [137, 1], "end": [138, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.apply_coe_mem_map", "start": [1397, 1], "end": [1398, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/BilinearMap.lean", "full_name": "LinearMap.lcomp\u209b\u2097_apply", "start": [298, 1], "end": [299, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Range.lean", "full_name": "Multiset.range_disjoint_map_add", "start": [66, 1], "end": [71, 43], "traced_tactics": [{"tactic": "intro x hxa hxb", "annotated_tactic": ["intro x hxa hxb", []], "state_before": "a : \u2115\nm : Multiset \u2115\n\u22a2 Disjoint (range a) (map (fun x => a + x) m)", "state_after": "a : \u2115\nm : Multiset \u2115\nx : \u2115\nhxa : x \u2208 range a\nhxb : x \u2208 map (fun x => a + x) m\n\u22a2 False"}, {"tactic": "rw [range, mem_coe, List.mem_range] at hxa", "annotated_tactic": ["rw [<a>range</a>, <a>mem_coe</a>, <a>List.mem_range</a>] at hxa", [{"full_name": "Multiset.range", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Range.lean", "def_pos": [21, 5], "def_end_pos": [21, 10]}, {"full_name": "Multiset.mem_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [226, 9], "def_end_pos": [226, 16]}, {"full_name": "List.mem_range", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2128, 9], "def_end_pos": [2128, 18]}]], "state_before": "a : \u2115\nm : Multiset \u2115\nx : \u2115\nhxa : x \u2208 range a\nhxb : x \u2208 map (fun x => a + x) m\n\u22a2 False", "state_after": "a : \u2115\nm : Multiset \u2115\nx : \u2115\nhxa : x < a\nhxb : x \u2208 map (fun x => a + x) m\n\u22a2 False"}, {"tactic": "obtain \u27e8c, _, rfl\u27e9 := mem_map.1 hxb", "annotated_tactic": ["obtain \u27e8c, _, rfl\u27e9 := <a>mem_map</a>.1 hxb", [{"full_name": "Multiset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1232, 9], "def_end_pos": [1232, 16]}]], "state_before": "a : \u2115\nm : Multiset \u2115\nx : \u2115\nhxa : x < a\nhxb : x \u2208 map (fun x => a + x) m\n\u22a2 False", "state_after": "case intro.intro\na : \u2115\nm : Multiset \u2115\nc : \u2115\nleft\u271d : c \u2208 m\nhxa : a + c < a\nhxb : a + c \u2208 map (fun x => a + x) m\n\u22a2 False"}, {"tactic": "exact (self_le_add_right _ _).not_lt hxa", "annotated_tactic": ["exact (<a>self_le_add_right</a> _ _).<a>not_lt</a> hxa", [{"full_name": "self_le_add_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [167, 3], "def_end_pos": [167, 14]}, {"full_name": "LE.le.not_lt", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [379, 7], "def_end_pos": [379, 19]}]], "state_before": "case intro.intro\na : \u2115\nm : Multiset \u2115\nc : \u2115\nleft\u271d : c \u2208 m\nhxa : a + c < a\nhxb : a + c \u2208 map (fun x => a + x) m\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.disjoint_singleton", "start": [2961, 1], "end": [2962, 41], "traced_tactics": [{"tactic": "rw [disjoint_comm, singleton_disjoint]", "annotated_tactic": ["rw [<a>disjoint_comm</a>, <a>singleton_disjoint</a>]", [{"full_name": "Multiset.disjoint_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2918, 9], "def_end_pos": [2918, 22]}, {"full_name": "Multiset.singleton_disjoint", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2956, 9], "def_end_pos": [2956, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nl : Multiset \u03b1\na : \u03b1\n\u22a2 Disjoint l {a} \u2194 a \u2209 l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Set.lean", "full_name": "Equiv.image_preimage", "start": [93, 1], "end": [94, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.iUnion_vsub", "start": [718, 1], "end": [719, 27], "traced_tactics": []}, {"url": "https://github.com/Moyvbai/Theorem", "commit": "2fad0ff51bf93233afcde842768074b0c8b33efa", "file_path": "Theorem/example_separate/sum_choose_eq.lean", "full_name": "sum_choose_eq", "start": [11, 1], "end": [15, 26], "traced_tactics": [{"tactic": "refine' sum_congr rfl fun y hy \u21a6 _", "annotated_tactic": ["refine' <a>sum_congr</a> <a>rfl</a> fun y hy \u21a6 _", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "n : \u2115\n\u22a2 \u2211 k in Ico 0 n, Nat.choose (2 * n) k = \u2211 k in Ico 0 n, Nat.choose (2 * n) (2 * n - k)", "state_after": "n y : \u2115\nhy : y \u2208 Ico 0 n\n\u22a2 Nat.choose (2 * n) y = Nat.choose (2 * n) (2 * n - y)"}, {"tactic": "have yn : y < n := by exact (mem_Ico.1 hy).2", "annotated_tactic": ["have yn : y < n := by exact (<a>mem_Ico</a>.1 hy).2", [{"full_name": "Finset.mem_Ico", "def_path": "lake-packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [331, 9], "def_end_pos": [331, 16]}]], "state_before": "n y : \u2115\nhy : y \u2208 Ico 0 n\n\u22a2 Nat.choose (2 * n) y = Nat.choose (2 * n) (2 * n - y)", "state_after": "n y : \u2115\nhy : y \u2208 Ico 0 n\nyn : y < n\n\u22a2 Nat.choose (2 * n) y = Nat.choose (2 * n) (2 * n - y)"}, {"tactic": "have y2n : y \u2264 2 * n := by linarith", "annotated_tactic": ["have y2n : y \u2264 2 * n := by linarith", []], "state_before": "n y : \u2115\nhy : y \u2208 Ico 0 n\nyn : y < n\n\u22a2 Nat.choose (2 * n) y = Nat.choose (2 * n) (2 * n - y)", "state_after": "n y : \u2115\nhy : y \u2208 Ico 0 n\nyn : y < n\ny2n : y \u2264 2 * n\n\u22a2 Nat.choose (2 * n) y = Nat.choose (2 * n) (2 * n - y)"}, {"tactic": "rw[\u2190 choose_symm y2n]", "annotated_tactic": ["rw[\u2190 <a>choose_symm</a> y2n]", [{"full_name": "Nat.choose_symm", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [192, 9], "def_end_pos": [192, 20]}]], "state_before": "n y : \u2115\nhy : y \u2208 Ico 0 n\nyn : y < n\ny2n : y \u2264 2 * n\n\u22a2 Nat.choose (2 * n) y = Nat.choose (2 * n) (2 * n - y)", "state_after": "no goals"}, {"tactic": "exact (mem_Ico.1 hy).2", "annotated_tactic": ["exact (<a>mem_Ico</a>.1 hy).2", [{"full_name": "Finset.mem_Ico", "def_path": "lake-packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [331, 9], "def_end_pos": [331, 16]}]], "state_before": "n y : \u2115\nhy : y \u2208 Ico 0 n\n\u22a2 y < n", "state_after": "no goals"}, {"tactic": "linarith", "annotated_tactic": ["linarith", []], "state_before": "n y : \u2115\nhy : y \u2208 Ico 0 n\nyn : y < n\n\u22a2 y \u2264 2 * n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.lift_sum", "start": [904, 1], "end": [910, 81], "traced_tactics": [{"tactic": "rw [\u2190 lift_mk_eq.{_,_,v}, mk_out, mk_out, lift_lift]", "annotated_tactic": ["rw [\u2190 <a>lift_mk_eq</a>.{_,_,v}, <a>mk_out</a>, <a>mk_out</a>, <a>lift_lift</a>]", [{"full_name": "Cardinal.lift_mk_eq", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [324, 9], "def_end_pos": [324, 19]}, {"full_name": "Cardinal.mk_out", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [153, 9], "def_end_pos": [153, 15]}, {"full_name": "Cardinal.mk_out", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [153, 9], "def_end_pos": [153, 15]}, {"full_name": "Cardinal.lift_lift", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [236, 9], "def_end_pos": [236, 18]}]], "state_before": "\u03b1 \u03b2 \u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{v}\na : \u03b9\n\u22a2 Nonempty (Quotient.out (f a) \u2243 Quotient.out ((fun i => lift.{w, v} (f i)) a))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/LinearMap.lean", "full_name": "IsLinearMap.map_neg", "start": [749, 1], "end": [750, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Sigma.lean", "full_name": "Set.sigma_preimage_eq", "start": [156, 1], "end": [159, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.inf'_mul_le_mul_inf'_of_nonneg", "start": [1998, 1], "end": [2001, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.empty_div", "start": [622, 1], "end": [623, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.set_eq_nil", "start": [2247, 1], "end": [2248, 42], "traced_tactics": [{"tactic": "cases l <;> cases n <;> simp only [set]", "annotated_tactic": ["cases l <;> cases n <;> simp only [<a>set</a>]", [{"full_name": "List.set", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2235, 5], "def_end_pos": [2235, 13]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 l : List \u03b1\nn : \u2115\na : \u03b1\n\u22a2 set l n a = [] \u2194 l = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get_set_ne", "start": [966, 9], "end": [969, 72], "traced_tactics": [{"tactic": "simp at hj", "annotated_tactic": ["simp at hj", []], "state_before": "\u03b1 : Type ?u.147541\nl : List \u03b1\ni j : Nat\nh : i \u2260 j\na : \u03b1\nhj : j < length (set l i a)\n\u22a2 j < length l", "state_after": "\u03b1 : Type ?u.147541\nl : List \u03b1\ni j : Nat\nh : i \u2260 j\na : \u03b1\nhj : j < length l\n\u22a2 j < length l"}, {"tactic": "exact hj", "annotated_tactic": ["exact hj", []], "state_before": "\u03b1 : Type ?u.147541\nl : List \u03b1\ni j : Nat\nh : i \u2260 j\na : \u03b1\nhj : j < length l\n\u22a2 j < length l", "state_after": "no goals"}, {"tactic": "rw [\u2190 Option.some_inj, \u2190 get?_eq_get, get?_set_ne _ _ h, get?_eq_get]", "annotated_tactic": ["rw [\u2190 <a>Option.some_inj</a>, \u2190 <a>get?_eq_get</a>, <a>get?_set_ne</a> _ _ h, <a>get?_eq_get</a>]", [{"full_name": "Option.some_inj", "def_path": "lake-packages/std/Std/Data/Option/Basic.lean", "def_pos": [27, 9], "def_end_pos": [27, 17]}, {"full_name": "List.get?_eq_get", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 20]}, {"full_name": "List.get?_set_ne", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [929, 9], "def_end_pos": [929, 20]}, {"full_name": "List.get?_eq_get", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [598, 9], "def_end_pos": [598, 20]}]], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\ni j : Nat\nh : i \u2260 j\na : \u03b1\nhj : j < length (set l i a)\n\u22a2 get (set l i a) { val := j, isLt := hj } = get l { val := j, isLt := (_ : j < length l) }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "full_name": "MonoidHom.map_zpowers", "start": [157, 1], "end": [159, 100], "traced_tactics": [{"tactic": "rw [Subgroup.zpowers_eq_closure, Subgroup.zpowers_eq_closure, f.map_closure, Set.image_singleton]", "annotated_tactic": ["rw [<a>Subgroup.zpowers_eq_closure</a>, <a>Subgroup.zpowers_eq_closure</a>, f.map_closure, <a>Set.image_singleton</a>]", [{"full_name": "Subgroup.zpowers_eq_closure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/ZPowers.lean", "def_pos": [40, 9], "def_end_pos": [40, 27]}, {"full_name": "Subgroup.zpowers_eq_closure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/ZPowers.lean", "def_pos": [40, 9], "def_end_pos": [40, 27]}, {"full_name": "Set.image_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [363, 9], "def_end_pos": [363, 24]}]], "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nf : G \u2192* N\nx : G\n\u22a2 Subgroup.map f (Subgroup.zpowers x) = Subgroup.zpowers (\u2191f x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.smul_eq_cast", "start": [510, 1], "end": [510, 98], "traced_tactics": [{"tactic": "subst_vars", "annotated_tactic": ["subst_vars", []], "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na : \u2115\na' b c : R\nx\u271d\u00b9 : \u2191a = a'\nx\u271d : a' * b = c\n\u22a2 a \u2022 b = c", "state_after": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na : \u2115\nb : R\n\u22a2 a \u2022 b = \u2191a * b"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na : \u2115\nb : R\n\u22a2 a \u2022 b = \u2191a * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.toFinset_ssubset", "start": [203, 1], "end": [204, 49], "traced_tactics": [{"tactic": "rw [\u2190 Finset.coe_ssubset, Finite.coe_toFinset]", "annotated_tactic": ["rw [\u2190 <a>Finset.coe_ssubset</a>, <a>Finite.coe_toFinset</a>]", [{"full_name": "Finset.coe_ssubset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [412, 9], "def_end_pos": [412, 20]}, {"full_name": "Set.Finite.coe_toFinset", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [178, 19], "def_end_pos": [178, 31]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t\u271d : Set \u03b1\na : \u03b1\nhs : Set.Finite s\nht : Set.Finite t\u271d\nt : Finset \u03b1\n\u22a2 Finite.toFinset hs \u2282 t \u2194 s \u2282 \u2191t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/OrderIsoNat.lean", "full_name": "Nat.exists_subseq_of_forall_mem_union", "start": [153, 1], "end": [161, 94], "traced_tactics": [{"tactic": "classical\n  have : Infinite (e \u207b\u00b9' s) \u2228 Infinite (e \u207b\u00b9' t) := by\n    simp only [Set.infinite_coe_iff, \u2190 Set.infinite_union, \u2190 Set.preimage_union,\n      Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n), Set.infinite_univ]\n  cases this\n  exacts [\u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' s), Or.inl fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' s) _).2\u27e9,\n    \u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' t), Or.inr fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' t) _).2\u27e9]", "annotated_tactic": ["classical\n    have : <a>Infinite</a> (e \u207b\u00b9' s) \u2228 <a>Infinite</a> (e \u207b\u00b9' t) := by\n      simp only [<a>Set.infinite_coe_iff</a>, \u2190 <a>Set.infinite_union</a>, \u2190 <a>Set.preimage_union</a>,\n        <a>Set.eq_univ_of_forall</a> fun n => <a>Set.mem_preimage</a>.2 (he n), <a>Set.infinite_univ</a>]\n    cases this\n    exacts [\u27e8<a>Nat.orderEmbeddingOfSet</a> (e \u207b\u00b9' s), <a>Or.inl</a> fun n => (<a>Nat.Subtype.ofNat</a> (e \u207b\u00b9' s) _).2\u27e9,\n      \u27e8<a>Nat.orderEmbeddingOfSet</a> (e \u207b\u00b9' t), <a>Or.inr</a> fun n => (<a>Nat.Subtype.ofNat</a> (e \u207b\u00b9' t) _).2\u27e9]", [{"full_name": "Infinite", "def_path": "lake-packages/mathlib/Mathlib/Data/Finite/Defs.lean", "def_pos": [95, 7], "def_end_pos": [95, 15]}, {"full_name": "Infinite", "def_path": "lake-packages/mathlib/Mathlib/Data/Finite/Defs.lean", "def_pos": [95, 7], "def_end_pos": [95, 15]}, {"full_name": "Set.infinite_coe_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1287, 9], "def_end_pos": [1287, 25]}, {"full_name": "Set.infinite_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 23]}, {"full_name": "Set.preimage_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [92, 9], "def_end_pos": [92, 23]}, {"full_name": "Set.eq_univ_of_forall", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [698, 9], "def_end_pos": [698, 26]}, {"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Set.infinite_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1283, 9], "def_end_pos": [1283, 22]}, {"full_name": "Nat.orderEmbeddingOfSet", "def_path": "lake-packages/mathlib/Mathlib/Order/OrderIsoNat.lean", "def_pos": [110, 5], "def_end_pos": [110, 24]}, {"full_name": "Or.inl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 5], "def_end_pos": [517, 8]}, {"full_name": "Nat.Subtype.ofNat", "def_path": "lake-packages/mathlib/Mathlib/Logic/Denumerable.lean", "def_pos": [274, 5], "def_end_pos": [274, 10]}, {"full_name": "Nat.orderEmbeddingOfSet", "def_path": "lake-packages/mathlib/Mathlib/Order/OrderIsoNat.lean", "def_pos": [110, 5], "def_end_pos": [110, 24]}, {"full_name": "Or.inr", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [519, 5], "def_end_pos": [519, 8]}, {"full_name": "Nat.Subtype.ofNat", "def_path": "lake-packages/mathlib/Mathlib/Logic/Denumerable.lean", "def_pos": [274, 5], "def_end_pos": [274, 10]}]], "state_before": "\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t", "state_after": "no goals"}, {"tactic": "have : Infinite (e \u207b\u00b9' s) \u2228 Infinite (e \u207b\u00b9' t) := by\n  simp only [Set.infinite_coe_iff, \u2190 Set.infinite_union, \u2190 Set.preimage_union,\n    Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n), Set.infinite_univ]", "annotated_tactic": ["have : <a>Infinite</a> (e \u207b\u00b9' s) \u2228 <a>Infinite</a> (e \u207b\u00b9' t) := by\n      simp only [<a>Set.infinite_coe_iff</a>, \u2190 <a>Set.infinite_union</a>, \u2190 <a>Set.preimage_union</a>,\n        <a>Set.eq_univ_of_forall</a> fun n => <a>Set.mem_preimage</a>.2 (he n), <a>Set.infinite_univ</a>]", [{"full_name": "Infinite", "def_path": "lake-packages/mathlib/Mathlib/Data/Finite/Defs.lean", "def_pos": [95, 7], "def_end_pos": [95, 15]}, {"full_name": "Infinite", "def_path": "lake-packages/mathlib/Mathlib/Data/Finite/Defs.lean", "def_pos": [95, 7], "def_end_pos": [95, 15]}, {"full_name": "Set.infinite_coe_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1287, 9], "def_end_pos": [1287, 25]}, {"full_name": "Set.infinite_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 23]}, {"full_name": "Set.preimage_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [92, 9], "def_end_pos": [92, 23]}, {"full_name": "Set.eq_univ_of_forall", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [698, 9], "def_end_pos": [698, 26]}, {"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Set.infinite_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1283, 9], "def_end_pos": [1283, 22]}]], "state_before": "\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t", "state_after": "\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\nthis : Infinite \u2191(e \u207b\u00b9' s) \u2228 Infinite \u2191(e \u207b\u00b9' t)\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t"}, {"tactic": "cases this", "annotated_tactic": ["cases this", []], "state_before": "\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\nthis : Infinite \u2191(e \u207b\u00b9' s) \u2228 Infinite \u2191(e \u207b\u00b9' t)\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t", "state_after": "case inl\n\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\nh\u271d : Infinite \u2191(e \u207b\u00b9' s)\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t\n\ncase inr\n\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\nh\u271d : Infinite \u2191(e \u207b\u00b9' t)\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t"}, {"tactic": "exacts [\u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' s), Or.inl fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' s) _).2\u27e9,\n  \u27e8Nat.orderEmbeddingOfSet (e \u207b\u00b9' t), Or.inr fun n => (Nat.Subtype.ofNat (e \u207b\u00b9' t) _).2\u27e9]", "annotated_tactic": ["exacts [\u27e8<a>Nat.orderEmbeddingOfSet</a> (e \u207b\u00b9' s), <a>Or.inl</a> fun n => (<a>Nat.Subtype.ofNat</a> (e \u207b\u00b9' s) _).2\u27e9,\n      \u27e8<a>Nat.orderEmbeddingOfSet</a> (e \u207b\u00b9' t), <a>Or.inr</a> fun n => (<a>Nat.Subtype.ofNat</a> (e \u207b\u00b9' t) _).2\u27e9]", [{"full_name": "Nat.orderEmbeddingOfSet", "def_path": "lake-packages/mathlib/Mathlib/Order/OrderIsoNat.lean", "def_pos": [110, 5], "def_end_pos": [110, 24]}, {"full_name": "Or.inl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 5], "def_end_pos": [517, 8]}, {"full_name": "Nat.Subtype.ofNat", "def_path": "lake-packages/mathlib/Mathlib/Logic/Denumerable.lean", "def_pos": [274, 5], "def_end_pos": [274, 10]}, {"full_name": "Nat.orderEmbeddingOfSet", "def_path": "lake-packages/mathlib/Mathlib/Order/OrderIsoNat.lean", "def_pos": [110, 5], "def_end_pos": [110, 24]}, {"full_name": "Or.inr", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [519, 5], "def_end_pos": [519, 8]}, {"full_name": "Nat.Subtype.ofNat", "def_path": "lake-packages/mathlib/Mathlib/Logic/Denumerable.lean", "def_pos": [274, 5], "def_end_pos": [274, 10]}]], "state_before": "case inl\n\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\nh\u271d : Infinite \u2191(e \u207b\u00b9' s)\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t\n\ncase inr\n\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\nh\u271d : Infinite \u2191(e \u207b\u00b9' t)\n\u22a2 \u2203 g, (\u2200 (n : \u2115), e (\u2191g n) \u2208 s) \u2228 \u2200 (n : \u2115), e (\u2191g n) \u2208 t", "state_after": "no goals"}, {"tactic": "simp only [Set.infinite_coe_iff, \u2190 Set.infinite_union, \u2190 Set.preimage_union,\n  Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n), Set.infinite_univ]", "annotated_tactic": ["simp only [<a>Set.infinite_coe_iff</a>, \u2190 <a>Set.infinite_union</a>, \u2190 <a>Set.preimage_union</a>,\n        <a>Set.eq_univ_of_forall</a> fun n => <a>Set.mem_preimage</a>.2 (he n), <a>Set.infinite_univ</a>]", [{"full_name": "Set.infinite_coe_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1287, 9], "def_end_pos": [1287, 25]}, {"full_name": "Set.infinite_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1322, 9], "def_end_pos": [1322, 23]}, {"full_name": "Set.preimage_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [92, 9], "def_end_pos": [92, 23]}, {"full_name": "Set.eq_univ_of_forall", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [698, 9], "def_end_pos": [698, 26]}, {"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Set.infinite_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [1283, 9], "def_end_pos": [1283, 22]}]], "state_before": "\u03b1 : Type u_1\ns\u271d : Set \u2115\ninst\u271d : Infinite \u2191s\u271d\ns t : Set \u03b1\ne : \u2115 \u2192 \u03b1\nhe : \u2200 (n : \u2115), e n \u2208 s \u222a t\n\u22a2 Infinite \u2191(e \u207b\u00b9' s) \u2228 Infinite \u2191(e \u207b\u00b9' t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.nthLe_insertNth_add_succ", "start": [1689, 1], "end": [1695, 28], "traced_tactics": [{"tactic": "rw [length_insertNth _ _ (le_self_add.trans hk'.le)]", "annotated_tactic": ["rw [<a>length_insertNth</a> _ _ (le_self_add.trans hk'.le)]", [{"full_name": "List.length_insertNth", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1552, 9], "def_end_pos": [1552, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl : List \u03b1\nx : \u03b1\nn k : \u2115\nhk' : n + k < length l\n\u22a2 n + k + 1 < length (insertNth n x l)", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl : List \u03b1\nx : \u03b1\nn k : \u2115\nhk' : n + k < length l\n\u22a2 n + k + 1 < length l + 1"}, {"tactic": "exact Nat.succ_lt_succ_iff.2 hk'", "annotated_tactic": ["exact <a>Nat.succ_lt_succ_iff</a>.2 hk'", [{"full_name": "Nat.succ_lt_succ_iff", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [298, 9], "def_end_pos": [298, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl : List \u03b1\nx : \u03b1\nn k : \u2115\nhk' : n + k < length l\n\u22a2 n + k + 1 < length l + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeq.lean", "full_name": "CauSeq.pow_equiv_pow", "start": [582, 1], "end": [585, 52], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\nn : \u2115\n\u22a2 f1 ^ n \u2248 f2 ^ n", "state_after": "case zero\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\n\u22a2 f1 ^ Nat.zero \u2248 f2 ^ Nat.zero\n\ncase succ\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\nn : \u2115\nih : f1 ^ n \u2248 f2 ^ n\n\u22a2 f1 ^ Nat.succ n \u2248 f2 ^ Nat.succ n"}, {"tactic": "simp only [Nat.zero_eq, pow_zero, Setoid.refl]", "annotated_tactic": ["simp only [<a>Nat.zero_eq</a>, <a>pow_zero</a>, <a>Setoid.refl</a>]", [{"full_name": "Nat.zero_eq", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "pow_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [639, 9], "def_end_pos": [639, 17]}, {"full_name": "Setoid.refl", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [1094, 9], "def_end_pos": [1094, 13]}]], "state_before": "case zero\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\n\u22a2 f1 ^ Nat.zero \u2248 f2 ^ Nat.zero", "state_after": "no goals"}, {"tactic": "simpa only [pow_succ] using mul_equiv_mul hf ih", "annotated_tactic": ["simpa only [<a>pow_succ</a>] using <a>mul_equiv_mul</a> hf ih", [{"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}, {"full_name": "CauSeq.mul_equiv_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/CauSeq.lean", "def_pos": [562, 9], "def_end_pos": [562, 22]}]], "state_before": "case succ\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\nn : \u2115\nih : f1 ^ n \u2248 f2 ^ n\n\u22a2 f1 ^ Nat.succ n \u2248 f2 ^ Nat.succ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.union_mul_inter_subset", "start": [871, 1], "end": [872, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "le_csInf_inter", "start": [715, 1], "end": [717, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Combinatorics/Composition.lean", "full_name": "CompositionAsSet.boundary_length", "start": [901, 1], "end": [903, 71], "traced_tactics": [{"tactic": "convert Finset.orderEmbOfFin_last rfl c.card_boundaries_pos", "annotated_tactic": ["convert <a>Finset.orderEmbOfFin_last</a> <a>rfl</a> c.card_boundaries_pos", [{"full_name": "Finset.orderEmbOfFin_last", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Sort.lean", "def_pos": [201, 9], "def_end_pos": [201, 27]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "n : \u2115\nc : CompositionAsSet n\n\u22a2 \u2191(boundary c) { val := length c, isLt := (_ : length c < Finset.card c.boundaries) } = Fin.last n", "state_after": "case h.e'_3\nn : \u2115\nc : CompositionAsSet n\n\u22a2 Fin.last n = Finset.max' c.boundaries (_ : Finset.Nonempty c.boundaries)"}, {"tactic": "exact le_antisymm (Finset.le_max' _ _ c.getLast_mem) (Fin.le_last _)", "annotated_tactic": ["exact <a>le_antisymm</a> (<a>Finset.le_max'</a> _ _ c.getLast_mem) (<a>Fin.le_last</a> _)", [{"full_name": "le_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}, {"full_name": "Finset.le_max'", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1445, 9], "def_end_pos": [1445, 16]}, {"full_name": "Fin.le_last", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [149, 9], "def_end_pos": [149, 16]}]], "state_before": "case h.e'_3\nn : \u2115\nc : CompositionAsSet n\n\u22a2 Fin.last n = Finset.max' c.boundaries (_ : Finset.Nonempty c.boundaries)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.compl_image", "start": [552, 1], "end": [553, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.filter_ne", "start": [3014, 1], "end": [3018, 8], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b2\nb : \u03b2\n\u22a2 filter (fun a => b \u2260 a) s = erase s b", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b2\nb a\u271d : \u03b2\n\u22a2 a\u271d \u2208 filter (fun a => b \u2260 a) s \u2194 a\u271d \u2208 erase s b"}, {"tactic": "simp only [mem_filter, mem_erase, Ne.def, decide_not, Bool.not_eq_true', decide_eq_false_iff_not]", "annotated_tactic": ["simp only [<a>mem_filter</a>, <a>mem_erase</a>, <a>Ne.def</a>, <a>decide_not</a>, <a>Bool.not_eq_true'</a>, <a>decide_eq_false_iff_not</a>]", [{"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}, {"full_name": "Finset.mem_erase", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1904, 9], "def_end_pos": [1904, 18]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "decide_not", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [146, 17], "def_end_pos": [146, 27]}, {"full_name": "Bool.not_eq_true'", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [134, 17], "def_end_pos": [134, 34]}, {"full_name": "decide_eq_false_iff_not", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [545, 17], "def_end_pos": [545, 40]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b2\nb a\u271d : \u03b2\n\u22a2 a\u271d \u2208 filter (fun a => b \u2260 a) s \u2194 a\u271d \u2208 erase s b", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b2\nb a\u271d : \u03b2\n\u22a2 a\u271d \u2208 s \u2227 \u00acb = a\u271d \u2194 \u00aca\u271d = b \u2227 a\u271d \u2208 s"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np q : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\ninst\u271d\u00b2 : DecidablePred q\ns\u271d : Finset \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\ns : Finset \u03b2\nb a\u271d : \u03b2\n\u22a2 a\u271d \u2208 s \u2227 \u00acb = a\u271d \u2194 \u00aca\u271d = b \u2227 a\u271d \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.nsmul_mem", "start": [152, 11], "end": [153, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iInf_union", "start": [1487, 1], "end": [1488, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.minimalPeriod_id", "start": [367, 1], "end": [369, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Fin.lean", "full_name": "Fin.cycleRange_of_eq", "start": [207, 1], "end": [208, 39], "traced_tactics": [{"tactic": "rw [cycleRange_of_le h.le, if_pos h]", "annotated_tactic": ["rw [<a>cycleRange_of_le</a> h.le, <a>if_pos</a> h]", [{"full_name": "Fin.cycleRange_of_le", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Fin.lean", "def_pos": [169, 9], "def_end_pos": [169, 25]}, {"full_name": "if_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [790, 9], "def_end_pos": [790, 15]}]], "state_before": "n : \u2115\ni j : Fin (Nat.succ n)\nh : j = i\n\u22a2 \u2191(cycleRange i) j = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.single_eq_algebraMap_mul_of", "start": [822, 1], "end": [823, 74], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring k\ninst\u271d : Monoid G\na : G\nb : k\n\u22a2 single a b = \u2191(algebraMap k (MonoidAlgebra k G)) b * \u2191(of k G) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.iInf_sets_eq_finite'", "start": [852, 1], "end": [855, 6], "traced_tactics": [{"tactic": "rw [\u2190 iInf_sets_eq_finite, \u2190 Equiv.plift.surjective.iInf_comp]", "annotated_tactic": ["rw [\u2190 <a>iInf_sets_eq_finite</a>, \u2190 Equiv.plift.surjective.iInf_comp]", [{"full_name": "Filter.iInf_sets_eq_finite", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [846, 9], "def_end_pos": [846, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\n\u22a2 (\u2a05 i, f i).sets = \u22c3 t, (\u2a05 i \u2208 t, f i.down).sets", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\n\u22a2 (\u2a05 x, f (\u2191Equiv.plift x)).sets = (\u2a05 i, f i.down).sets"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\n\u22a2 (\u2a05 x, f (\u2191Equiv.plift x)).sets = (\u2a05 i, f i.down).sets", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.single_eq_zero", "start": [133, 1], "end": [133, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Sigma/Basic.lean", "full_name": "Sigma.uncurry_curry", "start": [168, 1], "end": [170, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "gt_or_eq_of_le", "start": [422, 1], "end": [423, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.mem_sup_left", "start": [406, 1], "end": [407, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "apply_ite", "start": [751, 1], "end": [753, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/IsEmpty.lean", "full_name": "isEmpty_pi", "start": [152, 1], "end": [153, 68], "traced_tactics": [{"tactic": "simp only [\u2190 not_nonempty_iff, Classical.nonempty_pi, not_forall]", "annotated_tactic": ["simp only [\u2190 <a>not_nonempty_iff</a>, <a>Classical.nonempty_pi</a>, <a>not_forall</a>]", [{"full_name": "not_nonempty_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [137, 9], "def_end_pos": [137, 25]}, {"full_name": "Classical.nonempty_pi", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nonempty.lean", "def_pos": [165, 9], "def_end_pos": [165, 30]}, {"full_name": "Classical.not_forall", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [692, 9], "def_end_pos": [692, 19]}]], "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\n\u03c0 : \u03b1 \u2192 Sort u_4\n\u22a2 IsEmpty ((a : \u03b1) \u2192 \u03c0 a) \u2194 \u2203 a, IsEmpty (\u03c0 a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Monic.lean", "full_name": "Polynomial.Monic.nextCoeff_mul", "start": [209, 1], "end": [215, 36], "traced_tactics": [{"tactic": "nontriviality", "annotated_tactic": ["nontriviality", []], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nhq : Monic q\n\u22a2 nextCoeff (p * q) = nextCoeff p + nextCoeff q", "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nhq : Monic q\n\u271d : Nontrivial R\n\u22a2 nextCoeff (p * q) = nextCoeff p + nextCoeff q"}, {"tactic": "simp only [\u2190 coeff_one_reverse]", "annotated_tactic": ["simp only [\u2190 <a>coeff_one_reverse</a>]", [{"full_name": "Polynomial.coeff_one_reverse", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [341, 9], "def_end_pos": [341, 26]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nhq : Monic q\n\u271d : Nontrivial R\n\u22a2 nextCoeff (p * q) = nextCoeff p + nextCoeff q", "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nhq : Monic q\n\u271d : Nontrivial R\n\u22a2 coeff (reverse (p * q)) 1 = coeff (reverse p) 1 + coeff (reverse q) 1"}, {"tactic": "rw [reverse_mul] <;>\n  simp [coeff_mul, antidiagonal, hp.leadingCoeff, hq.leadingCoeff, add_comm,\n    show Nat.succ 0 = 1 from rfl]", "annotated_tactic": ["rw [<a>reverse_mul</a>] <;>\n    simp [<a>coeff_mul</a>, <a>antidiagonal</a>, hp.leadingCoeff, hq.leadingCoeff, <a>add_comm</a>,\n      show <a>Nat.succ</a> 0 = 1 from <a>rfl</a>]", [{"full_name": "Polynomial.reverse_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [318, 9], "def_end_pos": [318, 20]}, {"full_name": "Polynomial.coeff_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [116, 9], "def_end_pos": [116, 18]}, {"full_name": "Finset.HasAntidiagonal.antidiagonal", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Antidiagonal.lean", "def_pos": [60, 3], "def_end_pos": [60, 15]}, {"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : Monic p\nhq : Monic q\n\u271d : Nontrivial R\n\u22a2 coeff (reverse (p * q)) 1 = coeff (reverse p) 1 + coeff (reverse q) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "Monotone.reflect_lt", "start": [790, 1], "end": [791, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Archimedean.lean", "full_name": "le_of_forall_rat_lt_imp_le", "start": [290, 1], "end": [293, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "LinearMap.ker_restrictScalars", "start": [918, 1], "end": [920, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "full_name": "AddSubmonoid.mul_mem_mul", "start": [533, 1], "end": [534, 50], "traced_tactics": [{"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\nG : Type u_2\nM\u271d : Type u_3\nR : Type u_4\nA : Type u_5\ninst\u271d\u00b2 : Monoid M\u271d\ninst\u271d\u00b9 : AddMonoid A\ninst\u271d : NonUnitalNonAssocSemiring R\nM N : AddSubmonoid R\nm n : R\nhm : m \u2208 M\nhn : n \u2208 N\n\u22a2 \u2191(\u2191AddMonoidHom.mul \u2191{ val := m, property := hm }) n = m * n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "full_name": "ConjAct.mem_orbit_conjAct", "start": [306, 1], "end": [307, 51], "traced_tactics": [{"tactic": "rw [isConj_comm, isConj_iff, mem_orbit_iff]", "annotated_tactic": ["rw [<a>isConj_comm</a>, <a>isConj_iff</a>, <a>mem_orbit_iff</a>]", [{"full_name": "isConj_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Conj.lean", "def_pos": [42, 9], "def_end_pos": [42, 20]}, {"full_name": "isConj_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Conj.lean", "def_pos": [91, 9], "def_end_pos": [91, 19]}, {"full_name": "MulAction.mem_orbit_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Basic.lean", "def_pos": [56, 9], "def_end_pos": [56, 22]}]], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nG : Type u_3\nG\u2080 : Type u_4\nR : Type u_5\nK : Type u_6\ninst\u271d : Group G\ng h : G\n\u22a2 g \u2208 orbit (ConjAct G) h \u2194 IsConj g h", "state_after": "\u03b1 : Type u_1\nM : Type u_2\nG : Type u_3\nG\u2080 : Type u_4\nR : Type u_5\nK : Type u_6\ninst\u271d : Group G\ng h : G\n\u22a2 (\u2203 x, x \u2022 h = g) \u2194 \u2203 c, c * h * c\u207b\u00b9 = g"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nG : Type u_3\nG\u2080 : Type u_4\nR : Type u_5\nK : Type u_6\ninst\u271d : Group G\ng h : G\n\u22a2 (\u2203 x, x \u2022 h = g) \u2194 \u2203 c, c * h * c\u207b\u00b9 = g", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "himp_le_himp", "start": [419, 1], "end": [420, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "IsPartialOrder.swap", "start": [105, 1], "end": [106, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/CCLemmas.lean", "full_name": "or_eq_of_eq_true_left", "start": [36, 1], "end": [37, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get?_set_eq", "start": [923, 1], "end": [924, 50], "traced_tactics": [{"tactic": "simp only [set_eq_modifyNth, get?_modifyNth_eq]", "annotated_tactic": ["simp only [<a>set_eq_modifyNth</a>, <a>get?_modifyNth_eq</a>]", [{"full_name": "List.set_eq_modifyNth", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [899, 9], "def_end_pos": [899, 25]}, {"full_name": "List.get?_modifyNth_eq", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [883, 17], "def_end_pos": [883, 34]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\nn : Nat\nl : List \u03b1\n\u22a2 get? (set l n a) n = (fun x => a) <$> get? l n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/List.lean", "full_name": "Encodable.decode_list_zero", "start": [70, 1], "end": [71, 49], "traced_tactics": [{"tactic": "rw [decodeList]", "annotated_tactic": ["rw [<a>decodeList</a>]", [{"full_name": "Encodable.decodeList", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/List.lean", "def_pos": [37, 5], "def_end_pos": [37, 15]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Encodable \u03b1\n\u22a2 decodeList 0 = some []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Function.Bijective.Prod_map", "start": [330, 1], "end": [331, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_le_of_one_le_right", "start": [409, 1], "end": [410, 60], "traced_tactics": [{"tactic": "simpa only [mul_one] using mul_le_mul_of_nonpos_left h ha", "annotated_tactic": ["simpa only [<a>mul_one</a>] using <a>mul_le_mul_of_nonpos_left</a> h ha", [{"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}, {"full_name": "mul_le_mul_of_nonpos_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [351, 9], "def_end_pos": [351, 34]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d : OrderedRing \u03b1\na b c d : \u03b1\nha : a \u2264 0\nh : 1 \u2264 b\n\u22a2 a * b \u2264 a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Option.lean", "full_name": "Equiv.removeNone_symm", "start": [130, 1], "end": [131, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Archimedean.lean", "full_name": "exists_rat_btwn", "start": [269, 1], "end": [287, 22], "traced_tactics": [{"tactic": "cases' exists_nat_gt (y - x)\u207b\u00b9 with n nh", "annotated_tactic": ["cases' <a>exists_nat_gt</a> (y - x)\u207b\u00b9 with n nh", [{"full_name": "exists_nat_gt", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Archimedean.lean", "def_pos": [118, 9], "def_end_pos": [118, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\n\u22a2 \u2203 q, x < \u2191q \u2227 \u2191q < y", "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\n\u22a2 \u2203 q, x < \u2191q \u2227 \u2191q < y"}, {"tactic": "cases' exists_floor (x * n) with z zh", "annotated_tactic": ["cases' <a>exists_floor</a> (x * n) with z zh", [{"full_name": "exists_floor", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Archimedean.lean", "def_pos": [165, 9], "def_end_pos": [165, 21]}]], "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\n\u22a2 \u2203 q, x < \u2191q \u2227 \u2191q < y", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\n\u22a2 \u2203 q, x < \u2191q \u2227 \u2191q < y"}, {"tactic": "refine' \u27e8(z + 1 : \u2124) / n, _\u27e9", "annotated_tactic": ["refine' \u27e8(z + 1 : \u2124) / n, _\u27e9", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\n\u22a2 \u2203 q, x < \u2191q \u2227 \u2191q < y", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\n\u22a2 x < \u2191(\u2191(z + 1) / \u2191n) \u2227 \u2191(\u2191(z + 1) / \u2191n) < y"}, {"tactic": "have n0' := (inv_pos.2 (sub_pos.2 h)).trans nh", "annotated_tactic": ["have n0' := (<a>inv_pos</a>.2 (<a>sub_pos</a>.2 h)).<a>trans</a> nh", [{"full_name": "inv_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [49, 9], "def_end_pos": [49, 16]}, {"full_name": "sub_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [883, 30], "def_end_pos": [883, 37]}, {"full_name": "LT.lt.trans", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [144, 7], "def_end_pos": [144, 18]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\n\u22a2 x < \u2191(\u2191(z + 1) / \u2191n) \u2227 \u2191(\u2191(z + 1) / \u2191n) < y", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\n\u22a2 x < \u2191(\u2191(z + 1) / \u2191n) \u2227 \u2191(\u2191(z + 1) / \u2191n) < y"}, {"tactic": "have n0 := Nat.cast_pos.1 n0'", "annotated_tactic": ["have n0 := <a>Nat.cast_pos</a>.1 n0'", [{"full_name": "Nat.cast_pos", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Order.lean", "def_pos": [72, 9], "def_end_pos": [72, 17]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\n\u22a2 x < \u2191(\u2191(z + 1) / \u2191n) \u2227 \u2191(\u2191(z + 1) / \u2191n) < y", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 x < \u2191(\u2191(z + 1) / \u2191n) \u2227 \u2191(\u2191(z + 1) / \u2191n) < y"}, {"tactic": "rw [Rat.cast_div_of_ne_zero, Rat.cast_coe_nat, Rat.cast_coe_int, div_lt_iff n0']", "annotated_tactic": ["rw [<a>Rat.cast_div_of_ne_zero</a>, <a>Rat.cast_coe_nat</a>, <a>Rat.cast_coe_int</a>, <a>div_lt_iff</a> n0']", [{"full_name": "Rat.cast_div_of_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Cast/Defs.lean", "def_pos": [157, 9], "def_end_pos": [157, 28]}, {"full_name": "Rat.cast_coe_nat", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Cast/Defs.lean", "def_pos": [46, 9], "def_end_pos": [46, 21]}, {"full_name": "Rat.cast_coe_int", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Cast/Defs.lean", "def_pos": [41, 9], "def_end_pos": [41, 21]}, {"full_name": "div_lt_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [169, 9], "def_end_pos": [169, 19]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 x < \u2191(\u2191(z + 1) / \u2191n) \u2227 \u2191(\u2191(z + 1) / \u2191n) < y", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 x < \u2191(z + 1) / \u2191n \u2227 \u2191(z + 1) < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0"}, {"tactic": "refine' \u27e8(lt_div_iff n0').2 <| (lt_iff_lt_of_le_iff_le (zh _)).1 (lt_add_one _), _\u27e9", "annotated_tactic": ["refine' \u27e8(<a>lt_div_iff</a> n0').2 <| (<a>lt_iff_lt_of_le_iff_le</a> (zh _)).1 (<a>lt_add_one</a> _), _\u27e9", [{"full_name": "lt_div_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [162, 9], "def_end_pos": [162, 19]}, {"full_name": "lt_iff_lt_of_le_iff_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 31]}, {"full_name": "lt_add_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [20, 7], "def_end_pos": [20, 17]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 x < \u2191(z + 1) / \u2191n \u2227 \u2191(z + 1) < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(z + 1) < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0"}, {"tactic": "rw [Int.cast_add, Int.cast_one]", "annotated_tactic": ["rw [<a>Int.cast_add</a>, <a>Int.cast_one</a>]", [{"full_name": "Int.cast_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [108, 9], "def_end_pos": [108, 17]}, {"full_name": "Int.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [77, 9], "def_end_pos": [77, 17]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(z + 1) < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191z + 1 < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0"}, {"tactic": "refine' lt_of_le_of_lt (add_le_add_right ((zh _).1 le_rfl) _) _", "annotated_tactic": ["refine' <a>lt_of_le_of_lt</a> (<a>add_le_add_right</a> ((zh _).1 <a>le_rfl</a>) _) _", [{"full_name": "lt_of_le_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [122, 9], "def_end_pos": [122, 23]}, {"full_name": "add_le_add_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [66, 15], "def_end_pos": [66, 31]}, {"full_name": "le_rfl", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [170, 9], "def_end_pos": [170, 15]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191z + 1 < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0", "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 x * \u2191n + 1 < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0"}, {"tactic": "rwa [\u2190 lt_sub_iff_add_lt', \u2190 sub_mul, \u2190 div_lt_iff' (sub_pos.2 h), one_div]", "annotated_tactic": ["rwa [\u2190 <a>lt_sub_iff_add_lt'</a>, \u2190 <a>sub_mul</a>, \u2190 <a>div_lt_iff'</a> (<a>sub_pos</a>.2 h), <a>one_div</a>]", [{"full_name": "lt_sub_iff_add_lt'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [970, 3], "def_end_pos": [970, 14]}, {"full_name": "sub_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [372, 7], "def_end_pos": [372, 14]}, {"full_name": "div_lt_iff'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [173, 9], "def_end_pos": [173, 20]}, {"full_name": "sub_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [883, 30], "def_end_pos": [883, 37]}, {"full_name": "one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [318, 9], "def_end_pos": [318, 16]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 x * \u2191n + 1 < y * \u2191n\n\ncase intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0", "state_after": "case intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0\n\ncase intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0\n\ncase intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0"}, {"tactic": "rw [Rat.coe_int_den, Nat.cast_one]", "annotated_tactic": ["rw [<a>Rat.coe_int_den</a>, <a>Nat.cast_one</a>]", [{"full_name": "Rat.coe_int_den", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [53, 9], "def_end_pos": [53, 20]}, {"full_name": "Nat.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [147, 9], "def_end_pos": [147, 17]}]], "state_before": "case intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191(z + 1)).den \u2260 0", "state_after": "case intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 1 \u2260 0"}, {"tactic": "exact one_ne_zero", "annotated_tactic": ["exact <a>one_ne_zero</a>", [{"full_name": "one_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "case intro.intro.md\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 1 \u2260 0", "state_after": "no goals"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).num \u2260 0", "state_after": "case intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\nH : \u2191(\u2191n).num = 0\n\u22a2 False"}, {"tactic": "rw [Rat.coe_nat_num, Int.cast_ofNat, Nat.cast_eq_zero] at H", "annotated_tactic": ["rw [<a>Rat.coe_nat_num</a>, <a>Int.cast_ofNat</a>, <a>Nat.cast_eq_zero</a>] at H", [{"full_name": "Rat.coe_nat_num", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [533, 9], "def_end_pos": [533, 20]}, {"full_name": "Int.cast_ofNat", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [65, 9], "def_end_pos": [65, 19]}, {"full_name": "Nat.cast_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/CharZero/Defs.lean", "def_pos": [80, 9], "def_end_pos": [80, 21]}]], "state_before": "case intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\nH : \u2191(\u2191n).num = 0\n\u22a2 False", "state_after": "case intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\nH : n = 0\n\u22a2 False"}, {"tactic": "subst H", "annotated_tactic": ["subst H", []], "state_before": "case intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\nH : n = 0\n\u22a2 False", "state_after": "case intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nz : \u2124\nnh : (y - x)\u207b\u00b9 < \u21910\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u21910\nn0' : 0 < \u21910\nn0 : 0 < 0\n\u22a2 False"}, {"tactic": "cases n0", "annotated_tactic": ["cases n0", []], "state_before": "case intro.intro.nn\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nz : \u2124\nnh : (y - x)\u207b\u00b9 < \u21910\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u21910\nn0' : 0 < \u21910\nn0 : 0 < 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [Rat.coe_nat_den, Nat.cast_one]", "annotated_tactic": ["rw [<a>Rat.coe_nat_den</a>, <a>Nat.cast_one</a>]", [{"full_name": "Rat.coe_nat_den", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Defs.lean", "def_pos": [538, 9], "def_end_pos": [538, 20]}, {"full_name": "Nat.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [147, 9], "def_end_pos": [147, 17]}]], "state_before": "case intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 \u2191(\u2191n).den \u2260 0", "state_after": "case intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 1 \u2260 0"}, {"tactic": "exact one_ne_zero", "annotated_tactic": ["exact <a>one_ne_zero</a>", [{"full_name": "one_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/NeZero.lean", "def_pos": [58, 15], "def_end_pos": [58, 26]}]], "state_before": "case intro.intro.nd\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedField \u03b1\ninst\u271d : Archimedean \u03b1\nx\u271d y\u271d \u03b5 x y : \u03b1\nh : x < y\nn : \u2115\nnh : (y - x)\u207b\u00b9 < \u2191n\nz : \u2124\nzh : \u2200 (z_1 : \u2124), z_1 \u2264 z \u2194 \u2191z_1 \u2264 x * \u2191n\nn0' : 0 < \u2191n\nn0 : 0 < n\n\u22a2 1 \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.prod_inf", "start": [1842, 1], "end": [1843, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/Basic.lean", "full_name": "Real.ofCauchy_ratCast", "start": [185, 1], "end": [186, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Quotient.lean", "full_name": "Ideal.Quotient.exists_inv", "start": [198, 1], "end": [206, 60], "traced_tactics": [{"tactic": "rintro \u27e8a\u27e9 h", "annotated_tactic": ["rintro \u27e8a\u27e9 h", []], "state_before": "R : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na b : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\n\u22a2 \u2200 {a : R \u29f8 I}, a \u2260 0 \u2192 \u2203 b, a * b = 1", "state_after": "case mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\n\u22a2 \u2203 b, \u27e6a\u27e7 * b = 1"}, {"tactic": "rcases hI.exists_inv (mt eq_zero_iff_mem.2 h) with \u27e8b, c, hc, abc\u27e9", "annotated_tactic": ["rcases hI.exists_inv (<a>mt</a> <a>eq_zero_iff_mem</a>.2 h) with \u27e8b, c, hc, abc\u27e9", [{"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "Ideal.Quotient.eq_zero_iff_mem", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [129, 9], "def_end_pos": [129, 24]}]], "state_before": "case mk\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\n\u22a2 \u2203 b, \u27e6a\u27e7 * b = 1", "state_after": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : b * a + c = 1\n\u22a2 \u2203 b, \u27e6a\u27e7 * b = 1"}, {"tactic": "rw [mul_comm] at abc", "annotated_tactic": ["rw [<a>mul_comm</a>] at abc", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : b * a + c = 1\n\u22a2 \u2203 b, \u27e6a\u27e7 * b = 1", "state_after": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : a * b + c = 1\n\u22a2 \u2203 b, \u27e6a\u27e7 * b = 1"}, {"tactic": "refine' \u27e8mk _ b, Quot.sound _\u27e9", "annotated_tactic": ["refine' \u27e8<a>mk</a> _ b, <a>Quot.sound</a> _\u27e9", [{"full_name": "Ideal.Quotient.mk", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [96, 5], "def_end_pos": [96, 7]}, {"full_name": "Quot.sound", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [1209, 7], "def_end_pos": [1209, 12]}]], "state_before": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : a * b + c = 1\n\u22a2 \u2203 b, \u27e6a\u27e7 * b = 1", "state_after": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : a * b + c = 1\n\u22a2 Setoid.r ((fun x x_1 => x * x_1) a b) 1"}, {"tactic": "simp only [Submodule.quotientRel_r_def]", "annotated_tactic": ["simp only [<a>Submodule.quotientRel_r_def</a>]", [{"full_name": "Submodule.quotientRel_r_def", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Quotient.lean", "def_pos": [38, 9], "def_end_pos": [38, 26]}]], "state_before": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : a * b + c = 1\n\u22a2 Setoid.r ((fun x x_1 => x * x_1) a b) 1", "state_after": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : a * b + c = 1\n\u22a2 a * b - 1 \u2208 I"}, {"tactic": "rw [\u2190 eq_sub_iff_add_eq'] at abc", "annotated_tactic": ["rw [\u2190 <a>eq_sub_iff_add_eq'</a>] at abc", [{"full_name": "eq_sub_iff_add_eq'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [938, 15], "def_end_pos": [938, 33]}]], "state_before": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : a * b + c = 1\n\u22a2 a * b - 1 \u2208 I", "state_after": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : c = 1 - a * b\n\u22a2 a * b - 1 \u2208 I"}, {"tactic": "rwa [abc, \u2190 neg_mem_iff (G := R) (H := I), neg_sub] at hc", "annotated_tactic": ["rwa [abc, \u2190 <a>neg_mem_iff</a> (G := R) (H := I), <a>neg_sub</a>] at hc", [{"full_name": "neg_mem_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [129, 3], "def_end_pos": [129, 14]}, {"full_name": "neg_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [400, 3], "def_end_pos": [400, 14]}]], "state_before": "case mk.intro.intro.intro\nR : Type u\ninst\u271d : CommRing R\nI\u271d : Ideal R\na\u271d\u00b9 b\u271d : R\nS : Type v\nx y : R\nI : Ideal R\nhI : IsMaximal I\na\u271d : R \u29f8 I\na : R\nh : \u27e6a\u27e7 \u2260 0\nb c : R\nhc : c \u2208 I\nabc : c = 1 - a * b\n\u22a2 a * b - 1 \u2208 I", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.map_injective", "start": [163, 1], "end": [165, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "sSup_inter_le", "start": [534, 1], "end": [535, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "IsAntichain.not_lt", "start": [217, 1], "end": [218, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.coe_copy", "start": [94, 1], "end": [95, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.repeat_zero", "start": [383, 1], "end": [385, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "symmDiff_symmDiff_cancel_left", "start": [493, 1], "end": [493, 86], "traced_tactics": [{"tactic": "simp [\u2190 symmDiff_assoc]", "annotated_tactic": ["simp [\u2190 <a>symmDiff_assoc</a>]", [{"full_name": "symmDiff_assoc", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [473, 9], "def_end_pos": [473, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\n\u22a2 a \u2206 (a \u2206 b) = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.fromBlocks_inj", "start": [138, 1], "end": [141, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "PUnit.sdiff_eq", "start": [1371, 1], "end": [1372, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Relation.lean", "full_name": "Relation.ReflTransGen.single", "start": [276, 1], "end": [277, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "sSup_le_sSup", "start": [217, 1], "end": [218, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.insertNth_zero", "start": [725, 1], "end": [730, 33], "traced_tactics": [{"tactic": "refine' insertNth_eq_iff.2 \u27e8by simp, _\u27e9", "annotated_tactic": ["refine' <a>insertNth_eq_iff</a>.2 \u27e8by simp, _\u27e9", [{"full_name": "Fin.insertNth_eq_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [699, 9], "def_end_pos": [699, 25]}]], "state_before": "m n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\n\u03b2 : Type v\nx : \u03b1 0\np : (j : Fin n) \u2192 \u03b1 (succAbove 0 j)\n\u22a2 insertNth 0 x p = cons x fun j => _root_.cast (_ : \u03b1 (succAbove 0 j) = \u03b1 (succ j)) (p j)", "state_after": "m n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\n\u03b2 : Type v\nx : \u03b1 0\np : (j : Fin n) \u2192 \u03b1 (succAbove 0 j)\n\u22a2 p = fun j => cons x (fun j => _root_.cast (_ : \u03b1 (succAbove 0 j) = \u03b1 (succ j)) (p j)) (succAbove 0 j)"}, {"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "m n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\n\u03b2 : Type v\nx : \u03b1 0\np : (j : Fin n) \u2192 \u03b1 (succAbove 0 j)\n\u22a2 p = fun j => cons x (fun j => _root_.cast (_ : \u03b1 (succAbove 0 j) = \u03b1 (succ j)) (p j)) (succAbove 0 j)", "state_after": "case h\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\n\u03b2 : Type v\nx : \u03b1 0\np : (j : Fin n) \u2192 \u03b1 (succAbove 0 j)\nj : Fin n\n\u22a2 p j = cons x (fun j => _root_.cast (_ : \u03b1 (succAbove 0 j) = \u03b1 (succ j)) (p j)) (succAbove 0 j)"}, {"tactic": "convert (cons_succ x p j).symm", "annotated_tactic": ["convert (<a>cons_succ</a> x p j).<a>symm</a>", [{"full_name": "Fin.cons_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [74, 9], "def_end_pos": [74, 18]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "case h\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\n\u03b2 : Type v\nx : \u03b1 0\np : (j : Fin n) \u2192 \u03b1 (succAbove 0 j)\nj : Fin n\n\u22a2 p j = cons x (fun j => _root_.cast (_ : \u03b1 (succAbove 0 j) = \u03b1 (succ j)) (p j)) (succAbove 0 j)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "m n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\n\u03b2 : Type v\nx : \u03b1 0\np : (j : Fin n) \u2192 \u03b1 (succAbove 0 j)\n\u22a2 cons x (fun j => _root_.cast (_ : \u03b1 (succAbove 0 j) = \u03b1 (succ j)) (p j)) 0 = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.zero_ne_one_of_proper", "start": [278, 1], "end": [279, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Size.lean", "full_name": "Nat.size_zero", "start": [54, 1], "end": [54, 49], "traced_tactics": [{"tactic": "simp [size]", "annotated_tactic": ["simp [<a>size</a>]", [{"full_name": "Nat.size", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [240, 5], "def_end_pos": [240, 9]}]], "state_before": "\u22a2 size 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.map_fst'", "start": [76, 1], "end": [77, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Part.lean", "full_name": "Part.eq_none_or_eq_some", "start": [210, 1], "end": [211, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Division.lean", "full_name": "AddMonoidAlgebra.divOf_apply", "start": [61, 1], "end": [62, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/CommRing.lean", "full_name": "MvPolynomial.support_neg", "start": [84, 1], "end": [85, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Sort.lean", "full_name": "Multiset.sort_zero", "start": [59, 1], "end": [60, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.fst_apply", "start": [194, 1], "end": [196, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "eq_bot_of_top_isCompl", "start": [643, 1], "end": [644, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Pi.lean", "full_name": "Fintype.piFinset_subsingleton", "start": [68, 1], "end": [70, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.gc_map_comap", "start": [222, 1], "end": [223, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.univ_mul_univ", "start": [995, 1], "end": [996, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/PairingHeap.lean", "full_name": "Std.PairingHeapImp.Heap.noSibling_merge", "start": [91, 1], "end": [94, 40], "traced_tactics": [{"tactic": "unfold merge", "annotated_tactic": ["unfold <a>merge</a>", [{"full_name": "Std.PairingHeapImp.Heap.merge", "def_path": "lake-packages/std/Std/Data/PairingHeap.lean", "def_pos": [43, 19], "def_end_pos": [43, 29]}]], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns\u2081 s\u2082 : Heap \u03b1\n\u22a2 NoSibling (merge le s\u2081 s\u2082)", "state_after": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns\u2081 s\u2082 : Heap \u03b1\n\u22a2 NoSibling\n    (match s\u2081, s\u2082 with\n    | nil, nil => nil\n    | nil, node a\u2082 c\u2082 sibling => node a\u2082 c\u2082 nil\n    | node a\u2081 c\u2081 sibling, nil => node a\u2081 c\u2081 nil\n    | node a\u2081 c\u2081 sibling, node a\u2082 c\u2082 sibling_1 =>\n      if le a\u2081 a\u2082 = true then node a\u2081 (node a\u2082 c\u2082 c\u2081) nil else node a\u2082 (node a\u2081 c\u2081 c\u2082) nil)"}, {"tactic": "(split <;> try split) <;> constructor", "annotated_tactic": ["(split <;> try split) <;> constructor", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns\u2081 s\u2082 : Heap \u03b1\n\u22a2 NoSibling\n    (match s\u2081, s\u2082 with\n    | nil, nil => nil\n    | nil, node a\u2082 c\u2082 sibling => node a\u2082 c\u2082 nil\n    | node a\u2081 c\u2081 sibling, nil => node a\u2081 c\u2081 nil\n    | node a\u2081 c\u2081 sibling, node a\u2082 c\u2082 sibling_1 =>\n      if le a\u2081 a\u2082 = true then node a\u2081 (node a\u2082 c\u2082 c\u2081) nil else node a\u2082 (node a\u2081 c\u2081 c\u2082) nil)", "state_after": "no goals"}, {"tactic": "split <;> try split", "annotated_tactic": ["split <;> try split", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns\u2081 s\u2082 : Heap \u03b1\n\u22a2 NoSibling\n    (match s\u2081, s\u2082 with\n    | nil, nil => nil\n    | nil, node a\u2082 c\u2082 sibling => node a\u2082 c\u2082 nil\n    | node a\u2081 c\u2081 sibling, nil => node a\u2081 c\u2081 nil\n    | node a\u2081 c\u2081 sibling, node a\u2082 c\u2082 sibling_1 =>\n      if le a\u2081 a\u2082 = true then node a\u2081 (node a\u2082 c\u2082 c\u2081) nil else node a\u2082 (node a\u2081 c\u2081 c\u2082) nil)", "state_after": "case h_1\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\n\u22a2 NoSibling nil\n\ncase h_2\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\na\u2082\u271d : \u03b1\nc\u2082\u271d sibling\u271d : Heap \u03b1\n\u22a2 NoSibling (node a\u2082\u271d c\u2082\u271d nil)\n\ncase h_3\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\na\u2081\u271d : \u03b1\nc\u2081\u271d sibling\u271d : Heap \u03b1\n\u22a2 NoSibling (node a\u2081\u271d c\u2081\u271d nil)\n\ncase h_4.inl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\na\u2081\u271d : \u03b1\nc\u2081\u271d sibling\u271d\u00b9 : Heap \u03b1\na\u2082\u271d : \u03b1\nc\u2082\u271d sibling\u271d : Heap \u03b1\nh\u271d : le a\u2081\u271d a\u2082\u271d = true\n\u22a2 NoSibling (node a\u2081\u271d (node a\u2082\u271d c\u2082\u271d c\u2081\u271d) nil)\n\ncase h_4.inr\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\na\u2081\u271d : \u03b1\nc\u2081\u271d sibling\u271d\u00b9 : Heap \u03b1\na\u2082\u271d : \u03b1\nc\u2082\u271d sibling\u271d : Heap \u03b1\nh\u271d : \u00acle a\u2081\u271d a\u2082\u271d = true\n\u22a2 NoSibling (node a\u2082\u271d (node a\u2081\u271d c\u2081\u271d c\u2082\u271d) nil)"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "case h_4\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\na\u2081\u271d : \u03b1\nc\u2081\u271d sibling\u271d\u00b9 : Heap \u03b1\na\u2082\u271d : \u03b1\nc\u2082\u271d sibling\u271d : Heap \u03b1\n\u22a2 NoSibling (if le a\u2081\u271d a\u2082\u271d = true then node a\u2081\u271d (node a\u2082\u271d c\u2082\u271d c\u2081\u271d) nil else node a\u2082\u271d (node a\u2081\u271d c\u2081\u271d c\u2082\u271d) nil)", "state_after": "case h_4.inl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\na\u2081\u271d : \u03b1\nc\u2081\u271d sibling\u271d\u00b9 : Heap \u03b1\na\u2082\u271d : \u03b1\nc\u2082\u271d sibling\u271d : Heap \u03b1\nh\u271d : le a\u2081\u271d a\u2082\u271d = true\n\u22a2 NoSibling (node a\u2081\u271d (node a\u2082\u271d c\u2082\u271d c\u2081\u271d) nil)\n\ncase h_4.inr\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d\u00b9 x\u271d : Heap \u03b1\na\u2081\u271d : \u03b1\nc\u2081\u271d sibling\u271d\u00b9 : Heap \u03b1\na\u2082\u271d : \u03b1\nc\u2082\u271d sibling\u271d : Heap \u03b1\nh\u271d : \u00acle a\u2081\u271d a\u2082\u271d = true\n\u22a2 NoSibling (node a\u2082\u271d (node a\u2081\u271d c\u2081\u271d c\u2082\u271d) nil)"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.iSup_induction", "start": [636, 1], "end": [640, 61], "traced_tactics": [{"tactic": "rw [\u2190 mem_toAddSubmonoid, iSup_toAddSubmonoid] at hx", "annotated_tactic": ["rw [\u2190 <a>mem_toAddSubmonoid</a>, <a>iSup_toAddSubmonoid</a>] at hx", [{"full_name": "Submodule.mem_toAddSubmonoid", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 27]}, {"full_name": "Submodule.iSup_toAddSubmonoid", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [612, 9], "def_end_pos": [612, 28]}]], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np\u271d p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\n\u03b9 : Sort u_9\np : \u03b9 \u2192 Submodule R M\nC : M \u2192 Prop\nx : M\nhx : x \u2208 \u2a06 i, p i\nhp : \u2200 (i : \u03b9), \u2200 x \u2208 p i, C x\nh0 : C 0\nhadd : \u2200 (x y : M), C x \u2192 C y \u2192 C (x + y)\n\u22a2 C x", "state_after": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np\u271d p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\n\u03b9 : Sort u_9\np : \u03b9 \u2192 Submodule R M\nC : M \u2192 Prop\nx : M\nhx : x \u2208 \u2a06 i, (p i).toAddSubmonoid\nhp : \u2200 (i : \u03b9), \u2200 x \u2208 p i, C x\nh0 : C 0\nhadd : \u2200 (x y : M), C x \u2192 C y \u2192 C (x + y)\n\u22a2 C x"}, {"tactic": "exact AddSubmonoid.iSup_induction (x := x) _ hx hp h0 hadd", "annotated_tactic": ["exact <a>AddSubmonoid.iSup_induction</a> (x := x) _ hx hp h0 hadd", [{"full_name": "AddSubmonoid.iSup_induction", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [272, 3], "def_end_pos": [272, 14]}]], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np\u271d p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\n\u03b9 : Sort u_9\np : \u03b9 \u2192 Submodule R M\nC : M \u2192 Prop\nx : M\nhx : x \u2208 \u2a06 i, (p i).toAddSubmonoid\nhp : \u2200 (i : \u03b9), \u2200 x \u2208 p i, C x\nh0 : C 0\nhadd : \u2200 (x y : M), C x \u2192 C y \u2192 C (x + y)\n\u22a2 C x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Nat/Lemmas.lean", "full_name": "Nat.bit1_ne_bit0", "start": [250, 11], "end": [259, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.sigmaFinsuppLEquivPiFinsupp_apply", "start": [990, 1], "end": [992, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "Int.toNat_sub_of_le", "start": [547, 1], "end": [548, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.dvd_antisymm", "start": [675, 1], "end": [678, 25], "traced_tactics": [{"tactic": "rw [\u2190 natAbs_of_nonneg H1, \u2190 natAbs_of_nonneg H2]", "annotated_tactic": ["rw [\u2190 <a>natAbs_of_nonneg</a> H1, \u2190 <a>natAbs_of_nonneg</a> H2]", [{"full_name": "Int.natAbs_of_nonneg", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [1246, 9], "def_end_pos": [1246, 25]}, {"full_name": "Int.natAbs_of_nonneg", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [1246, 9], "def_end_pos": [1246, 25]}]], "state_before": "a b : Int\nH1 : 0 \u2264 a\nH2 : 0 \u2264 b\n\u22a2 a \u2223 b \u2192 b \u2223 a \u2192 a = b", "state_after": "a b : Int\nH1 : 0 \u2264 a\nH2 : 0 \u2264 b\n\u22a2 \u2191(natAbs a) \u2223 \u2191(natAbs b) \u2192 \u2191(natAbs b) \u2223 \u2191(natAbs a) \u2192 \u2191(natAbs a) = \u2191(natAbs b)"}, {"tactic": "rw [ofNat_dvd, ofNat_dvd, ofNat_inj]", "annotated_tactic": ["rw [<a>ofNat_dvd</a>, <a>ofNat_dvd</a>, <a>ofNat_inj</a>]", [{"full_name": "Int.ofNat_dvd", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [642, 22], "def_end_pos": [642, 31]}, {"full_name": "Int.ofNat_dvd", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [642, 22], "def_end_pos": [642, 31]}, {"full_name": "Int.ofNat_inj", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [66, 9], "def_end_pos": [66, 18]}]], "state_before": "a b : Int\nH1 : 0 \u2264 a\nH2 : 0 \u2264 b\n\u22a2 \u2191(natAbs a) \u2223 \u2191(natAbs b) \u2192 \u2191(natAbs b) \u2223 \u2191(natAbs a) \u2192 \u2191(natAbs a) = \u2191(natAbs b)", "state_after": "a b : Int\nH1 : 0 \u2264 a\nH2 : 0 \u2264 b\n\u22a2 natAbs a \u2223 natAbs b \u2192 natAbs b \u2223 natAbs a \u2192 natAbs a = natAbs b"}, {"tactic": "apply Nat.dvd_antisymm", "annotated_tactic": ["apply <a>Nat.dvd_antisymm</a>", [{"full_name": "Nat.dvd_antisymm", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [1117, 19], "def_end_pos": [1117, 31]}]], "state_before": "a b : Int\nH1 : 0 \u2264 a\nH2 : 0 \u2264 b\n\u22a2 natAbs a \u2223 natAbs b \u2192 natAbs b \u2223 natAbs a \u2192 natAbs a = natAbs b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.image\u2082_nonempty_iff", "start": [118, 1], "end": [120, 28], "traced_tactics": [{"tactic": "rw [\u2190 coe_nonempty, coe_image\u2082]", "annotated_tactic": ["rw [\u2190 <a>coe_nonempty</a>, <a>coe_image\u2082</a>]", [{"full_name": "Finset.coe_nonempty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [489, 9], "def_end_pos": [489, 21]}, {"full_name": "Finset.coe_image\u2082", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [49, 9], "def_end_pos": [49, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\n\u22a2 Finset.Nonempty (image\u2082 f s t) \u2194 Finset.Nonempty s \u2227 Finset.Nonempty t", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\n\u22a2 Set.Nonempty (image2 f \u2191s \u2191t) \u2194 Finset.Nonempty s \u2227 Finset.Nonempty t"}, {"tactic": "exact image2_nonempty_iff", "annotated_tactic": ["exact <a>image2_nonempty_iff</a>", [{"full_name": "Set.image2_nonempty_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [161, 9], "def_end_pos": [161, 28]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\n\u22a2 Set.Nonempty (image2 f \u2191s \u2191t) \u2194 Finset.Nonempty s \u2227 Finset.Nonempty t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.card_image\u2082_singleton_right", "start": [258, 1], "end": [259, 99], "traced_tactics": [{"tactic": "rw [image\u2082_singleton_right, card_image_of_injective _ hf]", "annotated_tactic": ["rw [<a>image\u2082_singleton_right</a>, <a>card_image_of_injective</a> _ hf]", [{"full_name": "Finset.image\u2082_singleton_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [156, 9], "def_end_pos": [156, 31]}, {"full_name": "Finset.card_image_of_injective", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [250, 9], "def_end_pos": [250, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\nhf : Injective fun a => f a b\n\u22a2 card (image\u2082 f s {b}) = card s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Control/EquivFunctor.lean", "full_name": "EquivFunctor.mapEquiv_apply", "start": [61, 1], "end": [62, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Denumerable.lean", "full_name": "Denumerable.ofEquiv_ofNat", "start": [104, 1], "end": [110, 7], "traced_tactics": [{"tactic": "letI := ofEquiv _ e", "annotated_tactic": ["letI := <a>ofEquiv</a> _ e", [{"full_name": "Denumerable.ofEquiv", "def_path": "lake-packages/mathlib/Mathlib/Logic/Denumerable.lean", "def_pos": [94, 5], "def_end_pos": [94, 12]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b2 : Denumerable \u03b1\u271d\ninst\u271d\u00b9 : Denumerable \u03b2\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\n\u22a2 ofNat \u03b2 n = \u2191e.symm (ofNat \u03b1 n)", "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b2 : Denumerable \u03b1\u271d\ninst\u271d\u00b9 : Denumerable \u03b2\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\nthis : Denumerable \u03b2 := ofEquiv \u03b1 e\n\u22a2 ofNat \u03b2 n = \u2191e.symm (ofNat \u03b1 n)"}, {"tactic": "refine ofNat_of_decode ?_", "annotated_tactic": ["refine <a>ofNat_of_decode</a> ?_", [{"full_name": "Denumerable.ofNat_of_decode", "def_path": "lake-packages/mathlib/Mathlib/Logic/Denumerable.lean", "def_pos": [60, 9], "def_end_pos": [60, 24]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b2 : Denumerable \u03b1\u271d\ninst\u271d\u00b9 : Denumerable \u03b2\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\nthis : Denumerable \u03b2 := ofEquiv \u03b1 e\n\u22a2 ofNat \u03b2 n = \u2191e.symm (ofNat \u03b1 n)", "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b2 : Denumerable \u03b1\u271d\ninst\u271d\u00b9 : Denumerable \u03b2\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\nthis : Denumerable \u03b2 := ofEquiv \u03b1 e\n\u22a2 decode n = some (\u2191e.symm (ofNat \u03b1 n))"}, {"tactic": "rw [decode_ofEquiv e]", "annotated_tactic": ["rw [<a>decode_ofEquiv</a> e]", [{"full_name": "Encodable.decode_ofEquiv", "def_path": "lake-packages/mathlib/Mathlib/Logic/Encodable/Basic.lean", "def_pos": [114, 9], "def_end_pos": [114, 23]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b2 : Denumerable \u03b1\u271d\ninst\u271d\u00b9 : Denumerable \u03b2\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\nthis : Denumerable \u03b2 := ofEquiv \u03b1 e\n\u22a2 decode n = some (\u2191e.symm (ofNat \u03b1 n))", "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b2 : Denumerable \u03b1\u271d\ninst\u271d\u00b9 : Denumerable \u03b2\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\nthis : Denumerable \u03b2 := ofEquiv \u03b1 e\n\u22a2 Option.map (\u2191e.symm) (decode n) = some (\u2191e.symm (ofNat \u03b1 n))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\ninst\u271d\u00b2 : Denumerable \u03b1\u271d\ninst\u271d\u00b9 : Denumerable \u03b2\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Denumerable \u03b1\ne : \u03b2 \u2243 \u03b1\nn : \u2115\nthis : Denumerable \u03b2 := ofEquiv \u03b1 e\n\u22a2 Option.map (\u2191e.symm) (decode n) = some (\u2191e.symm (ofNat \u03b1 n))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearMap.range_smul'", "start": [1074, 1], "end": [1076, 60], "traced_tactics": [{"tactic": "simpa only [range_eq_map] using Submodule.map_smul' f _ a", "annotated_tactic": ["simpa only [<a>range_eq_map</a>] using <a>Submodule.map_smul'</a> f _ a", [{"full_name": "LinearMap.range_eq_map", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [677, 9], "def_end_pos": [677, 21]}, {"full_name": "Submodule.map_smul'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [472, 9], "def_end_pos": [472, 18]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u2075 : Semifield K\ninst\u271d\u2074 : Semifield K\u2082\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\na : K\n\u22a2 range (a \u2022 f) = \u2a06 (_ : a \u2260 0), range f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Pairing.lean", "full_name": "Nat.unpair_pair", "start": [65, 1], "end": [74, 50], "traced_tactics": [{"tactic": "dsimp only [pair]", "annotated_tactic": ["dsimp only [<a>pair</a>]", [{"full_name": "Nat.pair", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Pairing.lean", "def_pos": [37, 5], "def_end_pos": [37, 9]}]], "state_before": "a b : \u2115\n\u22a2 unpair (pair a b) = (a, b)", "state_after": "a b : \u2115\n\u22a2 unpair (if a < b then b * b + a else a * a + a + b) = (a, b)"}, {"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "a b : \u2115\n\u22a2 unpair (if a < b then b * b + a else a * a + a + b) = (a, b)", "state_after": "case pos\na b : \u2115\nh : a < b\n\u22a2 unpair (b * b + a) = (a, b)\n\ncase neg\na b : \u2115\nh : \u00aca < b\n\u22a2 unpair (a * a + a + b) = (a, b)"}, {"tactic": "have be : sqrt (b * b + a) = b := sqrt_add_eq _ (le_trans (le_of_lt h) (Nat.le_add_left _ _))", "annotated_tactic": ["have be : <a>sqrt</a> (b * b + a) = b := <a>sqrt_add_eq</a> _ (<a>le_trans</a> (<a>le_of_lt</a> h) (<a>Nat.le_add_left</a> _ _))", [{"full_name": "Nat.sqrt", "def_path": "lake-packages/std/Std/Data/Nat/Basic.lean", "def_pos": [116, 5], "def_end_pos": [116, 9]}, {"full_name": "Nat.sqrt_add_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Sqrt.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}, {"full_name": "le_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [110, 9], "def_end_pos": [110, 17]}, {"full_name": "Nat.le_add_left", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 20]}]], "state_before": "case pos\na b : \u2115\nh : a < b\n\u22a2 unpair (b * b + a) = (a, b)", "state_after": "case pos\na b : \u2115\nh : a < b\nbe : sqrt (b * b + a) = b\n\u22a2 unpair (b * b + a) = (a, b)"}, {"tactic": "simp [unpair, be, add_tsub_cancel_right, h]", "annotated_tactic": ["simp [<a>unpair</a>, be, <a>add_tsub_cancel_right</a>, h]", [{"full_name": "Nat.unpair", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Pairing.lean", "def_pos": [44, 5], "def_end_pos": [44, 11]}, {"full_name": "add_tsub_cancel_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [356, 9], "def_end_pos": [356, 30]}]], "state_before": "case pos\na b : \u2115\nh : a < b\nbe : sqrt (b * b + a) = b\n\u22a2 unpair (b * b + a) = (a, b)", "state_after": "no goals"}, {"tactic": "have ae : sqrt (a * a + (a + b)) = a := by\n  rw [sqrt_add_eq]\n  exact add_le_add_left (le_of_not_gt h) _", "annotated_tactic": ["have ae : <a>sqrt</a> (a * a + (a + b)) = a := by\n      rw [<a>sqrt_add_eq</a>]\n      exact <a>add_le_add_left</a> (<a>le_of_not_gt</a> h) _", [{"full_name": "Nat.sqrt", "def_path": "lake-packages/std/Std/Data/Nat/Basic.lean", "def_pos": [116, 5], "def_end_pos": [116, 9]}, {"full_name": "Nat.sqrt_add_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Sqrt.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "add_le_add_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [49, 15], "def_end_pos": [49, 30]}, {"full_name": "le_of_not_gt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [328, 9], "def_end_pos": [328, 21]}]], "state_before": "case neg\na b : \u2115\nh : \u00aca < b\n\u22a2 unpair (a * a + a + b) = (a, b)", "state_after": "case neg\na b : \u2115\nh : \u00aca < b\nae : sqrt (a * a + (a + b)) = a\n\u22a2 unpair (a * a + a + b) = (a, b)"}, {"tactic": "simp [unpair, ae, Nat.not_lt_zero, add_assoc]", "annotated_tactic": ["simp [<a>unpair</a>, ae, <a>Nat.not_lt_zero</a>, <a>add_assoc</a>]", [{"full_name": "Nat.unpair", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Pairing.lean", "def_pos": [44, 5], "def_end_pos": [44, 11]}, {"full_name": "Nat.not_lt_zero", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1575, 9], "def_end_pos": [1575, 24]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}]], "state_before": "case neg\na b : \u2115\nh : \u00aca < b\nae : sqrt (a * a + (a + b)) = a\n\u22a2 unpair (a * a + a + b) = (a, b)", "state_after": "no goals"}, {"tactic": "rw [sqrt_add_eq]", "annotated_tactic": ["rw [<a>sqrt_add_eq</a>]", [{"full_name": "Nat.sqrt_add_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Sqrt.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}]], "state_before": "a b : \u2115\nh : \u00aca < b\n\u22a2 sqrt (a * a + (a + b)) = a", "state_after": "case h\na b : \u2115\nh : \u00aca < b\n\u22a2 a + b \u2264 a + a"}, {"tactic": "exact add_le_add_left (le_of_not_gt h) _", "annotated_tactic": ["exact <a>add_le_add_left</a> (<a>le_of_not_gt</a> h) _", [{"full_name": "add_le_add_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [49, 15], "def_end_pos": [49, 30]}, {"full_name": "le_of_not_gt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [328, 9], "def_end_pos": [328, 21]}]], "state_before": "case h\na b : \u2115\nh : \u00aca < b\n\u22a2 a + b \u2264 a + a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Lattice.lean", "full_name": "Set.biUnion_le_succ'", "start": [241, 1], "end": [242, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "IsComplemented.sup", "start": [672, 1], "end": [673, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basis.lean", "full_name": "Matrix.std_basis_eq_basis_mul_basis", "start": [81, 1], "end": [89, 24], "traced_tactics": [{"tactic": "ext i' j'", "annotated_tactic": ["ext i' j'", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Semiring \u03b1\ni : m\nj : n\n\u22a2 stdBasisMatrix i j 1 = vecMulVec (fun i' => if i = i' then 1 else 0) fun j' => if j = j' then 1 else 0", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Semiring \u03b1\ni : m\nj : n\ni' : m\nj' : n\n\u22a2 stdBasisMatrix i j 1 i' j' = vecMulVec (fun i' => if i = i' then 1 else 0) (fun j' => if j = j' then 1 else 0) i' j'"}, {"tactic": "simp only [stdBasisMatrix, vecMulVec, mul_ite, mul_one, mul_zero, of_apply]", "annotated_tactic": ["simp only [<a>stdBasisMatrix</a>, <a>vecMulVec</a>, <a>mul_ite</a>, <a>mul_one</a>, <a>mul_zero</a>, <a>of_apply</a>]", [{"full_name": "Matrix.stdBasisMatrix", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basis.lean", "def_pos": [36, 5], "def_end_pos": [36, 19]}, {"full_name": "Matrix.vecMulVec", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [1672, 5], "def_end_pos": [1672, 14]}, {"full_name": "mul_ite", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [195, 9], "def_end_pos": [195, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}, {"full_name": "Matrix.of_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [119, 9], "def_end_pos": [119, 17]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Semiring \u03b1\ni : m\nj : n\ni' : m\nj' : n\n\u22a2 stdBasisMatrix i j 1 i' j' = vecMulVec (fun i' => if i = i' then 1 else 0) (fun j' => if j = j' then 1 else 0) i' j'", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Semiring \u03b1\ni : m\nj : n\ni' : m\nj' : n\n\u22a2 (if i = i' \u2227 j = j' then 1 else 0) = if j = j' then if i = i' then 1 else 0 else 0"}, {"tactic": "simp_rw [@and_comm (i = i')]", "annotated_tactic": ["simp_rw [@<a>and_comm</a> (i = i')]", [{"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Semiring \u03b1\ni : m\nj : n\ni' : m\nj' : n\n\u22a2 (if i = i' \u2227 j = j' then 1 else 0) = if j = j' then if i = i' then 1 else 0 else 0", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Semiring \u03b1\ni : m\nj : n\ni' : m\nj' : n\n\u22a2 (if j = j' \u2227 i = i' then 1 else 0) = if j = j' then if i = i' then 1 else 0 else 0"}, {"tactic": "exact ite_and _ _ _ _", "annotated_tactic": ["exact <a>ite_and</a> _ _ _ _", [{"full_name": "ite_and", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [1252, 9], "def_end_pos": [1252, 16]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b3 : DecidableEq l\ninst\u271d\u00b2 : DecidableEq m\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Semiring \u03b1\ni : m\nj : n\ni' : m\nj' : n\n\u22a2 (if j = j' \u2227 i = i' then 1 else 0) = if j = j' then if i = i' then 1 else 0 else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "subset_upperClosure", "start": [1402, 1], "end": [1402, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.submodule_span_eq", "start": [114, 1], "end": [115, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "MulAction.orbit_smul", "start": [244, 1], "end": [248, 51], "traced_tactics": [{"tactic": "rw [inv_smul_smul]", "annotated_tactic": ["rw [<a>inv_smul_smul</a>]", [{"full_name": "inv_smul_smul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Group.lean", "def_pos": [36, 9], "def_end_pos": [36, 22]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Group G\n\u03b1 : Type v\ninst\u271d : MulAction G \u03b1\ng : G\na : \u03b1\n\u22a2 orbit G a = orbit G (g\u207b\u00b9 \u2022 g \u2022 a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "Even.sub_odd", "start": [492, 1], "end": [494, 26], "traced_tactics": [{"tactic": "rw [sub_eq_add_neg]", "annotated_tactic": ["rw [<a>sub_eq_add_neg</a>]", [{"full_name": "sub_eq_add_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [975, 3], "def_end_pos": [975, 14]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Even a\nhb : Odd b\n\u22a2 Odd (a - b)", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Even a\nhb : Odd b\n\u22a2 Odd (a + -b)"}, {"tactic": "exact ha.add_odd hb.neg", "annotated_tactic": ["exact ha.add_odd hb.neg", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Even a\nhb : Odd b\n\u22a2 Odd (a + -b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Init/Lemmas.lean", "full_name": "Nat.pos_of_ne_zero", "start": [25, 11], "end": [25, 94], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.nonempty_iff_ne_empty'", "start": [612, 1], "end": [613, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Nonempty.lean", "full_name": "not_nonempty_iff_imp_false", "start": [43, 1], "end": [44, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.Iterator.Valid.prevn", "start": [674, 1], "end": [676, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.Nonempty.right", "start": [507, 1], "end": [508, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.prod_apply_inl_fst", "start": [728, 1], "end": [734, 54], "traced_tactics": [{"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ni : \u03b9\n\u22a2 \u2191b.repr (\u2191(Basis.prod b b') (Sum.inl i)).1 = \u2191b.repr (\u2191b i)", "state_after": "case h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ni j : \u03b9\n\u22a2 \u2191(\u2191b.repr (\u2191(Basis.prod b b') (Sum.inl i)).1) j = \u2191(\u2191b.repr (\u2191b i)) j"}, {"tactic": "simp only [Basis.prod, Basis.coe_ofRepr, LinearEquiv.symm_trans_apply, LinearEquiv.prod_symm,\n  LinearEquiv.prod_apply, b.repr.apply_symm_apply, LinearEquiv.symm_symm, repr_self,\n  Equiv.toFun_as_coe, Finsupp.fst_sumFinsuppLEquivProdFinsupp]", "annotated_tactic": ["simp only [<a>Basis.prod</a>, <a>Basis.coe_ofRepr</a>, <a>LinearEquiv.symm_trans_apply</a>, <a>LinearEquiv.prod_symm</a>,\n      <a>LinearEquiv.prod_apply</a>, b.repr.apply_symm_apply, <a>LinearEquiv.symm_symm</a>, <a>repr_self</a>,\n      <a>Equiv.toFun_as_coe</a>, <a>Finsupp.fst_sumFinsuppLEquivProdFinsupp</a>]", [{"full_name": "Basis.prod", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [714, 15], "def_end_pos": [714, 19]}, {"full_name": "Basis.coe_ofRepr", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [128, 9], "def_end_pos": [128, 19]}, {"full_name": "LinearEquiv.symm_trans_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [388, 9], "def_end_pos": [388, 25]}, {"full_name": "LinearEquiv.prod_symm", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [810, 9], "def_end_pos": [810, 18]}, {"full_name": "LinearEquiv.prod_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [815, 9], "def_end_pos": [815, 19]}, {"full_name": "LinearEquiv.symm_symm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [515, 9], "def_end_pos": [515, 18]}, {"full_name": "Basis.repr_self", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [148, 9], "def_end_pos": [148, 18]}, {"full_name": "Equiv.toFun_as_coe", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [186, 29], "def_end_pos": [186, 41]}, {"full_name": "Finsupp.fst_sumFinsuppLEquivProdFinsupp", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [948, 9], "def_end_pos": [948, 40]}]], "state_before": "case h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ni j : \u03b9\n\u22a2 \u2191(\u2191b.repr (\u2191(Basis.prod b b') (Sum.inl i)).1) j = \u2191(\u2191b.repr (\u2191b i)) j", "state_after": "case h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ni j : \u03b9\n\u22a2 (\u2191fun\u2080 | Sum.inl i => 1) (Sum.inl j) = (\u2191fun\u2080 | i => 1) j"}, {"tactic": "apply Finsupp.single_apply_left Sum.inl_injective", "annotated_tactic": ["apply <a>Finsupp.single_apply_left</a> <a>Sum.inl_injective</a>", [{"full_name": "Finsupp.single_apply_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [313, 9], "def_end_pos": [313, 26]}, {"full_name": "Sum.inl_injective", "def_path": "lake-packages/mathlib/Mathlib/Data/Sum/Basic.lean", "def_pos": [31, 9], "def_end_pos": [31, 22]}]], "state_before": "case h\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nK : Type u_5\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\nV : Type u\nV' : Type u_9\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nb b\u2081 : Basis \u03b9 R M\ni\u271d : \u03b9\nc : R\nx : M\nb' : Basis \u03b9' R M'\ni j : \u03b9\n\u22a2 (\u2191fun\u2080 | Sum.inl i => 1) (Sum.inl j) = (\u2191fun\u2080 | i => 1) j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ModularLattice.lean", "full_name": "Disjoint.disjoint_sup_left_of_disjoint_sup_right", "start": [404, 1], "end": [409, 40], "traced_tactics": [{"tactic": "rw [disjoint_comm, sup_comm]", "annotated_tactic": ["rw [<a>disjoint_comm</a>, <a>sup_comm</a>]", [{"full_name": "disjoint_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [49, 9], "def_end_pos": [49, 22]}, {"full_name": "sup_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [250, 9], "def_end_pos": [250, 17]}]], "state_before": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint (a \u2294 b) c", "state_after": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint c (b \u2294 a)"}, {"tactic": "apply Disjoint.disjoint_sup_right_of_disjoint_sup_left h.symm", "annotated_tactic": ["apply <a>Disjoint.disjoint_sup_right_of_disjoint_sup_left</a> h.symm", [{"full_name": "Disjoint.disjoint_sup_right_of_disjoint_sup_left", "def_path": "lake-packages/mathlib/Mathlib/Order/ModularLattice.lean", "def_pos": [395, 9], "def_end_pos": [395, 48]}]], "state_before": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint c (b \u2294 a)", "state_after": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint (c \u2294 b) a"}, {"tactic": "rwa [sup_comm, disjoint_comm] at hsup", "annotated_tactic": ["rwa [<a>sup_comm</a>, <a>disjoint_comm</a>] at hsup", [{"full_name": "sup_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [250, 9], "def_end_pos": [250, 17]}, {"full_name": "disjoint_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [49, 9], "def_end_pos": [49, 22]}]], "state_before": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint (c \u2294 b) a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompactlyGenerated.lean", "full_name": "CompleteLattice.isSupClosedCompact_iff_wellFounded", "start": [288, 1], "end": [290, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.zipWith_nil_right", "start": [356, 9], "end": [357, 17], "traced_tactics": [{"tactic": "simp [zipWith]", "annotated_tactic": ["simp [<a>zipWith</a>]", [{"full_name": "List.zipWith", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [548, 19], "def_end_pos": [548, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 zipWith f l [] = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.Subsingleton.monotoneOn", "start": [2699, 11], "end": [2700, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsField.localization_map_bijective", "start": [1273, 1], "end": [1281, 98], "traced_tactics": [{"tactic": "letI := hR.toField", "annotated_tactic": ["letI := hR.toField", []], "state_before": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhM : 0 \u2209 M\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\n\u22a2 Bijective \u2191(algebraMap R R\u2098)", "state_after": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhM : 0 \u2209 M\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\n\u22a2 Bijective \u2191(algebraMap R R\u2098)"}, {"tactic": "replace hM := le_nonZeroDivisors_of_noZeroDivisors hM", "annotated_tactic": ["replace hM := <a>le_nonZeroDivisors_of_noZeroDivisors</a> hM", [{"full_name": "le_nonZeroDivisors_of_noZeroDivisors", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/NonZeroDivisors.lean", "def_pos": [137, 9], "def_end_pos": [137, 45]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhM : 0 \u2209 M\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\n\u22a2 Bijective \u2191(algebraMap R R\u2098)", "state_after": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\n\u22a2 Bijective \u2191(algebraMap R R\u2098)"}, {"tactic": "refine' \u27e8IsLocalization.injective _ hM, fun x => _\u27e9", "annotated_tactic": ["refine' \u27e8<a>IsLocalization.injective</a> _ hM, fun x => _\u27e9", [{"full_name": "IsLocalization.injective", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [1175, 19], "def_end_pos": [1175, 28]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\n\u22a2 Bijective \u2191(algebraMap R R\u2098)", "state_after": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\nx : R\u2098\n\u22a2 \u2203 a, \u2191(algebraMap R R\u2098) a = x"}, {"tactic": "obtain \u27e8r, \u27e8m, hm\u27e9, rfl\u27e9 := mk'_surjective M x", "annotated_tactic": ["obtain \u27e8r, \u27e8m, hm\u27e9, rfl\u27e9 := <a>mk'_surjective</a> M x", [{"full_name": "IsLocalization.mk'_surjective", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [298, 9], "def_end_pos": [298, 23]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\nx : R\u2098\n\u22a2 \u2203 a, \u2191(algebraMap R R\u2098) a = x", "state_after": "case intro.intro.mk\nR\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\nr m : R\nhm : m \u2208 M\n\u22a2 \u2203 a, \u2191(algebraMap R R\u2098) a = mk' R\u2098 r { val := m, property := hm }"}, {"tactic": "obtain \u27e8n, hn\u27e9 := hR.mul_inv_cancel (nonZeroDivisors.ne_zero <| hM hm)", "annotated_tactic": ["obtain \u27e8n, hn\u27e9 := hR.mul_inv_cancel (<a>nonZeroDivisors.ne_zero</a> <| hM hm)", [{"full_name": "nonZeroDivisors.ne_zero", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/NonZeroDivisors.lean", "def_pos": [83, 9], "def_end_pos": [83, 32]}]], "state_before": "case intro.intro.mk\nR\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\nr m : R\nhm : m \u2208 M\n\u22a2 \u2203 a, \u2191(algebraMap R R\u2098) a = mk' R\u2098 r { val := m, property := hm }", "state_after": "case intro.intro.mk.intro\nR\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\nr m : R\nhm : m \u2208 M\nn : R\nhn : m * n = 1\n\u22a2 \u2203 a, \u2191(algebraMap R R\u2098) a = mk' R\u2098 r { val := m, property := hm }"}, {"tactic": "exact \u27e8r * n, by erw [eq_mk'_iff_mul_eq, \u2190 map_mul, mul_assoc, _root_.mul_comm n, hn, mul_one]\u27e9", "annotated_tactic": ["exact \u27e8r * n, by erw [<a>eq_mk'_iff_mul_eq</a>, \u2190 <a>map_mul</a>, <a>mul_assoc</a>, <a>_root_.mul_comm</a> n, hn, <a>mul_one</a>]\u27e9", [{"full_name": "IsLocalization.eq_mk'_iff_mul_eq", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [281, 9], "def_end_pos": [281, 26]}, {"full_name": "map_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [299, 9], "def_end_pos": [299, 16]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case intro.intro.mk.intro\nR\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\nr m : R\nhm : m \u2208 M\nn : R\nhn : m * n = 1\n\u22a2 \u2203 a, \u2191(algebraMap R R\u2098) a = mk' R\u2098 r { val := m, property := hm }", "state_after": "no goals"}, {"tactic": "erw [eq_mk'_iff_mul_eq, \u2190 map_mul, mul_assoc, _root_.mul_comm n, hn, mul_one]", "annotated_tactic": ["erw [<a>eq_mk'_iff_mul_eq</a>, \u2190 <a>map_mul</a>, <a>mul_assoc</a>, <a>_root_.mul_comm</a> n, hn, <a>mul_one</a>]", [{"full_name": "IsLocalization.eq_mk'_iff_mul_eq", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [281, 9], "def_end_pos": [281, 26]}, {"full_name": "map_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [299, 9], "def_end_pos": [299, 16]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "R\u271d : Type u_1\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Submonoid R\u271d\nS : Type u_2\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : Algebra R\u271d S\nP : Type u_3\ninst\u271d\u2074 : CommRing P\nR : Type u_4\nR\u2098 : Type u_5\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing R\u2098\nM : Submonoid R\nhR : IsField R\ninst\u271d\u00b9 : Algebra R R\u2098\ninst\u271d : IsLocalization M R\u2098\nthis : Field R := toField hR\nhM : M \u2264 nonZeroDivisors R\nr m : R\nhm : m \u2208 M\nn : R\nhn : m * n = 1\n\u22a2 \u2191(algebraMap R R\u2098) (r * n) = mk' R\u2098 r { val := m, property := hm }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "span_gcd", "start": [353, 1], "end": [371, 49], "traced_tactics": [{"tactic": "obtain \u27e8d, hd\u27e9 := IsPrincipalIdealRing.principal (span ({x, y} : Set R))", "annotated_tactic": ["obtain \u27e8d, hd\u27e9 := <a>IsPrincipalIdealRing.principal</a> (<a>span</a> ({x, y} : <a>Set</a> R))", [{"full_name": "IsPrincipalIdealRing.principal", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [74, 3], "def_end_pos": [74, 12]}, {"full_name": "Ideal.span", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [109, 5], "def_end_pos": [109, 9]}, {"full_name": "Set", "def_path": "lake-packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [38, 5], "def_end_pos": [38, 8]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y : R\n\u22a2 Ideal.span {gcd x y} = Ideal.span {x, y}", "state_after": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Submodule.span R {d}\n\u22a2 Ideal.span {gcd x y} = Ideal.span {x, y}"}, {"tactic": "rw [submodule_span_eq] at hd", "annotated_tactic": ["rw [<a>submodule_span_eq</a>] at hd", [{"full_name": "Ideal.submodule_span_eq", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [114, 9], "def_end_pos": [114, 26]}]], "state_before": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Submodule.span R {d}\n\u22a2 Ideal.span {gcd x y} = Ideal.span {x, y}", "state_after": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 Ideal.span {gcd x y} = Ideal.span {x, y}"}, {"tactic": "rw [hd]", "annotated_tactic": ["rw [hd]", []], "state_before": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 Ideal.span {gcd x y} = Ideal.span {x, y}", "state_after": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 Ideal.span {gcd x y} = Ideal.span {d}"}, {"tactic": "suffices Associated d (gcd x y) by\n  obtain \u27e8D, HD\u27e9 := this\n  rw [\u2190 HD]\n  exact span_singleton_mul_right_unit D.isUnit _", "annotated_tactic": ["suffices <a>Associated</a> d (<a>gcd</a> x y) by\n    obtain \u27e8D, HD\u27e9 := this\n    rw [\u2190 HD]\n    exact <a>span_singleton_mul_right_unit</a> D.isUnit _", [{"full_name": "Associated", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [379, 5], "def_end_pos": [379, 15]}, {"full_name": "GCDMonoid.gcd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [274, 3], "def_end_pos": [274, 6]}, {"full_name": "Ideal.span_singleton_mul_right_unit", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [516, 9], "def_end_pos": [516, 38]}]], "state_before": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 Ideal.span {gcd x y} = Ideal.span {d}", "state_after": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 Associated d (gcd x y)"}, {"tactic": "apply associated_of_dvd_dvd", "annotated_tactic": ["apply <a>associated_of_dvd_dvd</a>", [{"full_name": "associated_of_dvd_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [550, 9], "def_end_pos": [550, 30]}]], "state_before": "case mk.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 Associated d (gcd x y)", "state_after": "case mk.intro.hab\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 d \u2223 gcd x y\n\ncase mk.intro.hba\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 gcd x y \u2223 d"}, {"tactic": "obtain \u27e8D, HD\u27e9 := this", "annotated_tactic": ["obtain \u27e8D, HD\u27e9 := this", []], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\nthis : Associated d (gcd x y)\n\u22a2 Ideal.span {gcd x y} = Ideal.span {d}", "state_after": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\nD : R\u02e3\nHD : d * \u2191D = gcd x y\n\u22a2 Ideal.span {gcd x y} = Ideal.span {d}"}, {"tactic": "rw [\u2190 HD]", "annotated_tactic": ["rw [\u2190 HD]", []], "state_before": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\nD : R\u02e3\nHD : d * \u2191D = gcd x y\n\u22a2 Ideal.span {gcd x y} = Ideal.span {d}", "state_after": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\nD : R\u02e3\nHD : d * \u2191D = gcd x y\n\u22a2 Ideal.span {d * \u2191D} = Ideal.span {d}"}, {"tactic": "exact span_singleton_mul_right_unit D.isUnit _", "annotated_tactic": ["exact <a>span_singleton_mul_right_unit</a> D.isUnit _", [{"full_name": "Ideal.span_singleton_mul_right_unit", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [516, 9], "def_end_pos": [516, 38]}]], "state_before": "case intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\nD : R\u02e3\nHD : d * \u2191D = gcd x y\n\u22a2 Ideal.span {d * \u2191D} = Ideal.span {d}", "state_after": "no goals"}, {"tactic": "rw [dvd_gcd_iff]", "annotated_tactic": ["rw [<a>dvd_gcd_iff</a>]", [{"full_name": "dvd_gcd_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [325, 9], "def_end_pos": [325, 20]}]], "state_before": "case mk.intro.hab\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 d \u2223 gcd x y", "state_after": "case mk.intro.hab\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 d \u2223 x \u2227 d \u2223 y"}, {"tactic": "constructor <;> rw [\u2190 Ideal.mem_span_singleton, \u2190 hd, Ideal.mem_span_pair]", "annotated_tactic": ["constructor <;> rw [\u2190 <a>Ideal.mem_span_singleton</a>, \u2190 hd, <a>Ideal.mem_span_pair</a>]", [{"full_name": "Ideal.mem_span_singleton", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [497, 9], "def_end_pos": [497, 27]}, {"full_name": "Ideal.mem_span_pair", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [364, 9], "def_end_pos": [364, 22]}]], "state_before": "case mk.intro.hab\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 d \u2223 x \u2227 d \u2223 y", "state_after": "case mk.intro.hab.left\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 \u2203 a b, a * x + b * y = x\n\ncase mk.intro.hab.right\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 \u2203 a b, a * x + b * y = y"}, {"tactic": "use 1, 0", "annotated_tactic": ["use 1, 0", []], "state_before": "case mk.intro.hab.left\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 \u2203 a b, a * x + b * y = x", "state_after": "case h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 1 * x + 0 * y = x"}, {"tactic": "rw [one_mul, zero_mul, add_zero]", "annotated_tactic": ["rw [<a>one_mul</a>, <a>zero_mul</a>, <a>add_zero</a>]", [{"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "MulZeroClass.zero_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [36, 3], "def_end_pos": [36, 11]}, {"full_name": "add_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [469, 3], "def_end_pos": [469, 14]}]], "state_before": "case h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 1 * x + 0 * y = x", "state_after": "no goals"}, {"tactic": "use 0, 1", "annotated_tactic": ["use 0, 1", []], "state_before": "case mk.intro.hab.right\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 \u2203 a b, a * x + b * y = y", "state_after": "case h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 0 * x + 1 * y = y"}, {"tactic": "rw [one_mul, zero_mul, zero_add]", "annotated_tactic": ["rw [<a>one_mul</a>, <a>zero_mul</a>, <a>zero_add</a>]", [{"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "MulZeroClass.zero_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [36, 3], "def_end_pos": [36, 11]}, {"full_name": "zero_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [463, 3], "def_end_pos": [463, 14]}]], "state_before": "case h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 0 * x + 1 * y = y", "state_after": "no goals"}, {"tactic": "obtain \u27e8r, s, rfl\u27e9 : \u2203 r s, r * x + s * y = d := by\n  rw [\u2190 Ideal.mem_span_pair, hd, Ideal.mem_span_singleton]", "annotated_tactic": ["obtain \u27e8r, s, rfl\u27e9 : \u2203 r s, r * x + s * y = d := by\n      rw [\u2190 <a>Ideal.mem_span_pair</a>, hd, <a>Ideal.mem_span_singleton</a>]", [{"full_name": "Ideal.mem_span_pair", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [364, 9], "def_end_pos": [364, 22]}, {"full_name": "Ideal.mem_span_singleton", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [497, 9], "def_end_pos": [497, 27]}]], "state_before": "case mk.intro.hba\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 gcd x y \u2223 d", "state_after": "case mk.intro.hba.intro.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y r s : R\nhd : Ideal.span {x, y} = Ideal.span {r * x + s * y}\n\u22a2 gcd x y \u2223 r * x + s * y"}, {"tactic": "apply dvd_add <;> apply dvd_mul_of_dvd_right", "annotated_tactic": ["apply <a>dvd_add</a> <;> apply <a>dvd_mul_of_dvd_right</a>", [{"full_name": "dvd_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "def_pos": [27, 9], "def_end_pos": [27, 16]}, {"full_name": "dvd_mul_of_dvd_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [173, 9], "def_end_pos": [173, 29]}]], "state_before": "case mk.intro.hba.intro.intro\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y r s : R\nhd : Ideal.span {x, y} = Ideal.span {r * x + s * y}\n\u22a2 gcd x y \u2223 r * x + s * y", "state_after": "case mk.intro.hba.intro.intro.h\u2081.h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y r s : R\nhd : Ideal.span {x, y} = Ideal.span {r * x + s * y}\n\u22a2 gcd x y \u2223 x\n\ncase mk.intro.hba.intro.intro.h\u2082.h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y r s : R\nhd : Ideal.span {x, y} = Ideal.span {r * x + s * y}\n\u22a2 gcd x y \u2223 y"}, {"tactic": "exacts [gcd_dvd_left x y, gcd_dvd_right x y]", "annotated_tactic": ["exacts [<a>gcd_dvd_left</a> x y, <a>gcd_dvd_right</a> x y]", [{"full_name": "GCDMonoid.gcd_dvd_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [278, 3], "def_end_pos": [278, 15]}, {"full_name": "GCDMonoid.gcd_dvd_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [280, 3], "def_end_pos": [280, 16]}]], "state_before": "case mk.intro.hba.intro.intro.h\u2081.h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y r s : R\nhd : Ideal.span {x, y} = Ideal.span {r * x + s * y}\n\u22a2 gcd x y \u2223 x\n\ncase mk.intro.hba.intro.intro.h\u2082.h\nR : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y r s : R\nhd : Ideal.span {x, y} = Ideal.span {r * x + s * y}\n\u22a2 gcd x y \u2223 y", "state_after": "no goals"}, {"tactic": "rw [\u2190 Ideal.mem_span_pair, hd, Ideal.mem_span_singleton]", "annotated_tactic": ["rw [\u2190 <a>Ideal.mem_span_pair</a>, hd, <a>Ideal.mem_span_singleton</a>]", [{"full_name": "Ideal.mem_span_pair", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [364, 9], "def_end_pos": [364, 22]}, {"full_name": "Ideal.mem_span_singleton", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [497, 9], "def_end_pos": [497, 27]}]], "state_before": "R : Type u\nM : Type v\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : GCDMonoid R\nx y d : R\nhd : Ideal.span {x, y} = Ideal.span {d}\n\u22a2 \u2203 r s, r * x + s * y = d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "min_rec", "start": [957, 1], "end": [959, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Nonempty.lean", "full_name": "Function.Surjective.nonempty", "start": [173, 1], "end": [177, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iic_union_Ici", "start": [1241, 1], "end": [1242, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeqCompletion.lean", "full_name": "CauSeq.Completion.ofRat_intCast", "start": [140, 1], "end": [141, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "full_name": "min_mul_distrib", "start": [361, 1], "end": [366, 20], "traced_tactics": [{"tactic": "cases' le_total a b with hb hb", "annotated_tactic": ["cases' <a>le_total</a> a b with hb hb", [{"full_name": "le_total", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [295, 9], "def_end_pos": [295, 17]}]], "state_before": "\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\n\u22a2 min a (b * c) = min a (min a b * min a c)", "state_after": "case inl\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : a \u2264 b\n\u22a2 min a (b * c) = min a (min a b * min a c)\n\ncase inr\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : b \u2264 a\n\u22a2 min a (b * c) = min a (min a b * min a c)"}, {"tactic": "simp [hb, le_mul_right]", "annotated_tactic": ["simp [hb, <a>le_mul_right</a>]", [{"full_name": "le_mul_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [279, 9], "def_end_pos": [279, 21]}]], "state_before": "case inl\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : a \u2264 b\n\u22a2 min a (b * c) = min a (min a b * min a c)", "state_after": "no goals"}, {"tactic": "cases' le_total a c with hc hc", "annotated_tactic": ["cases' <a>le_total</a> a c with hc hc", [{"full_name": "le_total", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [295, 9], "def_end_pos": [295, 17]}]], "state_before": "case inr\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : b \u2264 a\n\u22a2 min a (b * c) = min a (min a b * min a c)", "state_after": "case inr.inl\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : b \u2264 a\nhc : a \u2264 c\n\u22a2 min a (b * c) = min a (min a b * min a c)\n\ncase inr.inr\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : b \u2264 a\nhc : c \u2264 a\n\u22a2 min a (b * c) = min a (min a b * min a c)"}, {"tactic": "simp [hc, le_mul_left]", "annotated_tactic": ["simp [hc, <a>le_mul_left</a>]", [{"full_name": "le_mul_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [271, 9], "def_end_pos": [271, 20]}]], "state_before": "case inr.inl\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : b \u2264 a\nhc : a \u2264 c\n\u22a2 min a (b * c) = min a (min a b * min a c)", "state_after": "no goals"}, {"tactic": "simp [hb, hc]", "annotated_tactic": ["simp [hb, hc]", []], "state_before": "case inr.inr\n\u03b1 : Type u\ninst\u271d : CanonicallyLinearOrderedCommMonoid \u03b1\na b c : \u03b1\nhb : b \u2264 a\nhc : c \u2264 a\n\u22a2 min a (b * c) = min a (min a b * min a c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Cofinite.lean", "full_name": "Filter.eventually_cofinite_ne", "start": [90, 1], "end": [91, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBNode.lowerBound?_mem_lb", "start": [276, 1], "end": [278, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.toFinsupp_add", "start": [209, 1], "end": [212, 23], "traced_tactics": [{"tactic": "cases a", "annotated_tactic": ["cases a", []], "state_before": "R : Type u\na\u271d b\u271d : R\nm n : \u2115\ninst\u271d : Semiring R\np q a b : R[X]\n\u22a2 (a + b).toFinsupp = a.toFinsupp + b.toFinsupp", "state_after": "case ofFinsupp\nR : Type u\na b\u271d : R\nm n : \u2115\ninst\u271d : Semiring R\np q b : R[X]\ntoFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d } + b).toFinsupp = { toFinsupp := toFinsupp\u271d }.toFinsupp + b.toFinsupp"}, {"tactic": "cases b", "annotated_tactic": ["cases b", []], "state_before": "case ofFinsupp\nR : Type u\na b\u271d : R\nm n : \u2115\ninst\u271d : Semiring R\np q b : R[X]\ntoFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d } + b).toFinsupp = { toFinsupp := toFinsupp\u271d }.toFinsupp + b.toFinsupp", "state_after": "case ofFinsupp.ofFinsupp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\ntoFinsupp\u271d\u00b9 toFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d\u00b9 } + { toFinsupp := toFinsupp\u271d }).toFinsupp =\n    { toFinsupp := toFinsupp\u271d\u00b9 }.toFinsupp + { toFinsupp := toFinsupp\u271d }.toFinsupp"}, {"tactic": "rw [\u2190 ofFinsupp_add]", "annotated_tactic": ["rw [\u2190 <a>ofFinsupp_add</a>]", [{"full_name": "Polynomial.ofFinsupp_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [164, 9], "def_end_pos": [164, 22]}]], "state_before": "case ofFinsupp.ofFinsupp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\ntoFinsupp\u271d\u00b9 toFinsupp\u271d : R[\u2115]\n\u22a2 ({ toFinsupp := toFinsupp\u271d\u00b9 } + { toFinsupp := toFinsupp\u271d }).toFinsupp =\n    { toFinsupp := toFinsupp\u271d\u00b9 }.toFinsupp + { toFinsupp := toFinsupp\u271d }.toFinsupp", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "Ideal.algebraMap_quotient_injective", "start": [588, 1], "end": [593, 28], "traced_tactics": [{"tactic": "rintro \u27e8a\u27e9 \u27e8b\u27e9 hab", "annotated_tactic": ["rintro \u27e8a\u27e9 \u27e8b\u27e9 hab", []], "state_before": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2077 : CommSemiring R\u2081\ninst\u271d\u2076 : CommSemiring R\u2082\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R\u2081 A\ninst\u271d\u00b2 : Algebra R\u2082 A\ninst\u271d\u00b9 : Algebra R\u2081 B\nI : Ideal A\ninst\u271d : Algebra R A\n\u22a2 Injective \u2191(algebraMap (R \u29f8 comap (algebraMap R A) I) (A \u29f8 I))", "state_after": "case mk.mk\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2077 : CommSemiring R\u2081\ninst\u271d\u2076 : CommSemiring R\u2082\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R\u2081 A\ninst\u271d\u00b2 : Algebra R\u2082 A\ninst\u271d\u00b9 : Algebra R\u2081 B\nI : Ideal A\ninst\u271d : Algebra R A\na\u2081\u271d : R \u29f8 comap (algebraMap R A) I\na : R\na\u2082\u271d : R \u29f8 comap (algebraMap R A) I\nb : R\nhab :\n  \u2191(algebraMap (R \u29f8 comap (algebraMap R A) I) (A \u29f8 I)) \u27e6a\u27e7 = \u2191(algebraMap (R \u29f8 comap (algebraMap R A) I) (A \u29f8 I)) \u27e6b\u27e7\n\u22a2 \u27e6a\u27e7 = \u27e6b\u27e7"}, {"tactic": "replace hab := Quotient.eq.mp hab", "annotated_tactic": ["replace hab := Quotient.eq.mp hab", []], "state_before": "case mk.mk\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2077 : CommSemiring R\u2081\ninst\u271d\u2076 : CommSemiring R\u2082\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R\u2081 A\ninst\u271d\u00b2 : Algebra R\u2082 A\ninst\u271d\u00b9 : Algebra R\u2081 B\nI : Ideal A\ninst\u271d : Algebra R A\na\u2081\u271d : R \u29f8 comap (algebraMap R A) I\na : R\na\u2082\u271d : R \u29f8 comap (algebraMap R A) I\nb : R\nhab :\n  \u2191(algebraMap (R \u29f8 comap (algebraMap R A) I) (A \u29f8 I)) \u27e6a\u27e7 = \u2191(algebraMap (R \u29f8 comap (algebraMap R A) I) (A \u29f8 I)) \u27e6b\u27e7\n\u22a2 \u27e6a\u27e7 = \u27e6b\u27e7", "state_after": "case mk.mk\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2077 : CommSemiring R\u2081\ninst\u271d\u2076 : CommSemiring R\u2082\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R\u2081 A\ninst\u271d\u00b2 : Algebra R\u2082 A\ninst\u271d\u00b9 : Algebra R\u2081 B\nI : Ideal A\ninst\u271d : Algebra R A\na\u2081\u271d : R \u29f8 comap (algebraMap R A) I\na : R\na\u2082\u271d : R \u29f8 comap (algebraMap R A) I\nb : R\nhab : \u2191(algebraMap R A) a - \u2191(algebraMap R A) b \u2208 I\n\u22a2 \u27e6a\u27e7 = \u27e6b\u27e7"}, {"tactic": "rw [\u2190 RingHom.map_sub] at hab", "annotated_tactic": ["rw [\u2190 <a>RingHom.map_sub</a>] at hab", [{"full_name": "RingHom.map_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [618, 19], "def_end_pos": [618, 26]}]], "state_before": "case mk.mk\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2077 : CommSemiring R\u2081\ninst\u271d\u2076 : CommSemiring R\u2082\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R\u2081 A\ninst\u271d\u00b2 : Algebra R\u2082 A\ninst\u271d\u00b9 : Algebra R\u2081 B\nI : Ideal A\ninst\u271d : Algebra R A\na\u2081\u271d : R \u29f8 comap (algebraMap R A) I\na : R\na\u2082\u271d : R \u29f8 comap (algebraMap R A) I\nb : R\nhab : \u2191(algebraMap R A) a - \u2191(algebraMap R A) b \u2208 I\n\u22a2 \u27e6a\u27e7 = \u27e6b\u27e7", "state_after": "case mk.mk\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2077 : CommSemiring R\u2081\ninst\u271d\u2076 : CommSemiring R\u2082\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R\u2081 A\ninst\u271d\u00b2 : Algebra R\u2082 A\ninst\u271d\u00b9 : Algebra R\u2081 B\nI : Ideal A\ninst\u271d : Algebra R A\na\u2081\u271d : R \u29f8 comap (algebraMap R A) I\na : R\na\u2082\u271d : R \u29f8 comap (algebraMap R A) I\nb : R\nhab : \u2191(algebraMap R A) (a - b) \u2208 I\n\u22a2 \u27e6a\u27e7 = \u27e6b\u27e7"}, {"tactic": "exact Quotient.eq.mpr hab", "annotated_tactic": ["exact Quotient.eq.mpr hab", []], "state_before": "case mk.mk\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2077 : CommSemiring R\u2081\ninst\u271d\u2076 : CommSemiring R\u2082\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : CommRing B\ninst\u271d\u00b3 : Algebra R\u2081 A\ninst\u271d\u00b2 : Algebra R\u2082 A\ninst\u271d\u00b9 : Algebra R\u2081 B\nI : Ideal A\ninst\u271d : Algebra R A\na\u2081\u271d : R \u29f8 comap (algebraMap R A) I\na : R\na\u2082\u271d : R \u29f8 comap (algebraMap R A) I\nb : R\nhab : \u2191(algebraMap R A) (a - b) \u2208 I\n\u22a2 \u27e6a\u27e7 = \u27e6b\u27e7", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Nilpotent.lean", "full_name": "IsNilpotent.eq_zero", "start": [120, 1], "end": [121, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Subtype.lean", "full_name": "Subtype.ext_val", "start": [86, 1], "end": [87, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diagonal_smul", "start": [455, 1], "end": [459, 11], "traced_tactics": [{"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : DistribMulAction R \u03b1\nr : R\nd : n \u2192 \u03b1\n\u22a2 diagonal (r \u2022 d) = r \u2022 diagonal d", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : DistribMulAction R \u03b1\nr : R\nd : n \u2192 \u03b1\ni j : n\n\u22a2 diagonal (r \u2022 d) i j = (r \u2022 diagonal d) i j"}, {"tactic": "by_cases h : i = j <;>\nsimp [h]", "annotated_tactic": ["by_cases h : i = j <;>\n  simp [h]", []], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : DistribMulAction R \u03b1\nr : R\nd : n \u2192 \u03b1\ni j : n\n\u22a2 diagonal (r \u2022 d) i j = (r \u2022 diagonal d) i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diagonal_mul_diagonal'", "start": [1069, 1], "end": [1071, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Vector/Basic.lean", "full_name": "Vector.replicate_succ", "start": [774, 1], "end": [776, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Control/EquivFunctor.lean", "full_name": "EquivFunctor.mapEquiv_symm", "start": [75, 1], "end": [76, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.exists_mem_of_ne_nil", "start": [51, 1], "end": [52, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycle.isCycleOn", "start": [815, 11], "end": [816, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.frequently_imp_distrib", "start": [1370, 1], "end": [1372, 63], "traced_tactics": [{"tactic": "simp [imp_iff_not_or, not_eventually, frequently_or_distrib]", "annotated_tactic": ["simp [<a>imp_iff_not_or</a>, <a>not_eventually</a>, <a>frequently_or_distrib</a>]", [{"full_name": "imp_iff_not_or", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [374, 9], "def_end_pos": [374, 23]}, {"full_name": "Filter.not_eventually", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1332, 9], "def_end_pos": [1332, 23]}, {"full_name": "Filter.frequently_or_distrib", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1356, 9], "def_end_pos": [1356, 30]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : Filter \u03b1\np q : \u03b1 \u2192 Prop\n\u22a2 (\u2203\u1da0 (x : \u03b1) in f, p x \u2192 q x) \u2194 (\u2200\u1da0 (x : \u03b1) in f, p x) \u2192 \u2203\u1da0 (x : \u03b1) in f, q x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Bool.lean", "full_name": "Bool.lt_trans", "start": [144, 11], "end": [144, 82], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u2200 {x y z : Bool}, x < y \u2192 y < z \u2192 x < z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "algebraMap.coe_neg", "start": [176, 1], "end": [177, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/NatAntidiagonal.lean", "full_name": "Finset.Nat.prod_antidiagonal_swap", "start": [36, 1], "end": [38, 60], "traced_tactics": [{"tactic": "conv_lhs => rw [\u2190 map_swap_antidiagonal, Finset.prod_map]", "annotated_tactic": ["conv_lhs => rw [\u2190 <a>map_swap_antidiagonal</a>, <a>Finset.prod_map</a>]", [{"full_name": "Finset.map_swap_antidiagonal", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Antidiagonal.lean", "def_pos": [92, 17], "def_end_pos": [92, 38]}, {"full_name": "Finset.prod_map", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [376, 9], "def_end_pos": [376, 17]}]], "state_before": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : AddCommMonoid N\nn : \u2115\nf : \u2115 \u00d7 \u2115 \u2192 M\n\u22a2 \u220f p in antidiagonal n, f (Prod.swap p) = \u220f p in antidiagonal n, f p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Noetherian.lean", "full_name": "isNoetherian_of_ker_bot", "start": [186, 1], "end": [188, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.comap_fst_neBot_iff", "start": [2458, 1], "end": [2462, 41], "traced_tactics": [{"tactic": "cases isEmpty_or_nonempty \u03b2", "annotated_tactic": ["cases <a>isEmpty_or_nonempty</a> \u03b2", [{"full_name": "isEmpty_or_nonempty", "def_path": "lake-packages/mathlib/Mathlib/Logic/IsEmpty.lean", "def_pos": [207, 9], "def_end_pos": [207, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\n\u22a2 NeBot (comap Prod.fst f) \u2194 NeBot f \u2227 Nonempty \u03b2", "state_after": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\nh\u271d : IsEmpty \u03b2\n\u22a2 NeBot (comap Prod.fst f) \u2194 NeBot f \u2227 Nonempty \u03b2\n\ncase inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\nh\u271d : Nonempty \u03b2\n\u22a2 NeBot (comap Prod.fst f) \u2194 NeBot f \u2227 Nonempty \u03b2"}, {"tactic": "rw [filter_eq_bot_of_isEmpty (f.comap _), \u2190 not_iff_not]", "annotated_tactic": ["rw [<a>filter_eq_bot_of_isEmpty</a> (f.comap _), \u2190 <a>not_iff_not</a>]", [{"full_name": "Filter.filter_eq_bot_of_isEmpty", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [717, 9], "def_end_pos": [717, 33]}, {"full_name": "not_iff_not", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [436, 9], "def_end_pos": [436, 20]}]], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\nh\u271d : IsEmpty \u03b2\n\u22a2 NeBot (comap Prod.fst f) \u2194 NeBot f \u2227 Nonempty \u03b2", "state_after": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\nh\u271d : IsEmpty \u03b2\n\u22a2 \u00acNeBot \u22a5 \u2194 \u00ac(NeBot f \u2227 Nonempty \u03b2)"}, {"tactic": "simp [*]", "annotated_tactic": ["simp [*]", []], "state_before": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\nh\u271d : IsEmpty \u03b2\n\u22a2 \u00acNeBot \u22a5 \u2194 \u00ac(NeBot f \u2227 Nonempty \u03b2)", "state_after": "no goals"}, {"tactic": "simp [comap_neBot_iff_frequently, *]", "annotated_tactic": ["simp [<a>comap_neBot_iff_frequently</a>, *]", [{"full_name": "Filter.comap_neBot_iff_frequently", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2428, 9], "def_end_pos": [2428, 35]}]], "state_before": "case inr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d f\u2081 f\u2082 : Filter \u03b1\ng g\u2081 g\u2082 : Filter \u03b2\nm : \u03b1 \u2192 \u03b2\nm' : \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : Filter \u03b1\nh\u271d : Nonempty \u03b2\n\u22a2 NeBot (comap Prod.fst f) \u2194 NeBot f \u2227 Nonempty \u03b2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "mul_lt_of_lt_of_lt_one", "start": [637, 1], "end": [643, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.smul_iUnion", "start": [246, 1], "end": [247, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelIso/Basic.lean", "full_name": "RelHom.coe_fn_toFun", "start": [120, 1], "end": [121, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Closure.lean", "full_name": "ClosureOperator.closure_is_closed", "start": [184, 1], "end": [185, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Count.lean", "full_name": "List.count_le_length", "start": [151, 1], "end": [151, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "linearIndependent_finset_map_embedding_subtype", "start": [339, 1], "end": [353, 41], "traced_tactics": [{"tactic": "let f : t.map (Embedding.subtype s) \u2192 s := fun x =>\n  \u27e8x.1, by\n    obtain \u27e8x, h\u27e9 := x\n    rw [Finset.mem_map] at h\n    obtain \u27e8a, _ha, rfl\u27e9 := h\n    simp only [Subtype.coe_prop, Embedding.coe_subtype]\u27e9", "annotated_tactic": ["let f : t.map (<a>Embedding.subtype</a> s) \u2192 s := fun x =>\n    \u27e8x.1, by\n      obtain \u27e8x, h\u27e9 := x\n      rw [<a>Finset.mem_map</a>] at h\n      obtain \u27e8a, _ha, rfl\u27e9 := h\n      simp only [<a>Subtype.coe_prop</a>, <a>Embedding.coe_subtype</a>]\u27e9", [{"full_name": "Function.Embedding.subtype", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [229, 5], "def_end_pos": [229, 12]}, {"full_name": "Finset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Subtype.coe_prop", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [262, 9], "def_end_pos": [262, 17]}, {"full_name": "Function.Embedding.coe_subtype", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [234, 9], "def_end_pos": [234, 20]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\n\u22a2 LinearIndependent R Subtype.val", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\n\u22a2 LinearIndependent R Subtype.val"}, {"tactic": "convert LinearIndependent.comp li f ?_", "annotated_tactic": ["convert <a>LinearIndependent.comp</a> li f ?_", [{"full_name": "LinearIndependent.comp", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/LinearIndependent.lean", "def_pos": [209, 9], "def_end_pos": [209, 31]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\n\u22a2 LinearIndependent R Subtype.val", "state_after": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\n\u22a2 Injective f"}, {"tactic": "rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9", "annotated_tactic": ["rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\n\u22a2 Injective f", "state_after": "case mk.mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\nx : M\nhx : x \u2208 Finset.map (Embedding.subtype s) t\ny : M\nhy : y \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 f { val := x, property := hx } = f { val := y, property := hy } \u2192\n    { val := x, property := hx } = { val := y, property := hy }"}, {"tactic": "rw [Finset.mem_map] at hx hy", "annotated_tactic": ["rw [<a>Finset.mem_map</a>] at hx hy", [{"full_name": "Finset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}]], "state_before": "case mk.mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\nx : M\nhx : x \u2208 Finset.map (Embedding.subtype s) t\ny : M\nhy : y \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 f { val := x, property := hx } = f { val := y, property := hy } \u2192\n    { val := x, property := hx } = { val := y, property := hy }", "state_after": "case mk.mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\nx : M\nhx\u271d : x \u2208 Finset.map (Embedding.subtype s) t\nhx : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = x\ny : M\nhy\u271d : y \u2208 Finset.map (Embedding.subtype s) t\nhy : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = y\n\u22a2 f { val := x, property := hx\u271d } = f { val := y, property := hy\u271d } \u2192\n    { val := x, property := hx\u271d } = { val := y, property := hy\u271d }"}, {"tactic": "obtain \u27e8a, _ha, rfl\u27e9 := hx", "annotated_tactic": ["obtain \u27e8a, _ha, rfl\u27e9 := hx", []], "state_before": "case mk.mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y\u271d : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\nx : M\nhx\u271d : x \u2208 Finset.map (Embedding.subtype s) t\nhx : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = x\ny : M\nhy\u271d : y \u2208 Finset.map (Embedding.subtype s) t\nhy : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = y\n\u22a2 f { val := x, property := hx\u271d } = f { val := y, property := hy\u271d } \u2192\n    { val := x, property := hx\u271d } = { val := y, property := hy\u271d }", "state_after": "case mk.mk.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na\u271d b : R\nx y\u271d : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\ny : M\nhy\u271d : y \u2208 Finset.map (Embedding.subtype s) t\nhy : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = y\na : Subtype s\n_ha : a \u2208 t\nhx : \u2191(Embedding.subtype s) a \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 f { val := \u2191(Embedding.subtype s) a, property := hx } = f { val := y, property := hy\u271d } \u2192\n    { val := \u2191(Embedding.subtype s) a, property := hx } = { val := y, property := hy\u271d }"}, {"tactic": "obtain \u27e8b, _hb, rfl\u27e9 := hy", "annotated_tactic": ["obtain \u27e8b, _hb, rfl\u27e9 := hy", []], "state_before": "case mk.mk.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na\u271d b : R\nx y\u271d : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\ny : M\nhy\u271d : y \u2208 Finset.map (Embedding.subtype s) t\nhy : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = y\na : Subtype s\n_ha : a \u2208 t\nhx : \u2191(Embedding.subtype s) a \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 f { val := \u2191(Embedding.subtype s) a, property := hx } = f { val := y, property := hy\u271d } \u2192\n    { val := \u2191(Embedding.subtype s) a, property := hx } = { val := y, property := hy\u271d }", "state_after": "case mk.mk.intro.intro.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na\u271d b\u271d : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\na : Subtype s\n_ha : a \u2208 t\nhx : \u2191(Embedding.subtype s) a \u2208 Finset.map (Embedding.subtype s) t\nb : Subtype s\n_hb : b \u2208 t\nhy : \u2191(Embedding.subtype s) b \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 f { val := \u2191(Embedding.subtype s) a, property := hx } = f { val := \u2191(Embedding.subtype s) b, property := hy } \u2192\n    { val := \u2191(Embedding.subtype s) a, property := hx } = { val := \u2191(Embedding.subtype s) b, property := hy }"}, {"tactic": "simp only [imp_self, Subtype.mk_eq_mk]", "annotated_tactic": ["simp only [<a>imp_self</a>, <a>Subtype.mk_eq_mk</a>]", [{"full_name": "imp_self", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [122, 17], "def_end_pos": [122, 25]}, {"full_name": "Subtype.mk_eq_mk", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [107, 9], "def_end_pos": [107, 17]}]], "state_before": "case mk.mk.intro.intro.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na\u271d b\u271d : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nf : { x // x \u2208 Finset.map (Embedding.subtype s) t } \u2192 \u2191s := fun x => { val := \u2191x, property := (_ : \u2191x \u2208 s) }\na : Subtype s\n_ha : a \u2208 t\nhx : \u2191(Embedding.subtype s) a \u2208 Finset.map (Embedding.subtype s) t\nb : Subtype s\n_hb : b \u2208 t\nhy : \u2191(Embedding.subtype s) b \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 f { val := \u2191(Embedding.subtype s) a, property := hx } = f { val := \u2191(Embedding.subtype s) b, property := hy } \u2192\n    { val := \u2191(Embedding.subtype s) a, property := hx } = { val := \u2191(Embedding.subtype s) b, property := hy }", "state_after": "no goals"}, {"tactic": "obtain \u27e8x, h\u27e9 := x", "annotated_tactic": ["obtain \u27e8x, h\u27e9 := x", []], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nx : { x // x \u2208 Finset.map (Embedding.subtype s) t }\n\u22a2 \u2191x \u2208 s", "state_after": "case mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nx : M\nh : x \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 \u2191{ val := x, property := h } \u2208 s"}, {"tactic": "rw [Finset.mem_map] at h", "annotated_tactic": ["rw [<a>Finset.mem_map</a>] at h", [{"full_name": "Finset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}]], "state_before": "case mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nx : M\nh : x \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 \u2191{ val := x, property := h } \u2208 s", "state_after": "case mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nx : M\nh\u271d : x \u2208 Finset.map (Embedding.subtype s) t\nh : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = x\n\u22a2 \u2191{ val := x, property := h\u271d } \u2208 s"}, {"tactic": "obtain \u27e8a, _ha, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8a, _ha, rfl\u27e9 := h", []], "state_before": "case mk\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx\u271d y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\nx : M\nh\u271d : x \u2208 Finset.map (Embedding.subtype s) t\nh : \u2203 a \u2208 t, \u2191(Embedding.subtype s) a = x\n\u22a2 \u2191{ val := x, property := h\u271d } \u2208 s", "state_after": "case mk.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na\u271d b : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\na : Subtype s\n_ha : a \u2208 t\nh : \u2191(Embedding.subtype s) a \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 \u2191{ val := \u2191(Embedding.subtype s) a, property := h } \u2208 s"}, {"tactic": "simp only [Subtype.coe_prop, Embedding.coe_subtype]", "annotated_tactic": ["simp only [<a>Subtype.coe_prop</a>, <a>Embedding.coe_subtype</a>]", [{"full_name": "Subtype.coe_prop", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [262, 9], "def_end_pos": [262, 17]}, {"full_name": "Function.Embedding.coe_subtype", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [234, 9], "def_end_pos": [234, 20]}]], "state_before": "case mk.intro.intro\n\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na\u271d b : R\nx y : M\ns : Set M\nli : LinearIndependent R Subtype.val\nt : Finset \u2191s\na : Subtype s\n_ha : a \u2208 t\nh : \u2191(Embedding.subtype s) a \u2208 Finset.map (Embedding.subtype s) t\n\u22a2 \u2191{ val := \u2191(Embedding.subtype s) a, property := h } \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "CommGroupWithZero.coe_normUnit", "start": [1436, 1], "end": [1436, 98], "traced_tactics": [{"tactic": "simp [normUnit, h0]", "annotated_tactic": ["simp [<a>normUnit</a>, h0]", [{"full_name": "NormalizationMonoid.normUnit", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [76, 3], "def_end_pos": [76, 11]}]], "state_before": "\u03b1 : Type u_1\nG\u2080 : Type u_2\ninst\u271d\u00b9 : CommGroupWithZero G\u2080\ninst\u271d : DecidableEq G\u2080\na : G\u2080\nh0 : a \u2260 0\n\u22a2 \u2191(normUnit a) = a\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/WF.lean", "full_name": "Acc.rec_eq_recC", "start": [63, 18], "end": [68, 38], "traced_tactics": [{"tactic": "funext \u03b1 r motive intro a t", "annotated_tactic": ["funext \u03b1 r motive intro a t", []], "state_before": "\u22a2 @rec = @Acc.recC", "state_after": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na : \u03b1\nt : Acc r a\n\u22a2 rec intro t = Acc.recC intro t"}, {"tactic": "induction t with\n| intro x h ih =>\n  dsimp only [recC_intro intro h]\n  congr; funext y hr; exact ih _ hr", "annotated_tactic": ["induction t with\n  | <a>intro</a> x h ih =>\n    dsimp only [<a>recC_intro</a> intro h]\n    congr; funext y hr; exact ih _ hr", [{"full_name": "Acc.intro", "def_path": "lake-packages/lean4/src/lean/Init/WF.lean", "def_pos": [13, 5], "def_end_pos": [13, 10]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.WF.0.Acc.recC_intro", "def_path": "lake-packages/std/Std/WF.lean", "def_pos": [56, 17], "def_end_pos": [56, 27]}]], "state_before": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na : \u03b1\nt : Acc r a\n\u22a2 rec intro t = Acc.recC intro t", "state_after": "no goals"}, {"tactic": "dsimp only [recC_intro intro h]", "annotated_tactic": ["dsimp only [<a>recC_intro</a> intro h]", [{"full_name": "_private.\u00ablake-packages\u00bb.std.Std.WF.0.Acc.recC_intro", "def_path": "lake-packages/std/Std/WF.lean", "def_pos": [56, 17], "def_end_pos": [56, 27]}]], "state_before": "case h.h.h.h.h.h.intro\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na x : \u03b1\nh : \u2200 (y : \u03b1), r y x \u2192 Acc r y\nih : \u2200 (y : \u03b1) (a : r y x), rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)\n\u22a2 rec intro (_ : Acc r x) = Acc.recC intro (_ : Acc r x)", "state_after": "case h.h.h.h.h.h.intro\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na x : \u03b1\nh : \u2200 (y : \u03b1), r y x \u2192 Acc r y\nih : \u2200 (y : \u03b1) (a : r y x), rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)\n\u22a2 (intro x h fun y a => rec intro (_ : Acc ?m.2672 y)) = intro x h fun y hr => Acc.recC intro (_ : Acc ?m.2672 y)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case h.h.h.h.h.h.intro\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na x : \u03b1\nh : \u2200 (y : \u03b1), r y x \u2192 Acc r y\nih : \u2200 (y : \u03b1) (a : r y x), rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)\n\u22a2 (intro x h fun y a => rec intro (_ : Acc ?m.2672 y)) = intro x h fun y hr => Acc.recC intro (_ : Acc ?m.2672 y)", "state_after": "case h.h.h.h.h.h.intro.e_h_ih\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na x : \u03b1\nh : \u2200 (y : \u03b1), r y x \u2192 Acc r y\nih : \u2200 (y : \u03b1) (a : r y x), rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)\n\u22a2 (fun y a => rec intro (_ : Acc ?m.2672 y)) = fun y hr => Acc.recC intro (_ : Acc ?m.2672 y)"}, {"tactic": "funext y hr", "annotated_tactic": ["funext y hr", []], "state_before": "case h.h.h.h.h.h.intro.e_h_ih\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na x : \u03b1\nh : \u2200 (y : \u03b1), r y x \u2192 Acc r y\nih : \u2200 (y : \u03b1) (a : r y x), rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)\n\u22a2 (fun y a => rec intro (_ : Acc ?m.2672 y)) = fun y hr => Acc.recC intro (_ : Acc ?m.2672 y)", "state_after": "case h.h.h.h.h.h.intro.e_h_ih.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na x : \u03b1\nh : \u2200 (y : \u03b1), r y x \u2192 Acc r y\nih : \u2200 (y : \u03b1) (a : r y x), rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)\ny : \u03b1\nhr : r y x\n\u22a2 rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)"}, {"tactic": "exact ih _ hr", "annotated_tactic": ["exact ih _ hr", []], "state_before": "case h.h.h.h.h.h.intro.e_h_ih.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nmotive : (a : \u03b1) \u2192 Acc r a \u2192 Sort u_2\nintro :\n  (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 motive y (_ : Acc r y)) \u2192 motive x (_ : Acc r x)\na x : \u03b1\nh : \u2200 (y : \u03b1), r y x \u2192 Acc r y\nih : \u2200 (y : \u03b1) (a : r y x), rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)\ny : \u03b1\nhr : r y x\n\u22a2 rec intro (_ : Acc ?m.2672 y) = Acc.recC intro (_ : Acc ?m.2672 y)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.lawfulMonad", "start": [2099, 11], "end": [2108, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.eq_finite_iUnion_of_finite_subset_iUnion", "start": [1127, 1], "end": [1142, 15], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\n\u22a2 t = \u22c3 i, (fun x => s \u2191x \u2229 t) i", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 x \u2208 t \u2194 x \u2208 \u22c3 i, (fun x => s \u2191x \u2229 t) i"}, {"tactic": "rw [mem_iUnion]", "annotated_tactic": ["rw [<a>mem_iUnion</a>]", [{"full_name": "Set.mem_iUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [201, 9], "def_end_pos": [201, 19]}]], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 x \u2208 t \u2194 x \u2208 \u22c3 i, (fun x => s \u2191x \u2229 t) i", "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 x \u2208 t \u2194 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 x \u2208 t \u2194 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i", "state_after": "case h.mp\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 x \u2208 t \u2192 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i\n\ncase h.mpr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 (\u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i) \u2192 x \u2208 t"}, {"tactic": "intro x_in", "annotated_tactic": ["intro x_in", []], "state_before": "case h.mp\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 x \u2208 t \u2192 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i", "state_after": "case h.mp\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\nx_in : x \u2208 t\n\u22a2 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i"}, {"tactic": "rcases mem_iUnion.mp (hI x_in) with \u27e8i, _, \u27e8hi, rfl\u27e9, H\u27e9", "annotated_tactic": ["rcases mem_iUnion.mp (hI x_in) with \u27e8i, _, \u27e8hi, rfl\u27e9, H\u27e9", []], "state_before": "case h.mp\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\nx_in : x \u2208 t\n\u22a2 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i", "state_after": "case h.mp.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\nx_in : x \u2208 t\ni : \u03b9\nhi : i \u2208 I\nH : x \u2208 (fun h => s i) hi\n\u22a2 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i"}, {"tactic": "refine' \u27e8\u27e8i, hi\u27e9, \u27e8H, x_in\u27e9\u27e9", "annotated_tactic": ["refine' \u27e8\u27e8i, hi\u27e9, \u27e8H, x_in\u27e9\u27e9", []], "state_before": "case h.mp.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\nx_in : x \u2208 t\ni : \u03b9\nhi : i \u2208 I\nH : x \u2208 (fun h => s i) hi\n\u22a2 \u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i", "state_after": "no goals"}, {"tactic": "rintro \u27e8i, -, H\u27e9", "annotated_tactic": ["rintro \u27e8i, -, H\u27e9", []], "state_before": "case h.mpr\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\n\u22a2 (\u2203 i, x \u2208 (fun x => s \u2191x \u2229 t) i) \u2192 x \u2208 t", "state_after": "case h.mpr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\ni : \u2191{i | i \u2208 I}\nH : x \u2208 t\n\u22a2 x \u2208 t"}, {"tactic": "exact H", "annotated_tactic": ["exact H", []], "state_before": "case h.mpr.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9\u271d : Sort w\n\u03b3 : Type x\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ntfin : Set.Finite t\nh : t \u2286 \u22c3 i, s i\nI : Set \u03b9\nIfin : Set.Finite I\nhI : t \u2286 \u22c3 i \u2208 I, s i\nx : \u03b1\ni : \u2191{i | i \u2208 I}\nH : x \u2208 t\n\u22a2 x \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelIso/Basic.lean", "full_name": "RelEmbedding.coe_mk", "start": [273, 1], "end": [274, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "Codisjoint.himp_inf_cancel_right", "start": [442, 1], "end": [443, 63], "traced_tactics": [{"tactic": "rw [himp_inf_distrib, himp_self, top_inf_eq, h.himp_eq_left]", "annotated_tactic": ["rw [<a>himp_inf_distrib</a>, <a>himp_self</a>, <a>top_inf_eq</a>, h.himp_eq_left]", [{"full_name": "himp_inf_distrib", "def_path": "lake-packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [401, 9], "def_end_pos": [401, 25]}, {"full_name": "himp_self", "def_path": "lake-packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [337, 9], "def_end_pos": [337, 18]}, {"full_name": "top_inf_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [474, 9], "def_end_pos": [474, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : GeneralizedHeytingAlgebra \u03b1\na b c d : \u03b1\nh : Codisjoint a b\n\u22a2 a \u21e8 a \u2293 b = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.piCongrRight_trans", "start": [700, 1], "end": [702, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Size.lean", "full_name": "Nat.size_shiftLeft", "start": [108, 1], "end": [109, 85], "traced_tactics": [{"tactic": "simp only [size_shiftLeft' (shiftLeft'_ne_zero_left _ h _), \u2190 shiftLeft'_false]", "annotated_tactic": ["simp only [<a>size_shiftLeft'</a> (<a>shiftLeft'_ne_zero_left</a> _ h _), \u2190 <a>shiftLeft'_false</a>]", [{"full_name": "Nat.size_shiftLeft'", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Size.lean", "def_pos": [88, 9], "def_end_pos": [88, 24]}, {"full_name": "Nat.shiftLeft'_ne_zero_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Size.lean", "def_pos": [41, 9], "def_end_pos": [41, 32]}, {"full_name": "Nat.shiftLeft'_false", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [189, 9], "def_end_pos": [189, 25]}]], "state_before": "m : \u2115\nh : m \u2260 0\nn : \u2115\n\u22a2 size (m <<< n) = size m + n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.zipRight_cons_cons", "start": [4138, 1], "end": [4139, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Subsingleton.lean", "full_name": "Filter.subsingleton_bot", "start": [47, 1], "end": [48, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Log.lean", "full_name": "Nat.log_monotone", "start": [180, 1], "end": [185, 55], "traced_tactics": [{"tactic": "refine' monotone_nat_of_le_succ fun n => _", "annotated_tactic": ["refine' <a>monotone_nat_of_le_succ</a> fun n => _", [{"full_name": "monotone_nat_of_le_succ", "def_path": "lake-packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [1025, 9], "def_end_pos": [1025, 32]}]], "state_before": "b : \u2115\n\u22a2 Monotone (log b)", "state_after": "b n : \u2115\n\u22a2 log b n \u2264 log b (n + 1)"}, {"tactic": "cases' le_or_lt b 1 with hb hb", "annotated_tactic": ["cases' <a>le_or_lt</a> b 1 with hb hb", [{"full_name": "le_or_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}]], "state_before": "b n : \u2115\n\u22a2 log b n \u2264 log b (n + 1)", "state_after": "case inl\nb n : \u2115\nhb : b \u2264 1\n\u22a2 log b n \u2264 log b (n + 1)\n\ncase inr\nb n : \u2115\nhb : 1 < b\n\u22a2 log b n \u2264 log b (n + 1)"}, {"tactic": "rw [log_of_left_le_one hb]", "annotated_tactic": ["rw [<a>log_of_left_le_one</a> hb]", [{"full_name": "Nat.log_of_left_le_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [48, 9], "def_end_pos": [48, 27]}]], "state_before": "case inl\nb n : \u2115\nhb : b \u2264 1\n\u22a2 log b n \u2264 log b (n + 1)", "state_after": "case inl\nb n : \u2115\nhb : b \u2264 1\n\u22a2 0 \u2264 log b (n + 1)"}, {"tactic": "exact zero_le _", "annotated_tactic": ["exact <a>zero_le</a> _", [{"full_name": "Nat.zero_le", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1578, 9], "def_end_pos": [1578, 20]}]], "state_before": "case inl\nb n : \u2115\nhb : b \u2264 1\n\u22a2 0 \u2264 log b (n + 1)", "state_after": "no goals"}, {"tactic": "exact le_log_of_pow_le hb (pow_log_le_add_one _ _)", "annotated_tactic": ["exact <a>le_log_of_pow_le</a> hb (<a>pow_log_le_add_one</a> _ _)", [{"full_name": "Nat.le_log_of_pow_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [113, 9], "def_end_pos": [113, 25]}, {"full_name": "Nat.pow_log_le_add_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [175, 9], "def_end_pos": [175, 27]}]], "state_before": "case inr\nb n : \u2115\nhb : 1 < b\n\u22a2 log b n \u2264 log b (n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/WithBot.lean", "full_name": "Nat.WithBot.add_eq_one_iff", "start": [35, 1], "end": [39, 27], "traced_tactics": [{"tactic": "rcases n, m with \u27e8_ | _, _ | _\u27e9", "annotated_tactic": ["rcases n, m with \u27e8_ | _, _ | _\u27e9", []], "state_before": "n m : WithBot \u2115\n\u22a2 n + m = 1 \u2194 n = 0 \u2227 m = 1 \u2228 n = 1 \u2227 m = 0", "state_after": "case none.none\n\n\u22a2 none + none = 1 \u2194 none = 0 \u2227 none = 1 \u2228 none = 1 \u2227 none = 0\n\ncase none.some\nval\u271d : \u2115\n\u22a2 none + some val\u271d = 1 \u2194 none = 0 \u2227 some val\u271d = 1 \u2228 none = 1 \u2227 some val\u271d = 0\n\ncase some.none\nval\u271d : \u2115\n\u22a2 some val\u271d + none = 1 \u2194 some val\u271d = 0 \u2227 none = 1 \u2228 some val\u271d = 1 \u2227 none = 0\n\ncase some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 some val\u271d\u00b9 + some val\u271d = 1 \u2194 some val\u271d\u00b9 = 0 \u2227 some val\u271d = 1 \u2228 some val\u271d\u00b9 = 1 \u2227 some val\u271d = 0"}, {"tactic": "any_goals refine' \u27e8fun h => Option.noConfusion h, fun h => _\u27e9; aesop", "annotated_tactic": ["any_goals refine' \u27e8fun h => <a>Option.noConfusion</a> h, fun h => _\u27e9; aesop", [{"full_name": "Option.noConfusion", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2154, 11], "def_end_pos": [2154, 17]}]], "state_before": "case none.none\n\n\u22a2 none + none = 1 \u2194 none = 0 \u2227 none = 1 \u2228 none = 1 \u2227 none = 0\n\ncase none.some\nval\u271d : \u2115\n\u22a2 none + some val\u271d = 1 \u2194 none = 0 \u2227 some val\u271d = 1 \u2228 none = 1 \u2227 some val\u271d = 0\n\ncase some.none\nval\u271d : \u2115\n\u22a2 some val\u271d + none = 1 \u2194 some val\u271d = 0 \u2227 none = 1 \u2228 some val\u271d = 1 \u2227 none = 0\n\ncase some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 some val\u271d\u00b9 + some val\u271d = 1 \u2194 some val\u271d\u00b9 = 0 \u2227 some val\u271d = 1 \u2228 some val\u271d\u00b9 = 1 \u2227 some val\u271d = 0", "state_after": "case some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 some val\u271d\u00b9 + some val\u271d = 1 \u2194 some val\u271d\u00b9 = 0 \u2227 some val\u271d = 1 \u2228 some val\u271d\u00b9 = 1 \u2227 some val\u271d = 0"}, {"tactic": "repeat' erw [WithBot.coe_eq_coe]", "annotated_tactic": ["repeat' erw [<a>WithBot.coe_eq_coe</a>]", [{"full_name": "WithBot.coe_eq_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [130, 9], "def_end_pos": [130, 19]}]], "state_before": "case some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 some val\u271d\u00b9 + some val\u271d = 1 \u2194 some val\u271d\u00b9 = 0 \u2227 some val\u271d = 1 \u2228 some val\u271d\u00b9 = 1 \u2227 some val\u271d = 0", "state_after": "case some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 (fun x x_1 => x + x_1) val\u271d\u00b9 val\u271d = 1 \u2194 val\u271d\u00b9 = 0 \u2227 val\u271d = 1 \u2228 val\u271d\u00b9 = 1 \u2227 val\u271d = 0"}, {"tactic": "exact Nat.add_eq_one_iff", "annotated_tactic": ["exact <a>Nat.add_eq_one_iff</a>", [{"full_name": "Nat.add_eq_one_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Order/Basic.lean", "def_pos": [180, 9], "def_end_pos": [180, 23]}]], "state_before": "case some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 (fun x x_1 => x + x_1) val\u271d\u00b9 val\u271d = 1 \u2194 val\u271d\u00b9 = 0 \u2227 val\u271d = 1 \u2228 val\u271d\u00b9 = 1 \u2227 val\u271d = 0", "state_after": "no goals"}, {"tactic": "refine' \u27e8fun h => Option.noConfusion h, fun h => _\u27e9", "annotated_tactic": ["refine' \u27e8fun h => <a>Option.noConfusion</a> h, fun h => _\u27e9", [{"full_name": "Option.noConfusion", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2154, 11], "def_end_pos": [2154, 17]}]], "state_before": "case some.none\nval\u271d : \u2115\n\u22a2 some val\u271d + none = 1 \u2194 some val\u271d = 0 \u2227 none = 1 \u2228 some val\u271d = 1 \u2227 none = 0", "state_after": "case some.none\nval\u271d : \u2115\nh : some val\u271d = 0 \u2227 none = 1 \u2228 some val\u271d = 1 \u2227 none = 0\n\u22a2 some val\u271d + none = 1"}, {"tactic": "aesop", "annotated_tactic": ["aesop", []], "state_before": "case some.none\nval\u271d : \u2115\nh : some val\u271d = 0 \u2227 none = 1 \u2228 some val\u271d = 1 \u2227 none = 0\n\u22a2 some val\u271d + none = 1", "state_after": "no goals"}, {"tactic": "erw [WithBot.coe_eq_coe]", "annotated_tactic": ["erw [<a>WithBot.coe_eq_coe</a>]", [{"full_name": "WithBot.coe_eq_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [130, 9], "def_end_pos": [130, 19]}]], "state_before": "case some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 (fun x x_1 => x + x_1) val\u271d\u00b9 val\u271d = 1 \u2194 val\u271d\u00b9 = 0 \u2227 val\u271d = 1 \u2228 val\u271d\u00b9 = 1 \u2227 some val\u271d = 0", "state_after": "case some.some\nval\u271d\u00b9 val\u271d : \u2115\n\u22a2 (fun x x_1 => x + x_1) val\u271d\u00b9 val\u271d = 1 \u2194 val\u271d\u00b9 = 0 \u2227 val\u271d = 1 \u2228 val\u271d\u00b9 = 1 \u2227 val\u271d = 0"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_congr'", "start": [224, 1], "end": [225, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "posMulMono_iff_posMulStrictMono", "start": [987, 1], "end": [988, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_le_of_le_of_le_one'", "start": [737, 1], "end": [739, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "inv_lt_one_iff", "start": [317, 1], "end": [320, 66], "traced_tactics": [{"tactic": "cases' le_or_lt a 0 with ha ha", "annotated_tactic": ["cases' <a>le_or_lt</a> a 0 with ha ha", [{"full_name": "le_or_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [340, 9], "def_end_pos": [340, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a", "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : a \u2264 0\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a\n\ncase inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a"}, {"tactic": "simp [ha, (inv_nonpos.2 ha).trans_lt zero_lt_one]", "annotated_tactic": ["simp [ha, (<a>inv_nonpos</a>.2 ha).<a>trans_lt</a> <a>zero_lt_one</a>]", [{"full_name": "inv_nonpos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [70, 9], "def_end_pos": [70, 19]}, {"full_name": "LE.le.trans_lt", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [124, 7], "def_end_pos": [124, 21]}, {"full_name": "zero_lt_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : a \u2264 0\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a", "state_after": "no goals"}, {"tactic": "simp only [ha.not_le, false_or_iff, inv_lt_one_iff_of_pos ha]", "annotated_tactic": ["simp only [ha.not_le, <a>false_or_iff</a>, <a>inv_lt_one_iff_of_pos</a> ha]", [{"full_name": "false_or_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [185, 9], "def_end_pos": [185, 21]}, {"full_name": "inv_lt_one_iff_of_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 30]}]], "state_before": "case inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.zero_pow", "start": [768, 1], "end": [768, 91], "traced_tactics": [{"tactic": "simp [pow_succ]", "annotated_tactic": ["simp [<a>pow_succ</a>]", [{"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}]], "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\nb\u271d b : \u2115\nx\u271d : 0 < b + 1\n\u22a2 0 ^ (b + 1) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "le_of_max_le_left", "start": [286, 1], "end": [287, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/Cast/Defs.lean", "full_name": "Rat.cast_id", "start": [172, 1], "end": [172, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.strictMono_map_iff", "start": [1181, 1], "end": [1183, 59], "traced_tactics": [{"tactic": "simp [StrictMono, coe_lt_top]", "annotated_tactic": ["simp [<a>StrictMono</a>, <a>coe_lt_top</a>]", [{"full_name": "StrictMono", "def_path": "lake-packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [97, 5], "def_end_pos": [97, 15]}, {"full_name": "WithTop.coe_lt_top", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [1096, 9], "def_end_pos": [1096, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 ((StrictMono fun a => map f \u2191a) \u2227 \u2200 (x : \u03b1), map f \u2191x < map f \u22a4) \u2194 StrictMono f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "Monotone.le_map_sup", "start": [1102, 1], "end": [1104, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.map_ne_zero_iff", "start": [454, 1], "end": [455, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Pow.lean", "full_name": "Nat.mod_pow_succ", "start": [163, 1], "end": [191, 45], "traced_tactics": [{"tactic": "by_cases b_h : b = 0", "annotated_tactic": ["by_cases b_h : b = 0", []], "state_before": "b w m : \u2115\n\u22a2 m % b ^ succ w = b * (m / b % b ^ w) + m % b", "state_after": "case pos\nb w m : \u2115\nb_h : b = 0\n\u22a2 m % b ^ succ w = b * (m / b % b ^ w) + m % b\n\ncase neg\nb w m : \u2115\nb_h : \u00acb = 0\n\u22a2 m % b ^ succ w = b * (m / b % b ^ w) + m % b"}, {"tactic": "have b_pos := Nat.pos_of_ne_zero b_h", "annotated_tactic": ["have b_pos := <a>Nat.pos_of_ne_zero</a> b_h", [{"full_name": "Nat.pos_of_ne_zero", "def_path": "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "def_pos": [25, 19], "def_end_pos": [25, 33]}]], "state_before": "case neg\nb w m : \u2115\nb_h : \u00acb = 0\n\u22a2 m % b ^ succ w = b * (m / b % b ^ w) + m % b", "state_after": "case neg\nb w m : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\n\u22a2 m % b ^ succ w = b * (m / b % b ^ w) + m % b"}, {"tactic": "simp [b_h, pow_succ]", "annotated_tactic": ["simp [b_h, <a>pow_succ</a>]", [{"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}]], "state_before": "case pos\nb w m : \u2115\nb_h : b = 0\n\u22a2 m % b ^ succ w = b * (m / b % b ^ w) + m % b", "state_after": "no goals"}, {"tactic": "cases' lt_or_ge p (b ^ succ w) with h\u2081 h\u2081", "annotated_tactic": ["cases' <a>lt_or_ge</a> p (b ^ <a>succ</a> w) with h\u2081 h\u2081", [{"full_name": "lt_or_ge", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [344, 9], "def_end_pos": [344, 17]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}]], "state_before": "case neg.h\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inl\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b\n\ncase neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b"}, {"tactic": "have h\u2082 : p / b < b ^ w := by\n  rw [div_lt_iff_lt_mul b_pos]\n  simpa [pow_succ] using h\u2081", "annotated_tactic": ["have h\u2082 : p / b < b ^ w := by\n          rw [<a>div_lt_iff_lt_mul</a> b_pos]\n          simpa [<a>pow_succ</a>] using h\u2081", [{"full_name": "Nat.div_lt_iff_lt_mul", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [794, 9], "def_end_pos": [794, 26]}, {"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}]], "state_before": "case neg.h.inl\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inl\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\nh\u2082 : p / b < b ^ w\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b"}, {"tactic": "rw [mod_eq_of_lt h\u2081, mod_eq_of_lt h\u2082]", "annotated_tactic": ["rw [<a>mod_eq_of_lt</a> h\u2081, <a>mod_eq_of_lt</a> h\u2082]", [{"full_name": "Nat.mod_eq_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [111, 9], "def_end_pos": [111, 21]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [111, 9], "def_end_pos": [111, 21]}]], "state_before": "case neg.h.inl\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\nh\u2082 : p / b < b ^ w\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inl\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\nh\u2082 : p / b < b ^ w\n\u22a2 p = b * (p / b) + p % b"}, {"tactic": "simp [div_add_mod]", "annotated_tactic": ["simp [<a>div_add_mod</a>]", [{"full_name": "Nat.div_add_mod", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [166, 9], "def_end_pos": [166, 20]}]], "state_before": "case neg.h.inl\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\nh\u2082 : p / b < b ^ w\n\u22a2 p = b * (p / b) + p % b", "state_after": "no goals"}, {"tactic": "rw [div_lt_iff_lt_mul b_pos]", "annotated_tactic": ["rw [<a>div_lt_iff_lt_mul</a> b_pos]", [{"full_name": "Nat.div_lt_iff_lt_mul", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [794, 9], "def_end_pos": [794, 26]}]], "state_before": "b w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\n\u22a2 p / b < b ^ w", "state_after": "b w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\n\u22a2 p < b ^ w * b"}, {"tactic": "simpa [pow_succ] using h\u2081", "annotated_tactic": ["simpa [<a>pow_succ</a>] using h\u2081", [{"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}]], "state_before": "b w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p < b ^ succ w\n\u22a2 p < b ^ w * b", "state_after": "no goals"}, {"tactic": "have h\u2082 : p - b ^ succ w < p :=\n  tsub_lt_self ((pow_pos b_pos _).trans_le h\u2081) (pow_pos b_pos _)", "annotated_tactic": ["have h\u2082 : p - b ^ <a>succ</a> w < p :=\n          <a>tsub_lt_self</a> ((<a>pow_pos</a> b_pos _).<a>trans_le</a> h\u2081) (<a>pow_pos</a> b_pos _)", [{"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}, {"full_name": "tsub_lt_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [474, 9], "def_end_pos": [474, 21]}, {"full_name": "pow_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [530, 9], "def_end_pos": [530, 16]}, {"full_name": "LT.lt.trans_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [148, 7], "def_end_pos": [148, 21]}, {"full_name": "pow_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [530, 9], "def_end_pos": [530, 16]}]], "state_before": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\nh\u2082 : p - b ^ succ w < p\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b"}, {"tactic": "rw [mod_eq_sub_mod h\u2081, IH _ h\u2082]", "annotated_tactic": ["rw [<a>mod_eq_sub_mod</a> h\u2081, IH _ h\u2082]", [{"full_name": "Nat.mod_eq_sub_mod", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [117, 9], "def_end_pos": [117, 23]}]], "state_before": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\nh\u2082 : p - b ^ succ w < p\n\u22a2 p % b ^ succ w = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\nh\u2082 : p - b ^ succ w < p\n\u22a2 b * ((p - b ^ succ w) / b % b ^ w) + (p - b ^ succ w) % b = b * (p / b % b ^ w) + p % b"}, {"tactic": "simp only [pow_succ']", "annotated_tactic": ["simp only [<a>pow_succ'</a>]", [{"full_name": "Nat.pow_succ'", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [985, 9], "def_end_pos": [985, 18]}]], "state_before": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\nh\u2082 : p - b ^ succ w < p\n\u22a2 b * ((p - b ^ succ w) / b % b ^ w) + (p - b ^ succ w) % b = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\nh\u2082 : p - b ^ succ w < p\n\u22a2 b * ((p - b * b ^ w) / b % b ^ w) + (p - b * b ^ w) % b = b * (p / b % b ^ w) + p % b"}, {"tactic": "simp only [GE.ge, pow_succ'] at h\u2081", "annotated_tactic": ["simp only [<a>GE.ge</a>, <a>pow_succ'</a>] at h\u2081", [{"full_name": "GE.ge", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1083, 18], "def_end_pos": [1083, 23]}, {"full_name": "Nat.pow_succ'", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [985, 9], "def_end_pos": [985, 18]}]], "state_before": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2081 : p \u2265 b ^ succ w\nh\u2082 : p - b ^ succ w < p\n\u22a2 b * ((p - b * b ^ w) / b % b ^ w) + (p - b * b ^ w) % b = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\n\u22a2 b * ((p - b * b ^ w) / b % b ^ w) + (p - b * b ^ w) % b = b * (p / b % b ^ w) + p % b"}, {"tactic": "rw [sub_mul_mod h\u2081, sub_mul_div _ _ _ h\u2081]", "annotated_tactic": ["rw [<a>sub_mul_mod</a> h\u2081, <a>sub_mul_div</a> _ _ _ h\u2081]", [{"full_name": "Nat.sub_mul_mod", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [951, 9], "def_end_pos": [951, 20]}, {"full_name": "Nat.sub_mul_div", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [797, 9], "def_end_pos": [797, 20]}]], "state_before": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\n\u22a2 b * ((p - b * b ^ w) / b % b ^ w) + (p - b * b ^ w) % b = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\n\u22a2 b * ((p / b - b ^ w) % b ^ w) + p % b = b * (p / b % b ^ w) + p % b"}, {"tactic": "have p_b_ge : b ^ w \u2264 p / b := by\n  rw [le_div_iff_mul_le b_pos, mul_comm]\n  exact h\u2081", "annotated_tactic": ["have p_b_ge : b ^ w \u2264 p / b := by\n          rw [<a>le_div_iff_mul_le</a> b_pos, <a>mul_comm</a>]\n          exact h\u2081", [{"full_name": "Nat.le_div_iff_mul_le", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [764, 9], "def_end_pos": [764, 26]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\n\u22a2 b * ((p / b - b ^ w) % b ^ w) + p % b = b * (p / b % b ^ w) + p % b", "state_after": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\np_b_ge : b ^ w \u2264 p / b\n\u22a2 b * ((p / b - b ^ w) % b ^ w) + p % b = b * (p / b % b ^ w) + p % b"}, {"tactic": "rw [Eq.symm (mod_eq_sub_mod p_b_ge)]", "annotated_tactic": ["rw [<a>Eq.symm</a> (<a>mod_eq_sub_mod</a> p_b_ge)]", [{"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}, {"full_name": "Nat.mod_eq_sub_mod", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [117, 9], "def_end_pos": [117, 23]}]], "state_before": "case neg.h.inr\nb w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\np_b_ge : b ^ w \u2264 p / b\n\u22a2 b * ((p / b - b ^ w) % b ^ w) + p % b = b * (p / b % b ^ w) + p % b", "state_after": "no goals"}, {"tactic": "rw [le_div_iff_mul_le b_pos, mul_comm]", "annotated_tactic": ["rw [<a>le_div_iff_mul_le</a> b_pos, <a>mul_comm</a>]", [{"full_name": "Nat.le_div_iff_mul_le", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [764, 9], "def_end_pos": [764, 26]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "b w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\n\u22a2 b ^ w \u2264 p / b", "state_after": "b w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\n\u22a2 b * b ^ w \u2264 p"}, {"tactic": "exact h\u2081", "annotated_tactic": ["exact h\u2081", []], "state_before": "b w : \u2115\nb_h : \u00acb = 0\nb_pos : 0 < b\np : \u2115\nIH : \u2200 m < p, m % b ^ succ w = b * (m / b % b ^ w) + m % b\nh\u2082 : p - b ^ succ w < p\nh\u2081 : b * b ^ w \u2264 p\n\u22a2 b * b ^ w \u2264 p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.preimage_Ico", "start": [392, 1], "end": [394, 26], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\n\u22a2 Nat.cast \u207b\u00b9' Ico a b = Ico \u2308a\u2309\u208a \u2308b\u2309\u208a", "state_after": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ico a b \u2194 x\u271d \u2208 Ico \u2308a\u2309\u208a \u2308b\u2309\u208a"}, {"tactic": "simp [ceil_le, lt_ceil]", "annotated_tactic": ["simp [<a>ceil_le</a>, <a>lt_ceil</a>]", [{"full_name": "Nat.ceil_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [278, 9], "def_end_pos": [278, 16]}, {"full_name": "Nat.lt_ceil", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [282, 9], "def_end_pos": [282, 16]}]], "state_before": "case h\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedSemiring \u03b1\ninst\u271d : FloorSemiring \u03b1\na\u271d : \u03b1\nn : \u2115\na b : \u03b1\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ico a b \u2194 x\u271d \u2208 Ico \u2308a\u2309\u208a \u2308b\u2309\u208a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.lcm_one_right", "start": [473, 1], "end": [475, 26], "traced_tactics": [{"tactic": "rw [Int.lcm]", "annotated_tactic": ["rw [<a>Int.lcm</a>]", [{"full_name": "Int.lcm", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/GCD.lean", "def_pos": [235, 5], "def_end_pos": [235, 8]}]], "state_before": "i : \u2124\n\u22a2 lcm i 1 = natAbs i", "state_after": "i : \u2124\n\u22a2 Nat.lcm (natAbs i) (natAbs 1) = natAbs i"}, {"tactic": "apply Nat.lcm_one_right", "annotated_tactic": ["apply <a>Nat.lcm_one_right</a>", [{"full_name": "Nat.lcm_one_right", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [205, 17], "def_end_pos": [205, 30]}]], "state_before": "i : \u2124\n\u22a2 Nat.lcm (natAbs i) (natAbs 1) = natAbs i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.pow_mem_of_mem", "start": [570, 1], "end": [572, 71], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\na b : \u03b1\ninst\u271d : CommSemiring \u03b1\nI : Ideal \u03b1\nha : a \u2208 I\nn : \u2115\nhn : 0 < n\n\u22a2 \u00ac0 < Nat.zero", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.indexOf_nil", "start": [1088, 1], "end": [1089, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "orderOf_submonoid", "start": [347, 1], "end": [348, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.coprime_iff_gcd_eq_one", "start": [255, 1], "end": [255, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.zero_eq_bot", "start": [420, 1], "end": [421, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.le_def", "start": [554, 1], "end": [554, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "odd_iff_exists_bit1", "start": [338, 1], "end": [341, 8], "traced_tactics": [{"tactic": "rw [two_mul]", "annotated_tactic": ["rw [<a>two_mul</a>]", [{"full_name": "two_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [177, 9], "def_end_pos": [177, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n a b : \u03b1\n\u22a2 a = 2 * b + 1 \u2194 a = bit1 b", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n a b : \u03b1\n\u22a2 a = b + b + 1 \u2194 a = bit1 b"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n a b : \u03b1\n\u22a2 a = b + b + 1 \u2194 a = bit1 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.div_mul_cancel_of_mod_eq_zero", "start": [590, 1], "end": [591, 53], "traced_tactics": [{"tactic": "rw [Int.mul_comm, mul_div_cancel_of_mod_eq_zero H]", "annotated_tactic": ["rw [<a>Int.mul_comm</a>, <a>mul_div_cancel_of_mod_eq_zero</a> H]", [{"full_name": "Int.mul_comm", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [380, 19], "def_end_pos": [380, 27]}, {"full_name": "Int.mul_div_cancel_of_mod_eq_zero", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [587, 9], "def_end_pos": [587, 38]}]], "state_before": "a b : Int\nH : mod a b = 0\n\u22a2 div a b * b = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "full_name": "iInf\u2082_sup_eq", "start": [322, 1], "end": [323, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.mem_closure", "start": [1108, 1], "end": [1109, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "le_iInf_comp", "start": [1059, 1], "end": [1060, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.refl_symm", "start": [380, 1], "end": [381, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/AlgebraMap.lean", "full_name": "Polynomial.ofFinsupp_algebraMap", "start": [67, 1], "end": [68, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/FractionRing.lean", "full_name": "IsFractionRing.to_map_eq_zero_iff", "start": [79, 1], "end": [80, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.comapSubtypeEquivOfLe_apply_coe", "start": [501, 1], "end": [504, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MulHom.coe_coe", "start": [320, 1], "end": [320, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Control/EquivFunctor.lean", "full_name": "EquivFunctor.mapEquiv_symm_apply", "start": [65, 1], "end": [66, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioi_inter_Ioi", "start": [1796, 1], "end": [1797, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.toFinset_union", "start": [258, 11], "end": [261, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\na : \u03b1\nhs\u271d : Set.Finite s\nht\u271d : Set.Finite t\ninst\u271d : DecidableEq \u03b1\nhs : Set.Finite s\nht : Set.Finite t\nh : Set.Finite (s \u222a t)\n\u22a2 Finite.toFinset h = Finite.toFinset hs \u222a Finite.toFinset ht", "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\na : \u03b1\nhs\u271d : Set.Finite s\nht\u271d : Set.Finite t\ninst\u271d : DecidableEq \u03b1\nhs : Set.Finite s\nht : Set.Finite t\nh : Set.Finite (s \u222a t)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 Finite.toFinset h \u2194 a\u271d \u2208 Finite.toFinset hs \u222a Finite.toFinset ht"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\na : \u03b1\nhs\u271d : Set.Finite s\nht\u271d : Set.Finite t\ninst\u271d : DecidableEq \u03b1\nhs : Set.Finite s\nht : Set.Finite t\nh : Set.Finite (s \u222a t)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 Finite.toFinset h \u2194 a\u271d \u2208 Finite.toFinset hs \u222a Finite.toFinset ht", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidHom.congr_fun", "start": [692, 1], "end": [693, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/GaloisConnection.lean", "full_name": "GaloisConnection.l_le", "start": [91, 1], "end": [92, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Option/Basic.lean", "full_name": "Option.seq_some", "start": [277, 1], "end": [278, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isLUB_Iio", "start": [593, 1], "end": [594, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.pos_of_dvd_of_pos", "start": [1122, 1], "end": [1123, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.some_lt_none", "start": [1101, 1], "end": [1102, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_lt_mul_of_pos_of_pos", "start": [238, 1], "end": [240, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.prod_mono", "start": [1963, 1], "end": [1963, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WellFoundedSet.lean", "full_name": "Set.isPwo_of_finite", "start": [476, 9], "end": [476, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.sigmaCongrRight_sigmaEquivProd", "start": [811, 1], "end": [815, 7], "traced_tactics": [{"tactic": "ext \u27e8a, b\u27e9 : 1", "annotated_tactic": ["ext \u27e8a, b\u27e9 : 1", []], "state_before": "\u03b1\u2081 : Type u_1\n\u03b2\u2081 : Type u_2\n\u03b2\u2082 : Type u_3\ne : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\n\u22a2 (sigmaCongrRight e).trans (sigmaEquivProd \u03b1\u2081 \u03b2\u2082) = (sigmaEquivProd \u03b1\u2081 \u03b2\u2081).trans (prodCongrRight e)", "state_after": "case H.mk\n\u03b1\u2081 : Type u_1\n\u03b2\u2081 : Type u_2\n\u03b2\u2082 : Type u_3\ne : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\na : \u03b1\u2081\nb : \u03b2\u2081\n\u22a2 \u2191((sigmaCongrRight e).trans (sigmaEquivProd \u03b1\u2081 \u03b2\u2082)) { fst := a, snd := b } =\n    \u2191((sigmaEquivProd \u03b1\u2081 \u03b2\u2081).trans (prodCongrRight e)) { fst := a, snd := b }"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case H.mk\n\u03b1\u2081 : Type u_1\n\u03b2\u2081 : Type u_2\n\u03b2\u2082 : Type u_3\ne : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\na : \u03b1\u2081\nb : \u03b2\u2081\n\u22a2 \u2191((sigmaCongrRight e).trans (sigmaEquivProd \u03b1\u2081 \u03b2\u2082)) { fst := a, snd := b } =\n    \u2191((sigmaEquivProd \u03b1\u2081 \u03b2\u2081).trans (prodCongrRight e)) { fst := a, snd := b }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply", "start": [996, 1], "end": [999, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.mem_diff_of_mem", "start": [1816, 1], "end": [1817, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.reverse_eq_iff", "start": [599, 1], "end": [600, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "Subtype.strictMono_coe", "start": [1176, 1], "end": [1178, 15], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.ringEquivOfRingEquiv_eq", "start": [708, 1], "end": [710, 7], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\ninst\u271d\u2077 : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u2076 : CommSemiring S\ninst\u271d\u2075 : Algebra R S\nP : Type u_3\ninst\u271d\u2074 : CommSemiring P\ninst\u271d\u00b3 : IsLocalization M S\ng : R \u2192+* P\nhg : \u2200 (y : \u21a5M), IsUnit (\u2191g \u2191y)\nT : Submonoid P\nQ : Type u_4\ninst\u271d\u00b2 : CommSemiring Q\nhy : M \u2264 Submonoid.comap g T\ninst\u271d\u00b9 : Algebra P Q\ninst\u271d : IsLocalization T Q\nj : R \u2243+* P\nH : Submonoid.map (RingEquiv.toMonoidHom j) M = T\nx : R\n\u22a2 \u2191(ringEquivOfRingEquiv S Q j H) (\u2191(algebraMap R S) x) = \u2191(algebraMap P Q) (\u2191j x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "Even.pow_pos", "start": [518, 1], "end": [519, 72], "traced_tactics": [{"tactic": "cases' hn with k hk", "annotated_tactic": ["cases' hn with k hk", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : LinearOrderedRing R\na : R\nn : \u2115\nhn : Even n\nha : a \u2260 0\n\u22a2 0 < a ^ n", "state_after": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : LinearOrderedRing R\na : R\nn : \u2115\nha : a \u2260 0\nk : \u2115\nhk : n = k + k\n\u22a2 0 < a ^ n"}, {"tactic": "simpa only [hk, two_mul] using pow_bit0_pos ha k", "annotated_tactic": ["simpa only [hk, <a>two_mul</a>] using <a>pow_bit0_pos</a> ha k", [{"full_name": "two_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [177, 9], "def_end_pos": [177, 16]}, {"full_name": "pow_bit0_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [307, 9], "def_end_pos": [307, 21]}]], "state_before": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : LinearOrderedRing R\na : R\nn : \u2115\nha : a \u2260 0\nk : \u2115\nhk : n = k + k\n\u22a2 0 < a ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.IsPeriodicPt.left_of_comp", "start": [153, 1], "end": [156, 28], "traced_tactics": [{"tactic": "rw [IsPeriodicPt, hco.comp_iterate] at hfg", "annotated_tactic": ["rw [<a>IsPeriodicPt</a>, hco.comp_iterate] at hfg", [{"full_name": "Function.IsPeriodicPt", "def_path": "lake-packages/mathlib/Mathlib/Dynamics/PeriodicPts.lean", "def_pos": [56, 5], "def_end_pos": [56, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\ng : \u03b1 \u2192 \u03b1\nhco : Function.Commute f g\nhfg : IsPeriodicPt (f \u2218 g) n x\nhg : IsPeriodicPt g n x\n\u22a2 IsPeriodicPt f n x", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\ng : \u03b1 \u2192 \u03b1\nhco : Function.Commute f g\nhfg : IsFixedPt (f^[n] \u2218 g^[n]) x\nhg : IsPeriodicPt g n x\n\u22a2 IsPeriodicPt f n x"}, {"tactic": "exact hfg.left_of_comp hg", "annotated_tactic": ["exact hfg.left_of_comp hg", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\ng : \u03b1 \u2192 \u03b1\nhco : Function.Commute f g\nhfg : IsFixedPt (f^[n] \u2218 g^[n]) x\nhg : IsPeriodicPt g n x\n\u22a2 IsPeriodicPt f n x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/NonUnitalHom.lean", "full_name": "NonUnitalAlgHom.zero_apply", "start": [282, 1], "end": [283, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Factors.lean", "full_name": "Nat.factors_zero", "start": [43, 1], "end": [43, 57], "traced_tactics": [{"tactic": "rw [factors]", "annotated_tactic": ["rw [<a>factors</a>]", [{"full_name": "Nat.factors", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factors.lean", "def_pos": [33, 5], "def_end_pos": [33, 12]}]], "state_before": "\u22a2 factors 0 = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean", "full_name": "DFinsupp.toFinsupp_neg", "start": [196, 1], "end": [198, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "mul_mem_nonunits_right", "start": [833, 1], "end": [834, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Function.Embedding.invOfMemRange_surjective", "start": [561, 1], "end": [562, 41], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\nb : \u2191(Set.range \u2191f)\na : \u03b1\n\u22a2 invOfMemRange f { val := \u2191f a, property := (_ : \u2191f a \u2208 Set.range \u2191f) } = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Iterate.lean", "full_name": "Function.iterate_succ'", "start": [186, 1], "end": [187, 56], "traced_tactics": [{"tactic": "rw [iterate_succ, (Commute.self_iterate f n).comp_eq]", "annotated_tactic": ["rw [<a>iterate_succ</a>, (<a>Commute.self_iterate</a> f n).<a>comp_eq</a>]", [{"full_name": "Function.iterate_succ", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [62, 9], "def_end_pos": [62, 21]}, {"full_name": "Function.Commute.self_iterate", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Iterate.lean", "def_pos": [169, 9], "def_end_pos": [169, 21]}, {"full_name": "Function.Semiconj.comp_eq", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Conjugate.lean", "def_pos": [39, 19], "def_end_pos": [39, 26]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b1\nn : \u2115\n\u22a2 f^[Nat.succ n] = f \u2218 f^[n]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.ite_univ", "start": [2296, 1], "end": [2296, 77], "traced_tactics": [{"tactic": "simp [Set.ite]", "annotated_tactic": ["simp [<a>Set.ite</a>]", [{"full_name": "Set.ite", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2254, 15], "def_end_pos": [2254, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns\u271d s\u2081 s\u2082 t t\u2081 t\u2082 u s s' : Set \u03b1\n\u22a2 Set.ite univ s s' = s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.sameCycle_zpow_left", "start": [169, 1], "end": [170, 84], "traced_tactics": [{"tactic": "simp [SameCycle, zpow_add]", "annotated_tactic": ["simp [<a>SameCycle</a>, <a>zpow_add</a>]", [{"full_name": "Equiv.Perm.SameCycle", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "def_pos": [73, 5], "def_end_pos": [73, 14]}, {"full_name": "zpow_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [215, 9], "def_end_pos": [215, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\np : \u03b1 \u2192 Prop\nx y z : \u03b1\nn : \u2124\n\u22a2 (\u2203 b, \u2191(f ^ \u2191(Equiv.addRight n).symm b) (\u2191(f ^ n) x) = y) \u2194 SameCycle f x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Cast/Basic.lean", "full_name": "eq_natCast'", "start": [92, 1], "end": [94, 71], "traced_tactics": [{"tactic": "simp [map_zero f]", "annotated_tactic": ["simp [<a>map_zero</a> f]", [{"full_name": "map_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [201, 3], "def_end_pos": [201, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nA : Type u_3\nB : Type u_4\nF : Type u_5\ninst\u271d\u00b2 : AddMonoidWithOne B\ninst\u271d\u00b9 : AddMonoidWithOne A\ninst\u271d : AddMonoidHomClass F \u2115 A\nf : F\nh1 : \u2191f 1 = 1\n\u22a2 \u2191f 0 = \u21910", "state_after": "no goals"}, {"tactic": "rw [map_add, h1, eq_natCast' f h1 n, Nat.cast_add_one]", "annotated_tactic": ["rw [<a>map_add</a>, h1, eq_natCast' f h1 n, <a>Nat.cast_add_one</a>]", [{"full_name": "map_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [298, 3], "def_end_pos": [298, 14]}, {"full_name": "Nat.cast_add_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [132, 9], "def_end_pos": [132, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nA : Type u_3\nB : Type u_4\nF : Type u_5\ninst\u271d\u00b2 : AddMonoidWithOne B\ninst\u271d\u00b9 : AddMonoidWithOne A\ninst\u271d : AddMonoidHomClass F \u2115 A\nf : F\nh1 : \u2191f 1 = 1\nn : \u2115\n\u22a2 \u2191f (n + 1) = \u2191(n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Finset.eq_univ_of_forall", "start": [84, 1], "end": [85, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.power_lt_aleph0", "start": [1601, 1], "end": [1603, 75], "traced_tactics": [{"tactic": "rw [\u2190 natCast_pow]", "annotated_tactic": ["rw [\u2190 <a>natCast_pow</a>]", [{"full_name": "Cardinal.natCast_pow", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1349, 9], "def_end_pos": [1349, 20]}]], "state_before": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u_1}\nm n : \u2115\nha : \u2191m < \u2135\u2080\nhb : \u2191n < \u2135\u2080\n\u22a2 \u2191m ^ \u2191n < \u2135\u2080", "state_after": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u_1}\nm n : \u2115\nha : \u2191m < \u2135\u2080\nhb : \u2191n < \u2135\u2080\n\u22a2 \u2191(m ^ n) < \u2135\u2080"}, {"tactic": "apply nat_lt_aleph0", "annotated_tactic": ["apply <a>nat_lt_aleph0</a>", [{"full_name": "Cardinal.nat_lt_aleph0", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1414, 9], "def_end_pos": [1414, 22]}]], "state_before": "\u03b1 \u03b2 : Type u\na b : Cardinal.{u_1}\nm n : \u2115\nha : \u2191m < \u2135\u2080\nhb : \u2191n < \u2135\u2080\n\u22a2 \u2191(m ^ n) < \u2135\u2080", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Max.lean", "full_name": "IsMax.eq_of_le", "start": [393, 11], "end": [394, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/NonUnitalHom.lean", "full_name": "NonUnitalAlgHom.coe_mulHom_mk", "start": [230, 1], "end": [232, 6], "traced_tactics": [{"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u\nA : Type v\nB : Type w\nC : Type w\u2081\ninst\u271d\u2076 : Monoid R\ninst\u271d\u2075 : NonUnitalNonAssocSemiring A\ninst\u271d\u2074 : DistribMulAction R A\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring B\ninst\u271d\u00b2 : DistribMulAction R B\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring C\ninst\u271d : DistribMulAction R C\nf : A \u2192\u2099\u2090[R] B\nh\u2081 : \u2200 (m : R) (x : A), \u2191f (m \u2022 x) = m \u2022 \u2191f x\nh\u2082 : MulActionHom.toFun { toFun := \u2191f, map_smul' := h\u2081 } 0 = 0\nh\u2083 :\n  \u2200 (x y : A),\n    MulActionHom.toFun { toFun := \u2191f, map_smul' := h\u2081 } (x + y) =\n      MulActionHom.toFun { toFun := \u2191f, map_smul' := h\u2081 } x + MulActionHom.toFun { toFun := \u2191f, map_smul' := h\u2081 } y\nh\u2084 :\n  \u2200 (x y : A),\n    MulActionHom.toFun\n        { toMulActionHom := { toFun := \u2191f, map_smul' := h\u2081 }, map_zero' := h\u2082, map_add' := h\u2083 }.toMulActionHom (x * y) =\n      MulActionHom.toFun\n          { toMulActionHom := { toFun := \u2191f, map_smul' := h\u2081 }, map_zero' := h\u2082, map_add' := h\u2083 }.toMulActionHom x *\n        MulActionHom.toFun\n          { toMulActionHom := { toFun := \u2191f, map_smul' := h\u2081 }, map_zero' := h\u2082, map_add' := h\u2083 }.toMulActionHom y\n\u22a2 \u2191{ toDistribMulActionHom := { toMulActionHom := { toFun := \u2191f, map_smul' := h\u2081 }, map_zero' := h\u2082, map_add' := h\u2083 },\n        map_mul' := h\u2084 } =\n    { toFun := \u2191f, map_mul' := h\u2084 }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "mul_lt_mul'", "start": [525, 1], "end": [526, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Regular/Basic.lean", "full_name": "mul_isRightRegular_iff", "start": [152, 1], "end": [154, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/LocallyFinite.lean", "full_name": "Finset.uIcc_subset_uIcc_left", "start": [994, 1], "end": [995, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.max_val", "start": [251, 1], "end": [251, 59], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n m : \u2115\na : Fin n\n\u22a2 max (\u2191a) n = n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Defs.lean", "full_name": "inv_eq_of_mul_eq_one_left", "start": [1062, 1], "end": [1063, 50], "traced_tactics": [{"tactic": "rw [\u2190 inv_eq_of_mul_eq_one_right h, inv_inv]", "annotated_tactic": ["rw [\u2190 <a>inv_eq_of_mul_eq_one_right</a> h, <a>inv_inv</a>]", [{"full_name": "inv_eq_of_mul_eq_one_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1056, 9], "def_end_pos": [1056, 35]}, {"full_name": "inv_inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [800, 9], "def_end_pos": [800, 16]}]], "state_before": "G : Type u_1\ninst\u271d : DivisionMonoid G\na b : G\nh : a * b = 1\n\u22a2 b\u207b\u00b9 = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.disjoint_compl_right_iff_subset", "start": [1767, 1], "end": [1768, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds", "start": [1515, 1], "end": [1517, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_def", "start": [47, 1], "end": [48, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.Nonempty.div", "start": [597, 1], "end": [598, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "full_name": "Set.one_mem_centralizer", "start": [56, 1], "end": [57, 29], "traced_tactics": [{"tactic": "simp [mem_centralizer_iff]", "annotated_tactic": ["simp [<a>mem_centralizer_iff</a>]", [{"full_name": "Set.mem_centralizer_iff", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "def_pos": [42, 9], "def_end_pos": [42, 28]}]], "state_before": "M : Type u_1\nS T : Set M\ninst\u271d : MulOneClass M\n\u22a2 1 \u2208 centralizer S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/Basic.lean", "full_name": "Real.cauchy_add", "start": [149, 1], "end": [150, 58], "traced_tactics": [{"tactic": "rw [add_def]", "annotated_tactic": ["rw [<a>add_def</a>]", [{"full_name": "_private.\u00ablake-packages\u00bb.mathlib.Mathlib.Data.Real.Basic.0.Real.add_def", "def_path": "lake-packages/mathlib/Mathlib/Data/Real/Basic.lean", "def_pos": [1, 1], "def_end_pos": [1, 1]}]], "state_before": "x y : \u211d\na b : Cauchy abs\n\u22a2 (Real.add { cauchy := a } { cauchy := b }).cauchy = { cauchy := a }.cauchy + { cauchy := b }.cauchy", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.fract_one", "start": [965, 1], "end": [965, 57], "traced_tactics": [{"tactic": "simp [fract]", "annotated_tactic": ["simp [<a>fract</a>]", [{"full_name": "Int.fract", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [635, 5], "def_end_pos": [635, 10]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\n\u22a2 fract 1 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.image\u2082_left", "start": [355, 1], "end": [358, 24], "traced_tactics": [{"tactic": "push_cast", "annotated_tactic": ["push_cast", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b1\nh : Finset.Nonempty t\n\u22a2 \u2191(image\u2082 (fun x x_1 => x) s t) = \u2191s", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b1\nh : Finset.Nonempty t\n\u22a2 image2 (fun x x_1 => x) \u2191s \u2191t = \u2191s"}, {"tactic": "exact image2_left h", "annotated_tactic": ["exact <a>image2_left</a> h", [{"full_name": "Set.image2_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [305, 9], "def_end_pos": [305, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b1\nh : Finset.Nonempty t\n\u22a2 image2 (fun x x_1 => x) \u2191s \u2191t = \u2191s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Classical.some_spec\u2082", "start": [990, 1], "end": [991, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "TensorProduct.rid_tmul", "start": [715, 1], "end": [716, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.mem_filter", "start": [1278, 1], "end": [1284, 54], "traced_tactics": [{"tactic": "simp [filter]", "annotated_tactic": ["simp [<a>filter</a>]", [{"full_name": "List.filter", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [227, 5], "def_end_pos": [227, 11]}]], "state_before": "case nil\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\np : \u03b1\u271d \u2192 Bool\n\u22a2 x \u2208 filter p [] \u2194 x \u2208 [] \u2227 p x = true", "state_after": "no goals"}, {"tactic": "by_cases h : p a <;> simp [*, or_and_right]", "annotated_tactic": ["by_cases h : p a <;> simp [*, <a>or_and_right</a>]", [{"full_name": "or_and_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [331, 9], "def_end_pos": [331, 21]}]], "state_before": "case cons\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\np : \u03b1\u271d \u2192 Bool\na : \u03b1\u271d\nas : List \u03b1\u271d\nih : x \u2208 filter p as \u2194 x \u2208 as \u2227 p x = true\n\u22a2 x \u2208 filter p (a :: as) \u2194 x \u2208 a :: as \u2227 p x = true", "state_after": "case pos\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\np : \u03b1\u271d \u2192 Bool\na : \u03b1\u271d\nas : List \u03b1\u271d\nih : x \u2208 filter p as \u2194 x \u2208 as \u2227 p x = true\nh : p a = true\n\u22a2 x = a \u2228 x \u2208 as \u2227 p x = true \u2194 x = a \u2227 p x = true \u2228 x \u2208 as \u2227 p x = true\n\ncase neg\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\np : \u03b1\u271d \u2192 Bool\na : \u03b1\u271d\nas : List \u03b1\u271d\nih : x \u2208 filter p as \u2194 x \u2208 as \u2227 p x = true\nh : \u00acp a = true\n\u22a2 x \u2208 as \u2227 p x = true \u2194 x = a \u2227 p x = true \u2228 x \u2208 as \u2227 p x = true"}, {"tactic": "exact or_congr_left (and_iff_left_of_imp fun | rfl => h).symm", "annotated_tactic": ["exact <a>or_congr_left</a> (<a>and_iff_left_of_imp</a> fun | <a>rfl</a> => h).<a>symm</a>", [{"full_name": "or_congr_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [263, 9], "def_end_pos": [263, 22]}, {"full_name": "and_iff_left_of_imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [201, 9], "def_end_pos": [201, 28]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "Iff.symm", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [671, 9], "def_end_pos": [671, 17]}]], "state_before": "case pos\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\np : \u03b1\u271d \u2192 Bool\na : \u03b1\u271d\nas : List \u03b1\u271d\nih : x \u2208 filter p as \u2194 x \u2208 as \u2227 p x = true\nh : p a = true\n\u22a2 x = a \u2228 x \u2208 as \u2227 p x = true \u2194 x = a \u2227 p x = true \u2228 x \u2208 as \u2227 p x = true", "state_after": "no goals"}, {"tactic": "exact (or_iff_right fun \u27e8rfl, h'\u27e9 => h h').symm", "annotated_tactic": ["exact (<a>or_iff_right</a> fun \u27e8<a>rfl</a>, h'\u27e9 => h h').<a>symm</a>", [{"full_name": "or_iff_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [309, 9], "def_end_pos": [309, 21]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "Iff.symm", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [671, 9], "def_end_pos": [671, 17]}]], "state_before": "case neg\n\u03b1\u271d : Type u_1\nx : \u03b1\u271d\np : \u03b1\u271d \u2192 Bool\na : \u03b1\u271d\nas : List \u03b1\u271d\nih : x \u2208 filter p as \u2194 x \u2208 as \u2227 p x = true\nh : \u00acp a = true\n\u22a2 x \u2208 as \u2227 p x = true \u2194 x = a \u2227 p x = true \u2228 x \u2208 as \u2227 p x = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/List/Instances.lean", "full_name": "List.bind_singleton'", "start": [26, 9], "end": [27, 27], "traced_tactics": [{"tactic": "induction l <;> simp [*]", "annotated_tactic": ["induction l <;> simp [*]", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl : List \u03b1\n\u22a2 (List.bind l fun x => [x]) = l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Int.addRight_one_isCycle", "start": [1869, 1], "end": [1870, 44], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : DecidableEq \u03b1\nn : \u2124\nx\u271d : \u2191(Equiv.addRight 1) n \u2260 n\n\u22a2 \u2191(Equiv.addRight 1 ^ n) 0 = n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.comap_abs_atTop", "start": [993, 1], "end": [1000, 34], "traced_tactics": [{"tactic": "refine'\n  le_antisymm (((atTop_basis.comap _).le_basis_iff (atBot_basis.sup atTop_basis)).2 _)\n    (sup_le tendsto_abs_atBot_atTop.le_comap tendsto_abs_atTop_atTop.le_comap)", "annotated_tactic": ["refine'\n    <a>le_antisymm</a> (((atTop_basis.comap _).<a>le_basis_iff</a> (atBot_basis.sup <a>atTop_basis</a>)).2 _)\n      (<a>sup_le</a> tendsto_abs_atBot_atTop.le_comap tendsto_abs_atTop_atTop.le_comap)", [{"full_name": "le_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}, {"full_name": "Filter.HasBasis.le_basis_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [463, 9], "def_end_pos": [463, 30]}, {"full_name": "Filter.atTop_basis", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [135, 9], "def_end_pos": [135, 20]}, {"full_name": "sup_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [167, 9], "def_end_pos": [167, 15]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\n\u22a2 comap abs atTop = atBot \u2294 atTop", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\n\u22a2 \u2200 (i' : \u03b1 \u00d7 \u03b1), True \u2227 True \u2192 \u2203 i, True \u2227 abs \u207b\u00b9' Ici i \u2286 Iic i'.1 \u222a Ici i'.2"}, {"tactic": "rintro \u27e8a, b\u27e9 -", "annotated_tactic": ["rintro \u27e8a, b\u27e9 -", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\n\u22a2 \u2200 (i' : \u03b1 \u00d7 \u03b1), True \u2227 True \u2192 \u2203 i, True \u2227 abs \u207b\u00b9' Ici i \u2286 Iic i'.1 \u222a Ici i'.2", "state_after": "case mk\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b : \u03b1\n\u22a2 \u2203 i, True \u2227 abs \u207b\u00b9' Ici i \u2286 Iic (a, b).1 \u222a Ici (a, b).2"}, {"tactic": "refine' \u27e8max (-a) b, trivial, fun x hx => _\u27e9", "annotated_tactic": ["refine' \u27e8<a>max</a> (-a) b, <a>trivial</a>, fun x hx => _\u27e9", [{"full_name": "Max.max", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1090, 3], "def_end_pos": [1090, 6]}, {"full_name": "trivial", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [514, 31], "def_end_pos": [514, 38]}]], "state_before": "case mk\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b : \u03b1\n\u22a2 \u2203 i, True \u2227 abs \u207b\u00b9' Ici i \u2286 Iic (a, b).1 \u222a Ici (a, b).2", "state_after": "case mk\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b x : \u03b1\nhx : x \u2208 abs \u207b\u00b9' Ici (max (-a) b)\n\u22a2 x \u2208 Iic (a, b).1 \u222a Ici (a, b).2"}, {"tactic": "rw [mem_preimage, mem_Ici, le_abs', max_le_iff, \u2190 min_neg_neg, le_min_iff, neg_neg] at hx", "annotated_tactic": ["rw [<a>mem_preimage</a>, <a>mem_Ici</a>, <a>le_abs'</a>, <a>max_le_iff</a>, \u2190 <a>min_neg_neg</a>, <a>le_min_iff</a>, <a>neg_neg</a>] at hx", [{"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Set.mem_Ici", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [146, 9], "def_end_pos": [146, 16]}, {"full_name": "le_abs'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [237, 9], "def_end_pos": [237, 16]}, {"full_name": "max_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [48, 9], "def_end_pos": [48, 19]}, {"full_name": "min_neg_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/MinMax.lean", "def_pos": [35, 15], "def_end_pos": [35, 26]}, {"full_name": "le_min_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [33, 9], "def_end_pos": [33, 19]}, {"full_name": "neg_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [799, 3], "def_end_pos": [799, 14]}]], "state_before": "case mk\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b x : \u03b1\nhx : x \u2208 abs \u207b\u00b9' Ici (max (-a) b)\n\u22a2 x \u2208 Iic (a, b).1 \u222a Ici (a, b).2", "state_after": "case mk\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b x : \u03b1\nhx : x \u2264 a \u2227 x \u2264 -b \u2228 -a \u2264 x \u2227 b \u2264 x\n\u22a2 x \u2208 Iic (a, b).1 \u222a Ici (a, b).2"}, {"tactic": "exact hx.imp And.left And.right", "annotated_tactic": ["exact hx.imp <a>And.left</a> <a>And.right</a>", [{"full_name": "And.left", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [504, 3], "def_end_pos": [504, 7]}, {"full_name": "And.right", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [507, 3], "def_end_pos": [507, 8]}]], "state_before": "case mk\n\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : LinearOrderedAddCommGroup \u03b1\na b x : \u03b1\nhx : x \u2264 a \u2227 x \u2264 -b \u2228 -a \u2264 x \u2227 b \u2264 x\n\u22a2 x \u2208 Iic (a, b).1 \u222a Ici (a, b).2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/IndicatorFunction.lean", "full_name": "Set.mulIndicator_inv'", "start": [534, 1], "end": [535, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "full_name": "Set.ordConnected_pi", "start": [144, 1], "end": [146, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.pow_subset_pow_of_one_mem", "start": [895, 1], "end": [900, 50], "traced_tactics": [{"tactic": "apply Nat.le_induction", "annotated_tactic": ["apply <a>Nat.le_induction</a>", [{"full_name": "Nat.le_induction", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [502, 9], "def_end_pos": [502, 21]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n : \u2115\nhs : 1 \u2208 s\n\u22a2 m \u2264 n \u2192 s ^ m \u2286 s ^ n", "state_after": "case base\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n : \u2115\nhs : 1 \u2208 s\n\u22a2 s ^ m \u2286 s ^ m\n\ncase succ\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n : \u2115\nhs : 1 \u2208 s\n\u22a2 \u2200 (n : \u2115), m \u2264 n \u2192 s ^ m \u2286 s ^ n \u2192 s ^ m \u2286 s ^ (n + 1)"}, {"tactic": "exact fun _ hn => hn", "annotated_tactic": ["exact fun _ hn => hn", []], "state_before": "case base\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n : \u2115\nhs : 1 \u2208 s\n\u22a2 s ^ m \u2286 s ^ m", "state_after": "no goals"}, {"tactic": "intro n _ hmn", "annotated_tactic": ["intro n _ hmn", []], "state_before": "case succ\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n : \u2115\nhs : 1 \u2208 s\n\u22a2 \u2200 (n : \u2115), m \u2264 n \u2192 s ^ m \u2286 s ^ n \u2192 s ^ m \u2286 s ^ (n + 1)", "state_after": "case succ\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n\u271d : \u2115\nhs : 1 \u2208 s\nn : \u2115\nhn\u271d : m \u2264 n\nhmn : s ^ m \u2286 s ^ n\n\u22a2 s ^ m \u2286 s ^ (n + 1)"}, {"tactic": "rw [pow_succ]", "annotated_tactic": ["rw [<a>pow_succ</a>]", [{"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}]], "state_before": "case succ\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n\u271d : \u2115\nhs : 1 \u2208 s\nn : \u2115\nhn\u271d : m \u2264 n\nhmn : s ^ m \u2286 s ^ n\n\u22a2 s ^ m \u2286 s ^ (n + 1)", "state_after": "case succ\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n\u271d : \u2115\nhs : 1 \u2208 s\nn : \u2115\nhn\u271d : m \u2264 n\nhmn : s ^ m \u2286 s ^ n\n\u22a2 s ^ m \u2286 s * s ^ n"}, {"tactic": "exact hmn.trans (subset_mul_right (s ^ n) hs)", "annotated_tactic": ["exact hmn.trans (<a>subset_mul_right</a> (s ^ n) hs)", [{"full_name": "Finset.subset_mul_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Pointwise.lean", "def_pos": [798, 9], "def_end_pos": [798, 25]}]], "state_before": "case succ\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b2\ninst\u271d : Monoid \u03b1\ns t : Finset \u03b1\na : \u03b1\nm n\u271d : \u2115\nhs : 1 \u2208 s\nn : \u2115\nhn\u271d : m \u2264 n\nhmn : s ^ m \u2286 s ^ n\n\u22a2 s ^ m \u2286 s * s ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Basic.lean", "full_name": "Equiv.Perm.sigmaCongrRight_one", "start": [254, 1], "end": [256, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.offDiag_insert", "start": [729, 1], "end": [733, 14], "traced_tactics": [{"tactic": "rw [insert_eq, union_comm, offDiag_union, offDiag_singleton, union_empty, union_right_comm]", "annotated_tactic": ["rw [<a>insert_eq</a>, <a>union_comm</a>, <a>offDiag_union</a>, <a>offDiag_singleton</a>, <a>union_empty</a>, <a>union_right_comm</a>]", [{"full_name": "Set.insert_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1303, 9], "def_end_pos": [1303, 18]}, {"full_name": "Set.union_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [779, 9], "def_end_pos": [779, 19]}, {"full_name": "Set.offDiag_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [714, 9], "def_end_pos": [714, 22]}, {"full_name": "Set.offDiag_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [688, 9], "def_end_pos": [688, 26]}, {"full_name": "Set.union_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [770, 9], "def_end_pos": [770, 20]}, {"full_name": "Set.union_right_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [799, 9], "def_end_pos": [799, 25]}]], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 offDiag (insert a s) = offDiag s \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}", "state_after": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}"}, {"tactic": "rw [disjoint_left]", "annotated_tactic": ["rw [<a>disjoint_left</a>]", [{"full_name": "Set.disjoint_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1539, 9], "def_end_pos": [1539, 22]}]], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}", "state_after": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a_1 \u2209 {a}"}, {"tactic": "rintro b hb (rfl : b = a)", "annotated_tactic": ["rintro b hb (rfl : b = a)", []], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a_1 \u2209 {a}", "state_after": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\nb : \u03b1\nhb : b \u2208 s\nha : b \u2209 s\n\u22a2 False"}, {"tactic": "exact ha hb", "annotated_tactic": ["exact ha hb", []], "state_before": "\u03b1 : Type u_1\ns t : Set \u03b1\nx : \u03b1 \u00d7 \u03b1\nb : \u03b1\nhb : b \u2208 s\nha : b \u2209 s\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.ne_and_not_mem_of_not_mem_cons", "start": [98, 1], "end": [99, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.mem_span_singleton'", "start": [170, 1], "end": [171, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.pred_succ", "start": [962, 1], "end": [963, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/ULift.lean", "full_name": "ULift.up_inj", "start": [110, 1], "end": [111, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.dvd_iff_modByMonic_eq_zero", "start": [409, 1], "end": [423, 77], "traced_tactics": [{"tactic": "rw [\u2190 modByMonic_add_div p hq, h, zero_add]", "annotated_tactic": ["rw [\u2190 <a>modByMonic_add_div</a> p hq, h, <a>zero_add</a>]", [{"full_name": "Polynomial.modByMonic_add_div", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [273, 9], "def_end_pos": [273, 27]}, {"full_name": "zero_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [463, 3], "def_end_pos": [463, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : p %\u2098 q = 0\n\u22a2 q \u2223 p", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : p %\u2098 q = 0\n\u22a2 q \u2223 q * (p /\u2098 q)"}, {"tactic": "exact dvd_mul_right _ _", "annotated_tactic": ["exact <a>dvd_mul_right</a> _ _", [{"full_name": "dvd_mul_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [82, 9], "def_end_pos": [82, 22]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : p %\u2098 q = 0\n\u22a2 q \u2223 q * (p /\u2098 q)", "state_after": "no goals"}, {"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u22a2 p %\u2098 q = 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\n\u22a2 p %\u2098 q = 0"}, {"tactic": "obtain \u27e8r, hr\u27e9 := exists_eq_mul_right_of_dvd h", "annotated_tactic": ["obtain \u27e8r, hr\u27e9 := <a>exists_eq_mul_right_of_dvd</a> h", [{"full_name": "exists_eq_mul_right_of_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [55, 9], "def_end_pos": [55, 35]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\n\u22a2 p %\u2098 q = 0", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\n\u22a2 p %\u2098 q = 0"}, {"tactic": "by_contra hpq0", "annotated_tactic": ["by_contra hpq0", []], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\n\u22a2 p %\u2098 q = 0", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\n\u22a2 False"}, {"tactic": "have hmod : p %\u2098 q = q * (r - p /\u2098 q) := by rw [modByMonic_eq_sub_mul_div _ hq, mul_sub, \u2190 hr]", "annotated_tactic": ["have hmod : p %\u2098 q = q * (r - p /\u2098 q) := by rw [<a>modByMonic_eq_sub_mul_div</a> _ hq, <a>mul_sub</a>, \u2190 hr]", [{"full_name": "Polynomial.modByMonic_eq_sub_mul_div", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [251, 9], "def_end_pos": [251, 34]}, {"full_name": "mul_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [365, 7], "def_end_pos": [365, 14]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\n\u22a2 False"}, {"tactic": "have : degree (q * (r - p /\u2098 q)) < degree q := hmod \u25b8 degree_modByMonic_lt _ hq", "annotated_tactic": ["have : <a>degree</a> (q * (r - p /\u2098 q)) < <a>degree</a> q := hmod \u25b8 <a>degree_modByMonic_lt</a> _ hq", [{"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.degree_modByMonic_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [140, 9], "def_end_pos": [140, 29]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\n\u22a2 False"}, {"tactic": "have hrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0 := fun h =>\n  hpq0 <|\n    leadingCoeff_eq_zero.1\n      (by rw [hmod, leadingCoeff_eq_zero.1 h, mul_zero, leadingCoeff_zero])", "annotated_tactic": ["have hrpq0 : <a>leadingCoeff</a> (r - p /\u2098 q) \u2260 0 := fun h =>\n      hpq0 <|\n        <a>leadingCoeff_eq_zero</a>.1\n          (by rw [hmod, <a>leadingCoeff_eq_zero</a>.1 h, <a>mul_zero</a>, <a>leadingCoeff_zero</a>])", [{"full_name": "Polynomial.leadingCoeff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [70, 5], "def_end_pos": [70, 17]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [670, 9], "def_end_pos": [670, 29]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [670, 9], "def_end_pos": [670, 29]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}, {"full_name": "Polynomial.leadingCoeff_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [665, 9], "def_end_pos": [665, 26]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\nhrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0\n\u22a2 False"}, {"tactic": "have hlc : leadingCoeff q * leadingCoeff (r - p /\u2098 q) \u2260 0 := by rwa [Monic.def.1 hq, one_mul]", "annotated_tactic": ["have hlc : <a>leadingCoeff</a> q * <a>leadingCoeff</a> (r - p /\u2098 q) \u2260 0 := by rwa [<a>Monic.def</a>.1 hq, <a>one_mul</a>]", [{"full_name": "Polynomial.leadingCoeff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [70, 5], "def_end_pos": [70, 17]}, {"full_name": "Polynomial.leadingCoeff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [70, 5], "def_end_pos": [70, 17]}, {"full_name": "Polynomial.Monic.def", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [84, 9], "def_end_pos": [84, 18]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\nhrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\nhrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0\nhlc : leadingCoeff q * leadingCoeff (r - p /\u2098 q) \u2260 0\n\u22a2 False"}, {"tactic": "rw [degree_mul' hlc, degree_eq_natDegree hq.ne_zero,\n  degree_eq_natDegree (mt leadingCoeff_eq_zero.2 hrpq0)] at this", "annotated_tactic": ["rw [<a>degree_mul'</a> hlc, <a>degree_eq_natDegree</a> hq.ne_zero,\n      <a>degree_eq_natDegree</a> (<a>mt</a> <a>leadingCoeff_eq_zero</a>.2 hrpq0)] at this", [{"full_name": "Polynomial.degree_mul'", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [950, 9], "def_end_pos": [950, 20]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [130, 9], "def_end_pos": [130, 28]}, {"full_name": "Polynomial.degree_eq_natDegree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [130, 9], "def_end_pos": [130, 28]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [670, 9], "def_end_pos": [670, 29]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\nhrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0\nhlc : leadingCoeff q * leadingCoeff (r - p /\u2098 q) \u2260 0\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : \u2191(natDegree q) + \u2191(natDegree (r - p /\u2098 q)) < \u2191(natDegree q)\nhrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0\nhlc : leadingCoeff q * leadingCoeff (r - p /\u2098 q) \u2260 0\n\u22a2 False"}, {"tactic": "exact not_lt_of_ge (Nat.le_add_right _ _) (WithBot.some_lt_some.1 this)", "annotated_tactic": ["exact <a>not_lt_of_ge</a> (<a>Nat.le_add_right</a> _ _) (<a>WithBot.some_lt_some</a>.1 this)", [{"full_name": "not_lt_of_ge", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [152, 9], "def_end_pos": [152, 21]}, {"full_name": "Nat.le_add_right", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 21]}, {"full_name": "WithBot.some_lt_some", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [275, 9], "def_end_pos": [275, 21]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : \u2191(natDegree q) + \u2191(natDegree (r - p /\u2098 q)) < \u2191(natDegree q)\nhrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0\nhlc : leadingCoeff q * leadingCoeff (r - p /\u2098 q) \u2260 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [modByMonic_eq_sub_mul_div _ hq, mul_sub, \u2190 hr]", "annotated_tactic": ["rw [<a>modByMonic_eq_sub_mul_div</a> _ hq, <a>mul_sub</a>, \u2190 hr]", [{"full_name": "Polynomial.modByMonic_eq_sub_mul_div", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [251, 9], "def_end_pos": [251, 34]}, {"full_name": "mul_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [365, 7], "def_end_pos": [365, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\n\u22a2 p %\u2098 q = q * (r - p /\u2098 q)", "state_after": "no goals"}, {"tactic": "rw [hmod, leadingCoeff_eq_zero.1 h, mul_zero, leadingCoeff_zero]", "annotated_tactic": ["rw [hmod, <a>leadingCoeff_eq_zero</a>.1 h, <a>mul_zero</a>, <a>leadingCoeff_zero</a>]", [{"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [670, 9], "def_end_pos": [670, 29]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}, {"full_name": "Polynomial.leadingCoeff_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [665, 9], "def_end_pos": [665, 26]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh\u271d : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\nh : leadingCoeff (r - p /\u2098 q) = 0\n\u22a2 leadingCoeff (p %\u2098 q) = 0", "state_after": "no goals"}, {"tactic": "rwa [Monic.def.1 hq, one_mul]", "annotated_tactic": ["rwa [<a>Monic.def</a>.1 hq, <a>one_mul</a>]", [{"full_name": "Polynomial.Monic.def", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [84, 9], "def_end_pos": [84, 18]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nhq : Monic q\nh : q \u2223 p\n\u271d : Nontrivial R\nr : R[X]\nhr : p = q * r\nhpq0 : \u00acp %\u2098 q = 0\nhmod : p %\u2098 q = q * (r - p /\u2098 q)\nthis : degree (q * (r - p /\u2098 q)) < degree q\nhrpq0 : leadingCoeff (r - p /\u2098 q) \u2260 0\n\u22a2 leadingCoeff q * leadingCoeff (r - p /\u2098 q) \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "InfHom.id_comp", "start": [609, 9], "end": [609, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Submonoid/Centralizer.lean", "full_name": "Submonoid.mem_centralizer_iff", "start": [61, 1], "end": [62, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Basis.mem_ideal_iff'", "start": [2068, 1], "end": [2070, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Zip.lean", "full_name": "List.map_prod_left_eq_zip", "start": [198, 1], "end": [202, 17], "traced_tactics": [{"tactic": "rw [\u2190 zip_map']", "annotated_tactic": ["rw [\u2190 <a>zip_map'</a>]", [{"full_name": "List.zip_map'", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Zip.lean", "def_pos": [105, 9], "def_end_pos": [105, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => (x, f x)) l = zip l (map f l)", "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 zip (map (fun x => x) l) (map (fun x => f x) l) = zip l (map f l)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 zip (map (fun x => x) l) (map (fun x => f x) l) = zip l (map f l)", "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l"}, {"tactic": "exact map_id _", "annotated_tactic": ["exact <a>map_id</a> _", [{"full_name": "List.map_id", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [104, 17], "def_end_pos": [104, 23]}]], "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.bijective", "start": [551, 11], "end": [552, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_le_tsub_iff_right", "start": [43, 1], "end": [44, 50], "traced_tactics": [{"tactic": "rw [tsub_le_iff_right, tsub_add_cancel_of_le h]", "annotated_tactic": ["rw [<a>tsub_le_iff_right</a>, <a>tsub_add_cancel_of_le</a> h]", [{"full_name": "tsub_le_iff_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [65, 9], "def_end_pos": [65, 26]}, {"full_name": "tsub_add_cancel_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : c \u2264 b\n\u22a2 a - c \u2264 b - c \u2194 a \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Basic.lean", "full_name": "eq_zero_of_mul_eq_self_left", "start": [214, 1], "end": [215, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.ext", "start": [122, 8], "end": [122, 87], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Cast/Order.lean", "full_name": "NeZero.nat_of_injective", "start": [145, 1], "end": [147, 84], "traced_tactics": [{"tactic": "simpa only [map_natCast, map_zero f]", "annotated_tactic": ["simpa only [<a>map_natCast</a>, <a>map_zero</a> f]", [{"full_name": "map_natCast", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [136, 9], "def_end_pos": [136, 20]}, {"full_name": "map_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [201, 3], "def_end_pos": [201, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\nS : Type u_4\nF : Type u_5\ninst\u271d\u00b2 : NonAssocSemiring R\ninst\u271d\u00b9 : NonAssocSemiring S\nn : \u2115\nh\u271d : NeZero \u2191n\ninst\u271d : RingHomClass F R S\nf : F\nhf : Function.Injective \u2191f\nh : \u2191n = 0\n\u22a2 \u2191f \u2191n = \u2191f 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.perm_comm", "start": [64, 1], "end": [65, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean", "full_name": "Finset.prod_Ico_succ_top", "start": [50, 1], "end": [52, 85], "traced_tactics": [{"tactic": "rw [Nat.Ico_succ_right_eq_insert_Ico hab, prod_insert right_not_mem_Ico, mul_comm]", "annotated_tactic": ["rw [<a>Nat.Ico_succ_right_eq_insert_Ico</a> hab, <a>prod_insert</a> <a>right_not_mem_Ico</a>, <a>mul_comm</a>]", [{"full_name": "Nat.Ico_succ_right_eq_insert_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [215, 9], "def_end_pos": [215, 37]}, {"full_name": "Finset.prod_insert", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [319, 9], "def_end_pos": [319, 20]}, {"full_name": "Finset.right_not_mem_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/LocallyFinite.lean", "def_pos": [163, 9], "def_end_pos": [163, 26]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u2082 s\u2081 s : Finset \u03b1\na\u271d : \u03b1\ng f\u271d : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\na b : \u2115\nhab : a \u2264 b\nf : \u2115 \u2192 \u03b2\n\u22a2 \u220f k in Ico a (b + 1), f k = (\u220f k in Ico a b, f k) * f b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get?_zero", "start": [639, 1], "end": [639, 74], "traced_tactics": [{"tactic": "cases l <;> rfl", "annotated_tactic": ["cases l <;> rfl", []], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 get? l 0 = head? l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean", "full_name": "add_tsub_cancel_right", "start": [356, 1], "end": [357, 55], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.empty_or_exists_mem", "start": [279, 1], "end": [280, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Perm.drop_inter", "start": [1160, 1], "end": [1178, 28], "traced_tactics": [{"tactic": "by_cases h'' : n \u2264 xs.length", "annotated_tactic": ["by_cases h'' : n \u2264 xs.length", []], "state_before": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\n\u22a2 drop n xs ~ List.inter ys (drop n xs)\n\ncase neg\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\n\u22a2 drop n xs ~ List.inter ys (drop n xs)"}, {"tactic": "let n' := xs.length - n", "annotated_tactic": ["let n' := xs.length - n", []], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\n\u22a2 drop n xs ~ List.inter ys (drop n xs)"}, {"tactic": "have h\u2080 : n = xs.length - n' := by\n  rwa [tsub_tsub_cancel_of_le]", "annotated_tactic": ["have h\u2080 : n = xs.length - n' := by\n      rwa [<a>tsub_tsub_cancel_of_le</a>]", [{"full_name": "tsub_tsub_cancel_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [295, 9], "def_end_pos": [295, 31]}]], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\n\u22a2 drop n xs ~ List.inter ys (drop n xs)"}, {"tactic": "have h\u2081 : n' \u2264 xs.length := by apply tsub_le_self", "annotated_tactic": ["have h\u2081 : n' \u2264 xs.length := by apply <a>tsub_le_self</a>", [{"full_name": "tsub_le_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [337, 9], "def_end_pos": [337, 21]}]], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\n\u22a2 drop n xs ~ List.inter ys (drop n xs)"}, {"tactic": "have h\u2082 : xs.drop n = (xs.reverse.take n').reverse := by\n  rw [reverse_take _ h\u2081, h\u2080, reverse_reverse]", "annotated_tactic": ["have h\u2082 : xs.drop n = (xs.reverse.take n').<a>reverse</a> := by\n      rw [<a>reverse_take</a> _ h\u2081, h\u2080, <a>reverse_reverse</a>]", [{"full_name": "List.reverse", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [54, 5], "def_end_pos": [54, 12]}, {"full_name": "List.reverse_take", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [2228, 9], "def_end_pos": [2228, 21]}, {"full_name": "List.reverse_reverse", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [67, 17], "def_end_pos": [67, 32]}]], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 drop n xs ~ List.inter ys (drop n xs)"}, {"tactic": "rw [h\u2082]", "annotated_tactic": ["rw [h\u2082]", []], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 reverse (take n' (reverse xs)) ~ List.inter ys (reverse (take n' (reverse xs)))"}, {"tactic": "apply (reverse_perm _).trans", "annotated_tactic": ["apply (<a>reverse_perm</a> _).<a>trans</a>", [{"full_name": "List.reverse_perm", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [179, 9], "def_end_pos": [179, 21]}, {"full_name": "List.Perm.trans", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [39, 5], "def_end_pos": [39, 10]}]], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 reverse (take n' (reverse xs)) ~ List.inter ys (reverse (take n' (reverse xs)))", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 take n' (reverse xs) ~ List.inter ys (reverse (take n' (reverse xs)))"}, {"tactic": "rw [inter_reverse]", "annotated_tactic": ["rw [<a>inter_reverse</a>]", [{"full_name": "List.inter_reverse", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Lattice.lean", "def_pos": [185, 9], "def_end_pos": [185, 22]}]], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 take n' (reverse xs) ~ List.inter ys (reverse (take n' (reverse xs)))", "state_after": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 take n' (reverse xs) ~ List.inter ys (take n' (reverse xs))"}, {"tactic": "apply Perm.take_inter _ _ h'", "annotated_tactic": ["apply <a>Perm.take_inter</a> _ _ h'", [{"full_name": "List.Perm.take_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [1152, 9], "def_end_pos": [1152, 24]}]], "state_before": "case pos\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 take n' (reverse xs) ~ List.inter ys (take n' (reverse xs))", "state_after": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 reverse xs ~ ys"}, {"tactic": "apply (reverse_perm _).trans", "annotated_tactic": ["apply (<a>reverse_perm</a> _).<a>trans</a>", [{"full_name": "List.reverse_perm", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [179, 9], "def_end_pos": [179, 21]}, {"full_name": "List.Perm.trans", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [39, 5], "def_end_pos": [39, 10]}]], "state_before": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 reverse xs ~ ys", "state_after": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 xs ~ ys"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\nh\u2082 : drop n xs = reverse (take n' (reverse xs))\n\u22a2 xs ~ ys", "state_after": "no goals"}, {"tactic": "rwa [tsub_tsub_cancel_of_le]", "annotated_tactic": ["rwa [<a>tsub_tsub_cancel_of_le</a>]", [{"full_name": "tsub_tsub_cancel_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [295, 9], "def_end_pos": [295, 31]}]], "state_before": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\n\u22a2 n = length xs - n'", "state_after": "no goals"}, {"tactic": "apply tsub_le_self", "annotated_tactic": ["apply <a>tsub_le_self</a>", [{"full_name": "tsub_le_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [337, 9], "def_end_pos": [337, 21]}]], "state_before": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\n\u22a2 n' \u2264 length xs", "state_after": "no goals"}, {"tactic": "rw [reverse_take _ h\u2081, h\u2080, reverse_reverse]", "annotated_tactic": ["rw [<a>reverse_take</a> _ h\u2081, h\u2080, <a>reverse_reverse</a>]", [{"full_name": "List.reverse_take", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [2228, 9], "def_end_pos": [2228, 21]}, {"full_name": "List.reverse_reverse", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [67, 17], "def_end_pos": [67, 32]}]], "state_before": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : n \u2264 length xs\nn' : \u2115 := length xs - n\nh\u2080 : n = length xs - n'\nh\u2081 : n' \u2264 length xs\n\u22a2 drop n xs = reverse (take n' (reverse xs))", "state_after": "no goals"}, {"tactic": "have : drop n xs = [] := by\n  apply eq_nil_of_length_eq_zero\n  rw [length_drop, tsub_eq_zero_iff_le]\n  apply le_of_not_ge h''", "annotated_tactic": ["have : <a>drop</a> n xs = [] := by\n      apply <a>eq_nil_of_length_eq_zero</a>\n      rw [<a>length_drop</a>, <a>tsub_eq_zero_iff_le</a>]\n      apply <a>le_of_not_ge</a> h''", [{"full_name": "List.drop", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [475, 5], "def_end_pos": [475, 9]}, {"full_name": "List.eq_nil_of_length_eq_zero", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [48, 9], "def_end_pos": [48, 33]}, {"full_name": "List.length_drop", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [166, 17], "def_end_pos": [166, 28]}, {"full_name": "tsub_eq_zero_iff_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [324, 9], "def_end_pos": [324, 28]}, {"full_name": "le_of_not_ge", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [299, 9], "def_end_pos": [299, 21]}]], "state_before": "case neg\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "case neg\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\nthis : drop n xs = []\n\u22a2 drop n xs ~ List.inter ys (drop n xs)"}, {"tactic": "simp [this, List.inter]", "annotated_tactic": ["simp [this, <a>List.inter</a>]", [{"full_name": "List.inter", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [433, 25], "def_end_pos": [433, 30]}]], "state_before": "case neg\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\nthis : drop n xs = []\n\u22a2 drop n xs ~ List.inter ys (drop n xs)", "state_after": "no goals"}, {"tactic": "apply eq_nil_of_length_eq_zero", "annotated_tactic": ["apply <a>eq_nil_of_length_eq_zero</a>", [{"full_name": "List.eq_nil_of_length_eq_zero", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [48, 9], "def_end_pos": [48, 33]}]], "state_before": "\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\n\u22a2 drop n xs = []", "state_after": "case x\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\n\u22a2 length (drop n xs) = 0"}, {"tactic": "rw [length_drop, tsub_eq_zero_iff_le]", "annotated_tactic": ["rw [<a>length_drop</a>, <a>tsub_eq_zero_iff_le</a>]", [{"full_name": "List.length_drop", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [166, 17], "def_end_pos": [166, 28]}, {"full_name": "tsub_eq_zero_iff_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [324, 9], "def_end_pos": [324, 28]}]], "state_before": "case x\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\n\u22a2 length (drop n xs) = 0", "state_after": "case x\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\n\u22a2 length xs \u2264 n"}, {"tactic": "apply le_of_not_ge h''", "annotated_tactic": ["apply <a>le_of_not_ge</a> h''", [{"full_name": "le_of_not_ge", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [299, 9], "def_end_pos": [299, 21]}]], "state_before": "case x\n\u03b1\u271d : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\u271d\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs ys : List \u03b1\nn : \u2115\nh : xs ~ ys\nh' : Nodup ys\nh'' : \u00acn \u2264 length xs\n\u22a2 length xs \u2264 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "not_isMin_top", "start": [208, 1], "end": [210, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Variables.lean", "full_name": "MvPolynomial.eval\u2082Hom_congr'", "start": [823, 1], "end": [839, 21], "traced_tactics": [{"tactic": "rintro rfl h rfl", "annotated_tactic": ["rintro rfl h rfl", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 f\u2082 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 p\u2082 : MvPolynomial \u03c3 R\n\u22a2 f\u2081 = f\u2082 \u2192 (\u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2082 \u2192 g\u2081 i = g\u2082 i) \u2192 p\u2081 = p\u2082 \u2192 \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081 = \u2191(eval\u2082Hom f\u2082 g\u2082) p\u2082", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081 = \u2191(eval\u2082Hom f\u2081 g\u2082) p\u2081"}, {"tactic": "rw [p\u2081.as_sum]", "annotated_tactic": ["rw [p\u2081.as_sum]", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081 = \u2191(eval\u2082Hom f\u2081 g\u2082) p\u2081", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 \u2191(eval\u2082Hom f\u2081 g\u2081) (\u2211 v in support p\u2081, \u2191(monomial v) (coeff v p\u2081)) =\n    \u2191(eval\u2082Hom f\u2081 g\u2082) (\u2211 v in support p\u2081, \u2191(monomial v) (coeff v p\u2081))"}, {"tactic": "simp only [map_sum, eval\u2082Hom_monomial]", "annotated_tactic": ["simp only [<a>map_sum</a>, <a>eval\u2082Hom_monomial</a>]", [{"full_name": "map_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [204, 3], "def_end_pos": [204, 14]}, {"full_name": "MvPolynomial.eval\u2082Hom_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1088, 9], "def_end_pos": [1088, 26]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 \u2191(eval\u2082Hom f\u2081 g\u2081) (\u2211 v in support p\u2081, \u2191(monomial v) (coeff v p\u2081)) =\n    \u2191(eval\u2082Hom f\u2081 g\u2082) (\u2211 v in support p\u2081, \u2191(monomial v) (coeff v p\u2081))", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 (\u2211 x in support p\u2081, \u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2081 i ^ k) =\n    \u2211 x in support p\u2081, \u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2082 i ^ k"}, {"tactic": "apply Finset.sum_congr rfl", "annotated_tactic": ["apply <a>Finset.sum_congr</a> <a>rfl</a>", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 (\u2211 x in support p\u2081, \u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2081 i ^ k) =\n    \u2211 x in support p\u2081, \u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2082 i ^ k", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 \u2200 x \u2208 support p\u2081,\n    (\u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2081 i ^ k) = \u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2082 i ^ k"}, {"tactic": "intro d hd", "annotated_tactic": ["intro d hd", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\n\u22a2 \u2200 x \u2208 support p\u2081,\n    (\u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2081 i ^ k) = \u2191f\u2081 (coeff x p\u2081) * Finsupp.prod x fun i k => g\u2082 i ^ k", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 (\u2191f\u2081 (coeff d p\u2081) * Finsupp.prod d fun i k => g\u2081 i ^ k) = \u2191f\u2081 (coeff d p\u2081) * Finsupp.prod d fun i k => g\u2082 i ^ k"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 (\u2191f\u2081 (coeff d p\u2081) * Finsupp.prod d fun i k => g\u2081 i ^ k) = \u2191f\u2081 (coeff d p\u2081) * Finsupp.prod d fun i k => g\u2082 i ^ k", "state_after": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 (Finsupp.prod d fun i k => g\u2081 i ^ k) = Finsupp.prod d fun i k => g\u2082 i ^ k"}, {"tactic": "simp only [Finsupp.prod]", "annotated_tactic": ["simp only [<a>Finsupp.prod</a>]", [{"full_name": "Finsupp.prod", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [52, 5], "def_end_pos": [52, 9]}]], "state_before": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 (Finsupp.prod d fun i k => g\u2081 i ^ k) = Finsupp.prod d fun i k => g\u2082 i ^ k", "state_after": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 \u220f x in d.support, g\u2081 x ^ \u2191d x = \u220f x in d.support, g\u2082 x ^ \u2191d x"}, {"tactic": "apply Finset.prod_congr rfl", "annotated_tactic": ["apply <a>Finset.prod_congr</a> <a>rfl</a>", [{"full_name": "Finset.prod_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [383, 9], "def_end_pos": [383, 19]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 \u220f x in d.support, g\u2081 x ^ \u2191d x = \u220f x in d.support, g\u2082 x ^ \u2191d x", "state_after": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 \u2200 x \u2208 d.support, g\u2081 x ^ \u2191d x = g\u2082 x ^ \u2191d x"}, {"tactic": "intro i hi", "annotated_tactic": ["intro i hi", []], "state_before": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\n\u22a2 \u2200 x \u2208 d.support, g\u2081 x ^ \u2191d x = g\u2082 x ^ \u2191d x", "state_after": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\ni : \u03c3\nhi : i \u2208 d.support\n\u22a2 g\u2081 i ^ \u2191d i = g\u2082 i ^ \u2191d i"}, {"tactic": "have : i \u2208 p\u2081.vars := by\n  rw [mem_vars]\n  exact \u27e8d, hd, hi\u27e9", "annotated_tactic": ["have : i \u2208 p\u2081.vars := by\n    rw [<a>mem_vars</a>]\n    exact \u27e8d, hd, hi\u27e9", [{"full_name": "MvPolynomial.mem_vars", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [306, 9], "def_end_pos": [306, 17]}]], "state_before": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\ni : \u03c3\nhi : i \u2208 d.support\n\u22a2 g\u2081 i ^ \u2191d i = g\u2082 i ^ \u2191d i", "state_after": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\ni : \u03c3\nhi : i \u2208 d.support\nthis : i \u2208 vars p\u2081\n\u22a2 g\u2081 i ^ \u2191d i = g\u2082 i ^ \u2191d i"}, {"tactic": "rw [h i this this]", "annotated_tactic": ["rw [h i this this]", []], "state_before": "case e_a\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\ni : \u03c3\nhi : i \u2208 d.support\nthis : i \u2208 vars p\u2081\n\u22a2 g\u2081 i ^ \u2191d i = g\u2082 i ^ \u2191d i", "state_after": "no goals"}, {"tactic": "rw [mem_vars]", "annotated_tactic": ["rw [<a>mem_vars</a>]", [{"full_name": "MvPolynomial.mem_vars", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [306, 9], "def_end_pos": [306, 17]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\ni : \u03c3\nhi : i \u2208 d.support\n\u22a2 i \u2208 vars p\u2081", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\ni : \u03c3\nhi : i \u2208 d.support\n\u22a2 \u2203 d, \u2203 (_ : d \u2208 support p\u2081), i \u2208 d.support"}, {"tactic": "exact \u27e8d, hd, hi\u27e9", "annotated_tactic": ["exact \u27e8d, hd, hi\u27e9", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\np q : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf\u2081 : R \u2192+* S\ng\u2081 g\u2082 : \u03c3 \u2192 S\np\u2081 : MvPolynomial \u03c3 R\nh : \u2200 i \u2208 vars p\u2081, i \u2208 vars p\u2081 \u2192 g\u2081 i = g\u2082 i\nd : \u03c3 \u2192\u2080 \u2115\nhd : d \u2208 support p\u2081\ni : \u03c3\nhi : i \u2208 d.support\n\u22a2 \u2203 d, \u2203 (_ : d \u2208 support p\u2081), i \u2208 d.support", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.max_empty", "start": [1256, 1], "end": [1257, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.support_le_prod_of_mem", "start": [531, 1], "end": [534, 75], "traced_tactics": [{"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nl : List (Perm \u03b1)\nh : f \u2208 l\nhl : List.Pairwise Disjoint l\n\u22a2 support f \u2264 support (List.prod l)", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nl : List (Perm \u03b1)\nh : f \u2208 l\nhl : List.Pairwise Disjoint l\nx : \u03b1\nhx : x \u2208 support f\n\u22a2 x \u2208 support (List.prod l)"}, {"tactic": "rwa [mem_support, \u2190 eq_on_support_mem_disjoint h hl _ hx, \u2190 mem_support]", "annotated_tactic": ["rwa [<a>mem_support</a>, \u2190 <a>eq_on_support_mem_disjoint</a> h hl _ hx, \u2190 <a>mem_support</a>]", [{"full_name": "Equiv.Perm.mem_support", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [290, 9], "def_end_pos": [290, 20]}, {"full_name": "Equiv.Perm.eq_on_support_mem_disjoint", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [510, 9], "def_end_pos": [510, 35]}, {"full_name": "Equiv.Perm.mem_support", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [290, 9], "def_end_pos": [290, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nl : List (Perm \u03b1)\nh : f \u2208 l\nhl : List.Pairwise Disjoint l\nx : \u03b1\nhx : x \u2208 support f\n\u22a2 x \u2208 support (List.prod l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.subset_univ", "start": [684, 1], "end": [684, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Count.lean", "full_name": "List.countP_cons_of_pos", "start": [36, 9], "end": [39, 49], "traced_tactics": [{"tactic": "have : countP.go p (a :: l) 0 = countP.go p l 1 := show cond .. = _ by rw [pa]; rfl", "annotated_tactic": ["have : <a>countP.go</a> p (a :: l) 0 = <a>countP.go</a> p l 1 := show <a>cond</a> .. = _ by rw [pa]; rfl", [{"full_name": "List.countP.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [799, 17], "def_end_pos": [799, 19]}, {"full_name": "List.countP.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [799, 17], "def_end_pos": [799, 19]}, {"full_name": "cond", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [971, 21], "def_end_pos": [971, 25]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\n\u22a2 countP p (a :: l) = countP p l + 1", "state_after": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\nthis : countP.go p (a :: l) 0 = countP.go p l 1\n\u22a2 countP p (a :: l) = countP p l + 1"}, {"tactic": "unfold countP", "annotated_tactic": ["unfold <a>countP</a>", [{"full_name": "List.countP", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [797, 15], "def_end_pos": [797, 21]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\nthis : countP.go p (a :: l) 0 = countP.go p l 1\n\u22a2 countP p (a :: l) = countP p l + 1", "state_after": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\nthis : countP.go p (a :: l) 0 = countP.go p l 1\n\u22a2 countP.go p (a :: l) 0 = countP.go p l 0 + 1"}, {"tactic": "rw [this, Nat.add_comm, List.countP_go_eq_add]", "annotated_tactic": ["rw [this, <a>Nat.add_comm</a>, <a>List.countP_go_eq_add</a>]", [{"full_name": "Nat.add_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "List.countP_go_eq_add", "def_path": "lake-packages/std/Std/Data/List/Count.lean", "def_pos": [28, 19], "def_end_pos": [28, 35]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\nthis : countP.go p (a :: l) 0 = countP.go p l 1\n\u22a2 countP.go p (a :: l) 0 = countP.go p l 0 + 1", "state_after": "no goals"}, {"tactic": "rw [pa]", "annotated_tactic": ["rw [pa]", []], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\n\u22a2 (bif p a then countP.go p l (0 + 1) else countP.go p l 0) = countP.go p l 1", "state_after": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\n\u22a2 (bif true then countP.go p l (0 + 1) else countP.go p l 0) = countP.go p l 1"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\na : \u03b1\nl : List \u03b1\npa : p a = true\n\u22a2 (bif true then countP.go p l (0 + 1) else countP.go p l 0) = countP.go p l 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.radical_eq_top", "start": [972, 1], "end": [977, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.zero_mem_smul_finset", "start": [2148, 1], "end": [2149, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeq.lean", "full_name": "CauSeq.add_apply", "start": [212, 1], "end": [213, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Relation.lean", "full_name": "Acc.of_fibration", "start": [192, 1], "end": [196, 18], "traced_tactics": [{"tactic": "induction' ha with a _ ih", "annotated_tactic": ["induction' ha with a _ ih", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nfib : Fibration r\u03b1 r\u03b2 f\na : \u03b1\nha : Acc r\u03b1 a\n\u22a2 Acc r\u03b2 (f a)", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nfib : Fibration r\u03b1 r\u03b2 f\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\nih : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b2 (f y)\n\u22a2 Acc r\u03b2 (f a)"}, {"tactic": "refine' Acc.intro (f a) fun b hr \u21a6 _", "annotated_tactic": ["refine' <a>Acc.intro</a> (f a) fun b hr \u21a6 _", [{"full_name": "Acc.intro", "def_path": "lake-packages/lean4/src/lean/Init/WF.lean", "def_pos": [13, 5], "def_end_pos": [13, 10]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nfib : Fibration r\u03b1 r\u03b2 f\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\nih : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b2 (f y)\n\u22a2 Acc r\u03b2 (f a)", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nfib : Fibration r\u03b1 r\u03b2 f\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\nih : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b2 (f y)\nb : \u03b2\nhr : r\u03b2 b (f a)\n\u22a2 Acc r\u03b2 b"}, {"tactic": "obtain \u27e8a', hr', rfl\u27e9 := fib hr", "annotated_tactic": ["obtain \u27e8a', hr', rfl\u27e9 := fib hr", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nfib : Fibration r\u03b1 r\u03b2 f\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\nih : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b2 (f y)\nb : \u03b2\nhr : r\u03b2 b (f a)\n\u22a2 Acc r\u03b2 b", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nfib : Fibration r\u03b1 r\u03b2 f\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\nih : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b2 (f y)\na' : \u03b1\nhr' : r\u03b1 a' a\nhr : r\u03b2 (f a') (f a)\n\u22a2 Acc r\u03b2 (f a')"}, {"tactic": "exact ih a' hr'", "annotated_tactic": ["exact ih a' hr'", []], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop\nr\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nfib : Fibration r\u03b1 r\u03b2 f\na\u271d a : \u03b1\nh\u271d : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b1 y\nih : \u2200 (y : \u03b1), r\u03b1 y a \u2192 Acc r\u03b2 (f y)\na' : \u03b1\nhr' : r\u03b1 a' a\nhr : r\u03b2 (f a') (f a)\n\u22a2 Acc r\u03b2 (f a')", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "full_name": "Polynomial.coeff_mul_of_natDegree_le", "start": [163, 1], "end": [172, 52], "traced_tactics": [{"tactic": "rcases eq_or_lt_of_le pm with (rfl | hm) <;> rcases eq_or_lt_of_le qn with (rfl | hn)", "annotated_tactic": ["rcases <a>eq_or_lt_of_le</a> pm with (rfl | hm) <;> rcases <a>eq_or_lt_of_le</a> qn with (rfl | hn)", [{"full_name": "eq_or_lt_of_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [414, 9], "def_end_pos": [414, 23]}, {"full_name": "eq_or_lt_of_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [414, 9], "def_end_pos": [414, 23]}]], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nqn : natDegree q \u2264 n\n\u22a2 coeff (p * q) (m + n) = coeff p m * coeff q n", "state_after": "case inl.inl\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 natDegree p\nqn : natDegree q \u2264 natDegree q\n\u22a2 coeff (p * q) (natDegree p + natDegree q) = coeff p (natDegree p) * coeff q (natDegree q)\n\ncase inl.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nn : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nqn : natDegree q \u2264 n\npm : natDegree p \u2264 natDegree p\nhn : natDegree q < n\n\u22a2 coeff (p * q) (natDegree p + n) = coeff p (natDegree p) * coeff q n\n\ncase inr.inl\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nhm : natDegree p < m\nqn : natDegree q \u2264 natDegree q\n\u22a2 coeff (p * q) (m + natDegree q) = coeff p m * coeff q (natDegree q)\n\ncase inr.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nqn : natDegree q \u2264 n\nhm : natDegree p < m\nhn : natDegree q < n\n\u22a2 coeff (p * q) (m + n) = coeff p m * coeff q n"}, {"tactic": "exact natDegree_add_coeff_mul _ _", "annotated_tactic": ["exact <a>natDegree_add_coeff_mul</a> _ _", [{"full_name": "Polynomial.natDegree_add_coeff_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Lemmas.lean", "def_pos": [153, 9], "def_end_pos": [153, 32]}]], "state_before": "case inl.inl\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 natDegree p\nqn : natDegree q \u2264 natDegree q\n\u22a2 coeff (p * q) (natDegree p + natDegree q) = coeff p (natDegree p) * coeff q (natDegree q)", "state_after": "no goals"}, {"tactic": "rw [coeff_eq_zero_of_natDegree_lt hn, mul_zero]", "annotated_tactic": ["rw [<a>coeff_eq_zero_of_natDegree_lt</a> hn, <a>mul_zero</a>]", [{"full_name": "Polynomial.coeff_eq_zero_of_natDegree_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [349, 9], "def_end_pos": [349, 38]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}]], "state_before": "case inl.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nn : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nqn : natDegree q \u2264 n\npm : natDegree p \u2264 natDegree p\nhn : natDegree q < n\n\u22a2 coeff (p * q) (natDegree p + n) = coeff p (natDegree p) * coeff q n", "state_after": "case inl.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nn : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nqn : natDegree q \u2264 n\npm : natDegree p \u2264 natDegree p\nhn : natDegree q < n\n\u22a2 coeff (p * q) (natDegree p + n) = 0"}, {"tactic": "exact natDegree_lt_coeff_mul (add_lt_add_left hn _)", "annotated_tactic": ["exact <a>natDegree_lt_coeff_mul</a> (<a>add_lt_add_left</a> hn _)", [{"full_name": "Polynomial.natDegree_lt_coeff_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Lemmas.lean", "def_pos": [158, 9], "def_end_pos": [158, 31]}, {"full_name": "add_lt_add_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [120, 15], "def_end_pos": [120, 30]}]], "state_before": "case inl.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nn : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nqn : natDegree q \u2264 n\npm : natDegree p \u2264 natDegree p\nhn : natDegree q < n\n\u22a2 coeff (p * q) (natDegree p + n) = 0", "state_after": "no goals"}, {"tactic": "rw [coeff_eq_zero_of_natDegree_lt hm, zero_mul]", "annotated_tactic": ["rw [<a>coeff_eq_zero_of_natDegree_lt</a> hm, <a>zero_mul</a>]", [{"full_name": "Polynomial.coeff_eq_zero_of_natDegree_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [349, 9], "def_end_pos": [349, 38]}, {"full_name": "MulZeroClass.zero_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [36, 3], "def_end_pos": [36, 11]}]], "state_before": "case inr.inl\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nhm : natDegree p < m\nqn : natDegree q \u2264 natDegree q\n\u22a2 coeff (p * q) (m + natDegree q) = coeff p m * coeff q (natDegree q)", "state_after": "case inr.inl\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nhm : natDegree p < m\nqn : natDegree q \u2264 natDegree q\n\u22a2 coeff (p * q) (m + natDegree q) = 0"}, {"tactic": "exact natDegree_lt_coeff_mul (add_lt_add_right hm _)", "annotated_tactic": ["exact <a>natDegree_lt_coeff_mul</a> (<a>add_lt_add_right</a> hm _)", [{"full_name": "Polynomial.natDegree_lt_coeff_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Lemmas.lean", "def_pos": [158, 9], "def_end_pos": [158, 31]}, {"full_name": "add_lt_add_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [135, 15], "def_end_pos": [135, 31]}]], "state_before": "case inr.inl\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nhm : natDegree p < m\nqn : natDegree q \u2264 natDegree q\n\u22a2 coeff (p * q) (m + natDegree q) = 0", "state_after": "no goals"}, {"tactic": "rw [coeff_eq_zero_of_natDegree_lt hn, mul_zero]", "annotated_tactic": ["rw [<a>coeff_eq_zero_of_natDegree_lt</a> hn, <a>mul_zero</a>]", [{"full_name": "Polynomial.coeff_eq_zero_of_natDegree_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [349, 9], "def_end_pos": [349, 38]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}]], "state_before": "case inr.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nqn : natDegree q \u2264 n\nhm : natDegree p < m\nhn : natDegree q < n\n\u22a2 coeff (p * q) (m + n) = coeff p m * coeff q n", "state_after": "case inr.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nqn : natDegree q \u2264 n\nhm : natDegree p < m\nhn : natDegree q < n\n\u22a2 coeff (p * q) (m + n) = 0"}, {"tactic": "exact natDegree_lt_coeff_mul (add_lt_add hm hn)", "annotated_tactic": ["exact <a>natDegree_lt_coeff_mul</a> (<a>add_lt_add</a> hm hn)", [{"full_name": "Polynomial.natDegree_lt_coeff_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Lemmas.lean", "def_pos": [158, 9], "def_end_pos": [158, 31]}, {"full_name": "add_lt_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [167, 7], "def_end_pos": [167, 17]}]], "state_before": "case inr.inr\nR : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\npm : natDegree p \u2264 m\nqn : natDegree q \u2264 n\nhm : natDegree p < m\nhn : natDegree q < n\n\u22a2 coeff (p * q) (m + n) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.exists_image_iff", "start": [602, 1], "end": [605, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Cast/Basic.lean", "full_name": "NeZero.nat_of_neZero", "start": [150, 1], "end": [152, 62], "traced_tactics": [{"tactic": "simp only [map_natCast, hn]", "annotated_tactic": ["simp only [<a>map_natCast</a>, hn]", [{"full_name": "map_natCast", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [136, 9], "def_end_pos": [136, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR\u271d : Type u_3\nS\u271d : Type u_4\nF\u271d : Type u_5\ninst\u271d\u2074 : NonAssocSemiring R\u271d\ninst\u271d\u00b3 : NonAssocSemiring S\u271d\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Semiring S\nF : Type u_8\ninst\u271d : RingHomClass F R S\nf : F\nn : \u2115\nhn : NeZero \u2191n\n\u22a2 NeZero (\u2191f \u2191n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Coeff.lean", "full_name": "Polynomial.coeff_X_add_C_pow", "start": [321, 1], "end": [330, 61], "traced_tactics": [{"tactic": "rw [(commute_X (C r : R[X])).add_pow, \u2190 lcoeff_apply, map_sum]", "annotated_tactic": ["rw [(<a>commute_X</a> (<a>C</a> r : R[X])).<a>add_pow</a>, \u2190 <a>lcoeff_apply</a>, <a>map_sum</a>]", [{"full_name": "Polynomial.commute_X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [630, 9], "def_end_pos": [630, 18]}, {"full_name": "Polynomial.C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [498, 5], "def_end_pos": [498, 6]}, {"full_name": "Commute.add_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Sum.lean", "def_pos": [39, 9], "def_end_pos": [39, 16]}, {"full_name": "Polynomial.lcoeff_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [96, 9], "def_end_pos": [96, 21]}, {"full_name": "map_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [204, 3], "def_end_pos": [204, 14]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 coeff ((X + \u2191C r) ^ n) k = r ^ (n - k) * \u2191(Nat.choose n k)", "state_after": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 \u2211 x in range (n + 1), \u2191(lcoeff R k) (X ^ x * \u2191C r ^ (n - x) * \u2191(Nat.choose n x)) = r ^ (n - k) * \u2191(Nat.choose n k)"}, {"tactic": "simp only [one_pow, mul_one, lcoeff_apply, \u2190 C_eq_nat_cast, \u2190 C_pow, coeff_mul_C, Nat.cast_id]", "annotated_tactic": ["simp only [<a>one_pow</a>, <a>mul_one</a>, <a>lcoeff_apply</a>, \u2190 <a>C_eq_nat_cast</a>, \u2190 <a>C_pow</a>, <a>coeff_mul_C</a>, <a>Nat.cast_id</a>]", [{"full_name": "one_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}, {"full_name": "Polynomial.lcoeff_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [96, 9], "def_end_pos": [96, 21]}, {"full_name": "Polynomial.C_eq_nat_cast", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [551, 9], "def_end_pos": [551, 22]}, {"full_name": "Polynomial.C_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [546, 9], "def_end_pos": [546, 14]}, {"full_name": "Polynomial.coeff_mul_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [173, 9], "def_end_pos": [173, 20]}, {"full_name": "Nat.cast_id", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 20]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 \u2211 x in range (n + 1), \u2191(lcoeff R k) (X ^ x * \u2191C r ^ (n - x) * \u2191(Nat.choose n x)) = r ^ (n - k) * \u2191(Nat.choose n k)", "state_after": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 \u2211 x in range (n + 1), coeff (X ^ x) k * r ^ (n - x) * \u2191(Nat.choose n x) = r ^ (n - k) * \u2191(Nat.choose n k)"}, {"tactic": "rw [Finset.sum_eq_single k, coeff_X_pow_self, one_mul]", "annotated_tactic": ["rw [<a>Finset.sum_eq_single</a> k, <a>coeff_X_pow_self</a>, <a>one_mul</a>]", [{"full_name": "Finset.sum_eq_single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [804, 3], "def_end_pos": [804, 14]}, {"full_name": "Polynomial.coeff_X_pow_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [202, 9], "def_end_pos": [202, 25]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 \u2211 x in range (n + 1), coeff (X ^ x) k * r ^ (n - x) * \u2191(Nat.choose n x) = r ^ (n - k) * \u2191(Nat.choose n k)", "state_after": "case h\u2080\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 \u2200 b \u2208 range (n + 1), b \u2260 k \u2192 coeff (X ^ b) k * r ^ (n - b) * \u2191(Nat.choose n b) = 0\n\ncase h\u2081\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 k \u2209 range (n + 1) \u2192 coeff (X ^ k) k * r ^ (n - k) * \u2191(Nat.choose n k) = 0"}, {"tactic": "intro _ _ h", "annotated_tactic": ["intro _ _ h", []], "state_before": "case h\u2080\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 \u2200 b \u2208 range (n + 1), b \u2260 k \u2192 coeff (X ^ b) k * r ^ (n - b) * \u2191(Nat.choose n b) = 0", "state_after": "case h\u2080\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k b\u271d : \u2115\na\u271d : b\u271d \u2208 range (n + 1)\nh : b\u271d \u2260 k\n\u22a2 coeff (X ^ b\u271d) k * r ^ (n - b\u271d) * \u2191(Nat.choose n b\u271d) = 0"}, {"tactic": "simp [coeff_X_pow, h.symm]", "annotated_tactic": ["simp [<a>coeff_X_pow</a>, h.symm]", [{"full_name": "Polynomial.coeff_X_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [198, 9], "def_end_pos": [198, 20]}]], "state_before": "case h\u2080\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k b\u271d : \u2115\na\u271d : b\u271d \u2208 range (n + 1)\nh : b\u271d \u2260 k\n\u22a2 coeff (X ^ b\u271d) k * r ^ (n - b\u271d) * \u2191(Nat.choose n b\u271d) = 0", "state_after": "no goals"}, {"tactic": "simp only [coeff_X_pow_self, one_mul, not_lt, Finset.mem_range]", "annotated_tactic": ["simp only [<a>coeff_X_pow_self</a>, <a>one_mul</a>, <a>not_lt</a>, <a>Finset.mem_range</a>]", [{"full_name": "Polynomial.coeff_X_pow_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [202, 9], "def_end_pos": [202, 25]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}, {"full_name": "Finset.mem_range", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3060, 9], "def_end_pos": [3060, 18]}]], "state_before": "case h\u2081\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 k \u2209 range (n + 1) \u2192 coeff (X ^ k) k * r ^ (n - k) * \u2191(Nat.choose n k) = 0", "state_after": "case h\u2081\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 n + 1 \u2264 k \u2192 r ^ (n - k) * \u2191(Nat.choose n k) = 0"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case h\u2081\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\n\u22a2 n + 1 \u2264 k \u2192 r ^ (n - k) * \u2191(Nat.choose n k) = 0", "state_after": "case h\u2081\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\nh : n + 1 \u2264 k\n\u22a2 r ^ (n - k) * \u2191(Nat.choose n k) = 0"}, {"tactic": "rw [Nat.choose_eq_zero_of_lt h, Nat.cast_zero, mul_zero]", "annotated_tactic": ["rw [<a>Nat.choose_eq_zero_of_lt</a> h, <a>Nat.cast_zero</a>, <a>mul_zero</a>]", [{"full_name": "Nat.choose_eq_zero_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [68, 9], "def_end_pos": [68, 29]}, {"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}, {"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}]], "state_before": "case h\u2081\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r\u271d : R[X]\nr : R\nn k : \u2115\nh : n + 1 \u2264 k\n\u22a2 r ^ (n - k) * \u2191(Nat.choose n k) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Basic.lean", "full_name": "pow_add", "start": [118, 1], "end": [121, 66], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm n : \u2115\n\u22a2 a ^ (m + n) = a ^ m * a ^ n", "state_after": "case zero\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm : \u2115\n\u22a2 a ^ (m + Nat.zero) = a ^ m * a ^ Nat.zero\n\ncase succ\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm n : \u2115\nih : a ^ (m + n) = a ^ m * a ^ n\n\u22a2 a ^ (m + Nat.succ n) = a ^ m * a ^ Nat.succ n"}, {"tactic": "rw [Nat.add_zero, pow_zero, mul_one]", "annotated_tactic": ["rw [<a>Nat.add_zero</a>, <a>pow_zero</a>, <a>mul_one</a>]", [{"full_name": "Nat.add_zero", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [457, 27], "def_end_pos": [457, 39]}, {"full_name": "pow_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [639, 9], "def_end_pos": [639, 17]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case zero\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm : \u2115\n\u22a2 a ^ (m + Nat.zero) = a ^ m * a ^ Nat.zero", "state_after": "no goals"}, {"tactic": "rw [pow_succ', \u2190 mul_assoc, \u2190 ih, \u2190 pow_succ', Nat.add_assoc]", "annotated_tactic": ["rw [<a>pow_succ'</a>, \u2190 <a>mul_assoc</a>, \u2190 ih, \u2190 <a>pow_succ'</a>, <a>Nat.add_assoc</a>]", [{"full_name": "pow_succ'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [213, 9], "def_end_pos": [213, 25]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "pow_succ'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [213, 9], "def_end_pos": [213, 25]}, {"full_name": "Nat.add_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "case succ\n\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b9 : Monoid M\ninst\u271d : AddMonoid A\na : M\nm n : \u2115\nih : a ^ (m + n) = a ^ m * a ^ n\n\u22a2 a ^ (m + Nat.succ n) = a ^ m * a ^ Nat.succ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.emod_emod", "start": [502, 9], "end": [503, 64], "traced_tactics": [{"tactic": "conv => rhs; rw [\u2190 emod_add_ediv a b, add_mul_emod_self_left]", "annotated_tactic": ["conv => rhs; rw [\u2190 <a>emod_add_ediv</a> a b, <a>add_mul_emod_self_left</a>]", [{"full_name": "Int.emod_add_ediv", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [306, 9], "def_end_pos": [306, 22]}, {"full_name": "Int.add_mul_emod_self_left", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [419, 17], "def_end_pos": [419, 39]}]], "state_before": "a b : Int\n\u22a2 a % b % b = a % b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Opposites.lean", "full_name": "MulOpposite.unop_inv", "start": [301, 1], "end": [302, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "Valuation.isEquiv_of_map_strictMono", "start": [415, 1], "end": [418, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Join.lean", "full_name": "List.length_bind", "start": [75, 1], "end": [76, 97], "traced_tactics": [{"tactic": "rw [List.bind, length_join, map_map]", "annotated_tactic": ["rw [<a>List.bind</a>, <a>length_join</a>, <a>map_map</a>]", [{"full_name": "List.bind", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [643, 25], "def_end_pos": [643, 29]}, {"full_name": "List.length_join", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Join.lean", "def_pos": [70, 9], "def_end_pos": [70, 20]}, {"full_name": "List.map_map", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [106, 17], "def_end_pos": [106, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : List \u03b1\nf : \u03b1 \u2192 List \u03b2\n\u22a2 length (List.bind l f) = sum (map (length \u2218 f) l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "sup_sdiff_distrib", "start": [640, 1], "end": [641, 83], "traced_tactics": [{"tactic": "simp_rw [sdiff_le_iff, sup_le_iff, sdiff_le_iff]", "annotated_tactic": ["simp_rw [<a>sdiff_le_iff</a>, <a>sup_le_iff</a>, <a>sdiff_le_iff</a>]", [{"full_name": "sdiff_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [500, 9], "def_end_pos": [500, 21]}, {"full_name": "sup_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [172, 9], "def_end_pos": [172, 19]}, {"full_name": "sdiff_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [500, 9], "def_end_pos": [500, 21]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : GeneralizedCoheytingAlgebra \u03b1\na\u271d b\u271d c\u271d d\u271d a b c d : \u03b1\n\u22a2 (a \u2294 b) \\ c \u2264 d \u2194 a \\ c \u2294 b \\ c \u2264 d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.update_preimage_univ_pi", "start": [997, 1], "end": [999, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Set.Finite.toFinset_image2", "start": [590, 1], "end": [592, 34], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d : DecidableEq \u03b3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nhs : Set.Finite s\nht : Set.Finite t\nhf : optParam (Set.Finite (image2 f s t)) (_ : Set.Finite (image2 f s t))\n\u22a2 \u2191(Finite.toFinset hf) = \u2191(Finset.image\u2082 f (Finite.toFinset hs) (Finite.toFinset ht))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "InfTopHom.id_apply", "start": [933, 1], "end": [934, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get?_of_mem", "start": [626, 1], "end": [627, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.eventuallyEq_set", "start": [1461, 1], "end": [1462, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.Perm.subtypeCongr.refl", "start": [640, 1], "end": [643, 30], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b5 : Type u_1\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\nep ep' : Perm { a // p a }\nen en' : Perm { a // \u00acp a }\n\u22a2 subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // \u00acp a }) = Equiv.refl \u03b5", "state_after": "case H\n\u03b5 : Type u_1\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\nep ep' : Perm { a // p a }\nen en' : Perm { a // \u00acp a }\nx : \u03b5\n\u22a2 \u2191(subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // \u00acp a })) x = \u2191(Equiv.refl \u03b5) x"}, {"tactic": "by_cases h:p x <;> simp [h]", "annotated_tactic": ["by_cases h:p x <;> simp [h]", []], "state_before": "case H\n\u03b5 : Type u_1\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\nep ep' : Perm { a // p a }\nen en' : Perm { a // \u00acp a }\nx : \u03b5\n\u22a2 \u2191(subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // \u00acp a })) x = \u2191(Equiv.refl \u03b5) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.leadingCoeff_eq_zero", "start": [670, 1], "end": [674, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Interval.lean", "full_name": "Nat.card_Ioc", "start": [108, 1], "end": [109, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.mapDomain_mul", "start": [1579, 1], "end": [1590, 19], "traced_tactics": [{"tactic": "simp_rw [mul_def, mapDomain_sum, mapDomain_single, map_add]", "annotated_tactic": ["simp_rw [<a>mul_def</a>, <a>mapDomain_sum</a>, <a>mapDomain_single</a>, <a>map_add</a>]", [{"full_name": "AddMonoidAlgebra.mul_def", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1295, 9], "def_end_pos": [1295, 16]}, {"full_name": "AddMonoidAlgebra.mapDomain_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1256, 9], "def_end_pos": [1256, 22]}, {"full_name": "AddMonoidAlgebra.mapDomain_single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1261, 9], "def_end_pos": [1261, 25]}, {"full_name": "map_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [298, 3], "def_end_pos": [298, 14]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 mapDomain (\u2191f) (x * y) = mapDomain (\u2191f) x * mapDomain (\u2191f) y", "state_after": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) =\n    sum (mapDomain (\u2191f) x) fun a\u2081 b\u2081 => sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (a\u2081 + a\u2082) (b\u2081 * b\u2082)"}, {"tactic": "rw [Finsupp.sum_mapDomain_index]", "annotated_tactic": ["rw [<a>Finsupp.sum_mapDomain_index</a>]", [{"full_name": "Finsupp.sum_mapDomain_index", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [580, 3], "def_end_pos": [580, 14]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) =\n    sum (mapDomain (\u2191f) x) fun a\u2081 b\u2081 => sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (a\u2081 + a\u2082) (b\u2081 * b\u2082)", "state_after": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) =\n    sum x fun a m => sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (\u2191f a + a\u2082) (m * b\u2082)\n\ncase h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 \u2200 (b : \u03b1\u2082), (sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) (0 * b\u2082)) = 0\n\ncase h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 \u2200 (b : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    (sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) ((m\u2081 + m\u2082) * b\u2082)) =\n      (sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) (m\u2081 * b\u2082)) +\n        sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) (m\u2082 * b\u2082)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 (sum x fun a b => sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) =\n    sum x fun a m => sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (\u2191f a + a\u2082) (m * b\u2082)", "state_after": "case e_g\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 (fun a b => sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) = fun a m =>\n    sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (\u2191f a + a\u2082) (m * b\u2082)"}, {"tactic": "ext a b", "annotated_tactic": ["ext a b", []], "state_before": "case e_g\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 (fun a b => sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) = fun a m =>\n    sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (\u2191f a + a\u2082) (m * b\u2082)", "state_after": "case e_g.h.h\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\na : \u03b1\nb : \u03b2\n\u22a2 (sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) =\n    sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (\u2191f a + a\u2082) (b * b\u2082)"}, {"tactic": "rw [Finsupp.sum_mapDomain_index]", "annotated_tactic": ["rw [<a>Finsupp.sum_mapDomain_index</a>]", [{"full_name": "Finsupp.sum_mapDomain_index", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [580, 3], "def_end_pos": [580, 14]}]], "state_before": "case e_g.h.h\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\na : \u03b1\nb : \u03b2\n\u22a2 (sum y fun a_1 b_1 => single (\u2191f a + \u2191f a_1) (b * b_1)) =\n    sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (\u2191f a + a\u2082) (b * b\u2082)", "state_after": "case e_g.h.h.h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082), single (\u2191f a + b_1) (b * 0) = 0\n\ncase e_g.h.h.h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    single (\u2191f a + b_1) (b * (m\u2081 + m\u2082)) = single (\u2191f a + b_1) (b * m\u2081) + single (\u2191f a + b_1) (b * m\u2082)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case e_g.h.h.h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082), single (\u2191f a + b_1) (b * 0) = 0", "state_after": "no goals"}, {"tactic": "simp [mul_add]", "annotated_tactic": ["simp [<a>mul_add</a>]", [{"full_name": "mul_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}]], "state_before": "case e_g.h.h.h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\na : \u03b1\nb : \u03b2\n\u22a2 \u2200 (b_1 : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    single (\u2191f a + b_1) (b * (m\u2081 + m\u2082)) = single (\u2191f a + b_1) (b * m\u2081) + single (\u2191f a + b_1) (b * m\u2082)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h_zero\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 \u2200 (b : \u03b1\u2082), (sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) (0 * b\u2082)) = 0", "state_after": "no goals"}, {"tactic": "simp [add_mul]", "annotated_tactic": ["simp [<a>add_mul</a>]", [{"full_name": "add_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}]], "state_before": "case h_add\nk : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2074 : Semiring k\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b1\u2082 : Type u_5\ninst\u271d\u00b3 : Semiring \u03b2\ninst\u271d\u00b2 : Add \u03b1\ninst\u271d\u00b9 : Add \u03b1\u2082\nF : Type u_6\ninst\u271d : AddHomClass F \u03b1 \u03b1\u2082\nf : F\nx y : \u03b2[\u03b1]\n\u22a2 \u2200 (b : \u03b1\u2082) (m\u2081 m\u2082 : \u03b2),\n    (sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) ((m\u2081 + m\u2082) * b\u2082)) =\n      (sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) (m\u2081 * b\u2082)) +\n        sum (mapDomain (\u2191f) y) fun a\u2082 b\u2082 => single (b + a\u2082) (m\u2082 * b\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_pi_mulSingle'", "start": [1134, 1], "end": [1136, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "full_name": "FreeMonoid.hom_eq", "start": [200, 1], "end": [202, 62], "traced_tactics": [{"tactic": "simp only [h, hxs, MonoidHom.map_mul]", "annotated_tactic": ["simp only [h, hxs, <a>MonoidHom.map_mul</a>]", [{"full_name": "MonoidHom.map_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [938, 19], "def_end_pos": [938, 36]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nM : Type u_4\ninst\u271d\u00b9 : Monoid M\nN : Type u_5\ninst\u271d : Monoid N\nf g : FreeMonoid \u03b1 \u2192* M\nh : \u2200 (x : \u03b1), \u2191f (of x) = \u2191g (of x)\nl : FreeMonoid \u03b1\nx : \u03b1\nxs : FreeMonoid \u03b1\nhxs : \u2191f xs = \u2191g xs\n\u22a2 \u2191f (of x * xs) = \u2191g (of x * xs)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_surjective_of_surjective", "start": [1356, 1], "end": [1363, 36], "traced_tactics": [{"tactic": "intro s", "annotated_tactic": ["intro s", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 Surjective (map f)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Multiset \u03b2\n\u22a2 \u2203 a, map f a = s"}, {"tactic": "induction' s using Multiset.induction_on with x s ih", "annotated_tactic": ["induction' s using <a>Multiset.induction_on</a> with x s ih", [{"full_name": "Multiset.induction_on", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [160, 19], "def_end_pos": [160, 31]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Multiset \u03b2\n\u22a2 \u2203 a, map f a = s", "state_after": "case empty\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 \u2203 a, map f a = 0\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nx : \u03b2\ns : Multiset \u03b2\nih : \u2203 a, map f a = s\n\u22a2 \u2203 a, map f a = x ::\u2098 s"}, {"tactic": "exact \u27e80, map_zero _\u27e9", "annotated_tactic": ["exact \u27e80, <a>map_zero</a> _\u27e9", [{"full_name": "Multiset.map_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1175, 9], "def_end_pos": [1175, 17]}]], "state_before": "case empty\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 \u2203 a, map f a = 0", "state_after": "no goals"}, {"tactic": "obtain \u27e8y, rfl\u27e9 := hf x", "annotated_tactic": ["obtain \u27e8y, rfl\u27e9 := hf x", []], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nx : \u03b2\ns : Multiset \u03b2\nih : \u2203 a, map f a = s\n\u22a2 \u2203 a, map f a = x ::\u2098 s", "state_after": "case cons.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Multiset \u03b2\nih : \u2203 a, map f a = s\ny : \u03b1\n\u22a2 \u2203 a, map f a = f y ::\u2098 s"}, {"tactic": "obtain \u27e8t, rfl\u27e9 := ih", "annotated_tactic": ["obtain \u27e8t, rfl\u27e9 := ih", []], "state_before": "case cons.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Multiset \u03b2\nih : \u2203 a, map f a = s\ny : \u03b1\n\u22a2 \u2203 a, map f a = f y ::\u2098 s", "state_after": "case cons.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ny : \u03b1\nt : Multiset \u03b1\n\u22a2 \u2203 a, map f a = f y ::\u2098 map f t"}, {"tactic": "exact \u27e8y ::\u2098 t, map_cons _ _ _\u27e9", "annotated_tactic": ["exact \u27e8y ::\u2098 t, <a>map_cons</a> _ _ _\u27e9", [{"full_name": "Multiset.map_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1180, 9], "def_end_pos": [1180, 17]}]], "state_before": "case cons.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ny : \u03b1\nt : Multiset \u03b1\n\u22a2 \u2203 a, map f a = f y ::\u2098 map f t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_nonneg", "start": [94, 1], "end": [96, 40], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>]", [{"full_name": "div_eq_mul_inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [977, 9], "def_end_pos": [977, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 0 \u2264 a / b", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 0 \u2264 a * b\u207b\u00b9"}, {"tactic": "exact mul_nonneg ha (inv_nonneg.2 hb)", "annotated_tactic": ["exact <a>mul_nonneg</a> ha (<a>inv_nonneg</a>.2 hb)", [{"full_name": "mul_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [380, 7], "def_end_pos": [380, 17]}, {"full_name": "inv_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [58, 9], "def_end_pos": [58, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 0 \u2264 a * b\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.head_cons", "start": [31, 9], "end": [31, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.ringHom_ext", "start": [1842, 1], "end": [1845, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Denumerable.lean", "full_name": "Denumerable.ofNat_nat", "start": [123, 1], "end": [124, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.gcd_mul_left", "start": [84, 1], "end": [87, 72], "traced_tactics": [{"tactic": "induction n, k using gcd.induction with\n| H0 k => simp\n| H1 n k _ IH => rwa [\u2190 mul_mod_mul_left, \u2190 gcd_rec, \u2190 gcd_rec] at IH", "annotated_tactic": ["induction n, k using <a>gcd.induction</a> with\n  | H0 k => simp\n  | H1 n k _ IH => rwa [\u2190 <a>mul_mod_mul_left</a>, \u2190 <a>gcd_rec</a>, \u2190 <a>gcd_rec</a>] at IH", [{"full_name": "Nat.gcd.induction", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [21, 25], "def_end_pos": [21, 38]}, {"full_name": "Nat.mul_mod_mul_left", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [929, 9], "def_end_pos": [929, 25]}, {"full_name": "Nat.gcd_rec", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [16, 9], "def_end_pos": [16, 16]}, {"full_name": "Nat.gcd_rec", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [16, 9], "def_end_pos": [16, 16]}]], "state_before": "m n k : Nat\n\u22a2 gcd (m * n) (m * k) = m * gcd n k", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case H0\nm k : Nat\n\u22a2 gcd (m * 0) (m * k) = m * gcd 0 k", "state_after": "no goals"}, {"tactic": "rwa [\u2190 mul_mod_mul_left, \u2190 gcd_rec, \u2190 gcd_rec] at IH", "annotated_tactic": ["rwa [\u2190 <a>mul_mod_mul_left</a>, \u2190 <a>gcd_rec</a>, \u2190 <a>gcd_rec</a>] at IH", [{"full_name": "Nat.mul_mod_mul_left", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [929, 9], "def_end_pos": [929, 25]}, {"full_name": "Nat.gcd_rec", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [16, 9], "def_end_pos": [16, 16]}, {"full_name": "Nat.gcd_rec", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [16, 9], "def_end_pos": [16, 16]}]], "state_before": "case H1\nm n k : Nat\na\u271d : 0 < n\nIH : gcd (m * (k % n)) (m * n) = m * gcd (k % n) n\n\u22a2 gcd (m * n) (m * k) = m * gcd n k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.unit_right", "start": [323, 1], "end": [324, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_multiset_count_of_subset", "start": [1341, 1], "end": [1346, 38], "traced_tactics": [{"tactic": "revert hs", "annotated_tactic": ["revert hs", []], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\ns : Finset \u03b1\nhs : Multiset.toFinset m \u2286 s\n\u22a2 Multiset.prod m = \u220f i in s, i ^ Multiset.count i m", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\ns : Finset \u03b1\n\u22a2 Multiset.toFinset m \u2286 s \u2192 Multiset.prod m = \u220f i in s, i ^ Multiset.count i m"}, {"tactic": "refine' Quot.induction_on m fun l => _", "annotated_tactic": ["refine' <a>Quot.induction_on</a> m fun l => _", [{"full_name": "Quot.induction_on", "def_path": "lake-packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [47, 19], "def_end_pos": [47, 31]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\ns : Finset \u03b1\n\u22a2 Multiset.toFinset m \u2286 s \u2192 Multiset.prod m = \u220f i in s, i ^ Multiset.count i m", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\ns : Finset \u03b1\nl : List \u03b1\n\u22a2 Multiset.toFinset \u27e6l\u27e7 \u2286 s \u2192 Multiset.prod \u27e6l\u27e7 = \u220f i in s, i ^ Multiset.count i \u27e6l\u27e7"}, {"tactic": "simp only [quot_mk_to_coe'', coe_prod, coe_count]", "annotated_tactic": ["simp only [<a>quot_mk_to_coe''</a>, <a>coe_prod</a>, <a>coe_count</a>]", [{"full_name": "Multiset.quot_mk_to_coe''", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [53, 9], "def_end_pos": [53, 25]}, {"full_name": "Multiset.coe_prod", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [64, 9], "def_end_pos": [64, 17]}, {"full_name": "Multiset.coe_count", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2359, 9], "def_end_pos": [2359, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\ns : Finset \u03b1\nl : List \u03b1\n\u22a2 Multiset.toFinset \u27e6l\u27e7 \u2286 s \u2192 Multiset.prod \u27e6l\u27e7 = \u220f i in s, i ^ Multiset.count i \u27e6l\u27e7", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\ns : Finset \u03b1\nl : List \u03b1\n\u22a2 Multiset.toFinset \u2191l \u2286 s \u2192 List.prod l = \u220f x in s, x ^ List.count x l"}, {"tactic": "apply prod_list_count_of_subset l s", "annotated_tactic": ["apply <a>prod_list_count_of_subset</a> l s", [{"full_name": "Finset.prod_list_count_of_subset", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1308, 9], "def_end_pos": [1308, 34]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\ns : Finset \u03b1\nl : List \u03b1\n\u22a2 Multiset.toFinset \u2191l \u2286 s \u2192 List.prod l = \u220f x in s, x ^ List.count x l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Set.SurjOn.subset_range", "start": [771, 1], "end": [772, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval\u2082Hom_congr", "start": [1055, 1], "end": [1057, 26], "traced_tactics": [{"tactic": "rintro rfl rfl rfl", "annotated_tactic": ["rintro rfl rfl rfl", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\nf\u2081 f\u2082 : R \u2192+* S\u2081\ng\u2081 g\u2082 : \u03c3 \u2192 S\u2081\np\u2081 p\u2082 : MvPolynomial \u03c3 R\n\u22a2 f\u2081 = f\u2082 \u2192 g\u2081 = g\u2082 \u2192 p\u2081 = p\u2082 \u2192 \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081 = \u2191(eval\u2082Hom f\u2082 g\u2082) p\u2082", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\nf\u2081 : R \u2192+* S\u2081\ng\u2081 : \u03c3 \u2192 S\u2081\np\u2081 : MvPolynomial \u03c3 R\n\u22a2 \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081 = \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\nf\u2081 : R \u2192+* S\u2081\ng\u2081 : \u03c3 \u2192 S\u2081\np\u2081 : MvPolynomial \u03c3 R\n\u22a2 \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081 = \u2191(eval\u2082Hom f\u2081 g\u2081) p\u2081", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "ne_one_of_map", "start": [228, 1], "end": [229, 73], "traced_tactics": [{"tactic": "rwa [(map_one f)]", "annotated_tactic": ["rwa [(<a>map_one</a> f)]", [{"full_name": "map_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [202, 9], "def_end_pos": [202, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nG : Type u_6\nH : Type u_7\nF\u271d : Type u_8\ninst\u271d\u2074 : One M\ninst\u271d\u00b3 : One N\nR : Type u_9\nS : Type u_10\nF : Type u_11\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : One S\ninst\u271d : OneHomClass F R S\nf : F\nx : R\nhx : \u2191f x \u2260 1\n\u22a2 \u2191f x \u2260 \u2191f 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/Cast/Defs.lean", "full_name": "Rat.cast_coe_int", "start": [41, 1], "end": [42, 81], "traced_tactics": [{"tactic": "rw [Nat.cast_one, div_one]", "annotated_tactic": ["rw [<a>Nat.cast_one</a>, <a>div_one</a>]", [{"full_name": "Nat.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [147, 9], "def_end_pos": [147, 17]}, {"full_name": "div_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [340, 9], "def_end_pos": [340, 16]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : DivisionRing \u03b1\nn : \u2124\n\u22a2 \u2191n / \u21911 = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompactlyGenerated.lean", "full_name": "complementedLattice_of_sSup_atoms_eq_top", "start": [638, 1], "end": [642, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Pairing.lean", "full_name": "Set.iUnion_unpair", "start": [210, 1], "end": [212, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diagonal_apply", "start": [403, 1], "end": [404, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.leadingCoeff_X_add_C", "start": [1517, 1], "end": [1518, 66], "traced_tactics": [{"tactic": "rw [\u2190 pow_one (X : S[X]), leadingCoeff_X_pow_add_C zero_lt_one]", "annotated_tactic": ["rw [\u2190 <a>pow_one</a> (<a>X</a> : S[X]), <a>leadingCoeff_X_pow_add_C</a> <a>zero_lt_one</a>]", [{"full_name": "pow_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [97, 9], "def_end_pos": [97, 16]}, {"full_name": "Polynomial.X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [566, 5], "def_end_pos": [566, 6]}, {"full_name": "Polynomial.leadingCoeff_X_pow_add_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1509, 9], "def_end_pos": [1509, 33]}, {"full_name": "zero_lt_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [39, 15], "def_end_pos": [39, 26]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nr : S\n\u22a2 leadingCoeff (X + \u2191C r) = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.mem_pi", "start": [753, 1], "end": [754, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/HashMap/Basic.lean", "full_name": "Std.HashMap.Imp.WF.empty", "start": [240, 1], "end": [240, 96], "traced_tactics": [{"tactic": "unfold empty", "annotated_tactic": ["unfold <a>empty</a>", [{"full_name": "Std.HashMap.Imp.empty", "def_path": "lake-packages/std/Std/Data/HashMap/Basic.lean", "def_pos": [87, 5], "def_end_pos": [87, 10]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\ninst\u271d\u00b9 : BEq \u03b1\ninst\u271d : Hashable \u03b1\n\u22a2 WF (Imp.empty n)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\ninst\u271d\u00b9 : BEq \u03b1\ninst\u271d : Hashable \u03b1\n\u22a2 WF\n    (let nbuckets := numBucketsForCapacity n;\n    let n_1 :=\n      if h : nbuckets = 0 then { val := 8, property := empty.proof_1 }\n      else { val := nbuckets, property := (_ : 0 < nbuckets) };\n    Imp.empty' n_1.val)"}, {"tactic": "apply empty'", "annotated_tactic": ["apply <a>empty'</a>", [{"full_name": "Std.HashMap.Imp.WF.empty'", "def_path": "lake-packages/std/Std/Data/HashMap/Basic.lean", "def_pos": [232, 5], "def_end_pos": [232, 11]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\ninst\u271d\u00b9 : BEq \u03b1\ninst\u271d : Hashable \u03b1\n\u22a2 WF\n    (let nbuckets := numBucketsForCapacity n;\n    let n_1 :=\n      if h : nbuckets = 0 then { val := 8, property := empty.proof_1 }\n      else { val := nbuckets, property := (_ : 0 < nbuckets) };\n    Imp.empty' n_1.val)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WellFounded.lean", "full_name": "Acc.induction_bot'", "start": [247, 1], "end": [252, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Defs.lean", "full_name": "mul_inv_cancel_left\u2080", "start": [217, 1], "end": [220, 25], "traced_tactics": [{"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "G\u2080 : Type u\nM\u2080 : Type u_1\nM\u2080' : Type u_2\nG\u2080' : Type u_3\ninst\u271d : GroupWithZero G\u2080\na b\u271d c g h\u271d x : G\u2080\nh : a \u2260 0\nb : G\u2080\n\u22a2 a * a\u207b\u00b9 * b = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "isMin_bot", "start": [311, 1], "end": [312, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/MinMax.lean", "full_name": "List.maximum_of_length_pos_mem", "start": [452, 1], "end": [455, 40], "traced_tactics": [{"tactic": "apply maximum_mem", "annotated_tactic": ["apply <a>maximum_mem</a>", [{"full_name": "List.maximum_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/List/MinMax.lean", "def_pos": [304, 9], "def_end_pos": [304, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\nl : List \u03b1\na m : \u03b1\nh : 0 < length l\n\u22a2 maximum_of_length_pos h \u2208 l", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\nl : List \u03b1\na m : \u03b1\nh : 0 < length l\n\u22a2 maximum l = \u2191(maximum_of_length_pos h)"}, {"tactic": "simp only [coe_maximum_of_length_pos]", "annotated_tactic": ["simp only [<a>coe_maximum_of_length_pos</a>]", [{"full_name": "List.coe_maximum_of_length_pos", "def_path": "lake-packages/mathlib/Mathlib/Data/List/MinMax.lean", "def_pos": [433, 7], "def_end_pos": [433, 32]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\nl : List \u03b1\na m : \u03b1\nh : 0 < length l\n\u22a2 maximum l = \u2191(maximum_of_length_pos h)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.eq_of_infinite_eval_eq", "start": [645, 1], "end": [649, 45], "traced_tactics": [{"tactic": "rw [\u2190 sub_eq_zero]", "annotated_tactic": ["rw [\u2190 <a>sub_eq_zero</a>]", [{"full_name": "sub_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [801, 3], "def_end_pos": [801, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : Set.Infinite {x | eval x p = eval x q}\n\u22a2 p = q", "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : Set.Infinite {x | eval x p = eval x q}\n\u22a2 p - q = 0"}, {"tactic": "apply eq_zero_of_infinite_isRoot", "annotated_tactic": ["apply <a>eq_zero_of_infinite_isRoot</a>", [{"full_name": "Polynomial.eq_zero_of_infinite_isRoot", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [633, 9], "def_end_pos": [633, 35]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : Set.Infinite {x | eval x p = eval x q}\n\u22a2 p - q = 0", "state_after": "case h\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : Set.Infinite {x | eval x p = eval x q}\n\u22a2 Set.Infinite {x | IsRoot (p - q) x}"}, {"tactic": "simpa only [IsRoot, eval_sub, sub_eq_zero]", "annotated_tactic": ["simpa only [<a>IsRoot</a>, <a>eval_sub</a>, <a>sub_eq_zero</a>]", [{"full_name": "Polynomial.IsRoot", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [492, 5], "def_end_pos": [492, 11]}, {"full_name": "Polynomial.eval_sub", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1286, 9], "def_end_pos": [1286, 17]}, {"full_name": "sub_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [801, 3], "def_end_pos": [801, 14]}]], "state_before": "case h\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : Set.Infinite {x | eval x p = eval x q}\n\u22a2 Set.Infinite {x | IsRoot (p - q) x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Hom/Defs.lean", "full_name": "RingHom.map_ite_zero_one", "start": [574, 1], "end": [576, 32], "traced_tactics": [{"tactic": "split_ifs with h <;> simp [h]", "annotated_tactic": ["split_ifs with h <;> simp [h]", []], "state_before": "F\u271d : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\nx\u271d\u00b9 : NonAssocSemiring \u03b1\nx\u271d : NonAssocSemiring \u03b2\nf\u271d : \u03b1 \u2192+* \u03b2\nx y : \u03b1\nF : Type u_5\ninst\u271d\u00b9 : RingHomClass F \u03b1 \u03b2\nf : F\np : Prop\ninst\u271d : Decidable p\n\u22a2 \u2191f (if p then 0 else 1) = if p then 0 else 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Sort.lean", "full_name": "List.sorted_cons", "start": [93, 1], "end": [94, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Basic.lean", "full_name": "smul_right_injective", "start": [671, 1], "end": [673, 100], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Int.cast_finsupp_sum", "start": [411, 1], "end": [413, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/CommRing.lean", "full_name": "MvPolynomial.vars_neg", "start": [111, 1], "end": [111, 69], "traced_tactics": [{"tactic": "simp [vars, degrees_neg]", "annotated_tactic": ["simp [<a>vars</a>, <a>degrees_neg</a>]", [{"full_name": "MvPolynomial.vars", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Variables.lean", "def_pos": [274, 5], "def_end_pos": [274, 9]}, {"full_name": "MvPolynomial.degrees_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/CommRing.lean", "def_pos": [97, 9], "def_end_pos": [97, 20]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommRing R\np q : MvPolynomial \u03c3 R\n\u22a2 vars (-p) = vars p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/CompleteLattice.lean", "full_name": "CompleteLatticeHom.coe_id", "start": [724, 1], "end": [725, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atBot_of_add_const_left", "start": [747, 1], "end": [749, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Fin.lean", "full_name": "Fin.prod_univ_seven", "start": [146, 1], "end": [149, 6], "traced_tactics": [{"tactic": "rw [prod_univ_castSucc, prod_univ_six]", "annotated_tactic": ["rw [<a>prod_univ_castSucc</a>, <a>prod_univ_six</a>]", [{"full_name": "Fin.prod_univ_castSucc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [91, 9], "def_end_pos": [91, 27]}, {"full_name": "Fin.prod_univ_six", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Fin.lean", "def_pos": [138, 9], "def_end_pos": [138, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 7 \u2192 \u03b2\n\u22a2 \u220f i : Fin 7, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 7 \u2192 \u03b2\n\u22a2 f (castSucc 0) * f (castSucc 1) * f (castSucc 2) * f (castSucc 3) * f (castSucc 4) * f (castSucc 5) * f (last 6) =\n    f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CommMonoid \u03b2\nf : Fin 7 \u2192 \u03b2\n\u22a2 f (castSucc 0) * f (castSucc 1) * f (castSucc 2) * f (castSucc 3) * f (castSucc 4) * f (castSucc 5) * f (last 6) =\n    f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.eval\u2082_sub", "start": [1275, 1], "end": [1277, 60], "traced_tactics": [{"tactic": "rw [sub_eq_add_neg, eval\u2082_add, eval\u2082_neg, sub_eq_add_neg]", "annotated_tactic": ["rw [<a>sub_eq_add_neg</a>, <a>eval\u2082_add</a>, <a>eval\u2082_neg</a>, <a>sub_eq_add_neg</a>]", [{"full_name": "sub_eq_add_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [975, 3], "def_end_pos": [975, 14]}, {"full_name": "Polynomial.eval\u2082_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [90, 9], "def_end_pos": [90, 18]}, {"full_name": "Polynomial.eval\u2082_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [1270, 9], "def_end_pos": [1270, 18]}, {"full_name": "sub_eq_add_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [975, 3], "def_end_pos": [975, 14]}]], "state_before": "R : Type u\nS\u271d : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Ring R\np q r : R[X]\nS : Type u_1\ninst\u271d : Ring S\nf : R \u2192+* S\nx : S\n\u22a2 eval\u2082 f x (p - q) = eval\u2082 f x p - eval\u2082 f x q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/Ring/Basic.lean", "full_name": "Mathlib.Tactic.Ring.cast_pos", "start": [838, 1], "end": [839, 23], "traced_tactics": [{"tactic": "simp [e]", "annotated_tactic": ["simp [e]", []], "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na : R\nn : \u2115\ne : a = \u2191n\n\u22a2 a = Nat.rawCast n + 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Group.lean", "full_name": "MulAction.surjective", "start": [156, 11], "end": [157, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.mem_roots'", "start": [600, 1], "end": [602, 57], "traced_tactics": [{"tactic": "classical\nrw [\u2190 count_pos, count_roots p, rootMultiplicity_pos']", "annotated_tactic": ["classical\n  rw [\u2190 <a>count_pos</a>, <a>count_roots</a> p, <a>rootMultiplicity_pos'</a>]", [{"full_name": "Multiset.count_pos", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2424, 9], "def_end_pos": [2424, 18]}, {"full_name": "Polynomial.count_roots", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [591, 9], "def_end_pos": [591, 20]}, {"full_name": "Polynomial.rootMultiplicity_pos'", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [617, 9], "def_end_pos": [617, 30]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\n\u22a2 a \u2208 roots p \u2194 p \u2260 0 \u2227 IsRoot p a", "state_after": "no goals"}, {"tactic": "rw [\u2190 count_pos, count_roots p, rootMultiplicity_pos']", "annotated_tactic": ["rw [\u2190 <a>count_pos</a>, <a>count_roots</a> p, <a>rootMultiplicity_pos'</a>]", [{"full_name": "Multiset.count_pos", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2424, 9], "def_end_pos": [2424, 18]}, {"full_name": "Polynomial.count_roots", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [591, 9], "def_end_pos": [591, 20]}, {"full_name": "Polynomial.rootMultiplicity_pos'", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [617, 9], "def_end_pos": [617, 30]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\n\u22a2 a \u2208 roots p \u2194 p \u2260 0 \u2227 IsRoot p a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.Nontrivial.not_subset_singleton", "start": [2574, 1], "end": [2575, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Coset.lean", "full_name": "QuotientGroup.rightRel_eq", "start": [385, 1], "end": [388, 25], "traced_tactics": [{"tactic": "simp only [eq_iff_iff]", "annotated_tactic": ["simp only [<a>eq_iff_iff</a>]", [{"full_name": "eq_iff_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [53, 17], "def_end_pos": [53, 27]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\ns : Subgroup \u03b1\n\u22a2 \u2200 (a b : \u03b1), Setoid.r a b = (b * a\u207b\u00b9 \u2208 s)", "state_after": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\ns : Subgroup \u03b1\n\u22a2 \u2200 (a b : \u03b1), Setoid.r a b \u2194 b * a\u207b\u00b9 \u2208 s"}, {"tactic": "apply rightRel_apply", "annotated_tactic": ["apply <a>rightRel_apply</a>", [{"full_name": "QuotientGroup.rightRel_apply", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Coset.lean", "def_pos": [374, 9], "def_end_pos": [374, 23]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\ns : Subgroup \u03b1\n\u22a2 \u2200 (a b : \u03b1), Setoid.r a b \u2194 b * a\u207b\u00b9 \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.addSubmonoid_closure_setOf_eq_monomial", "start": [839, 1], "end": [846, 48], "traced_tactics": [{"tactic": "apply top_unique", "annotated_tactic": ["apply <a>top_unique</a>", [{"full_name": "top_unique", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [161, 9], "def_end_pos": [161, 19]}]], "state_before": "R : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 AddSubmonoid.closure {p | \u2203 n a, p = \u2191(monomial n) a} = \u22a4", "state_after": "case h\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 \u22a4 \u2264 AddSubmonoid.closure {p | \u2203 n a, p = \u2191(monomial n) a}"}, {"tactic": "rw [\u2190 AddSubmonoid.map_equiv_top (toFinsuppIso R).symm.toAddEquiv, \u2190\n  Finsupp.add_closure_setOf_eq_single, AddMonoidHom.map_mclosure]", "annotated_tactic": ["rw [\u2190 <a>AddSubmonoid.map_equiv_top</a> (<a>toFinsuppIso</a> R).symm.toAddEquiv, \u2190\n    <a>Finsupp.add_closure_setOf_eq_single</a>, <a>AddMonoidHom.map_mclosure</a>]", [{"full_name": "AddSubmonoid.map_equiv_top", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [954, 3], "def_end_pos": [954, 14]}, {"full_name": "Polynomial.toFinsuppIso", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [373, 5], "def_end_pos": [373, 17]}, {"full_name": "Finsupp.add_closure_setOf_eq_single", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1127, 9], "def_end_pos": [1127, 36]}, {"full_name": "AddMonoidHom.map_mclosure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Operations.lean", "def_pos": [1091, 3], "def_end_pos": [1091, 14]}]], "state_before": "case h\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 \u22a4 \u2264 AddSubmonoid.closure {p | \u2203 n a, p = \u2191(monomial n) a}", "state_after": "case h\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 AddSubmonoid.closure\n      (\u2191(AddEquiv.toAddMonoidHom (RingEquiv.toAddEquiv (RingEquiv.symm (toFinsuppIso R)))) ''\n        {f | \u2203 a b, f = fun\u2080 | a => b}) \u2264\n    AddSubmonoid.closure {p | \u2203 n a, p = \u2191(monomial n) a}"}, {"tactic": "refine' AddSubmonoid.closure_mono (Set.image_subset_iff.2 _)", "annotated_tactic": ["refine' <a>AddSubmonoid.closure_mono</a> (<a>Set.image_subset_iff</a>.2 _)", [{"full_name": "AddSubmonoid.closure_mono", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [424, 3], "def_end_pos": [424, 14]}, {"full_name": "Set.image_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [497, 9], "def_end_pos": [497, 25]}]], "state_before": "case h\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 AddSubmonoid.closure\n      (\u2191(AddEquiv.toAddMonoidHom (RingEquiv.toAddEquiv (RingEquiv.symm (toFinsuppIso R)))) ''\n        {f | \u2203 a b, f = fun\u2080 | a => b}) \u2264\n    AddSubmonoid.closure {p | \u2203 n a, p = \u2191(monomial n) a}", "state_after": "case h\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 {f | \u2203 a b, f = fun\u2080 | a => b} \u2286\n    \u2191(AddEquiv.toAddMonoidHom (RingEquiv.toAddEquiv (RingEquiv.symm (toFinsuppIso R)))) \u207b\u00b9'\n      {p | \u2203 n a, p = \u2191(monomial n) a}"}, {"tactic": "rintro _ \u27e8n, a, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8n, a, rfl\u27e9", []], "state_before": "case h\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u22a2 {f | \u2203 a b, f = fun\u2080 | a => b} \u2286\n    \u2191(AddEquiv.toAddMonoidHom (RingEquiv.toAddEquiv (RingEquiv.symm (toFinsuppIso R)))) \u207b\u00b9'\n      {p | \u2203 n a, p = \u2191(monomial n) a}", "state_after": "case h.intro.intro\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q : R[X]\nn : \u2115\na : R\n\u22a2 (fun\u2080 | n => a) \u2208\n    \u2191(AddEquiv.toAddMonoidHom (RingEquiv.toAddEquiv (RingEquiv.symm (toFinsuppIso R)))) \u207b\u00b9'\n      {p | \u2203 n a, p = \u2191(monomial n) a}"}, {"tactic": "exact \u27e8n, a, Polynomial.ofFinsupp_single _ _\u27e9", "annotated_tactic": ["exact \u27e8n, a, <a>Polynomial.ofFinsupp_single</a> _ _\u27e9", [{"full_name": "Polynomial.ofFinsupp_single", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [443, 9], "def_end_pos": [443, 25]}]], "state_before": "case h.intro.intro\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q : R[X]\nn : \u2115\na : R\n\u22a2 (fun\u2080 | n => a) \u2208\n    \u2191(AddEquiv.toAddMonoidHom (RingEquiv.toAddEquiv (RingEquiv.symm (toFinsuppIso R)))) \u207b\u00b9'\n      {p | \u2203 n a, p = \u2191(monomial n) a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.min'_lt_of_mem_erase_min'", "start": [1583, 1], "end": [1585, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Pairwise.lean", "full_name": "Set.Pairwise.eq", "start": [73, 11], "end": [74, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "full_name": "Polynomial.natDegree_comp_le", "start": [37, 1], "end": [61, 36], "traced_tactics": [{"tactic": "rw [h0, natDegree_zero]", "annotated_tactic": ["rw [h0, <a>natDegree_zero</a>]", [{"full_name": "Polynomial.natDegree_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [106, 9], "def_end_pos": [106, 23]}]], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nthis : DecidableEq R := Classical.decEq R\nh0 : comp p q = 0\n\u22a2 natDegree (comp p q) \u2264 natDegree p * natDegree q", "state_after": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nthis : DecidableEq R := Classical.decEq R\nh0 : comp p q = 0\n\u22a2 0 \u2264 natDegree p * natDegree q"}, {"tactic": "exact Nat.zero_le _", "annotated_tactic": ["exact <a>Nat.zero_le</a> _", [{"full_name": "Nat.zero_le", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1578, 9], "def_end_pos": [1578, 20]}]], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nthis : DecidableEq R := Classical.decEq R\nh0 : comp p q = 0\n\u22a2 0 \u2264 natDegree p * natDegree q", "state_after": "no goals"}, {"tactic": "rw [natDegree_C, Nat.cast_zero, zero_add, nsmul_eq_mul]", "annotated_tactic": ["rw [<a>natDegree_C</a>, <a>Nat.cast_zero</a>, <a>zero_add</a>, <a>nsmul_eq_mul</a>]", [{"full_name": "Polynomial.natDegree_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [265, 9], "def_end_pos": [265, 20]}, {"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}, {"full_name": "zero_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [463, 3], "def_end_pos": [463, 14]}, {"full_name": "nsmul_eq_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [509, 9], "def_end_pos": [509, 21]}]], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nthis : DecidableEq R := Classical.decEq R\nh0 : \u00accomp p q = 0\nn : \u2115\nhn : n \u2208 support p\n\u22a2 \u2191(natDegree (\u2191C (coeff p n))) + n \u2022 \u2191(natDegree q) = \u2191(n * natDegree q)", "state_after": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nthis : DecidableEq R := Classical.decEq R\nh0 : \u00accomp p q = 0\nn : \u2115\nhn : n \u2208 support p\n\u22a2 \u2191n * \u2191(natDegree q) = \u2191(n * natDegree q)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nthis : DecidableEq R := Classical.decEq R\nh0 : \u00accomp p q = 0\nn : \u2115\nhn : n \u2208 support p\n\u22a2 \u2191n * \u2191(natDegree q) = \u2191(n * natDegree q)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidWithZeroHom.toZeroHom_coe", "start": [623, 1], "end": [624, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/Lemmas.lean", "full_name": "Std.RBNode.Stream.toList_nil", "start": [403, 9], "end": [403, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Finite.lean", "full_name": "Nat.card_sum", "start": [101, 1], "end": [104, 55], "traced_tactics": [{"tactic": "have := Fintype.ofFinite \u03b1", "annotated_tactic": ["have := <a>Fintype.ofFinite</a> \u03b1", [{"full_name": "Fintype.ofFinite", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [448, 19], "def_end_pos": [448, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"tactic": "have := Fintype.ofFinite \u03b2", "annotated_tactic": ["have := <a>Fintype.ofFinite</a> \u03b2", [{"full_name": "Fintype.ofFinite", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [448, 19], "def_end_pos": [448, 35]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"}, {"tactic": "simp_rw [Nat.card_eq_fintype_card, Fintype.card_sum]", "annotated_tactic": ["simp_rw [<a>Nat.card_eq_fintype_card</a>, <a>Fintype.card_sum</a>]", [{"full_name": "Nat.card_eq_fintype_card", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Finite.lean", "def_pos": [42, 9], "def_end_pos": [42, 29]}, {"full_name": "Fintype.card_sum", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Sum.lean", "def_pos": [36, 9], "def_end_pos": [36, 25]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diag_map", "start": [714, 1], "end": [715, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image_image2_distrib_right", "start": [363, 1], "end": [366, 62], "traced_tactics": [{"tactic": "rw [image_id']", "annotated_tactic": ["rw [<a>image_id'</a>]", [{"full_name": "Set.image_id'", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [396, 9], "def_end_pos": [396, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf f'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g'\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\ng : \u03b3 \u2192 \u03b4\nf' : \u03b1 \u2192 \u03b2' \u2192 \u03b4\ng' : \u03b2 \u2192 \u03b2'\nh_distrib : \u2200 (a : \u03b1) (b : \u03b2), g (f a b) = f' a (g' b)\n\u22a2 image2 f' ((fun a => a) '' s) ((fun b => g' b) '' t) = image2 f' s (g' '' t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.monoidHom_ext", "start": [541, 1], "end": [543, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/LinearMap.lean", "full_name": "LinearMap.comp_apply", "start": [549, 1], "end": [550, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_subtype_eq_finprod_cond", "start": [1024, 1], "end": [1026, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Sort.lean", "full_name": "List.Sorted.rel_nthLe_of_le", "start": [146, 1], "end": [148, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "IsLUB.dual", "start": [161, 1], "end": [162, 4], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.image2_iInter_subset_left", "start": [2040, 1], "end": [2043, 55], "traced_tactics": [{"tactic": "simp_rw [image2_subset_iff, mem_iInter]", "annotated_tactic": ["simp_rw [<a>image2_subset_iff</a>, <a>mem_iInter</a>]", [{"full_name": "Set.image2_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [83, 9], "def_end_pos": [83, 26]}, {"full_name": "Set.mem_iInter", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [207, 9], "def_end_pos": [207, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 image2 f (\u22c2 i, s i) t \u2286 \u22c2 i, image2 f (s i) t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 \u2200 (x : \u03b1), (\u2200 (i : \u03b9), x \u2208 s i) \u2192 \u2200 y \u2208 t, \u2200 (i : \u03b9), f x y \u2208 image2 f (s i) t"}, {"tactic": "exact fun x hx y hy i => mem_image2_of_mem (hx _) hy", "annotated_tactic": ["exact fun x hx y hy i => <a>mem_image2_of_mem</a> (hx _) hy", [{"full_name": "Set.mem_image2_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [44, 9], "def_end_pos": [44, 26]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\n\u03b9\u2082 : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba\u2081 : \u03b9 \u2192 Sort u_8\n\u03ba\u2082 : \u03b9 \u2192 Sort u_9\n\u03ba' : \u03b9' \u2192 Sort u_10\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns\u271d : Set \u03b1\nt\u271d : Set \u03b2\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 \u2200 (x : \u03b1), (\u2200 (i : \u03b9), x \u2208 s i) \u2192 \u2200 y \u2208 t, \u2200 (i : \u03b9), f x y \u2208 image2 f (s i) t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "full_name": "Multiset.sum_map_mul_left", "start": [336, 1], "end": [337, 72], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\na : \u03b1\ns : Multiset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 sum (map (fun i => a * f i) 0) = a * sum (map f 0)", "state_after": "no goals"}, {"tactic": "simp [ih, mul_add]", "annotated_tactic": ["simp [ih, <a>mul_add</a>]", [{"full_name": "mul_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\na : \u03b1\ns\u271d : Multiset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Multiset \u03b9\nih : sum (map (fun i => a * f i) s) = a * sum (map f s)\n\u22a2 sum (map (fun i => a * f i) (i ::\u2098 s)) = a * sum (map f (i ::\u2098 s))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.span_eq_bot", "start": [539, 1], "end": [542, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.pairwise_disjoint_powersetCard", "start": [279, 1], "end": [282, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Option/Basic.lean", "full_name": "Option.some_orElse'", "start": [282, 1], "end": [283, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "compl_lt_self", "start": [701, 9], "end": [702, 38], "traced_tactics": [{"tactic": "simpa using lt_compl_self (a := x\u1d9c)", "annotated_tactic": ["simpa using <a>lt_compl_self</a> (a := x\u1d9c)", [{"full_name": "lt_compl_self", "def_path": "lake-packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [906, 17], "def_end_pos": [906, 30]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d\u00b9 : BooleanAlgebra \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 x\u1d9c < x \u2194 x = \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/IterateHom.lean", "full_name": "MonoidHom.iterate_map_zpow", "start": [80, 1], "end": [81, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "Submodule.prod_map_fst", "start": [576, 1], "end": [577, 47], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 map (fst R M M\u2082) (prod p q) = p", "state_after": "case h\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\n\u22a2 x \u2208 map (fst R M M\u2082) (prod p q) \u2194 x \u2208 p"}, {"tactic": "simp [(\u27e80, zero_mem _\u27e9 : \u2203 x, x \u2208 q)]", "annotated_tactic": ["simp [(\u27e80, <a>zero_mem</a> _\u27e9 : \u2203 x, x \u2208 q)]", [{"full_name": "ZeroMemClass.zero_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}]], "state_before": "case h\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\n\u22a2 x \u2208 map (fst R M M\u2082) (prod p q) \u2194 x \u2208 p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pi.lean", "full_name": "Finset.Pi.cons_injective", "start": [74, 1], "end": [83, 13], "traced_tactics": [{"tactic": "simpa only [Multiset.mem_cons, mem_insert] using h", "annotated_tactic": ["simpa only [<a>Multiset.mem_cons</a>, <a>mem_insert</a>] using h", [{"full_name": "Multiset.mem_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 17]}, {"full_name": "Finset.mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1099, 9], "def_end_pos": [1099, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b4 a\ns : Finset \u03b1\nhs : a \u2209 s\ne\u2081 e\u2082 : (a : \u03b1) \u2192 a \u2208 s \u2192 \u03b4 a\neq : cons s a b e\u2081 = cons s a b e\u2082\ne : \u03b1\nh : e \u2208 a ::\u2098 s.val\n\u22a2 e \u2208 insert a s", "state_after": "no goals"}, {"tactic": "rw [eq]", "annotated_tactic": ["rw [eq]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u\n\u03b4 : \u03b1 \u2192 Sort v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nb : \u03b4 a\ns : Finset \u03b1\nhs : a \u2209 s\ne\u2081 e\u2082 : (a : \u03b1) \u2192 a \u2208 s \u2192 \u03b4 a\neq : cons s a b e\u2081 = cons s a b e\u2082\ne : \u03b1\nh : e \u2208 a ::\u2098 s.val\n\u22a2 cons s a b e\u2081 e (_ : e \u2208 insert a s) = cons s a b e\u2082 e (_ : e \u2208 insert a s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.toArray_data", "start": [37, 9], "end": [38, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iic_diff_Iio_same", "start": [849, 1], "end": [850, 86], "traced_tactics": [{"tactic": "rw [\u2190 Iic_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 right_mem_Iic)]", "annotated_tactic": ["rw [\u2190 <a>Iic_diff_right</a>, <a>diff_diff_cancel_left</a> (<a>singleton_subset_iff</a>.2 <a>right_mem_Iic</a>)]", [{"full_name": "Set.Iic_diff_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [813, 9], "def_end_pos": [813, 23]}, {"full_name": "Set.diff_diff_cancel_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2090, 9], "def_end_pos": [2090, 30]}, {"full_name": "Set.singleton_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1323, 9], "def_end_pos": [1323, 29]}, {"full_name": "Set.right_mem_Iic", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [222, 9], "def_end_pos": [222, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b c : \u03b1\n\u22a2 Iic a \\ Iio a = {a}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean", "full_name": "Polynomial.natDegree_list_prod_le", "start": [76, 1], "end": [79, 62], "traced_tactics": [{"tactic": "induction' l with hd tl IH", "annotated_tactic": ["induction' l with hd tl IH", []], "state_before": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\nS : Type u_1\ninst\u271d : Semiring S\nl : List S[X]\n\u22a2 natDegree (List.prod l) \u2264 List.sum (List.map natDegree l)", "state_after": "case nil\nR : Type u\n\u03b9 : Type w\ns : Finset \u03b9\nS : Type u_1\ninst\u271d : Semiring S\n\u22a2 natDegree (List.prod []) \u2264 List.sum (List.map natDegree [])\n\ncase cons\nR : Type u\n\u03b9 : Type w\ns : Finset \u03b9\nS : Type u_1\ninst\u271d : Semiring S\nhd : S[X]\ntl : List S[X]\nIH : natDegree (List.prod tl) \u2264 List.sum (List.map natDegree tl)\n\u22a2 natDegree (List.prod (hd :: tl)) \u2264 List.sum (List.map natDegree (hd :: tl))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\nR : Type u\n\u03b9 : Type w\ns : Finset \u03b9\nS : Type u_1\ninst\u271d : Semiring S\n\u22a2 natDegree (List.prod []) \u2264 List.sum (List.map natDegree [])", "state_after": "no goals"}, {"tactic": "simpa using natDegree_mul_le.trans (add_le_add_left IH _)", "annotated_tactic": ["simpa using natDegree_mul_le.trans (<a>add_le_add_left</a> IH _)", [{"full_name": "add_le_add_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [49, 15], "def_end_pos": [49, 30]}]], "state_before": "case cons\nR : Type u\n\u03b9 : Type w\ns : Finset \u03b9\nS : Type u_1\ninst\u271d : Semiring S\nhd : S[X]\ntl : List S[X]\nIH : natDegree (List.prod tl) \u2264 List.sum (List.map natDegree tl)\n\u22a2 natDegree (List.prod (hd :: tl)) \u2264 List.sum (List.map natDegree (hd :: tl))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.swap_apply_self", "start": [1703, 1], "end": [1704, 62], "traced_tactics": [{"tactic": "rw [\u2190 Equiv.trans_apply, Equiv.swap_swap, Equiv.refl_apply]", "annotated_tactic": ["rw [\u2190 <a>Equiv.trans_apply</a>, <a>Equiv.swap_swap</a>, <a>Equiv.refl_apply</a>]", [{"full_name": "Equiv.trans_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [272, 17], "def_end_pos": [272, 28]}, {"full_name": "Equiv.swap_swap", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1655, 9], "def_end_pos": [1655, 18]}, {"full_name": "Equiv.refl_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Defs.lean", "def_pos": [264, 17], "def_end_pos": [264, 27]}]], "state_before": "\u03b1 : Sort u_1\ninst\u271d : DecidableEq \u03b1\ni j a : \u03b1\n\u22a2 \u2191(swap i j) (\u2191(swap i j) a) = a", "state_after": "no goals"}]}, {"url": "https://github.com/Moyvbai/Theorem", "commit": "2fad0ff51bf93233afcde842768074b0c8b33efa", "file_path": "Theorem/example_separate/Ico_choose_range_choose.lean", "full_name": "Ico_choose_range_choose", "start": [9, 1], "end": [14, 11], "traced_tactics": [{"tactic": "have sum_choose_sub_eq_add_sub : \u2211 k in range (n + 1), choose (2 * n) k - (choose (2 * n) n) = (\u2211 k in range n, choose (2 * n) k) + (choose (2 * n) n) - (choose (2 * n) n) := by rw[Finset.sum_range_succ]", "annotated_tactic": ["have sum_choose_sub_eq_add_sub : \u2211 k in <a>range</a> (n + 1), <a>choose</a> (2 * n) k - (<a>choose</a> (2 * n) n) = (\u2211 k in <a>range</a> n, <a>choose</a> (2 * n) k) + (<a>choose</a> (2 * n) n) - (<a>choose</a> (2 * n) n) := by rw[<a>Finset.sum_range_succ</a>]", [{"full_name": "Finset.range", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3050, 5], "def_end_pos": [3050, 10]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Finset.range", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3050, 5], "def_end_pos": [3050, 10]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Finset.sum_range_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1225, 3], "def_end_pos": [1225, 14]}]], "state_before": "n : \u2115\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k =\n    \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n", "state_after": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k =\n    \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n"}, {"tactic": "rw[\u2190 sum_choose_eq_Ico]", "annotated_tactic": ["rw[\u2190 <a>sum_choose_eq_Ico</a>]", [{"full_name": "sum_choose_eq_Ico", "def_path": "Theorem/example_separate/sum_choose_eq_Ico.lean", "def_pos": [10, 9], "def_end_pos": [10, 26]}]], "state_before": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 \u2211 k in Ico (n + 1) (2 * n + 1), Nat.choose (2 * n) k =\n    \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n", "state_after": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 \u2211 k in range n, Nat.choose (2 * n) k = \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n\n\nn : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 n \u2264 2 * n"}, {"tactic": "simp at sum_choose_sub_eq_add_sub", "annotated_tactic": ["simp at sum_choose_sub_eq_add_sub", []], "state_before": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 \u2211 k in range n, Nat.choose (2 * n) k = \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n\n\nn : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 n \u2264 2 * n", "state_after": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n = \u2211 k in range n, Nat.choose (2 * n) k\n\u22a2 \u2211 k in range n, Nat.choose (2 * n) k = \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n\n\nn : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 n \u2264 2 * n"}, {"tactic": "rw[sum_choose_sub_eq_add_sub]", "annotated_tactic": ["rw[sum_choose_sub_eq_add_sub]", []], "state_before": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n = \u2211 k in range n, Nat.choose (2 * n) k\n\u22a2 \u2211 k in range n, Nat.choose (2 * n) k = \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n\n\nn : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 n \u2264 2 * n", "state_after": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 n \u2264 2 * n"}, {"tactic": "linarith", "annotated_tactic": ["linarith", []], "state_before": "n : \u2115\nsum_choose_sub_eq_add_sub :\n  \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n\n\u22a2 n \u2264 2 * n", "state_after": "no goals"}, {"tactic": "rw[Finset.sum_range_succ]", "annotated_tactic": ["rw[<a>Finset.sum_range_succ</a>]", [{"full_name": "Finset.sum_range_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1225, 3], "def_end_pos": [1225, 14]}]], "state_before": "n : \u2115\n\u22a2 \u2211 k in range (n + 1), Nat.choose (2 * n) k - Nat.choose (2 * n) n =\n    \u2211 k in range n, Nat.choose (2 * n) k + Nat.choose (2 * n) n - Nat.choose (2 * n) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "full_name": "RingHom.coe_restrict_apply", "start": [1172, 1], "end": [1174, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "Ideal.quotientMap_injective'", "start": [517, 1], "end": [522, 44], "traced_tactics": [{"tactic": "refine' (injective_iff_map_eq_zero (quotientMap I f H)).2 fun a ha => _", "annotated_tactic": ["refine' (<a>injective_iff_map_eq_zero</a> (<a>quotientMap</a> I f H)).2 fun a ha => _", [{"full_name": "injective_iff_map_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Basic.lean", "def_pos": [145, 3], "def_end_pos": [145, 14]}, {"full_name": "Ideal.quotientMap", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [454, 5], "def_end_pos": [454, 16]}]], "state_before": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\u2081\ninst\u271d\u2075 : CommSemiring R\u2082\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R\u2081 A\ninst\u271d\u00b9 : Algebra R\u2082 A\ninst\u271d : Algebra R\u2081 B\nJ : Ideal R\nI : Ideal S\nf : R \u2192+* S\nH : J \u2264 comap f I\nh : comap f I \u2264 J\n\u22a2 Injective \u2191(quotientMap I f H)", "state_after": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\u2081\ninst\u271d\u2075 : CommSemiring R\u2082\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R\u2081 A\ninst\u271d\u00b9 : Algebra R\u2082 A\ninst\u271d : Algebra R\u2081 B\nJ : Ideal R\nI : Ideal S\nf : R \u2192+* S\nH : J \u2264 comap f I\nh : comap f I \u2264 J\na : R \u29f8 J\nha : \u2191(quotientMap I f H) a = 0\n\u22a2 a = 0"}, {"tactic": "obtain \u27e8r, rfl\u27e9 := Quotient.mk_surjective a", "annotated_tactic": ["obtain \u27e8r, rfl\u27e9 := <a>Quotient.mk_surjective</a> a", [{"full_name": "Ideal.Quotient.mk_surjective", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [160, 9], "def_end_pos": [160, 22]}]], "state_before": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\u2081\ninst\u271d\u2075 : CommSemiring R\u2082\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R\u2081 A\ninst\u271d\u00b9 : Algebra R\u2082 A\ninst\u271d : Algebra R\u2081 B\nJ : Ideal R\nI : Ideal S\nf : R \u2192+* S\nH : J \u2264 comap f I\nh : comap f I \u2264 J\na : R \u29f8 J\nha : \u2191(quotientMap I f H) a = 0\n\u22a2 a = 0", "state_after": "case intro\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\u2081\ninst\u271d\u2075 : CommSemiring R\u2082\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R\u2081 A\ninst\u271d\u00b9 : Algebra R\u2082 A\ninst\u271d : Algebra R\u2081 B\nJ : Ideal R\nI : Ideal S\nf : R \u2192+* S\nH : J \u2264 comap f I\nh : comap f I \u2264 J\nr : R\nha : \u2191(quotientMap I f H) (\u2191(Quotient.mk J) r) = 0\n\u22a2 \u2191(Quotient.mk J) r = 0"}, {"tactic": "rw [quotientMap_mk, Quotient.eq_zero_iff_mem] at ha", "annotated_tactic": ["rw [<a>quotientMap_mk</a>, <a>Quotient.eq_zero_iff_mem</a>] at ha", [{"full_name": "Ideal.quotientMap_mk", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [460, 9], "def_end_pos": [460, 23]}, {"full_name": "Ideal.Quotient.eq_zero_iff_mem", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [129, 9], "def_end_pos": [129, 24]}]], "state_before": "case intro\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\u2081\ninst\u271d\u2075 : CommSemiring R\u2082\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R\u2081 A\ninst\u271d\u00b9 : Algebra R\u2082 A\ninst\u271d : Algebra R\u2081 B\nJ : Ideal R\nI : Ideal S\nf : R \u2192+* S\nH : J \u2264 comap f I\nh : comap f I \u2264 J\nr : R\nha : \u2191(quotientMap I f H) (\u2191(Quotient.mk J) r) = 0\n\u22a2 \u2191(Quotient.mk J) r = 0", "state_after": "case intro\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\u2081\ninst\u271d\u2075 : CommSemiring R\u2082\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R\u2081 A\ninst\u271d\u00b9 : Algebra R\u2082 A\ninst\u271d : Algebra R\u2081 B\nJ : Ideal R\nI : Ideal S\nf : R \u2192+* S\nH : J \u2264 comap f I\nh : comap f I \u2264 J\nr : R\nha : \u2191f r \u2208 I\n\u22a2 \u2191(Quotient.mk J) r = 0"}, {"tactic": "exact Quotient.eq_zero_iff_mem.mpr (h ha)", "annotated_tactic": ["exact Quotient.eq_zero_iff_mem.mpr (h ha)", []], "state_before": "case intro\nR : Type u\nS : Type v\nF : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : CommRing S\nR\u2081 : Type u_1\nR\u2082 : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\u2081\ninst\u271d\u2075 : CommSemiring R\u2082\ninst\u271d\u2074 : CommRing A\ninst\u271d\u00b3 : CommRing B\ninst\u271d\u00b2 : Algebra R\u2081 A\ninst\u271d\u00b9 : Algebra R\u2082 A\ninst\u271d : Algebra R\u2081 B\nJ : Ideal R\nI : Ideal S\nf : R \u2192+* S\nH : J \u2264 comap f I\nh : comap f I \u2264 J\nr : R\nha : \u2191f r \u2208 I\n\u22a2 \u2191(Quotient.mk J) r = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean", "full_name": "Finset.prod_Ico_succ_div_top", "start": [248, 1], "end": [250, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "add_one_le_two_mul", "start": [122, 1], "end": [126, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.total_eq_fintype_total_apply", "start": [1083, 1], "end": [1089, 24], "traced_tactics": [{"tactic": "apply Finset.sum_subset", "annotated_tactic": ["apply <a>Finset.sum_subset</a>", [{"full_name": "Finset.sum_subset", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [750, 3], "def_end_pos": [750, 14]}]], "state_before": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx : \u03b1 \u2192 R\n\u22a2 \u2191(Finsupp.total \u03b1 M R v) (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x) = \u2191(\u2191(Fintype.total R S) v) x", "state_after": "case h\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx : \u03b1 \u2192 R\n\u22a2 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x).support \u2286 Finset.univ\n\ncase hf\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx : \u03b1 \u2192 R\n\u22a2 \u2200 x_1 \u2208 Finset.univ,\n    x_1 \u2209 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x).support \u2192\n      (fun i => \u2191((fun i => smulRight LinearMap.id (v i)) i)) x_1\n          (\u2191(\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x) x_1) =\n        0"}, {"tactic": "exact Finset.subset_univ _", "annotated_tactic": ["exact <a>Finset.subset_univ</a> _", [{"full_name": "Finset.subset_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [124, 9], "def_end_pos": [124, 20]}]], "state_before": "case h\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx : \u03b1 \u2192 R\n\u22a2 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x).support \u2286 Finset.univ", "state_after": "no goals"}, {"tactic": "intro x _ hx", "annotated_tactic": ["intro x _ hx", []], "state_before": "case hf\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx : \u03b1 \u2192 R\n\u22a2 \u2200 x_1 \u2208 Finset.univ,\n    x_1 \u2209 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x).support \u2192\n      (fun i => \u2191((fun i => smulRight LinearMap.id (v i)) i)) x_1\n          (\u2191(\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x) x_1) =\n        0", "state_after": "case hf\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx\u271d : \u03b1 \u2192 R\nx : \u03b1\na\u271d : x \u2208 Finset.univ\nhx : x \u2209 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x\u271d).support\n\u22a2 (fun i => \u2191((fun i => smulRight LinearMap.id (v i)) i)) x\n      (\u2191(\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x\u271d) x) =\n    0"}, {"tactic": "rw [Finsupp.not_mem_support_iff.mp hx]", "annotated_tactic": ["rw [Finsupp.not_mem_support_iff.mp hx]", []], "state_before": "case hf\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx\u271d : \u03b1 \u2192 R\nx : \u03b1\na\u271d : x \u2208 Finset.univ\nhx : x \u2209 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x\u271d).support\n\u22a2 (fun i => \u2191((fun i => smulRight LinearMap.id (v i)) i)) x\n      (\u2191(\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x\u271d) x) =\n    0", "state_after": "case hf\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx\u271d : \u03b1 \u2192 R\nx : \u03b1\na\u271d : x \u2208 Finset.univ\nhx : x \u2209 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x\u271d).support\n\u22a2 (fun i => \u2191((fun i => smulRight LinearMap.id (v i)) i)) x 0 = 0"}, {"tactic": "exact zero_smul _ _", "annotated_tactic": ["exact <a>zero_smul</a> _ _", [{"full_name": "zero_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/SMulWithZero.lean", "def_pos": [70, 9], "def_end_pos": [70, 18]}]], "state_before": "case hf\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d\u2076 : Fintype \u03b1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\nS : Type u_4\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S M\ninst\u271d : SMulCommClass R S M\nv : \u03b1 \u2192 M\nx\u271d : \u03b1 \u2192 R\nx : \u03b1\na\u271d : x \u2208 Finset.univ\nhx : x \u2209 (\u2191(LinearEquiv.symm (linearEquivFunOnFinite R R \u03b1)) x\u271d).support\n\u22a2 (fun i => \u2191((fun i => smulRight LinearMap.id (v i)) i)) x 0 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Relation.lean", "full_name": "Relation.iff_comp", "start": [149, 1], "end": [151, 21], "traced_tactics": [{"tactic": "rw [this, eq_comp]", "annotated_tactic": ["rw [this, <a>eq_comp</a>]", [{"full_name": "Relation.eq_comp", "def_path": "lake-packages/mathlib/Mathlib/Logic/Relation.lean", "def_pos": [144, 9], "def_end_pos": [144, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b2 \u2192 \u03b3 \u2192 Prop\nq : \u03b3 \u2192 \u03b4 \u2192 Prop\nr : Prop \u2192 \u03b1 \u2192 Prop\nthis : (fun x x_1 => x \u2194 x_1) = fun x x_1 => x = x_1\n\u22a2 (fun x x_1 => x \u2194 x_1) \u2218r r = r", "state_after": "no goals"}, {"tactic": "funext a b", "annotated_tactic": ["funext a b", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b2 \u2192 \u03b3 \u2192 Prop\nq : \u03b3 \u2192 \u03b4 \u2192 Prop\nr : Prop \u2192 \u03b1 \u2192 Prop\n\u22a2 (fun x x_1 => x \u2194 x_1) = fun x x_1 => x = x_1", "state_after": "case h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b2 \u2192 \u03b3 \u2192 Prop\nq : \u03b3 \u2192 \u03b4 \u2192 Prop\nr : Prop \u2192 \u03b1 \u2192 Prop\na b : Prop\n\u22a2 (a \u2194 b) = (a = b)"}, {"tactic": "exact iff_eq_eq", "annotated_tactic": ["exact <a>iff_eq_eq</a>", [{"full_name": "iff_eq_eq", "def_path": "lake-packages/mathlib/Mathlib/Init/Propext.lean", "def_pos": [34, 9], "def_end_pos": [34, 18]}]], "state_before": "case h.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nr\u271d : \u03b1 \u2192 \u03b2 \u2192 Prop\np : \u03b2 \u2192 \u03b3 \u2192 Prop\nq : \u03b3 \u2192 \u03b4 \u2192 Prop\nr : Prop \u2192 \u03b1 \u2192 Prop\na b : Prop\n\u22a2 (a \u2194 b) = (a = b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.lt_sub_one_iff", "start": [1268, 1], "end": [1275, 46], "traced_tactics": [{"tactic": "rcases k with \u27e8_ | k, hk\u27e9", "annotated_tactic": ["rcases k with \u27e8_ | k, hk\u27e9", []], "state_before": "n\u271d m n : \u2115\nk : Fin (n + 2)\n\u22a2 k < k - 1 \u2194 k = 0", "state_after": "case mk.zero\nn\u271d m n : \u2115\nhk : zero < n + 2\n\u22a2 { val := zero, isLt := hk } < { val := zero, isLt := hk } - 1 \u2194 { val := zero, isLt := hk } = 0\n\ncase mk.succ\nn\u271d m n k : \u2115\nhk : Nat.succ k < n + 2\n\u22a2 { val := Nat.succ k, isLt := hk } < { val := Nat.succ k, isLt := hk } - 1 \u2194 { val := Nat.succ k, isLt := hk } = 0"}, {"tactic": "simp only [zero_eq, zero_eta, zero_sub, lt_iff_val_lt_val, val_zero, coe_neg_one, add_pos_iff,\n  or_true]", "annotated_tactic": ["simp only [<a>zero_eq</a>, <a>zero_eta</a>, <a>zero_sub</a>, <a>lt_iff_val_lt_val</a>, <a>val_zero</a>, <a>coe_neg_one</a>, <a>add_pos_iff</a>,\n    <a>or_true</a>]", [{"full_name": "Nat.zero_eq", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [83, 17], "def_end_pos": [83, 24]}, {"full_name": "Fin.zero_eta", "def_path": "lake-packages/std/Std/Data/Fin/Init/Lemmas.lean", "def_pos": [7, 17], "def_end_pos": [7, 29]}, {"full_name": "zero_sub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [317, 3], "def_end_pos": [317, 14]}, {"full_name": "Fin.lt_iff_val_lt_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [215, 9], "def_end_pos": [215, 26]}, {"full_name": "Fin.val_zero", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [106, 17], "def_end_pos": [106, 25]}, {"full_name": "Fin.coe_neg_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [1225, 9], "def_end_pos": [1225, 20]}, {"full_name": "add_pos_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [255, 30], "def_end_pos": [255, 41]}, {"full_name": "or_true", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [94, 17], "def_end_pos": [94, 24]}]], "state_before": "case mk.zero\nn\u271d m n : \u2115\nhk : zero < n + 2\n\u22a2 { val := zero, isLt := hk } < { val := zero, isLt := hk } - 1 \u2194 { val := zero, isLt := hk } = 0\n\ncase mk.succ\nn\u271d m n k : \u2115\nhk : Nat.succ k < n + 2\n\u22a2 { val := Nat.succ k, isLt := hk } < { val := Nat.succ k, isLt := hk } - 1 \u2194 { val := Nat.succ k, isLt := hk } = 0", "state_after": "case mk.succ\nn\u271d m n k : \u2115\nhk : Nat.succ k < n + 2\n\u22a2 { val := Nat.succ k, isLt := hk } < { val := Nat.succ k, isLt := hk } - 1 \u2194 { val := Nat.succ k, isLt := hk } = 0"}, {"tactic": "have : (k + 1 + (n + 1)) % (n + 2) = k % (n + 2) := by\n  rw [add_right_comm, add_assoc, add_mod_right]", "annotated_tactic": ["have : (k + 1 + (n + 1)) % (n + 2) = k % (n + 2) := by\n    rw [<a>add_right_comm</a>, <a>add_assoc</a>, <a>add_mod_right</a>]", [{"full_name": "add_right_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [101, 3], "def_end_pos": [101, 14]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}, {"full_name": "Nat.add_mod_right", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [909, 17], "def_end_pos": [909, 30]}]], "state_before": "case mk.succ\nn\u271d m n k : \u2115\nhk : Nat.succ k < n + 2\n\u22a2 { val := Nat.succ k, isLt := hk } < { val := Nat.succ k, isLt := hk } - 1 \u2194 { val := Nat.succ k, isLt := hk } = 0", "state_after": "case mk.succ\nn\u271d m n k : \u2115\nhk : Nat.succ k < n + 2\nthis : (k + 1 + (n + 1)) % (n + 2) = k % (n + 2)\n\u22a2 { val := Nat.succ k, isLt := hk } < { val := Nat.succ k, isLt := hk } - 1 \u2194 { val := Nat.succ k, isLt := hk } = 0"}, {"tactic": "simp [lt_iff_val_lt_val, ext_iff, Fin.coe_sub, succ_eq_add_one, this,\n  mod_eq_of_lt ((lt_succ_self _).trans hk)]", "annotated_tactic": ["simp [<a>lt_iff_val_lt_val</a>, <a>ext_iff</a>, <a>Fin.coe_sub</a>, <a>succ_eq_add_one</a>, this,\n    <a>mod_eq_of_lt</a> ((<a>lt_succ_self</a> _).<a>trans</a> hk)]", [{"full_name": "Fin.lt_iff_val_lt_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [215, 9], "def_end_pos": [215, 26]}, {"full_name": "Fin.ext_iff", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [39, 9], "def_end_pos": [39, 16]}, {"full_name": "Fin.coe_sub", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [1213, 19], "def_end_pos": [1213, 26]}, {"full_name": "Nat.succ_eq_add_one", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [111, 9], "def_end_pos": [111, 21]}, {"full_name": "Nat.lt_succ_self", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [294, 9], "def_end_pos": [294, 21]}, {"full_name": "LT.lt.trans", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [144, 7], "def_end_pos": [144, 18]}]], "state_before": "case mk.succ\nn\u271d m n k : \u2115\nhk : Nat.succ k < n + 2\nthis : (k + 1 + (n + 1)) % (n + 2) = k % (n + 2)\n\u22a2 { val := Nat.succ k, isLt := hk } < { val := Nat.succ k, isLt := hk } - 1 \u2194 { val := Nat.succ k, isLt := hk } = 0", "state_after": "no goals"}, {"tactic": "rw [add_right_comm, add_assoc, add_mod_right]", "annotated_tactic": ["rw [<a>add_right_comm</a>, <a>add_assoc</a>, <a>add_mod_right</a>]", [{"full_name": "add_right_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [101, 3], "def_end_pos": [101, 14]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}, {"full_name": "Nat.add_mod_right", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [909, 17], "def_end_pos": [909, 30]}]], "state_before": "n\u271d m n k : \u2115\nhk : Nat.succ k < n + 2\n\u22a2 (k + 1 + (n + 1)) % (n + 2) = k % (n + 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/WithZero.lean", "full_name": "OrderIso.mulRight\u2080'_symm", "start": [282, 1], "end": [285, 6], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\na\u271d b c d x y z : \u03b1\ninst\u271d : LinearOrderedCommGroupWithZero \u03b1\na : \u03b1\nha : a \u2260 0\n\u22a2 symm (mulRight\u2080' ha) = mulRight\u2080' (_ : a\u207b\u00b9 \u2260 0)", "state_after": "case h.h\n\u03b1 : Type u_1\na\u271d b c d x y z : \u03b1\ninst\u271d : LinearOrderedCommGroupWithZero \u03b1\na : \u03b1\nha : a \u2260 0\nx\u271d : \u03b1\n\u22a2 \u2191(symm (mulRight\u2080' ha)) x\u271d = \u2191(mulRight\u2080' (_ : a\u207b\u00b9 \u2260 0)) x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.h\n\u03b1 : Type u_1\na\u271d b c d x y z : \u03b1\ninst\u271d : LinearOrderedCommGroupWithZero \u03b1\na : \u03b1\nha : a \u2260 0\nx\u271d : \u03b1\n\u22a2 \u2191(symm (mulRight\u2080' ha)) x\u271d = \u2191(mulRight\u2080' (_ : a\u207b\u00b9 \u2260 0)) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.getLast?_cons", "start": [574, 1], "end": [575, 39], "traced_tactics": [{"tactic": "simp [getLast?, getLast_eq_getLastD]", "annotated_tactic": ["simp [<a>getLast?</a>, <a>getLast_eq_getLastD</a>]", [{"full_name": "List.getLast?", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/BasicAux.lean", "def_pos": [66, 5], "def_end_pos": [66, 13]}, {"full_name": "List.getLast_eq_getLastD", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [562, 9], "def_end_pos": [562, 28]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\n\u22a2 getLast? (a :: l) = some (getLastD l a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Invertible/Basic.lean", "full_name": "div_self_of_invertible", "start": [191, 1], "end": [192, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.get!_eq_get", "start": [244, 9], "end": [244, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelIso/Basic.lean", "full_name": "RelIso.default_def", "start": [731, 1], "end": [732, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.fromBlocks_transpose", "start": [149, 1], "end": [152, 62], "traced_tactics": [{"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\n\u22a2 (fromBlocks A B C D)\u1d40 = fromBlocks A\u1d40 C\u1d40 B\u1d40 D\u1d40", "state_after": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\ni : l \u2295 m\nj : n \u2295 o\n\u22a2 (fromBlocks A B C D)\u1d40 i j = fromBlocks A\u1d40 C\u1d40 B\u1d40 D\u1d40 i j"}, {"tactic": "rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [fromBlocks]", "annotated_tactic": ["rcases i with \u27e8\u27e9 <;> rcases j with \u27e8\u27e9 <;> simp [<a>fromBlocks</a>]", [{"full_name": "Matrix.fromBlocks", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Block.lean", "def_pos": [45, 5], "def_end_pos": [45, 15]}]], "state_before": "case a.h\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\np : Type u_5\nq : Type u_6\nm' : o \u2192 Type u_7\nn' : o \u2192 Type u_8\np' : o \u2192 Type u_9\nR : Type u_10\nS : Type u_11\n\u03b1 : Type u_12\n\u03b2 : Type u_13\nA : Matrix n l \u03b1\nB : Matrix n m \u03b1\nC : Matrix o l \u03b1\nD : Matrix o m \u03b1\ni : l \u2295 m\nj : n \u2295 o\n\u22a2 (fromBlocks A B C D)\u1d40 i j = fromBlocks A\u1d40 C\u1d40 B\u1d40 D\u1d40 i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.le_of_lt_succ", "start": [225, 1], "end": [226, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.diff_diff_right", "start": [1983, 1], "end": [1984, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Classes/LawfulMonad.lean", "full_name": "SatisfiesM_ExceptT_eq", "start": [210, 9], "end": [216, 97], "traced_tactics": [{"tactic": "refine \u27e8fun \u27e8f, eq\u27e9 => eq \u25b8 ?_, fun \u27e8f, eq\u27e9 => eq \u25b8 ?_\u27e9", "annotated_tactic": ["refine \u27e8fun \u27e8f, eq\u27e9 => eq \u25b8 ?_, fun \u27e8f, eq\u27e9 => eq \u25b8 ?_\u27e9", []], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\n\u22a2 SatisfiesM p x \u2194 SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x", "state_after": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) (Subtype.val <$> f)\n\ncase refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 SatisfiesM p (Subtype.val <$> f)"}, {"tactic": "exists (fun | .ok \u27e8a, h\u27e9 => \u27e8.ok a, fun | _, rfl => h\u27e9 | .error e => \u27e8.error e, fun.\u27e9) <$> f", "annotated_tactic": ["exists (fun | .ok \u27e8a, h\u27e9 => \u27e8.ok a, fun | _, <a>rfl</a> => h\u27e9 | .error e => \u27e8.error e, fun.\u27e9) <$> f", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) (Subtype.val <$> f)", "state_after": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 Subtype.val <$>\n      (fun x =>\n          match x with\n          | Except.ok { val := a, property := h } =>\n            { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n          | Except.error e =>\n            { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) }) <$>\n        f =\n    Subtype.val <$> f"}, {"tactic": "show _ = _ >>= _", "annotated_tactic": ["show _ = _ >>= _", []], "state_before": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 Subtype.val <$>\n      (fun x =>\n          match x with\n          | Except.ok { val := a, property := h } =>\n            { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n          | Except.error e =>\n            { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) }) <$>\n        f =\n    Subtype.val <$> f", "state_after": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 Subtype.val <$>\n      (fun x =>\n          match x with\n          | Except.ok { val := a, property := h } =>\n            { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n          | Except.error e =>\n            { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) }) <$>\n        f =\n    do\n    let a \u2190 f\n    match a with\n      | Except.ok a => pure (Except.ok a.val)\n      | Except.error e => pure (Except.error e)"}, {"tactic": "rw [\u2190 comp_map, map_eq_pure_bind]", "annotated_tactic": ["rw [\u2190 <a>comp_map</a>, <a>map_eq_pure_bind</a>]", [{"full_name": "LawfulFunctor.comp_map", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [19, 3], "def_end_pos": [19, 11]}, {"full_name": "map_eq_pure_bind", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [62, 9], "def_end_pos": [62, 25]}]], "state_before": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 Subtype.val <$>\n      (fun x =>\n          match x with\n          | Except.ok { val := a, property := h } =>\n            { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n          | Except.error e =>\n            { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) }) <$>\n        f =\n    do\n    let a \u2190 f\n    match a with\n      | Except.ok a => pure (Except.ok a.val)\n      | Except.error e => pure (Except.error e)", "state_after": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 (do\n      let a \u2190 f\n      pure\n          ((Subtype.val \u2218 fun x =>\n              match x with\n              | Except.ok { val := a, property := h } =>\n                { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n              | Except.error e =>\n                { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) })\n            a)) =\n    do\n    let a \u2190 f\n    match a with\n      | Except.ok a => pure (Except.ok a.val)\n      | Except.error e => pure (Except.error e)"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case refine_1\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 (do\n      let a \u2190 f\n      pure\n          ((Subtype.val \u2218 fun x =>\n              match x with\n              | Except.ok { val := a, property := h } =>\n                { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n              | Except.error e =>\n                { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) })\n            a)) =\n    do\n    let a \u2190 f\n    match a with\n      | Except.ok a => pure (Except.ok a.val)\n      | Except.error e => pure (Except.error e)", "state_after": "case refine_1.e_a\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 (fun a =>\n      pure\n        ((Subtype.val \u2218 fun x =>\n            match x with\n            | Except.ok { val := a, property := h } =>\n              { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n            | Except.error e =>\n              { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) })\n          a)) =\n    fun a =>\n    match a with\n    | Except.ok a => pure (Except.ok a.val)\n    | Except.error e => pure (Except.error e)"}, {"tactic": "funext a", "annotated_tactic": ["funext a", []], "state_before": "case refine_1.e_a\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\n\u22a2 (fun a =>\n      pure\n        ((Subtype.val \u2218 fun x =>\n            match x with\n            | Except.ok { val := a, property := h } =>\n              { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n            | Except.error e =>\n              { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) })\n          a)) =\n    fun a =>\n    match a with\n    | Except.ok a => pure (Except.ok a.val)\n    | Except.error e => pure (Except.error e)", "state_after": "case refine_1.e_a.h\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\na : Except \u03c1 { a // p a }\n\u22a2 pure\n      ((Subtype.val \u2218 fun x =>\n          match x with\n          | Except.ok { val := a, property := h } =>\n            { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n          | Except.error e =>\n            { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) })\n        a) =\n    match a with\n    | Except.ok a => pure (Except.ok a.val)\n    | Except.error e => pure (Except.error e)"}, {"tactic": "cases a <;> rfl", "annotated_tactic": ["cases a <;> rfl", []], "state_before": "case refine_1.e_a.h\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM p x\nf : ExceptT \u03c1 m { a // p a }\neq : Subtype.val <$> f = x\na : Except \u03c1 { a // p a }\n\u22a2 pure\n      ((Subtype.val \u2218 fun x =>\n          match x with\n          | Except.ok { val := a, property := h } =>\n            { val := Except.ok a, property := (_ : \u2200 (x : \u03b1), Except.ok a = Except.ok x \u2192 p x) }\n          | Except.error e =>\n            { val := Except.error e, property := (_ : \u2200 (a : \u03b1), Except.error e = Except.ok a \u2192 p a) })\n        a) =\n    match a with\n    | Except.ok a => pure (Except.ok a.val)\n    | Except.error e => pure (Except.error e)", "state_after": "no goals"}, {"tactic": "exists ((fun | \u27e8.ok a, h\u27e9 => .ok \u27e8a, h _ rfl\u27e9 | \u27e8.error e, _\u27e9 => .error e) <$> f : m _)", "annotated_tactic": ["exists ((fun | \u27e8.ok a, h\u27e9 => .ok \u27e8a, h _ <a>rfl</a>\u27e9 | \u27e8.error e, _\u27e9 => .error e) <$> f : m _)", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 SatisfiesM p (Subtype.val <$> f)", "state_after": "case refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 Subtype.val <$>\n      (fun x =>\n          match x with\n          | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n          | { val := Except.error e, property := property } => Except.error e) <$>\n        f =\n    Subtype.val <$> f"}, {"tactic": "show _ >>= _ = _", "annotated_tactic": ["show _ >>= _ = _", []], "state_before": "case refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 Subtype.val <$>\n      (fun x =>\n          match x with\n          | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n          | { val := Except.error e, property := property } => Except.error e) <$>\n        f =\n    Subtype.val <$> f", "state_after": "case refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 (do\n      let a \u2190\n        (fun x =>\n              match x with\n              | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n              | { val := Except.error e, property := property } => Except.error e) <$>\n            f\n      match a with\n        | Except.ok a => pure (Except.ok a.val)\n        | Except.error e => pure (Except.error e)) =\n    Subtype.val <$> f"}, {"tactic": "simp [\u2190 comp_map, map_eq_pure_bind]", "annotated_tactic": ["simp [\u2190 <a>comp_map</a>, <a>map_eq_pure_bind</a>]", [{"full_name": "LawfulFunctor.comp_map", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [19, 3], "def_end_pos": [19, 11]}, {"full_name": "map_eq_pure_bind", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [62, 9], "def_end_pos": [62, 25]}]], "state_before": "case refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 (do\n      let a \u2190\n        (fun x =>\n              match x with\n              | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n              | { val := Except.error e, property := property } => Except.error e) <$>\n            f\n      match a with\n        | Except.ok a => pure (Except.ok a.val)\n        | Except.error e => pure (Except.error e)) =\n    Subtype.val <$> f", "state_after": "case refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 (do\n      let x \u2190 f\n      match\n          match x with\n          | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n          | { val := Except.error e, property := property } => Except.error e with\n        | Except.ok a => pure (Except.ok a.val)\n        | Except.error e => pure (Except.error e)) =\n    do\n    let a \u2190 f\n    pure a.val"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case refine_2\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 (do\n      let x \u2190 f\n      match\n          match x with\n          | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n          | { val := Except.error e, property := property } => Except.error e with\n        | Except.ok a => pure (Except.ok a.val)\n        | Except.error e => pure (Except.error e)) =\n    do\n    let a \u2190 f\n    pure a.val", "state_after": "case refine_2.e_a\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 (fun x =>\n      match\n        match x with\n        | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n        | { val := Except.error e, property := property } => Except.error e with\n      | Except.ok a => pure (Except.ok a.val)\n      | Except.error e => pure (Except.error e)) =\n    fun a => pure a.val"}, {"tactic": "funext \u27e8a, h\u27e9", "annotated_tactic": ["funext \u27e8a, h\u27e9", []], "state_before": "case refine_2.e_a\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\n\u22a2 (fun x =>\n      match\n        match x with\n        | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n        | { val := Except.error e, property := property } => Except.error e with\n      | Except.ok a => pure (Except.ok a.val)\n      | Except.error e => pure (Except.error e)) =\n    fun a => pure a.val", "state_after": "case refine_2.e_a.h\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\na : Except \u03c1 \u03b1\nh : \u2200 (a_1 : \u03b1), a = Except.ok a_1 \u2192 p a_1\n\u22a2 (match\n      match { val := a, property := h } with\n      | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n      | { val := Except.error e, property := property } => Except.error e with\n    | Except.ok a => pure (Except.ok a.val)\n    | Except.error e => pure (Except.error e)) =\n    pure { val := a, property := h }.val"}, {"tactic": "cases a <;> rfl", "annotated_tactic": ["cases a <;> rfl", []], "state_before": "case refine_2.e_a.h\nm : Type u_1 \u2192 Type u_2\n\u03b1 \u03c1 : Type u_1\np : \u03b1 \u2192 Prop\nx : ExceptT \u03c1 m \u03b1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nx\u271d : SatisfiesM (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) x\nf : m { a // (fun x => \u2200 (a : \u03b1), x = Except.ok a \u2192 p a) a }\neq : Subtype.val <$> f = x\na : Except \u03c1 \u03b1\nh : \u2200 (a_1 : \u03b1), a = Except.ok a_1 \u2192 p a_1\n\u22a2 (match\n      match { val := a, property := h } with\n      | { val := Except.ok a, property := h } => Except.ok { val := a, property := (_ : p a) }\n      | { val := Except.error e, property := property } => Except.error e with\n    | Except.ok a => pure (Except.ok a.val)\n    | Except.error e => pure (Except.error e)) =\n    pure { val := a, property := h }.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearMap.map_le_range", "start": [709, 1], "end": [710, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Option/Lemmas.lean", "full_name": "Option.join_ne_none", "start": [116, 1], "end": [117, 58], "traced_tactics": [{"tactic": "simp only [ne_none_iff_exists', join_eq_some, iff_self]", "annotated_tactic": ["simp only [<a>ne_none_iff_exists'</a>, <a>join_eq_some</a>, <a>iff_self</a>]", [{"full_name": "Option.ne_none_iff_exists'", "def_path": "lake-packages/std/Std/Data/Option/Lemmas.lean", "def_pos": [80, 9], "def_end_pos": [80, 28]}, {"full_name": "Option.join_eq_some", "def_path": "lake-packages/std/Std/Data/Option/Lemmas.lean", "def_pos": [113, 9], "def_end_pos": [113, 21]}, {"full_name": "iff_self", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [98, 17], "def_end_pos": [98, 25]}]], "state_before": "\u03b1\u271d : Type u_1\nx : Option (Option \u03b1\u271d)\n\u22a2 join x \u2260 none \u2194 \u2203 z, x = some (some z)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.isPrefixOf_nil_left", "start": [405, 9], "end": [406, 20], "traced_tactics": [{"tactic": "simp [isPrefixOf]", "annotated_tactic": ["simp [<a>isPrefixOf</a>]", [{"full_name": "List.isPrefixOf", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [691, 5], "def_end_pos": [691, 15]}]], "state_before": "\u03b1 : Type u_1\nl : List \u03b1\ninst\u271d : BEq \u03b1\n\u22a2 isPrefixOf [] l = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_neg_atTop_iff", "start": [908, 1], "end": [909, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.neg_nonneg_of_nonpos", "start": [878, 11], "end": [880, 29], "traced_tactics": [{"tactic": "have : -0 \u2264 -a := Int.neg_le_neg h", "annotated_tactic": ["have : -0 \u2264 -a := <a>Int.neg_le_neg</a> h", [{"full_name": "Int.neg_le_neg", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [859, 19], "def_end_pos": [859, 29]}]], "state_before": "a : Int\nh : a \u2264 0\n\u22a2 0 \u2264 -a", "state_after": "a : Int\nh : a \u2264 0\nthis : -0 \u2264 -a\n\u22a2 0 \u2264 -a"}, {"tactic": "rwa [Int.neg_zero] at this", "annotated_tactic": ["rwa [<a>Int.neg_zero</a>] at this", [{"full_name": "Int.neg_zero", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [33, 33], "def_end_pos": [33, 41]}]], "state_before": "a : Int\nh : a \u2264 0\nthis : -0 \u2264 -a\n\u22a2 0 \u2264 -a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.prod_bot_sup_bot_prod", "start": [1304, 1], "end": [1309, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Classes/LawfulMonad.lean", "full_name": "SatisfiesM_Option_eq", "start": [187, 9], "end": [189, 85], "traced_tactics": [{"tactic": "revert x", "annotated_tactic": ["revert x", []], "state_before": "\u03b1\u271d : Type u_1\np : \u03b1\u271d \u2192 Prop\nx : Option \u03b1\u271d\n\u22a2 SatisfiesM p x \u2192 \u2200 (a : \u03b1\u271d), x = some a \u2192 p a", "state_after": "\u03b1\u271d : Type u_1\np : \u03b1\u271d \u2192 Prop\n\u22a2 \u2200 {x : Option \u03b1\u271d}, SatisfiesM p x \u2192 \u2200 (a : \u03b1\u271d), x = some a \u2192 p a"}, {"tactic": "intro | some _, \u27e8some \u27e8_, h\u27e9, rfl\u27e9, _, rfl => exact h", "annotated_tactic": ["intro | <a>some</a> _, \u27e8<a>some</a> \u27e8_, h\u27e9, <a>rfl</a>\u27e9, _, <a>rfl</a> => exact h", [{"full_name": "Option.some", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2158, 5], "def_end_pos": [2158, 9]}, {"full_name": "Option.some", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2158, 5], "def_end_pos": [2158, 9]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b1\u271d : Type u_1\np : \u03b1\u271d \u2192 Prop\n\u22a2 \u2200 {x : Option \u03b1\u271d}, SatisfiesM p x \u2192 \u2200 (a : \u03b1\u271d), x = some a \u2192 p a", "state_after": "no goals"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "\u03b1\u271d : Type u_1\np : \u03b1\u271d \u2192 Prop\nx\u271d\u00b3 : Option \u03b1\u271d\nx\u271d\u00b2 : SatisfiesM p x\u271d\u00b3\nx\u271d\u00b9 : \u03b1\u271d\nx\u271d : x\u271d\u00b3 = some x\u271d\u00b9\nval\u271d : \u03b1\u271d\nh : p val\u271d\n\u22a2 p { val := val\u271d, property := h }.val", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Monomial.lean", "full_name": "Polynomial.card_support_le_one_iff_monomial", "start": [40, 1], "end": [57, 32], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\n\u22a2 Finset.card (support f) \u2264 1 \u2194 \u2203 n a, f = \u2191(monomial n) a", "state_after": "case mp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\n\u22a2 Finset.card (support f) \u2264 1 \u2192 \u2203 n a, f = \u2191(monomial n) a\n\ncase mpr\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\n\u22a2 (\u2203 n a, f = \u2191(monomial n) a) \u2192 Finset.card (support f) \u2264 1"}, {"tactic": "intro H", "annotated_tactic": ["intro H", []], "state_before": "case mp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\n\u22a2 Finset.card (support f) \u2264 1 \u2192 \u2203 n a, f = \u2191(monomial n) a", "state_after": "case mp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nH : Finset.card (support f) \u2264 1\n\u22a2 \u2203 n a, f = \u2191(monomial n) a"}, {"tactic": "rw [Finset.card_le_one_iff_subset_singleton] at H", "annotated_tactic": ["rw [<a>Finset.card_le_one_iff_subset_singleton</a>] at H", [{"full_name": "Finset.card_le_one_iff_subset_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [559, 9], "def_end_pos": [559, 41]}]], "state_before": "case mp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nH : Finset.card (support f) \u2264 1\n\u22a2 \u2203 n a, f = \u2191(monomial n) a", "state_after": "case mp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nH : \u2203 x, support f \u2286 {x}\n\u22a2 \u2203 n a, f = \u2191(monomial n) a"}, {"tactic": "rcases H with \u27e8n, hn\u27e9", "annotated_tactic": ["rcases H with \u27e8n, hn\u27e9", []], "state_before": "case mp\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nH : \u2203 x, support f \u2286 {x}\n\u22a2 \u2203 n a, f = \u2191(monomial n) a", "state_after": "case mp.intro\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\n\u22a2 \u2203 n a, f = \u2191(monomial n) a"}, {"tactic": "refine' \u27e8n, f.coeff n, _\u27e9", "annotated_tactic": ["refine' \u27e8n, f.coeff n, _\u27e9", []], "state_before": "case mp.intro\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\n\u22a2 \u2203 n a, f = \u2191(monomial n) a", "state_after": "case mp.intro\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\n\u22a2 f = \u2191(monomial n) (coeff f n)"}, {"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "case mp.intro\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\n\u22a2 f = \u2191(monomial n) (coeff f n)", "state_after": "case mp.intro.a\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i"}, {"tactic": "by_cases hi : i = n", "annotated_tactic": ["by_cases hi : i = n", []], "state_before": "case mp.intro.a\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i", "state_after": "case pos\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : i = n\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i\n\ncase neg\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : \u00aci = n\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i"}, {"tactic": "simp [hi, coeff_monomial]", "annotated_tactic": ["simp [hi, <a>coeff_monomial</a>]", [{"full_name": "Polynomial.coeff_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [687, 9], "def_end_pos": [687, 23]}]], "state_before": "case pos\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : i = n\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i", "state_after": "no goals"}, {"tactic": "have : f.coeff i = 0 := by\n  rw [\u2190 not_mem_support_iff]\n  exact fun hi' => hi (Finset.mem_singleton.1 (hn hi'))", "annotated_tactic": ["have : f.coeff i = 0 := by\n        rw [\u2190 <a>not_mem_support_iff</a>]\n        exact fun hi' => hi (<a>Finset.mem_singleton</a>.1 (hn hi'))", [{"full_name": "Polynomial.not_mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 28]}, {"full_name": "Finset.mem_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [679, 9], "def_end_pos": [679, 22]}]], "state_before": "case neg\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : \u00aci = n\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i", "state_after": "case neg\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : \u00aci = n\nthis : coeff f i = 0\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i"}, {"tactic": "simp [this, Ne.symm hi, coeff_monomial]", "annotated_tactic": ["simp [this, <a>Ne.symm</a> hi, <a>coeff_monomial</a>]", [{"full_name": "Ne.symm", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [575, 9], "def_end_pos": [575, 16]}, {"full_name": "Polynomial.coeff_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [687, 9], "def_end_pos": [687, 23]}]], "state_before": "case neg\nR : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : \u00aci = n\nthis : coeff f i = 0\n\u22a2 coeff f i = coeff (\u2191(monomial n) (coeff f n)) i", "state_after": "no goals"}, {"tactic": "rw [\u2190 not_mem_support_iff]", "annotated_tactic": ["rw [\u2190 <a>not_mem_support_iff</a>]", [{"full_name": "Polynomial.not_mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [737, 9], "def_end_pos": [737, 28]}]], "state_before": "R : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : \u00aci = n\n\u22a2 coeff f i = 0", "state_after": "R : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : \u00aci = n\n\u22a2 i \u2209 support f"}, {"tactic": "exact fun hi' => hi (Finset.mem_singleton.1 (hn hi'))", "annotated_tactic": ["exact fun hi' => hi (<a>Finset.mem_singleton</a>.1 (hn hi'))", [{"full_name": "Finset.mem_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [679, 9], "def_end_pos": [679, 22]}]], "state_before": "R : Type u\na b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\nn : \u2115\nhn : support f \u2286 {n}\ni : \u2115\nhi : \u00aci = n\n\u22a2 i \u2209 support f", "state_after": "no goals"}, {"tactic": "rintro \u27e8n, a, rfl\u27e9", "annotated_tactic": ["rintro \u27e8n, a, rfl\u27e9", []], "state_before": "case mpr\nR : Type u\na b : R\nm n : \u2115\ninst\u271d : Semiring R\np q r f : R[X]\n\u22a2 (\u2203 n a, f = \u2191(monomial n) a) \u2192 Finset.card (support f) \u2264 1", "state_after": "case mpr.intro.intro\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\n\u22a2 Finset.card (support (\u2191(monomial n) a)) \u2264 1"}, {"tactic": "rw [\u2190 Finset.card_singleton n]", "annotated_tactic": ["rw [\u2190 <a>Finset.card_singleton</a> n]", [{"full_name": "Finset.card_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [86, 9], "def_end_pos": [86, 23]}]], "state_before": "case mpr.intro.intro\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\n\u22a2 Finset.card (support (\u2191(monomial n) a)) \u2264 1", "state_after": "case mpr.intro.intro\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\n\u22a2 Finset.card (support (\u2191(monomial n) a)) \u2264 Finset.card {n}"}, {"tactic": "apply Finset.card_le_of_subset", "annotated_tactic": ["apply <a>Finset.card_le_of_subset</a>", [{"full_name": "Finset.card_le_of_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [61, 9], "def_end_pos": [61, 26]}]], "state_before": "case mpr.intro.intro\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\n\u22a2 Finset.card (support (\u2191(monomial n) a)) \u2264 Finset.card {n}", "state_after": "case mpr.intro.intro.a\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\n\u22a2 support (\u2191(monomial n) a) \u2286 {n}"}, {"tactic": "exact support_monomial' _ _", "annotated_tactic": ["exact <a>support_monomial'</a> _ _", [{"full_name": "Polynomial.support_monomial'", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [879, 9], "def_end_pos": [879, 26]}]], "state_before": "case mpr.intro.intro.a\nR : Type u\na\u271d b : R\nm n\u271d : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\na : R\n\u22a2 support (\u2191(monomial n) a) \u2286 {n}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean", "full_name": "EuclideanDomain.mod_add_div", "start": [127, 1], "end": [128, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.reverse_sublist", "start": [456, 9], "end": [457, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Coprime/Basic.lean", "full_name": "IsCoprime.of_isCoprime_of_dvd_right", "start": [172, 1], "end": [173, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeq.lean", "full_name": "CauSeq.const_mul", "start": [306, 1], "end": [307, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Join.lean", "full_name": "List.sum_take_map_length_lt1", "start": [158, 1], "end": [161, 31], "traced_tactics": [{"tactic": "simp [hi, sum_take_succ, hj]", "annotated_tactic": ["simp [hi, <a>sum_take_succ</a>, hj]", [{"full_name": "List.sum_take_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [180, 3], "def_end_pos": [180, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nL : List (List \u03b1)\ni j : \u2115\nhi : i < length L\nhj : j < length (get L { val := i, isLt := hi })\n\u22a2 sum (take i (map length L)) + j < sum (take (i + 1) (map length L))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Group.lean", "full_name": "Set.inv_mem_Ico_iff", "start": [34, 1], "end": [35, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.sublist_append_of_sublist_right", "start": [423, 1], "end": [424, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Bitwise.lean", "full_name": "Int.testBit_succ", "start": [206, 1], "end": [211, 76], "traced_tactics": [{"tactic": "rw [bit_coe_nat]", "annotated_tactic": ["rw [<a>bit_coe_nat</a>]", [{"full_name": "Int.bit_coe_nat", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Bitwise.lean", "def_pos": [153, 9], "def_end_pos": [153, 20]}]], "state_before": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 testBit (bit b \u2191n) (Nat.succ m) = testBit (\u2191n) m", "state_after": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 testBit (\u2191(Nat.bit b n)) (Nat.succ m) = testBit (\u2191n) m"}, {"tactic": "apply Nat.testBit_succ", "annotated_tactic": ["apply <a>Nat.testBit_succ</a>", [{"full_name": "Nat.testBit_succ", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [308, 9], "def_end_pos": [308, 21]}]], "state_before": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 testBit (\u2191(Nat.bit b n)) (Nat.succ m) = testBit (\u2191n) m", "state_after": "no goals"}, {"tactic": "dsimp only [testBit]", "annotated_tactic": ["dsimp only [<a>testBit</a>]", [{"full_name": "Int.testBit", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Int/Bitwise.lean", "def_pos": [43, 5], "def_end_pos": [43, 12]}]], "state_before": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 testBit (bit b -[n+1]) (Nat.succ m) = testBit -[n+1] m", "state_after": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 (match bit b -[n+1], Nat.succ m with\n    | ofNat m, n => Nat.testBit m n\n    | -[m+1], n => !Nat.testBit m n) =\n    !Nat.testBit n m"}, {"tactic": "simp only [bit_negSucc]", "annotated_tactic": ["simp only [<a>bit_negSucc</a>]", [{"full_name": "Int.bit_negSucc", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Bitwise.lean", "def_pos": [159, 9], "def_end_pos": [159, 20]}]], "state_before": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 (match bit b -[n+1], Nat.succ m with\n    | ofNat m, n => Nat.testBit m n\n    | -[m+1], n => !Nat.testBit m n) =\n    !Nat.testBit n m", "state_after": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 (!Nat.testBit (Nat.bit (!b) n) (Nat.succ m)) = !Nat.testBit n m"}, {"tactic": "cases b <;> simp only [Bool.not_false, Bool.not_true, Nat.testBit_succ]", "annotated_tactic": ["cases b <;> simp only [<a>Bool.not_false</a>, <a>Bool.not_true</a>, <a>Nat.testBit_succ</a>]", [{"full_name": "Bool.not_false", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [131, 17], "def_end_pos": [131, 31]}, {"full_name": "Bool.not_true", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [130, 17], "def_end_pos": [130, 30]}, {"full_name": "Nat.testBit_succ", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [308, 9], "def_end_pos": [308, 21]}]], "state_before": "m : \u2115\nb : Bool\nn : \u2115\n\u22a2 (!Nat.testBit (Nat.bit (!b) n) (Nat.succ m)) = !Nat.testBit n m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.partialInv_of_injective", "start": [415, 1], "end": [427, 78], "traced_tactics": [{"tactic": "rw [hpi, dif_pos h'] at h", "annotated_tactic": ["rw [hpi, <a>dif_pos</a> h'] at h", [{"full_name": "dif_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [807, 9], "def_end_pos": [807, 16]}]], "state_before": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nh : partialInv f b = some a\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u2203 a, f a = b\n\u22a2 f a = b", "state_after": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u2203 a, f a = b\nh : some (Classical.choose h') = some a\n\u22a2 f a = b"}, {"tactic": "injection h with h", "annotated_tactic": ["injection h with h", []], "state_before": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u2203 a, f a = b\nh : some (Classical.choose h') = some a\n\u22a2 f a = b", "state_after": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u2203 a, f a = b\nh : Classical.choose h' = a\n\u22a2 f a = b"}, {"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u2203 a, f a = b\nh : Classical.choose h' = a\n\u22a2 f a = b", "state_after": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\nb : \u03b2\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u2203 a, f a = b\n\u22a2 f (Classical.choose h') = b"}, {"tactic": "apply Classical.choose_spec h'", "annotated_tactic": ["apply <a>Classical.choose_spec</a> h'", [{"full_name": "Classical.choose_spec", "def_path": "lake-packages/lean4/src/lean/Init/Classical.lean", "def_pos": [22, 9], "def_end_pos": [22, 20]}]], "state_before": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\nb : \u03b2\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u2203 a, f a = b\n\u22a2 f (Classical.choose h') = b", "state_after": "no goals"}, {"tactic": "rw [hpi, dif_neg h'] at h", "annotated_tactic": ["rw [hpi, <a>dif_neg</a> h'] at h", [{"full_name": "dif_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [812, 9], "def_end_pos": [812, 16]}]], "state_before": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nh : partialInv f b = some a\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u00ac\u2203 a, f a = b\n\u22a2 f a = b", "state_after": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nh : none = some a\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u00ac\u2203 a, f a = b\n\u22a2 f a = b"}, {"tactic": "contradiction", "annotated_tactic": ["contradiction", []], "state_before": "\u03b1\u271d : Sort ?u.12068\n\u03b2\u271d : Sort ?u.12071\n\u03b3 : Sort ?u.12074\nf\u271d : \u03b1\u271d \u2192 \u03b2\u271d\n\u03b1 : Type u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\nI : Injective f\na : \u03b1\nb : \u03b2\nh : none = some a\nhpi : partialInv f b = if h : \u2203 a, f a = b then some (Classical.choose h) else none\nh' : \u00ac\u2203 a, f a = b\n\u22a2 f a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "AddValuation.IsEquiv.comap", "start": [852, 1], "end": [854, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iUnion_inter_of_monotone", "start": [703, 1], "end": [705, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.C_mul_monomial", "start": [221, 1], "end": [224, 36], "traced_tactics": [{"tactic": "show AddMonoidAlgebra.single _ _ * AddMonoidAlgebra.single _ _ = AddMonoidAlgebra.single _ _", "annotated_tactic": ["show <a>AddMonoidAlgebra.single</a> _ _ * <a>AddMonoidAlgebra.single</a> _ _ = <a>AddMonoidAlgebra.single</a> _ _", [{"full_name": "AddMonoidAlgebra.single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1231, 8], "def_end_pos": [1231, 14]}, {"full_name": "AddMonoidAlgebra.single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1231, 8], "def_end_pos": [1231, 14]}, {"full_name": "AddMonoidAlgebra.single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1231, 8], "def_end_pos": [1231, 14]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\n\u22a2 \u2191C a * \u2191(monomial s) a' = \u2191(monomial s) (a * a')", "state_after": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\n\u22a2 AddMonoidAlgebra.single 0 a * AddMonoidAlgebra.single s a' = AddMonoidAlgebra.single s (a * a')"}, {"tactic": "simp [C_apply, single_mul_single]", "annotated_tactic": ["simp [<a>C_apply</a>, <a>single_mul_single</a>]", [{"full_name": "MvPolynomial.C_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 16]}, {"full_name": "AddMonoidAlgebra.single_mul_single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [1553, 9], "def_end_pos": [1553, 26]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\n\u22a2 AddMonoidAlgebra.single 0 a * AddMonoidAlgebra.single s a' = AddMonoidAlgebra.single s (a * a')", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "SupBotHom.bot_apply", "start": [850, 1], "end": [851, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.mem_cons", "start": [59, 9], "end": [61, 80], "traced_tactics": [{"tactic": "cases h <;> simp [Membership.mem, *]", "annotated_tactic": ["cases h <;> simp [<a>Membership.mem</a>, *]", [{"full_name": "Membership.mem", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1432, 3], "def_end_pos": [1432, 6]}]], "state_before": "\u03b1\u271d : Type u_1\na b : \u03b1\u271d\nl : List \u03b1\u271d\nh : a \u2208 b :: l\n\u22a2 a = b \u2228 a \u2208 l", "state_after": "no goals"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1\u271d : Type u_1\na b : \u03b1\u271d\nl : List \u03b1\u271d\n\u22a2 a \u2208 a :: l", "state_after": "no goals"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1\u271d : Type u_1\na b\u271d : \u03b1\u271d\nl : List \u03b1\u271d\nb : \u03b1\u271d\nh : a \u2208 l\n\u22a2 a \u2208 b :: l", "state_after": "case a\n\u03b1\u271d : Type u_1\na b\u271d : \u03b1\u271d\nl : List \u03b1\u271d\nb : \u03b1\u271d\nh : a \u2208 l\n\u22a2 Mem a l"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "case a\n\u03b1\u271d : Type u_1\na b\u271d : \u03b1\u271d\nl : List \u03b1\u271d\nb : \u03b1\u271d\nh : a \u2208 l\n\u22a2 Mem a l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.powerset_card_disjiUnion", "start": [285, 1], "end": [295, 54], "traced_tactics": [{"tactic": "refine' ext fun a => \u27e8fun ha => _, fun ha => _\u27e9", "annotated_tactic": ["refine' <a>ext</a> fun a => \u27e8fun ha => _, fun ha => _\u27e9", [{"full_name": "Finset.ext", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [240, 9], "def_end_pos": [240, 12]}]], "state_before": "\u03b1 : Type u_1\ns\u271d t s : Finset \u03b1\n\u22a2 powerset s =\n    disjiUnion (range (card s + 1)) (fun i => powersetCard i s)\n      (_ : Set.Pairwise \u2191(range (card s + 1)) fun i j => _root_.Disjoint (powersetCard i s) (powersetCard j s))", "state_after": "case refine'_1\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha : a \u2208 powerset s\n\u22a2 a \u2208\n    disjiUnion (range (card s + 1)) (fun i => powersetCard i s)\n      (_ : Set.Pairwise \u2191(range (card s + 1)) fun i j => _root_.Disjoint (powersetCard i s) (powersetCard j s))\n\ncase refine'_2\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha :\n  a \u2208\n    disjiUnion (range (card s + 1)) (fun i => powersetCard i s)\n      (_ : Set.Pairwise \u2191(range (card s + 1)) fun i j => _root_.Disjoint (powersetCard i s) (powersetCard j s))\n\u22a2 a \u2208 powerset s"}, {"tactic": "rw [mem_disjiUnion]", "annotated_tactic": ["rw [<a>mem_disjiUnion</a>]", [{"full_name": "Finset.mem_disjiUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3549, 9], "def_end_pos": [3549, 23]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha : a \u2208 powerset s\n\u22a2 a \u2208\n    disjiUnion (range (card s + 1)) (fun i => powersetCard i s)\n      (_ : Set.Pairwise \u2191(range (card s + 1)) fun i j => _root_.Disjoint (powersetCard i s) (powersetCard j s))", "state_after": "case refine'_1\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha : a \u2208 powerset s\n\u22a2 \u2203 a_1 \u2208 range (card s + 1), a \u2208 powersetCard a_1 s"}, {"tactic": "exact\n  \u27e8a.card, mem_range.mpr (Nat.lt_succ_of_le (card_le_of_subset (mem_powerset.mp ha))),\n    mem_powersetCard.mpr \u27e8mem_powerset.mp ha, rfl\u27e9\u27e9", "annotated_tactic": ["exact\n      \u27e8a.card, mem_range.mpr (<a>Nat.lt_succ_of_le</a> (<a>card_le_of_subset</a> (mem_powerset.mp ha))),\n        mem_powersetCard.mpr \u27e8mem_powerset.mp ha, <a>rfl</a>\u27e9\u27e9", [{"full_name": "Nat.lt_succ_of_le", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [212, 9], "def_end_pos": [212, 22]}, {"full_name": "Finset.card_le_of_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [61, 9], "def_end_pos": [61, 26]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case refine'_1\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha : a \u2208 powerset s\n\u22a2 \u2203 a_1 \u2208 range (card s + 1), a \u2208 powersetCard a_1 s", "state_after": "no goals"}, {"tactic": "rcases mem_disjiUnion.mp ha with \u27e8i, _hi, ha\u27e9", "annotated_tactic": ["rcases mem_disjiUnion.mp ha with \u27e8i, _hi, ha\u27e9", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha :\n  a \u2208\n    disjiUnion (range (card s + 1)) (fun i => powersetCard i s)\n      (_ : Set.Pairwise \u2191(range (card s + 1)) fun i j => _root_.Disjoint (powersetCard i s) (powersetCard j s))\n\u22a2 a \u2208 powerset s", "state_after": "case refine'_2.intro.intro\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha\u271d :\n  a \u2208\n    disjiUnion (range (card s + 1)) (fun i => powersetCard i s)\n      (_ : Set.Pairwise \u2191(range (card s + 1)) fun i j => _root_.Disjoint (powersetCard i s) (powersetCard j s))\ni : \u2115\n_hi : i \u2208 range (card s + 1)\nha : a \u2208 powersetCard i s\n\u22a2 a \u2208 powerset s"}, {"tactic": "exact mem_powerset.mpr (mem_powersetCard.mp ha).1", "annotated_tactic": ["exact mem_powerset.mpr (mem_powersetCard.mp ha).1", []], "state_before": "case refine'_2.intro.intro\n\u03b1 : Type u_1\ns\u271d t s a : Finset \u03b1\nha\u271d :\n  a \u2208\n    disjiUnion (range (card s + 1)) (fun i => powersetCard i s)\n      (_ : Set.Pairwise \u2191(range (card s + 1)) fun i j => _root_.Disjoint (powersetCard i s) (powersetCard j s))\ni : \u2115\n_hi : i \u2208 range (card s + 1)\nha : a \u2208 powersetCard i s\n\u22a2 a \u2208 powerset s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.rotate_eq_rotate", "start": [332, 1], "end": [333, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidWithZeroHom.copy_eq", "start": [901, 1], "end": [903, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Limit.lean", "full_name": "Order.not_isPredLimit_pred", "start": [307, 1], "end": [307, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.foldl_fixed", "start": [2355, 1], "end": [2356, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Semiconj/Units.lean", "full_name": "SemiconjBy.inv_symm_left_iff", "start": [110, 1], "end": [111, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Defs.lean", "full_name": "mul_right_cancel", "start": [207, 1], "end": [208, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "min_le_min", "start": [82, 1], "end": [83, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.Iic_pred_of_not_isMin", "start": [676, 1], "end": [677, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_range_succ", "start": [1226, 1], "end": [1228, 45], "traced_tactics": [{"tactic": "simp only [mul_comm, prod_range_succ_comm]", "annotated_tactic": ["simp only [<a>mul_comm</a>, <a>prod_range_succ_comm</a>]", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "Finset.prod_range_succ_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1219, 9], "def_end_pos": [1219, 29]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d : CommMonoid \u03b2\nf : \u2115 \u2192 \u03b2\nn : \u2115\n\u22a2 \u220f x in range (n + 1), f x = (\u220f x in range n, f x) * f n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.frequently_or_distrib_left", "start": [1361, 1], "end": [1362, 57], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : Filter \u03b1\ninst\u271d : NeBot f\np : Prop\nq : \u03b1 \u2192 Prop\n\u22a2 (\u2203\u1da0 (x : \u03b1) in f, p \u2228 q x) \u2194 p \u2228 \u2203\u1da0 (x : \u03b1) in f, q x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_mem_eq_prod_of_subset", "start": [482, 1], "end": [484, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "Int.toNat_le_toNat", "start": [513, 1], "end": [514, 52], "traced_tactics": [{"tactic": "rw [toNat_le]", "annotated_tactic": ["rw [<a>toNat_le</a>]", [{"full_name": "Int.toNat_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Order/Basic.lean", "def_pos": [498, 9], "def_end_pos": [498, 17]}]], "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\nh : a \u2264 b\n\u22a2 toNat a \u2264 toNat b", "state_after": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\nh : a \u2264 b\n\u22a2 a \u2264 \u2191(toNat b)"}, {"tactic": "exact le_trans h (self_le_toNat b)", "annotated_tactic": ["exact <a>le_trans</a> h (<a>self_le_toNat</a> b)", [{"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}, {"full_name": "Int.self_le_toNat", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [1387, 9], "def_end_pos": [1387, 22]}]], "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\nh : a \u2264 b\n\u22a2 a \u2264 \u2191(toNat b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Antichain.lean", "full_name": "IsAntichain.isAntisymm", "start": [69, 11], "end": [70, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_range_le", "start": [2126, 1], "end": [2127, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.perm_permutations'Aux_comm", "start": [1269, 1], "end": [1290, 43], "traced_tactics": [{"tactic": "induction' l with c l ih", "annotated_tactic": ["induction' l with c l ih", []], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\n\u22a2 List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)", "state_after": "case nil\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\n\u22a2 List.bind (permutations'Aux a []) (permutations'Aux b) ~ List.bind (permutations'Aux b []) (permutations'Aux a)\n\ncase cons\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\n\u22a2 List.bind (permutations'Aux a (c :: l)) (permutations'Aux b) ~\n    List.bind (permutations'Aux b (c :: l)) (permutations'Aux a)"}, {"tactic": "simp only [permutations'Aux, cons_bind, map_cons, map_map, cons_append]", "annotated_tactic": ["simp only [<a>permutations'Aux</a>, <a>cons_bind</a>, <a>map_cons</a>, <a>map_map</a>, <a>cons_append</a>]", [{"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.cons_bind", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [113, 17], "def_end_pos": [113, 26]}, {"full_name": "List.map_cons", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [99, 17], "def_end_pos": [99, 25]}, {"full_name": "List.map_map", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [106, 17], "def_end_pos": [106, 24]}, {"full_name": "List.cons_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [99, 17], "def_end_pos": [99, 28]}]], "state_before": "case cons\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\n\u22a2 List.bind (permutations'Aux a (c :: l)) (permutations'Aux b) ~\n    List.bind (permutations'Aux b (c :: l)) (permutations'Aux a)", "state_after": "case cons\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\n\u22a2 (b :: a :: c :: l) ::\n      (a :: b :: c :: l) ::\n        (map (cons a \u2218 cons c) (permutations'Aux b l) ++\n          List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b)) ~\n    (a :: b :: c :: l) ::\n      (b :: a :: c :: l) ::\n        (map (cons b \u2218 cons c) (permutations'Aux a l) ++\n          List.bind (map (cons c) (permutations'Aux b l)) (permutations'Aux a))"}, {"tactic": "apply Perm.swap'", "annotated_tactic": ["apply <a>Perm.swap'</a>", [{"full_name": "List.Perm.swap'", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [68, 9], "def_end_pos": [68, 19]}]], "state_before": "case cons\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\n\u22a2 (b :: a :: c :: l) ::\n      (a :: b :: c :: l) ::\n        (map (cons a \u2218 cons c) (permutations'Aux b l) ++\n          List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b)) ~\n    (a :: b :: c :: l) ::\n      (b :: a :: c :: l) ::\n        (map (cons b \u2218 cons c) (permutations'Aux a l) ++\n          List.bind (map (cons c) (permutations'Aux b l)) (permutations'Aux a))", "state_after": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++ List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++ List.bind (map (cons c) (permutations'Aux b l)) (permutations'Aux a)"}, {"tactic": "have :\n  \u2200 a b,\n    (map (cons c) (permutations'Aux a l)).bind (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) ((permutations'Aux a l).bind (permutations'Aux b)) := by\n  intros a' b'\n  simp only [map_bind, permutations'Aux]\n  show List.bind (permutations'Aux _ l) (fun a => ([b' :: c :: a] ++\n    map (cons c) (permutations'Aux _ a))) ~ _\n  refine' (bind_append_perm _ (fun x => [b' :: c :: x]) _).symm.trans _\n  rw [\u2190 map_eq_bind, \u2190 bind_map]\n  exact Perm.refl _", "annotated_tactic": ["have :\n    \u2200 a b,\n      (<a>map</a> (<a>cons</a> c) (<a>permutations'Aux</a> a l)).<a>bind</a> (<a>permutations'Aux</a> b) ~\n        <a>map</a> (<a>cons</a> b \u2218 <a>cons</a> c) (<a>permutations'Aux</a> a l) ++\n          <a>map</a> (<a>cons</a> c) ((<a>permutations'Aux</a> a l).<a>bind</a> (<a>permutations'Aux</a> b)) := by\n    intros a' b'\n    simp only [<a>map_bind</a>, <a>permutations'Aux</a>]\n    show <a>List.bind</a> (<a>permutations'Aux</a> _ l) (fun a => ([b' :: c :: a] ++\n      <a>map</a> (<a>cons</a> c) (<a>permutations'Aux</a> _ a))) ~ _\n    refine' (<a>bind_append_perm</a> _ (fun x => [b' :: c :: x]) _).symm.trans _\n    rw [\u2190 <a>map_eq_bind</a>, \u2190 <a>bind_map</a>]\n    exact <a>Perm.refl</a> _", [{"full_name": "List.map", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [151, 19], "def_end_pos": [151, 22]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.bind", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [643, 25], "def_end_pos": [643, 29]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.map", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [151, 19], "def_end_pos": [151, 22]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.map", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [151, 19], "def_end_pos": [151, 22]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.bind", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [643, 25], "def_end_pos": [643, 29]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.map_bind", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [166, 9], "def_end_pos": [166, 17]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.bind", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [643, 25], "def_end_pos": [643, 29]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.map", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [151, 19], "def_end_pos": [151, 22]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.bind_append_perm", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [1087, 9], "def_end_pos": [1087, 25]}, {"full_name": "List.map_eq_bind", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/List/Instances.lean", "def_pos": [30, 9], "def_end_pos": [30, 20]}, {"full_name": "List.bind_map", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [264, 9], "def_end_pos": [264, 17]}, {"full_name": "List.Perm.refl", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [49, 19], "def_end_pos": [49, 28]}]], "state_before": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++ List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++ List.bind (map (cons c) (permutations'Aux b l)) (permutations'Aux a)", "state_after": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\nthis :\n  \u2200 (a b : \u03b1),\n    List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++ List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++ List.bind (map (cons c) (permutations'Aux b l)) (permutations'Aux a)"}, {"tactic": "refine' (((this _ _).append_left _).trans _).trans ((this _ _).append_left _).symm", "annotated_tactic": ["refine' (((this _ _).<a>append_left</a> _).<a>trans</a> _).<a>trans</a> ((this _ _).<a>append_left</a> _).<a>symm</a>", [{"full_name": "List.Perm.append_left", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [115, 9], "def_end_pos": [115, 25]}, {"full_name": "List.Perm.trans", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [39, 5], "def_end_pos": [39, 10]}, {"full_name": "List.Perm.trans", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [39, 5], "def_end_pos": [39, 10]}, {"full_name": "List.Perm.append_left", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [115, 9], "def_end_pos": [115, 25]}, {"full_name": "List.Perm.symm", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [56, 19], "def_end_pos": [56, 28]}]], "state_before": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\nthis :\n  \u2200 (a b : \u03b1),\n    List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++ List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++ List.bind (map (cons c) (permutations'Aux b l)) (permutations'Aux a)", "state_after": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\nthis :\n  \u2200 (a b : \u03b1),\n    List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++\n      (map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++\n      (map (cons a \u2218 cons c) (permutations'Aux b l) ++\n        map (cons c) (List.bind (permutations'Aux b l) (permutations'Aux a)))"}, {"tactic": "rw [\u2190 append_assoc, \u2190 append_assoc]", "annotated_tactic": ["rw [\u2190 <a>append_assoc</a>, \u2190 <a>append_assoc</a>]", [{"full_name": "List.append_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 21]}, {"full_name": "List.append_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [103, 9], "def_end_pos": [103, 21]}]], "state_before": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\nthis :\n  \u2200 (a b : \u03b1),\n    List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++\n      (map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++\n      (map (cons a \u2218 cons c) (permutations'Aux b l) ++\n        map (cons c) (List.bind (permutations'Aux b l) (permutations'Aux a)))", "state_after": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\nthis :\n  \u2200 (a b : \u03b1),\n    List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++ map (cons b \u2218 cons c) (permutations'Aux a l) ++\n      map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b)) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++ map (cons a \u2218 cons c) (permutations'Aux b l) ++\n      map (cons c) (List.bind (permutations'Aux b l) (permutations'Aux a))"}, {"tactic": "exact perm_append_comm.append (ih.map _)", "annotated_tactic": ["exact perm_append_comm.append (ih.map _)", []], "state_before": "case cons.p\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\nthis :\n  \u2200 (a b : \u03b1),\n    List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))\n\u22a2 map (cons a \u2218 cons c) (permutations'Aux b l) ++ map (cons b \u2218 cons c) (permutations'Aux a l) ++\n      map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b)) ~\n    map (cons b \u2218 cons c) (permutations'Aux a l) ++ map (cons a \u2218 cons c) (permutations'Aux b l) ++\n      map (cons c) (List.bind (permutations'Aux b l) (permutations'Aux a))", "state_after": "no goals"}, {"tactic": "simp [swap]", "annotated_tactic": ["simp [<a>swap</a>]", [{"full_name": "List.Perm.swap", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [38, 5], "def_end_pos": [38, 9]}]], "state_before": "case nil\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\n\u22a2 List.bind (permutations'Aux a []) (permutations'Aux b) ~ List.bind (permutations'Aux b []) (permutations'Aux a)", "state_after": "no goals"}, {"tactic": "intros a' b'", "annotated_tactic": ["intros a' b'", []], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\n\u22a2 \u2200 (a b : \u03b1),\n    List.bind (map (cons c) (permutations'Aux a l)) (permutations'Aux b) ~\n      map (cons b \u2218 cons c) (permutations'Aux a l) ++\n        map (cons c) (List.bind (permutations'Aux a l) (permutations'Aux b))", "state_after": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 List.bind (map (cons c) (permutations'Aux a' l)) (permutations'Aux b') ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))"}, {"tactic": "simp only [map_bind, permutations'Aux]", "annotated_tactic": ["simp only [<a>map_bind</a>, <a>permutations'Aux</a>]", [{"full_name": "List.map_bind", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [166, 9], "def_end_pos": [166, 17]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}]], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 List.bind (map (cons c) (permutations'Aux a' l)) (permutations'Aux b') ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))", "state_after": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 (List.bind (permutations'Aux a' l) fun a => (b' :: c :: a) :: map (cons c) (permutations'Aux b' a)) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))"}, {"tactic": "show List.bind (permutations'Aux _ l) (fun a => ([b' :: c :: a] ++\n  map (cons c) (permutations'Aux _ a))) ~ _", "annotated_tactic": ["show <a>List.bind</a> (<a>permutations'Aux</a> _ l) (fun a => ([b' :: c :: a] ++\n      <a>map</a> (<a>cons</a> c) (<a>permutations'Aux</a> _ a))) ~ _", [{"full_name": "List.bind", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [643, 25], "def_end_pos": [643, 29]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}, {"full_name": "List.map", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [151, 19], "def_end_pos": [151, 22]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.permutations'Aux", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [294, 5], "def_end_pos": [294, 21]}]], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 (List.bind (permutations'Aux a' l) fun a => (b' :: c :: a) :: map (cons c) (permutations'Aux b' a)) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))", "state_after": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 (List.bind (permutations'Aux a' l) fun a => [b' :: c :: a] ++ map (cons c) (permutations'Aux b' a)) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))"}, {"tactic": "refine' (bind_append_perm _ (fun x => [b' :: c :: x]) _).symm.trans _", "annotated_tactic": ["refine' (<a>bind_append_perm</a> _ (fun x => [b' :: c :: x]) _).symm.trans _", [{"full_name": "List.bind_append_perm", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [1087, 9], "def_end_pos": [1087, 25]}]], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 (List.bind (permutations'Aux a' l) fun a => [b' :: c :: a] ++ map (cons c) (permutations'Aux b' a)) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))", "state_after": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 ((List.bind (permutations'Aux a' l) fun x => [b' :: c :: x]) ++\n      List.bind (permutations'Aux a' l) fun a => map (cons c) (permutations'Aux b' a)) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))"}, {"tactic": "rw [\u2190 map_eq_bind, \u2190 bind_map]", "annotated_tactic": ["rw [\u2190 <a>map_eq_bind</a>, \u2190 <a>bind_map</a>]", [{"full_name": "List.map_eq_bind", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/List/Instances.lean", "def_pos": [30, 9], "def_end_pos": [30, 20]}, {"full_name": "List.bind_map", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [264, 9], "def_end_pos": [264, 17]}]], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 ((List.bind (permutations'Aux a' l) fun x => [b' :: c :: x]) ++\n      List.bind (permutations'Aux a' l) fun a => map (cons c) (permutations'Aux b' a)) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))", "state_after": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 map (fun x => b' :: c :: x) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) fun a => permutations'Aux b' a) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))"}, {"tactic": "exact Perm.refl _", "annotated_tactic": ["exact <a>Perm.refl</a> _", [{"full_name": "List.Perm.refl", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [49, 19], "def_end_pos": [49, 28]}]], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na b c : \u03b1\nl : List \u03b1\nih : List.bind (permutations'Aux a l) (permutations'Aux b) ~ List.bind (permutations'Aux b l) (permutations'Aux a)\na' b' : \u03b1\n\u22a2 map (fun x => b' :: c :: x) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) fun a => permutations'Aux b' a) ~\n    map (cons b' \u2218 cons c) (permutations'Aux a' l) ++\n      map (cons c) (List.bind (permutations'Aux a' l) (permutations'Aux b'))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.cons_subset", "start": [327, 9], "end": [328, 66], "traced_tactics": [{"tactic": "simp only [subset_def, mem_cons, or_imp, forall_and, forall_eq]", "annotated_tactic": ["simp only [<a>subset_def</a>, <a>mem_cons</a>, <a>or_imp</a>, <a>forall_and</a>, <a>forall_eq</a>]", [{"full_name": "List.subset_def", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [291, 9], "def_end_pos": [291, 19]}, {"full_name": "List.mem_cons", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [59, 17], "def_end_pos": [59, 25]}, {"full_name": "or_imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [343, 9], "def_end_pos": [343, 15]}, {"full_name": "forall_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [432, 9], "def_end_pos": [432, 19]}, {"full_name": "forall_eq", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [456, 17], "def_end_pos": [456, 26]}]], "state_before": "\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl m : List \u03b1\u271d\n\u22a2 a :: l \u2286 m \u2194 a \u2208 m \u2227 l \u2286 m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean", "full_name": "Function.mapsTo_fixedPoints_comp", "start": [170, 1], "end": [171, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Defs.lean", "full_name": "lt_inv_mul_iff_mul_lt", "start": [171, 1], "end": [173, 7], "traced_tactics": [{"tactic": "rw [\u2190 mul_lt_mul_iff_left a]", "annotated_tactic": ["rw [\u2190 <a>mul_lt_mul_iff_left</a> a]", [{"full_name": "mul_lt_mul_iff_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [105, 9], "def_end_pos": [105, 28]}]], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c : \u03b1\n\u22a2 b < a\u207b\u00b9 * c \u2194 a * b < c", "state_after": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c : \u03b1\n\u22a2 a * b < a * (a\u207b\u00b9 * c) \u2194 a * b < c"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x < x_1\na b c : \u03b1\n\u22a2 a * b < a * (a\u207b\u00b9 * c) \u2194 a * b < c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/NonZeroDivisors.lean", "full_name": "mem_nonZeroDivisors_iff_ne_zero", "start": [123, 1], "end": [124, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "Valuation.map_one", "start": [159, 1], "end": [160, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.nontrivial_pair", "start": [2488, 1], "end": [2489, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Equiv.lean", "full_name": "AlgEquiv.congr_fun", "start": [159, 11], "end": [160, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.Nonempty.fst", "start": [339, 1], "end": [339, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Aut.lean", "full_name": "RingAut.smul_def", "start": [120, 11], "end": [121, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.constr_self", "start": [647, 1], "end": [648, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "Valuation.IsEquiv.comap", "start": [397, 1], "end": [398, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "MulAction.orbitRel_apply", "start": [294, 1], "end": [295, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.three_le", "start": [2401, 1], "end": [2405, 28], "traced_tactics": [{"tactic": "have : \u2191(3 : \u2115) \u2264 #\u03b1", "annotated_tactic": ["have : \u2191(3 : \u2115) \u2264 #\u03b1", []], "state_before": "\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y", "state_after": "case this\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\n\u22a2 \u21913 \u2264 #\u03b1\n\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis : \u21913 \u2264 #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "case this\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\n\u22a2 \u21913 \u2264 #\u03b1\n\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis : \u21913 \u2264 #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y", "state_after": "\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis : \u21913 \u2264 #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y"}, {"tactic": "have : \u2191(2 : \u2115) < #\u03b1", "annotated_tactic": ["have : \u2191(2 : \u2115) < #\u03b1", []], "state_before": "\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis : \u21913 \u2264 #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y", "state_after": "case this\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis : \u21913 \u2264 #\u03b1\n\u22a2 \u21912 < #\u03b1\n\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis\u271d : \u21913 \u2264 #\u03b1\nthis : \u21912 < #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y"}, {"tactic": "rwa [\u2190 succ_le_iff, \u2190 Cardinal.nat_succ]", "annotated_tactic": ["rwa [\u2190 <a>succ_le_iff</a>, \u2190 <a>Cardinal.nat_succ</a>]", [{"full_name": "Order.succ_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [343, 9], "def_end_pos": [343, 20]}, {"full_name": "Cardinal.nat_succ", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [1382, 9], "def_end_pos": [1382, 17]}]], "state_before": "case this\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis : \u21913 \u2264 #\u03b1\n\u22a2 \u21912 < #\u03b1\n\n\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis\u271d : \u21913 \u2264 #\u03b1\nthis : \u21912 < #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y", "state_after": "\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis\u271d : \u21913 \u2264 #\u03b1\nthis : \u21912 < #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y"}, {"tactic": "have := exists_not_mem_of_length_lt [x, y] this", "annotated_tactic": ["have := <a>exists_not_mem_of_length_lt</a> [x, y] this", [{"full_name": "Cardinal.exists_not_mem_of_length_lt", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2391, 9], "def_end_pos": [2391, 36]}]], "state_before": "\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis\u271d : \u21913 \u2264 #\u03b1\nthis : \u21912 < #\u03b1\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y", "state_after": "\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis\u271d\u00b9 : \u21913 \u2264 #\u03b1\nthis\u271d : \u21912 < #\u03b1\nthis : \u2203 z, z \u2209 [x, y]\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y"}, {"tactic": "simpa [not_or] using this", "annotated_tactic": ["simpa [<a>not_or</a>] using this", [{"full_name": "not_or", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [346, 9], "def_end_pos": [346, 15]}]], "state_before": "\u03b1\u271d \u03b2 : Type u\n\u03b1 : Type u_1\nh : 3 \u2264 #\u03b1\nx y : \u03b1\nthis\u271d\u00b9 : \u21913 \u2264 #\u03b1\nthis\u271d : \u21912 < #\u03b1\nthis : \u2203 z, z \u2209 [x, y]\n\u22a2 \u2203 z, z \u2260 x \u2227 z \u2260 y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atBot_mono", "start": [418, 1], "end": [420, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "Ne.lt_top", "start": [186, 1], "end": [187, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Hom.lean", "full_name": "AlgHom.comp_id", "start": [347, 1], "end": [348, 20], "traced_tactics": []}, {"url": "https://github.com/Moyvbai/Theorem", "commit": "2fad0ff51bf93233afcde842768074b0c8b33efa", "file_path": "Theorem/example_separate/pow_zero_mul_add_sum.lean", "full_name": "pow_zero_mul_add_sum", "start": [10, 1], "end": [16, 7], "traced_tactics": [{"tactic": "have h_pow_zero_mul_add: ((-1 : \u211d)^0 * (choose (n-1) 0 : \u211d) * (m / (m+0)) + \u2211 k in Ico 1 n, (-1 : \u211d)^k * ((choose (n-1) k) : \u211d) * (m / (m+k))) = ((-1 : \u211d)^0 * (choose (n-1) 0 : \u211d) * (m / (m+0)) + \u2211 k in Ico (0+1) n, (-1 : \u211d)^k * ((choose (n-1) k) : \u211d) * (m / (m+k))):= by\n  congr 1", "annotated_tactic": ["have h_pow_zero_mul_add: ((-1 : \u211d)^0 * (<a>choose</a> (n-1) 0 : \u211d) * (m / (m+0)) + \u2211 k in <a>Ico</a> 1 n, (-1 : \u211d)^k * ((<a>choose</a> (n-1) k) : \u211d) * (m / (m+k))) = ((-1 : \u211d)^0 * (<a>choose</a> (n-1) 0 : \u211d) * (m / (m+0)) + \u2211 k in <a>Ico</a> (0+1) n, (-1 : \u211d)^k * ((<a>choose</a> (n-1) k) : \u211d) * (m / (m+k))):= by\n    congr 1", [{"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Finset.Ico", "def_path": "lake-packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [309, 5], "def_end_pos": [309, 8]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}, {"full_name": "Finset.Ico", "def_path": "lake-packages/mathlib/Mathlib/Order/LocallyFinite.lean", "def_pos": [309, 5], "def_end_pos": [309, 8]}, {"full_name": "Nat.choose", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 11]}]], "state_before": "n : \u2115\nm : \u211d\nhn : 0 < n\n\u22a2 (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    \u2211 k in range n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))", "state_after": "n : \u2115\nm : \u211d\nhn : 0 < n\nh_pow_zero_mul_add :\n  (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))\n\u22a2 (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    \u2211 k in range n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))"}, {"tactic": "rw[h_pow_zero_mul_add, range_eq_Ico, sum_eq_sum_Ico_succ_bot hn]", "annotated_tactic": ["rw[h_pow_zero_mul_add, <a>range_eq_Ico</a>, <a>sum_eq_sum_Ico_succ_bot</a> hn]", [{"full_name": "Finset.range_eq_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [93, 9], "def_end_pos": [93, 35]}, {"full_name": "Finset.sum_eq_sum_Ico_succ_bot", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Intervals.lean", "def_pos": [56, 3], "def_end_pos": [56, 14]}]], "state_before": "n : \u2115\nm : \u211d\nhn : 0 < n\nh_pow_zero_mul_add :\n  (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))\n\u22a2 (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    \u2211 k in range n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))", "state_after": "n : \u2115\nm : \u211d\nhn : 0 < n\nh_pow_zero_mul_add :\n  (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))\n\u22a2 (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + \u21910)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n : \u2115\nm : \u211d\nhn : 0 < n\nh_pow_zero_mul_add :\n  (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))\n\u22a2 (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + \u21910)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))", "state_after": "no goals"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "n : \u2115\nm : \u211d\nhn : 0 < n\n\u22a2 (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico 1 n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k)) =\n    (-1) ^ 0 * \u2191(Nat.choose (n - 1) 0) * (m / (m + 0)) +\n      \u2211 k in Ico (0 + 1) n, (-1) ^ k * \u2191(Nat.choose (n - 1) k) * (m / (m + \u2191k))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Lattice.lean", "full_name": "sup_le_sup", "start": [229, 1], "end": [230, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Pointwise.lean", "full_name": "SubMulAction.coe_mul", "start": [62, 1], "end": [63, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/FieldDivision.lean", "full_name": "Polynomial.mul_div_eq_iff_isRoot", "start": [235, 1], "end": [236, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.mapsTo_sInter", "start": [1588, 1], "end": [1589, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "Disjoint.le_of_codisjoint", "start": [444, 1], "end": [446, 39], "traced_tactics": [{"tactic": "rw [\u2190 @inf_top_eq _ _ _ a, \u2190 @bot_sup_eq _ _ _ c, \u2190 hab.eq_bot, \u2190 hbc.eq_top, sup_inf_right]", "annotated_tactic": ["rw [\u2190 @<a>inf_top_eq</a> _ _ _ a, \u2190 @<a>bot_sup_eq</a> _ _ _ c, \u2190 hab.eq_bot, \u2190 hbc.eq_top, <a>sup_inf_right</a>]", [{"full_name": "inf_top_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [479, 9], "def_end_pos": [479, 19]}, {"full_name": "bot_sup_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [454, 9], "def_end_pos": [454, 19]}, {"full_name": "sup_inf_right", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [769, 9], "def_end_pos": [769, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : BoundedOrder \u03b1\na b c : \u03b1\nhab : Disjoint a b\nhbc : Codisjoint b c\n\u22a2 a \u2264 c", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : BoundedOrder \u03b1\na b c : \u03b1\nhab : Disjoint a b\nhbc : Codisjoint b c\n\u22a2 a \u2293 (b \u2294 c) \u2264 (a \u2294 c) \u2293 (b \u2294 c)"}, {"tactic": "exact inf_le_inf_right _ le_sup_left", "annotated_tactic": ["exact <a>inf_le_inf_right</a> _ <a>le_sup_left</a>", [{"full_name": "inf_le_inf_right", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [483, 9], "def_end_pos": [483, 25]}, {"full_name": "le_sup_left", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [130, 9], "def_end_pos": [130, 20]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : BoundedOrder \u03b1\na b c : \u03b1\nhab : Disjoint a b\nhbc : Codisjoint b c\n\u22a2 a \u2293 (b \u2294 c) \u2264 (a \u2294 c) \u2293 (b \u2294 c)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/StdBasis.lean", "full_name": "Pi.basisFun_apply", "start": [280, 1], "end": [282, 20], "traced_tactics": [{"tactic": "simp only [basisFun, Basis.coe_ofEquivFun, LinearEquiv.refl_symm, LinearEquiv.refl_apply,\n  stdBasis_apply]", "annotated_tactic": ["simp only [<a>basisFun</a>, <a>Basis.coe_ofEquivFun</a>, <a>LinearEquiv.refl_symm</a>, <a>LinearEquiv.refl_apply</a>,\n    <a>stdBasis_apply</a>]", [{"full_name": "Pi.basisFun", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [275, 19], "def_end_pos": [275, 27]}, {"full_name": "Basis.coe_ofEquivFun", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basis.lean", "def_pos": [968, 9], "def_end_pos": [968, 29]}, {"full_name": "LinearEquiv.refl_symm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [458, 9], "def_end_pos": [458, 18]}, {"full_name": "LinearEquiv.refl_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Equiv.lean", "def_pos": [265, 9], "def_end_pos": [265, 19]}, {"full_name": "LinearMap.stdBasis_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/StdBasis.lean", "def_pos": [52, 9], "def_end_pos": [52, 23]}]], "state_before": "R : Type u_1\n\u03b7 : Type u_2\n\u03b9s : \u03b7 \u2192 Type u_3\nMs : \u03b7 \u2192 Type u_4\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : (i : \u03b7) \u2192 AddCommMonoid (Ms i)\ninst\u271d\u00b2 : (i : \u03b7) \u2192 Module R (Ms i)\ninst\u271d\u00b9 : Fintype \u03b7\ninst\u271d : DecidableEq \u03b7\ni : \u03b7\n\u22a2 \u2191(basisFun R \u03b7) i = \u2191(stdBasis R (fun x => R) i) 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Kleene.lean", "full_name": "le_kstar", "start": [236, 1], "end": [237, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Basic.lean", "full_name": "Nat.findGreatest_of_not", "start": [921, 1], "end": [923, 29], "traced_tactics": [{"tactic": "simp [Nat.findGreatest, h]", "annotated_tactic": ["simp [<a>Nat.findGreatest</a>, h]", [{"full_name": "Nat.findGreatest", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [897, 15], "def_end_pos": [897, 27]}]], "state_before": "m n k : \u2115\nP Q : \u2115 \u2192 Prop\ninst\u271d : DecidablePred P\nb : \u2115\nh : \u00acP (b + 1)\n\u22a2 Nat.findGreatest P (b + 1) = Nat.findGreatest P b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "Disjoint.le_bot", "start": [134, 1], "end": [135, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "posMulMono_iff_mulPosMono", "start": [1035, 1], "end": [1036, 55], "traced_tactics": [{"tactic": "simp only [PosMulMono, MulPosMono, IsSymmOp.symm_op]", "annotated_tactic": ["simp only [<a>PosMulMono</a>, <a>MulPosMono</a>, <a>IsSymmOp.symm_op</a>]", [{"full_name": "PosMulMono", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [74, 8], "def_end_pos": [74, 18]}, {"full_name": "MulPosMono", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [80, 8], "def_end_pos": [80, 18]}, {"full_name": "IsSymmOp.symm_op", "def_path": "lake-packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [71, 3], "def_end_pos": [71, 10]}]], "state_before": "\u03b1 : Type u_1\na b c d : \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : IsSymmOp \u03b1 \u03b1 fun x x_1 => x * x_1\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : Preorder \u03b1\n\u22a2 PosMulMono \u03b1 \u2194 MulPosMono \u03b1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "Associates.out_mk", "start": [220, 1], "end": [221, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Basic.lean", "full_name": "Finset.compl_filter", "start": [242, 1], "end": [244, 17], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b3 : Fintype \u03b1\ns t : Finset \u03b1\ninst\u271d\u00b2 : DecidableEq \u03b1\na : \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : (x : \u03b1) \u2192 Decidable \u00acp x\n\u22a2 \u2200 (a : \u03b1), a \u2208 (filter p univ)\u1d9c \u2194 a \u2208 filter (fun x => \u00acp x) univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/Group.lean", "full_name": "Mathlib.Tactic.Group.zpow_trick_one'", "start": [49, 1], "end": [50, 72], "traced_tactics": [{"tactic": "rw [mul_assoc, mul_zpow_self]", "annotated_tactic": ["rw [<a>mul_assoc</a>, <a>mul_zpow_self</a>]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_zpow_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [233, 9], "def_end_pos": [233, 22]}]], "state_before": "G : Type u_1\ninst\u271d : Group G\na b : G\nn : \u2124\n\u22a2 a * b ^ n * b = a * b ^ (n + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iUnion_inter_subset", "start": [699, 1], "end": [700, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.ceil_zero", "start": [1287, 1], "end": [1287, 71], "traced_tactics": [{"tactic": "rw [\u2190 cast_zero, ceil_intCast]", "annotated_tactic": ["rw [\u2190 <a>cast_zero</a>, <a>ceil_intCast</a>]", [{"full_name": "Int.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [59, 9], "def_end_pos": [59, 18]}, {"full_name": "Int.ceil_intCast", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1207, 9], "def_end_pos": [1207, 21]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nz : \u2124\na : \u03b1\n\u22a2 \u23080\u2309 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.reindex_trans", "start": [2615, 1], "end": [2618, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.mul_max_mul_right", "start": [677, 11], "end": [681, 76], "traced_tactics": [{"tactic": "induction a, b using Nat.recDiagAux with\n| zero_left => simp only [Nat.zero_mul, Nat.zero_max]\n| zero_right => simp only [Nat.zero_mul, Nat.max_zero]\n| succ_succ _ _ ih => simp only [Nat.succ_mul, Nat.add_max_add_right, ih]", "annotated_tactic": ["induction a, b using <a>Nat.recDiagAux</a> with\n  | zero_left => simp only [<a>Nat.zero_mul</a>, <a>Nat.zero_max</a>]\n  | zero_right => simp only [<a>Nat.zero_mul</a>, <a>Nat.max_zero</a>]\n  | succ_succ _ _ ih => simp only [<a>Nat.succ_mul</a>, <a>Nat.add_max_add_right</a>, ih]", [{"full_name": "Nat.recDiagAux", "def_path": "lake-packages/std/Std/Data/Nat/Basic.lean", "def_pos": [51, 15], "def_end_pos": [51, 25]}, {"full_name": "Nat.zero_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [165, 27], "def_end_pos": [165, 35]}, {"full_name": "Nat.zero_max", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [581, 27], "def_end_pos": [581, 35]}, {"full_name": "Nat.zero_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [165, 27], "def_end_pos": [165, 35]}, {"full_name": "Nat.max_zero", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [583, 27], "def_end_pos": [583, 35]}, {"full_name": "Nat.succ_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [169, 9], "def_end_pos": [169, 17]}, {"full_name": "Nat.add_max_add_right", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [631, 19], "def_end_pos": [631, 36]}]], "state_before": "a b c : Nat\n\u22a2 max (a * c) (b * c) = max a b * c", "state_after": "no goals"}, {"tactic": "simp only [Nat.zero_mul, Nat.zero_max]", "annotated_tactic": ["simp only [<a>Nat.zero_mul</a>, <a>Nat.zero_max</a>]", [{"full_name": "Nat.zero_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [165, 27], "def_end_pos": [165, 35]}, {"full_name": "Nat.zero_max", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [581, 27], "def_end_pos": [581, 35]}]], "state_before": "case zero_left\nc n\u271d : Nat\n\u22a2 max (0 * c) (n\u271d * c) = max 0 n\u271d * c", "state_after": "no goals"}, {"tactic": "simp only [Nat.zero_mul, Nat.max_zero]", "annotated_tactic": ["simp only [<a>Nat.zero_mul</a>, <a>Nat.max_zero</a>]", [{"full_name": "Nat.zero_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [165, 27], "def_end_pos": [165, 35]}, {"full_name": "Nat.max_zero", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [583, 27], "def_end_pos": [583, 35]}]], "state_before": "case zero_right\nc m\u271d : Nat\n\u22a2 max (m\u271d * c) (0 * c) = max m\u271d 0 * c", "state_after": "no goals"}, {"tactic": "simp only [Nat.succ_mul, Nat.add_max_add_right, ih]", "annotated_tactic": ["simp only [<a>Nat.succ_mul</a>, <a>Nat.add_max_add_right</a>, ih]", [{"full_name": "Nat.succ_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [169, 9], "def_end_pos": [169, 17]}, {"full_name": "Nat.add_max_add_right", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [631, 19], "def_end_pos": [631, 36]}]], "state_before": "case succ_succ\nc m\u271d n\u271d : Nat\nih : max (m\u271d * c) (n\u271d * c) = max m\u271d n\u271d * c\n\u22a2 max ((m\u271d + 1) * c) ((n\u271d + 1) * c) = max (m\u271d + 1) (n\u271d + 1) * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/Lemmas.lean", "full_name": "Int.nonneg_or_nonneg_neg", "start": [550, 1], "end": [552, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/Congr!.lean", "full_name": "eq_imp_of_iff_imp", "start": [482, 9], "end": [485, 18], "traced_tactics": [{"tactic": "cases he", "annotated_tactic": ["cases he", []], "state_before": "x y : Prop\np : x = y \u2192 Prop\nh : \u2200 (he : x \u2194 y), p (_ : x = y)\nhe : x = y\n\u22a2 p he", "state_after": "case refl\nx : Prop\np : x = x \u2192 Prop\nh : \u2200 (he : x \u2194 x), p (_ : x = x)\n\u22a2 p (_ : x = x)"}, {"tactic": "exact h Iff.rfl", "annotated_tactic": ["exact h <a>Iff.rfl</a>", [{"full_name": "Iff.rfl", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [663, 19], "def_end_pos": [663, 26]}]], "state_before": "case refl\nx : Prop\np : x = x \u2192 Prop\nh : \u2200 (he : x \u2194 x), p (_ : x = x)\n\u22a2 p (_ : x = x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Lemmas.lean", "full_name": "zpow_left_inj", "start": [430, 1], "end": [431, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Nat/Bitwise.lean", "full_name": "Nat.div2_two", "start": [109, 1], "end": [110, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "StrictMono.prod_map", "start": [1205, 1], "end": [1208, 81], "traced_tactics": [{"tactic": "simp only [Prod.lt_iff]", "annotated_tactic": ["simp only [<a>Prod.lt_iff</a>]", [{"full_name": "Prod.lt_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [1258, 9], "def_end_pos": [1258, 15]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : Preorder \u03b3\ninst\u271d : Preorder \u03b4\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nhf : StrictMono f\nhg : StrictMono g\na b : \u03b1 \u00d7 \u03b2\n\u22a2 a < b \u2192 Prod.map f g a < Prod.map f g b", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : Preorder \u03b3\ninst\u271d : Preorder \u03b4\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nhf : StrictMono f\nhg : StrictMono g\na b : \u03b1 \u00d7 \u03b2\n\u22a2 a.1 < b.1 \u2227 a.2 \u2264 b.2 \u2228 a.1 \u2264 b.1 \u2227 a.2 < b.2 \u2192\n    (Prod.map f g a).1 < (Prod.map f g b).1 \u2227 (Prod.map f g a).2 \u2264 (Prod.map f g b).2 \u2228\n      (Prod.map f g a).1 \u2264 (Prod.map f g b).1 \u2227 (Prod.map f g a).2 < (Prod.map f g b).2"}, {"tactic": "exact Or.imp (And.imp hf.imp hg.monotone.imp) (And.imp hf.monotone.imp hg.imp)", "annotated_tactic": ["exact <a>Or.imp</a> (<a>And.imp</a> hf.imp hg.monotone.imp) (<a>And.imp</a> hf.monotone.imp hg.imp)", [{"full_name": "Or.imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [255, 9], "def_end_pos": [255, 15]}, {"full_name": "And.imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [153, 9], "def_end_pos": [153, 16]}, {"full_name": "And.imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [153, 9], "def_end_pos": [153, 16]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : Preorder \u03b3\ninst\u271d : Preorder \u03b4\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nhf : StrictMono f\nhg : StrictMono g\na b : \u03b1 \u00d7 \u03b2\n\u22a2 a.1 < b.1 \u2227 a.2 \u2264 b.2 \u2228 a.1 \u2264 b.1 \u2227 a.2 < b.2 \u2192\n    (Prod.map f g a).1 < (Prod.map f g b).1 \u2227 (Prod.map f g a).2 \u2264 (Prod.map f g b).2 \u2228\n      (Prod.map f g a).1 \u2264 (Prod.map f g b).1 \u2227 (Prod.map f g a).2 < (Prod.map f g b).2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearMap.pi_apply_eq_sum_univ", "start": [341, 1], "end": [345, 16], "traced_tactics": [{"tactic": "conv_lhs => rw [pi_eq_sum_univ x, map_sum]", "annotated_tactic": ["conv_lhs => rw [<a>pi_eq_sum_univ</a> x, <a>map_sum</a>]", [{"full_name": "pi_eq_sum_univ", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [148, 9], "def_end_pos": [148, 23]}, {"full_name": "map_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [204, 3], "def_end_pos": [204, 14]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u00b9\u2079 : Semiring R\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\ninst\u271d\u00b9\u2076 : Semiring R\u2084\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2084\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R M\u2081\ninst\u271d\u2078 : Module R\u2082 M\u2082\ninst\u271d\u2077 : Module R\u2083 M\u2083\ninst\u271d\u2076 : Module R\u2084 M\u2084\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084\n\u03c3\u2081\u2084 : R \u2192+* R\u2084\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084\nf\u271d : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 R) \u2192\u2097[R] M\nx : \u03b9 \u2192 R\n\u22a2 \u2191f x = \u2211 i : \u03b9, x i \u2022 \u2191f fun j => if i = j then 1 else 0", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u00b9\u2079 : Semiring R\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\ninst\u271d\u00b9\u2076 : Semiring R\u2084\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2084\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R M\u2081\ninst\u271d\u2078 : Module R\u2082 M\u2082\ninst\u271d\u2077 : Module R\u2083 M\u2083\ninst\u271d\u2076 : Module R\u2084 M\u2084\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084\n\u03c3\u2081\u2084 : R \u2192+* R\u2084\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084\nf\u271d : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 R) \u2192\u2097[R] M\nx : \u03b9 \u2192 R\n\u22a2 \u2211 x_1 : \u03b9, \u2191f (x x_1 \u2022 fun j => if x_1 = j then 1 else 0) = \u2211 i : \u03b9, x i \u2022 \u2191f fun j => if i = j then 1 else 0"}, {"tactic": "refine Finset.sum_congr rfl (fun _ _ => ?_)", "annotated_tactic": ["refine <a>Finset.sum_congr</a> <a>rfl</a> (fun _ _ => ?_)", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u00b9\u2079 : Semiring R\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\ninst\u271d\u00b9\u2076 : Semiring R\u2084\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2084\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R M\u2081\ninst\u271d\u2078 : Module R\u2082 M\u2082\ninst\u271d\u2077 : Module R\u2083 M\u2083\ninst\u271d\u2076 : Module R\u2084 M\u2084\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084\n\u03c3\u2081\u2084 : R \u2192+* R\u2084\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084\nf\u271d : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 R) \u2192\u2097[R] M\nx : \u03b9 \u2192 R\n\u22a2 \u2211 x_1 : \u03b9, \u2191f (x x_1 \u2022 fun j => if x_1 = j then 1 else 0) = \u2211 i : \u03b9, x i \u2022 \u2191f fun j => if i = j then 1 else 0", "state_after": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u00b9\u2079 : Semiring R\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\ninst\u271d\u00b9\u2076 : Semiring R\u2084\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2084\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R M\u2081\ninst\u271d\u2078 : Module R\u2082 M\u2082\ninst\u271d\u2077 : Module R\u2083 M\u2083\ninst\u271d\u2076 : Module R\u2084 M\u2084\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084\n\u03c3\u2081\u2084 : R \u2192+* R\u2084\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084\nf\u271d : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 R) \u2192\u2097[R] M\nx : \u03b9 \u2192 R\nx\u271d\u00b9 : \u03b9\nx\u271d : x\u271d\u00b9 \u2208 Finset.univ\n\u22a2 \u2191f (x x\u271d\u00b9 \u2022 fun j => if x\u271d\u00b9 = j then 1 else 0) = x x\u271d\u00b9 \u2022 \u2191f fun j => if x\u271d\u00b9 = j then 1 else 0"}, {"tactic": "rw [map_smul]", "annotated_tactic": ["rw [<a>map_smul</a>]", [{"full_name": "SMulHomClass.map_smul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Hom.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}]], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nR\u2084 : Type u_5\nS : Type u_6\nK : Type u_7\nK\u2082 : Type u_8\nM : Type u_9\nM' : Type u_10\nM\u2081 : Type u_11\nM\u2082 : Type u_12\nM\u2083 : Type u_13\nM\u2084 : Type u_14\nN : Type u_15\nN\u2082 : Type u_16\n\u03b9 : Type u_17\nV : Type u_18\nV\u2082 : Type u_19\ninst\u271d\u00b9\u2079 : Semiring R\ninst\u271d\u00b9\u2078 : Semiring R\u2082\ninst\u271d\u00b9\u2077 : Semiring R\u2083\ninst\u271d\u00b9\u2076 : Semiring R\u2084\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2084\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R M\u2081\ninst\u271d\u2078 : Module R\u2082 M\u2082\ninst\u271d\u2077 : Module R\u2083 M\u2083\ninst\u271d\u2076 : Module R\u2084 M\u2084\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084\n\u03c3\u2081\u2084 : R \u2192+* R\u2084\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084\ninst\u271d\u00b3 : RingHomCompTriple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084\ninst\u271d\u00b2 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084\nf\u271d : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 R) \u2192\u2097[R] M\nx : \u03b9 \u2192 R\nx\u271d\u00b9 : \u03b9\nx\u271d : x\u271d\u00b9 \u2208 Finset.univ\n\u22a2 \u2191f (x x\u271d\u00b9 \u2022 fun j => if x\u271d\u00b9 = j then 1 else 0) = x x\u271d\u00b9 \u2022 \u2191f fun j => if x\u271d\u00b9 = j then 1 else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/NeZero.lean", "full_name": "NeZero.of_pos", "start": [101, 1], "end": [101, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/TypeTags.lean", "full_name": "ofMul_eq_zero", "start": [225, 1], "end": [225, 92], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Powerset.lean", "full_name": "Multiset.powersetCard_coe", "start": [241, 1], "end": [243, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Abs.lean", "full_name": "abs_dvd", "start": [95, 1], "end": [96, 58], "traced_tactics": [{"tactic": "cases' abs_choice a with h h <;> simp only [h, neg_dvd]", "annotated_tactic": ["cases' <a>abs_choice</a> a with h h <;> simp only [h, <a>neg_dvd</a>]", [{"full_name": "abs_choice", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [45, 9], "def_end_pos": [45, 19]}, {"full_name": "neg_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Divisibility/Basic.lean", "def_pos": [67, 9], "def_end_pos": [67, 16]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : LinearOrder \u03b1\na\u271d b\u271d a b : \u03b1\n\u22a2 |a| \u2223 b \u2194 a \u2223 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.Monic.ne_zero", "start": [864, 1], "end": [867, 21], "traced_tactics": [{"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "R\u271d : Type u\nS : Type v\na b c d : R\u271d\nn m : \u2115\ninst\u271d\u00b2 : Semiring R\u271d\np\u271d q : R\u271d[X]\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : R[X]\nhp : Monic p\n\u22a2 p \u2260 0", "state_after": "R\u271d : Type u\nS : Type v\na b c d : R\u271d\nn m : \u2115\ninst\u271d\u00b2 : Semiring R\u271d\np q : R\u271d[X]\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nhp : Monic 0\n\u22a2 False"}, {"tactic": "simp [Monic] at hp", "annotated_tactic": ["simp [<a>Monic</a>] at hp", [{"full_name": "Polynomial.Monic", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [75, 5], "def_end_pos": [75, 10]}]], "state_before": "R\u271d : Type u\nS : Type v\na b c d : R\u271d\nn m : \u2115\ninst\u271d\u00b2 : Semiring R\u271d\np q : R\u271d[X]\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nhp : Monic 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.coe_sInf", "start": [591, 1], "end": [592, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.liftNC_mul", "start": [1335, 1], "end": [1339, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Bool.lean", "full_name": "Bool.and_not_self", "start": [45, 9], "end": [45, 76], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u2200 (x : Bool), (x && !x) = false", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.forall_iff_forall_finsupp", "start": [87, 1], "end": [89, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/LinearMap.lean", "full_name": "LinearMap.comp_smul", "start": [1007, 1], "end": [1010, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.symm_trans_apply", "start": [928, 1], "end": [930, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_unique", "start": [222, 1], "end": [223, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_mem_smul_finset_iff", "start": [1948, 1], "end": [1949, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Star/Basic.lean", "full_name": "star_star", "start": [86, 1], "end": [87, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.smul_mat_empty", "start": [378, 1], "end": [379, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.set_biInter_biUnion", "start": [2171, 1], "end": [2173, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "OrderIso.map_ciInf_set", "start": [1527, 1], "end": [1529, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.ext", "start": [35, 8], "end": [35, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BoundedOrderHom.dual_comp", "start": [817, 1], "end": [819, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.conjTransposeLinearEquiv_symm", "start": [2346, 1], "end": [2349, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fin.cast_eq_cast'", "start": [333, 1], "end": [336, 6], "traced_tactics": [{"tactic": "cases fin_injective h", "annotated_tactic": ["cases <a>fin_injective</a> h", [{"full_name": "fin_injective", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [328, 9], "def_end_pos": [328, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn m : \u2115\nh : Fin n = Fin m\n\u22a2 _root_.cast h = cast (_ : n = m)", "state_after": "case refl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\nh : Fin n = Fin n\n\u22a2 _root_.cast h = cast (_ : n = n)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case refl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\nh : Fin n = Fin n\n\u22a2 _root_.cast h = cast (_ : n = n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Nodup.lean", "full_name": "Multiset.Nodup.cons", "start": [45, 1], "end": [46, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "full_name": "dvd_mul", "start": [548, 1], "end": [551, 26], "traced_tactics": [{"tactic": "refine' \u27e8exists_dvd_and_dvd_of_dvd_mul, _\u27e9", "annotated_tactic": ["refine' \u27e8<a>exists_dvd_and_dvd_of_dvd_mul</a>, _\u27e9", [{"full_name": "exists_dvd_and_dvd_of_dvd_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [530, 9], "def_end_pos": [530, 38]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\nk m n : \u03b1\n\u22a2 k \u2223 m * n \u2194 \u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082", "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\nk m n : \u03b1\n\u22a2 (\u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082) \u2192 k \u2223 m * n"}, {"tactic": "rintro \u27e8d\u2081, d\u2082, hy, hz, rfl\u27e9", "annotated_tactic": ["rintro \u27e8d\u2081, d\u2082, hy, hz, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\nk m n : \u03b1\n\u22a2 (\u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082) \u2192 k \u2223 m * n", "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\nm n d\u2081 d\u2082 : \u03b1\nhy : d\u2081 \u2223 m\nhz : d\u2082 \u2223 n\n\u22a2 d\u2081 * d\u2082 \u2223 m * n"}, {"tactic": "exact mul_dvd_mul hy hz", "annotated_tactic": ["exact <a>mul_dvd_mul</a> hy hz", [{"full_name": "mul_dvd_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [181, 9], "def_end_pos": [181, 20]}]], "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\nm n d\u2081 d\u2082 : \u03b1\nhy : d\u2081 \u2223 m\nhz : d\u2082 \u2223 n\n\u22a2 d\u2081 * d\u2082 \u2223 m * n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.diff_inter_self", "start": [2046, 1], "end": [2047, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.dual_Iio", "start": [241, 1], "end": [242, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.inter_eventuallyEq_right", "start": [1615, 1], "end": [1617, 43], "traced_tactics": [{"tactic": "rw [inter_comm, inter_eventuallyEq_left]", "annotated_tactic": ["rw [<a>inter_comm</a>, <a>inter_eventuallyEq_left</a>]", [{"full_name": "Set.inter_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [933, 9], "def_end_pos": [933, 19]}, {"full_name": "Filter.inter_eventuallyEq_left", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1610, 9], "def_end_pos": [1610, 32]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\ns t : Set \u03b1\nl : Filter \u03b1\n\u22a2 s \u2229 t =\u1da0[l] t \u2194 \u2200\u1da0 (x : \u03b1) in l, x \u2208 t \u2192 x \u2208 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Finite.lean", "full_name": "Subgroup.eq_bot_of_card_eq", "start": [162, 1], "end": [163, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.isRadical_bot_of_noZeroDivisors", "start": [1053, 1], "end": [1054, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Basic.lean", "full_name": "Polynomial.C_ne_zero", "start": [807, 1], "end": [808, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/TypeTags.lean", "full_name": "ofMul_inv", "start": [316, 1], "end": [317, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/BigOperators.lean", "full_name": "Set.image_list_prod", "start": [29, 1], "end": [32, 101], "traced_tactics": [{"tactic": "rw [List.map_cons, List.prod_cons, List.prod_cons, image_mul, image_list_prod _ _]", "annotated_tactic": ["rw [<a>List.map_cons</a>, <a>List.prod_cons</a>, <a>List.prod_cons</a>, <a>image_mul</a>, image_list_prod _ _]", [{"full_name": "List.map_cons", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [99, 17], "def_end_pos": [99, 25]}, {"full_name": "List.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 18]}, {"full_name": "List.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 18]}, {"full_name": "Set.image_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [1295, 9], "def_end_pos": [1295, 18]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nF : Type u_4\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : Monoid \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\na : Set \u03b1\nas : List (Set \u03b1)\n\u22a2 \u2191f '' List.prod (a :: as) = List.prod (List.map (fun s => \u2191f '' s) (a :: as))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Eval.lean", "full_name": "Polynomial.eval_nat_cast_map", "start": [995, 1], "end": [1002, 81], "traced_tactics": [{"tactic": "induction p using Polynomial.induction_on' with\n| h_add p q hp hq =>\n  simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]\n| h_monomial n r =>\n  simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]", "annotated_tactic": ["induction p using <a>Polynomial.induction_on'</a> with\n  | h_add p q hp hq =>\n    simp only [hp, hq, <a>Polynomial.map_add</a>, <a>RingHom.map_add</a>, <a>eval_add</a>]\n  | h_monomial n r =>\n    simp only [<a>map_natCast</a> f, <a>eval_monomial</a>, <a>map_monomial</a>, f.map_pow, f.map_mul]", [{"full_name": "Polynomial.induction_on'", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Induction.lean", "def_pos": [63, 19], "def_end_pos": [63, 32]}, {"full_name": "Polynomial.map_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [739, 19], "def_end_pos": [739, 26]}, {"full_name": "RingHom.map_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "Polynomial.eval_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [388, 9], "def_end_pos": [388, 17]}, {"full_name": "map_natCast", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [136, 9], "def_end_pos": [136, 20]}, {"full_name": "Polynomial.eval_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [378, 9], "def_end_pos": [378, 22]}, {"full_name": "Polynomial.map_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [728, 9], "def_end_pos": [728, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q r : R[X]\ninst\u271d : Semiring S\nf\u271d f : R \u2192+* S\np : R[X]\nn : \u2115\n\u22a2 eval (\u2191n) (map f p) = \u2191f (eval (\u2191n) p)", "state_after": "no goals"}, {"tactic": "simp only [hp, hq, Polynomial.map_add, RingHom.map_add, eval_add]", "annotated_tactic": ["simp only [hp, hq, <a>Polynomial.map_add</a>, <a>RingHom.map_add</a>, <a>eval_add</a>]", [{"full_name": "Polynomial.map_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [739, 19], "def_end_pos": [739, 26]}, {"full_name": "RingHom.map_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Hom/Defs.lean", "def_pos": [564, 19], "def_end_pos": [564, 26]}, {"full_name": "Polynomial.eval_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [388, 9], "def_end_pos": [388, 17]}]], "state_before": "case h_add\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\np\u271d q\u271d r : R[X]\ninst\u271d : Semiring S\nf\u271d f : R \u2192+* S\nn : \u2115\np q : R[X]\nhp : eval (\u2191n) (map f p) = \u2191f (eval (\u2191n) p)\nhq : eval (\u2191n) (map f q) = \u2191f (eval (\u2191n) q)\n\u22a2 eval (\u2191n) (map f (p + q)) = \u2191f (eval (\u2191n) (p + q))", "state_after": "no goals"}, {"tactic": "simp only [map_natCast f, eval_monomial, map_monomial, f.map_pow, f.map_mul]", "annotated_tactic": ["simp only [<a>map_natCast</a> f, <a>eval_monomial</a>, <a>map_monomial</a>, f.map_pow, f.map_mul]", [{"full_name": "map_natCast", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Basic.lean", "def_pos": [136, 9], "def_end_pos": [136, 20]}, {"full_name": "Polynomial.eval_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [378, 9], "def_end_pos": [378, 22]}, {"full_name": "Polynomial.map_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [728, 9], "def_end_pos": [728, 21]}]], "state_before": "case h_monomial\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\na b : R\nm n\u271d\u00b9 : \u2115\ninst\u271d\u00b9 : Semiring R\np q r\u271d : R[X]\ninst\u271d : Semiring S\nf\u271d f : R \u2192+* S\nn\u271d n : \u2115\nr : R\n\u22a2 eval (\u2191n\u271d) (map f (\u2191(monomial n) r)) = \u2191f (eval (\u2191n\u271d) (\u2191(monomial n) r))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.image_mem_map", "start": [1869, 1], "end": [1870, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.coprime_one_left", "start": [372, 1], "end": [372, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "symmDiff_eq_top", "start": [753, 1], "end": [755, 30], "traced_tactics": [{"tactic": "rw [symmDiff_eq', \u2190 compl_inf, inf_eq_top_iff, compl_eq_top, isCompl_iff, disjoint_iff,\n  codisjoint_iff, and_comm]", "annotated_tactic": ["rw [<a>symmDiff_eq'</a>, \u2190 <a>compl_inf</a>, <a>inf_eq_top_iff</a>, <a>compl_eq_top</a>, <a>isCompl_iff</a>, <a>disjoint_iff</a>,\n    <a>codisjoint_iff</a>, <a>and_comm</a>]", [{"full_name": "symmDiff_eq'", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [716, 9], "def_end_pos": [716, 21]}, {"full_name": "compl_inf", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [679, 9], "def_end_pos": [679, 18]}, {"full_name": "inf_eq_top_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [484, 9], "def_end_pos": [484, 23]}, {"full_name": "compl_eq_top", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [669, 9], "def_end_pos": [669, 21]}, {"full_name": "isCompl_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [461, 9], "def_end_pos": [461, 20]}, {"full_name": "disjoint_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [130, 9], "def_end_pos": [130, 21]}, {"full_name": "codisjoint_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [314, 9], "def_end_pos": [314, 23]}, {"full_name": "and_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [162, 9], "def_end_pos": [162, 17]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : BooleanAlgebra \u03b1\na b c d : \u03b1\n\u22a2 a \u2206 b = \u22a4 \u2194 IsCompl a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.lift_eq", "start": [518, 1], "end": [519, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finite/Card.lean", "full_name": "Finite.card_image_le", "start": [172, 1], "end": [173, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.cons_sublist_cons_iff", "start": [1022, 1], "end": [1023, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/OmegaCompletePartialOrder.lean", "full_name": "CompleteLattice.top_continuous", "start": [549, 1], "end": [552, 61], "traced_tactics": [{"tactic": "intro c", "annotated_tactic": ["intro c", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\n\u22a2 Continuous \u22a4", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nc : Chain \u03b1\n\u22a2 \u2191\u22a4 (\u03c9Sup c) = \u03c9Sup (Chain.map c \u22a4)"}, {"tactic": "apply eq_of_forall_ge_iff", "annotated_tactic": ["apply <a>eq_of_forall_ge_iff</a>", [{"full_name": "eq_of_forall_ge_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [569, 9], "def_end_pos": [569, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nc : Chain \u03b1\n\u22a2 \u2191\u22a4 (\u03c9Sup c) = \u03c9Sup (Chain.map c \u22a4)", "state_after": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nc : Chain \u03b1\n\u22a2 \u2200 (c_1 : \u03b2), \u2191\u22a4 (\u03c9Sup c) \u2264 c_1 \u2194 \u03c9Sup (Chain.map c \u22a4) \u2264 c_1"}, {"tactic": "intro z", "annotated_tactic": ["intro z", []], "state_before": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nc : Chain \u03b1\n\u22a2 \u2200 (c_1 : \u03b2), \u2191\u22a4 (\u03c9Sup c) \u2264 c_1 \u2194 \u03c9Sup (Chain.map c \u22a4) \u2264 c_1", "state_after": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nc : Chain \u03b1\nz : \u03b2\n\u22a2 \u2191\u22a4 (\u03c9Sup c) \u2264 z \u2194 \u03c9Sup (Chain.map c \u22a4) \u2264 z"}, {"tactic": "simp only [OrderHom.instTopOrderHom_top, OrderHom.const_coe_coe, Function.const, top_le_iff,\n  \u03c9Sup_le_iff, Chain.map_coe, Function.comp, forall_const]", "annotated_tactic": ["simp only [<a>OrderHom.instTopOrderHom_top</a>, <a>OrderHom.const_coe_coe</a>, <a>Function.const</a>, <a>top_le_iff</a>,\n    <a>\u03c9Sup_le_iff</a>, <a>Chain.map_coe</a>, <a>Function.comp</a>, <a>forall_const</a>]", [{"full_name": "OrderHom.instTopOrderHom_top", "def_path": "lake-packages/mathlib/Mathlib/Order/Hom/Order.lean", "def_pos": [74, 3], "def_end_pos": [74, 8]}, {"full_name": "OrderHom.const_coe_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/Hom/Basic.lean", "def_pos": [370, 3], "def_end_pos": [370, 8]}, {"full_name": "Function.const", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [66, 15], "def_end_pos": [66, 29]}, {"full_name": "top_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [157, 9], "def_end_pos": [157, 19]}, {"full_name": "OmegaCompletePartialOrder.\u03c9Sup_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/OmegaCompletePartialOrder.lean", "def_pos": [232, 9], "def_end_pos": [232, 20]}, {"full_name": "OmegaCompletePartialOrder.Chain.map_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/OmegaCompletePartialOrder.lean", "def_pos": [124, 17], "def_end_pos": [124, 24]}, {"full_name": "Function.comp", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}, {"full_name": "forall_const", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [441, 17], "def_end_pos": [441, 29]}]], "state_before": "case H\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nc : Chain \u03b1\nz : \u03b2\n\u22a2 \u2191\u22a4 (\u03c9Sup c) \u2264 z \u2194 \u03c9Sup (Chain.map c \u22a4) \u2264 z", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "Set.finite_iff_bddBelow", "start": [1404, 1], "end": [1406, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.recAuxOn_succ", "start": [29, 1], "end": [31, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Hom.lean", "full_name": "MulSemiringActionHom.map_neg", "start": [536, 11], "end": [537, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "half_pos", "start": [504, 1], "end": [505, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "Finset.compl_inf", "start": [649, 11], "end": [650, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.extract_zero_endPos", "start": [451, 1], "end": [455, 35], "traced_tactics": [{"tactic": "simp [extract, Nat.ne_of_gt add_csize_pos]", "annotated_tactic": ["simp [<a>extract</a>, <a>Nat.ne_of_gt</a> <a>add_csize_pos</a>]", [{"full_name": "String.extract", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [220, 5], "def_end_pos": [220, 12]}, {"full_name": "Nat.ne_of_gt", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [138, 9], "def_end_pos": [138, 17]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.Data.String.Lemmas.0.String.add_csize_pos", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [44, 17], "def_end_pos": [44, 30]}]], "state_before": "c : Char\ncs : List Char\n\u22a2 extract { data := c :: cs } 0 (endPos { data := c :: cs }) = { data := c :: cs }", "state_after": "c : Char\ncs : List Char\n\u22a2 { data := extract.go\u2081 (c :: cs) 0 0 { byteIdx := utf8Len cs + csize c } } = { data := c :: cs }"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "c : Char\ncs : List Char\n\u22a2 { data := extract.go\u2081 (c :: cs) 0 0 { byteIdx := utf8Len cs + csize c } } = { data := c :: cs }", "state_after": "case e_data\nc : Char\ncs : List Char\n\u22a2 extract.go\u2081 (c :: cs) 0 0 { byteIdx := utf8Len cs + csize c } = c :: cs"}, {"tactic": "apply extract.go\u2081_zero_utf8Len", "annotated_tactic": ["apply <a>extract.go\u2081_zero_utf8Len</a>", [{"full_name": "String.extract.go\u2081_zero_utf8Len", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [442, 9], "def_end_pos": [442, 33]}]], "state_before": "case e_data\nc : Char\ncs : List Char\n\u22a2 extract.go\u2081 (c :: cs) 0 0 { byteIdx := utf8Len cs + csize c } = c :: cs", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "Units.eq_inv_of_mul_eq_one_right", "start": [372, 11], "end": [373, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Hom.lean", "full_name": "AlgHom.toLinearMap_injective", "start": [373, 1], "end": [375, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Lattice.lean", "full_name": "List.forall_mem_of_forall_mem_union_right", "start": [119, 1], "end": [120, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csInf_Icc", "start": [733, 1], "end": [734, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Bitwise.lean", "full_name": "Int.shiftLeft_sub", "start": [431, 1], "end": [432, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.equivOfEq_trans", "start": [1098, 1], "end": [1099, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.lt_ceil", "start": [1184, 1], "end": [1185, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "TensorProduct.tmul_smul", "start": [317, 1], "end": [319, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BoundedOrder.lean", "full_name": "isTop_iff_eq_top", "start": [138, 1], "end": [139, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Sum/Lemmas.lean", "full_name": "Sum.LiftRel.mono_left", "start": [175, 1], "end": [177, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "full_name": "sup_sInf_eq", "start": [301, 1], "end": [302, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.div_empty", "start": [579, 1], "end": [580, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Polynomial/Basic.lean", "full_name": "Ideal.polynomial_not_isField", "start": [649, 1], "end": [656, 17], "traced_tactics": [{"tactic": "nontriviality R", "annotated_tactic": ["nontriviality R", []], "state_before": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u22a2 \u00acIsField R[X]", "state_after": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\n\u22a2 \u00acIsField R[X]"}, {"tactic": "intro hR", "annotated_tactic": ["intro hR", []], "state_before": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\n\u22a2 \u00acIsField R[X]", "state_after": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\n\u22a2 False"}, {"tactic": "obtain \u27e8p, hp\u27e9 := hR.mul_inv_cancel X_ne_zero", "annotated_tactic": ["obtain \u27e8p, hp\u27e9 := hR.mul_inv_cancel <a>X_ne_zero</a>", [{"full_name": "Polynomial.X_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1253, 9], "def_end_pos": [1253, 18]}]], "state_before": "R : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\n\u22a2 False"}, {"tactic": "have hp0 : p \u2260 0 := right_ne_zero_of_mul_eq_one hp", "annotated_tactic": ["have hp0 : p \u2260 0 := <a>right_ne_zero_of_mul_eq_one</a> hp", [{"full_name": "right_ne_zero_of_mul_eq_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [150, 9], "def_end_pos": [150, 36]}]], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\n\u22a2 False"}, {"tactic": "have := degree_lt_degree_mul_X hp0", "annotated_tactic": ["have := <a>degree_lt_degree_mul_X</a> hp0", [{"full_name": "Polynomial.degree_lt_degree_mul_X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1144, 9], "def_end_pos": [1144, 31]}]], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : degree p < degree (p * X)\n\u22a2 False"}, {"tactic": "rw [\u2190 X_mul, congr_arg degree hp, degree_one, Nat.WithBot.lt_zero_iff, degree_eq_bot] at this", "annotated_tactic": ["rw [\u2190 <a>X_mul</a>, <a>congr_arg</a> <a>degree</a> hp, <a>degree_one</a>, <a>Nat.WithBot.lt_zero_iff</a>, <a>degree_eq_bot</a>] at this", [{"full_name": "Polynomial.X_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [586, 9], "def_end_pos": [586, 14]}, {"full_name": "congr_arg", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [43, 7], "def_end_pos": [43, 16]}, {"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.degree_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [512, 9], "def_end_pos": [512, 19]}, {"full_name": "Nat.WithBot.lt_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/WithBot.lean", "def_pos": [64, 9], "def_end_pos": [64, 20]}, {"full_name": "Polynomial.degree_eq_bot", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [116, 9], "def_end_pos": [116, 22]}]], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : degree p < degree (p * X)\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p = 0\n\u22a2 False"}, {"tactic": "exact hp0 this", "annotated_tactic": ["exact hp0 this", []], "state_before": "case intro\nR : Type u\nS : Type u_1\ninst\u271d : Ring R\n\u271d : Nontrivial R\nhR : IsField R[X]\np : R[X]\nhp : X * p = 1\nhp0 : p \u2260 0\nthis : p = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "full_name": "Submodule.IsPrincipal.of_comap", "start": [325, 1], "end": [329, 51], "traced_tactics": [{"tactic": "rw [\u2190 Set.image_singleton, \u2190 Submodule.map_span, IsPrincipal.span_singleton_generator,\n  Submodule.map_comap_eq_of_surjective hf]", "annotated_tactic": ["rw [\u2190 <a>Set.image_singleton</a>, \u2190 <a>Submodule.map_span</a>, <a>IsPrincipal.span_singleton_generator</a>,\n        <a>Submodule.map_comap_eq_of_surjective</a> hf]", [{"full_name": "Set.image_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [363, 9], "def_end_pos": [363, 24]}, {"full_name": "Submodule.map_span", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [95, 9], "def_end_pos": [95, 17]}, {"full_name": "Submodule.IsPrincipal.span_singleton_generator", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/PrincipalIdealDomain.lean", "def_pos": [102, 9], "def_end_pos": [102, 33]}, {"full_name": "Submodule.map_comap_eq_of_surjective", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [288, 9], "def_end_pos": [288, 35]}]], "state_before": "R : Type u\nM : Type v\nS\u271d : Type u_1\nN : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Ring S\u271d\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nf : M \u2192\u2097[R] N\nhf : Surjective \u2191f\nS : Submodule R N\nhI : IsPrincipal (comap f S)\n\u22a2 S = span R {\u2191f (generator (comap f S))}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Opposite.lean", "full_name": "Commute.op", "start": [249, 1], "end": [250, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.finite_preimage_inl_and_inr", "start": [994, 1], "end": [997, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Units.lean", "full_name": "Int.mul_eq_neg_one_iff_eq_one_or_neg_one", "start": [94, 1], "end": [98, 8], "traced_tactics": [{"tactic": "refine' \u27e8eq_one_or_neg_one_of_mul_eq_neg_one', fun h => Or.elim h (fun H => _) fun H => _\u27e9 <;>\n    rcases H with \u27e8rfl, rfl\u27e9 <;>\n  rfl", "annotated_tactic": ["refine' \u27e8<a>eq_one_or_neg_one_of_mul_eq_neg_one'</a>, fun h => <a>Or.elim</a> h (fun H => _) fun H => _\u27e9 <;>\n      rcases H with \u27e8rfl, rfl\u27e9 <;>\n    rfl", [{"full_name": "Int.eq_one_or_neg_one_of_mul_eq_neg_one'", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Units.lean", "def_pos": [87, 9], "def_end_pos": [87, 45]}, {"full_name": "Or.elim", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [533, 9], "def_end_pos": [533, 16]}]], "state_before": "z w : \u2124\n\u22a2 z * w = -1 \u2194 z = 1 \u2227 w = -1 \u2228 z = -1 \u2227 w = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "DoubleQuot.quotQuotEquivComm_mk_mk", "start": [767, 1], "end": [769, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "TensorProduct.map_add_left", "start": [834, 1], "end": [837, 68], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2078 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u2077 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u2076 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid N\ninst\u271d\u00b9\u00b3 : AddCommMonoid P\ninst\u271d\u00b9\u00b2 : AddCommMonoid Q\ninst\u271d\u00b9\u00b9 : AddCommMonoid S\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R N\ninst\u271d\u2078 : Module R P\ninst\u271d\u2077 : Module R Q\ninst\u271d\u2076 : Module R S\ninst\u271d\u2075 : DistribMulAction R' M\ninst\u271d\u2074 : Module R'' M\nP' : Type u_9\nQ' : Type u_10\ninst\u271d\u00b3 : AddCommMonoid P'\ninst\u271d\u00b2 : Module R P'\ninst\u271d\u00b9 : AddCommMonoid Q'\ninst\u271d : Module R Q'\nf\u2081 f\u2082 : M \u2192\u2097[R] P\ng : N \u2192\u2097[R] Q\n\u22a2 map (f\u2081 + f\u2082) g = map f\u2081 g + map f\u2082 g", "state_after": "case H.h.h\nR : Type u_1\ninst\u271d\u00b9\u2078 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u2077 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u2076 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid N\ninst\u271d\u00b9\u00b3 : AddCommMonoid P\ninst\u271d\u00b9\u00b2 : AddCommMonoid Q\ninst\u271d\u00b9\u00b9 : AddCommMonoid S\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R N\ninst\u271d\u2078 : Module R P\ninst\u271d\u2077 : Module R Q\ninst\u271d\u2076 : Module R S\ninst\u271d\u2075 : DistribMulAction R' M\ninst\u271d\u2074 : Module R'' M\nP' : Type u_9\nQ' : Type u_10\ninst\u271d\u00b3 : AddCommMonoid P'\ninst\u271d\u00b2 : Module R P'\ninst\u271d\u00b9 : AddCommMonoid Q'\ninst\u271d : Module R Q'\nf\u2081 f\u2082 : M \u2192\u2097[R] P\ng : N \u2192\u2097[R] Q\nx\u271d\u00b9 : M\nx\u271d : N\n\u22a2 \u2191(\u2191(compr\u2082 (mk R M N) (map (f\u2081 + f\u2082) g)) x\u271d\u00b9) x\u271d = \u2191(\u2191(compr\u2082 (mk R M N) (map f\u2081 g + map f\u2082 g)) x\u271d\u00b9) x\u271d"}, {"tactic": "simp only [add_tmul, compr\u2082_apply, mk_apply, map_tmul, add_apply]", "annotated_tactic": ["simp only [<a>add_tmul</a>, <a>compr\u2082_apply</a>, <a>mk_apply</a>, <a>map_tmul</a>, <a>add_apply</a>]", [{"full_name": "TensorProduct.add_tmul", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [155, 9], "def_end_pos": [155, 17]}, {"full_name": "LinearMap.compr\u2082_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/BilinearMap.lean", "def_pos": [382, 9], "def_end_pos": [382, 21]}, {"full_name": "TensorProduct.mk_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [395, 9], "def_end_pos": [395, 17]}, {"full_name": "TensorProduct.map_tmul", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/TensorProduct.lean", "def_pos": [763, 9], "def_end_pos": [763, 17]}, {"full_name": "LinearMap.add_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [912, 9], "def_end_pos": [912, 18]}]], "state_before": "case H.h.h\nR : Type u_1\ninst\u271d\u00b9\u2078 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u2077 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u2076 : Semiring R''\nM : Type u_4\nN : Type u_5\nP : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2075 : AddCommMonoid M\ninst\u271d\u00b9\u2074 : AddCommMonoid N\ninst\u271d\u00b9\u00b3 : AddCommMonoid P\ninst\u271d\u00b9\u00b2 : AddCommMonoid Q\ninst\u271d\u00b9\u00b9 : AddCommMonoid S\ninst\u271d\u00b9\u2070 : Module R M\ninst\u271d\u2079 : Module R N\ninst\u271d\u2078 : Module R P\ninst\u271d\u2077 : Module R Q\ninst\u271d\u2076 : Module R S\ninst\u271d\u2075 : DistribMulAction R' M\ninst\u271d\u2074 : Module R'' M\nP' : Type u_9\nQ' : Type u_10\ninst\u271d\u00b3 : AddCommMonoid P'\ninst\u271d\u00b2 : Module R P'\ninst\u271d\u00b9 : AddCommMonoid Q'\ninst\u271d : Module R Q'\nf\u2081 f\u2082 : M \u2192\u2097[R] P\ng : N \u2192\u2097[R] Q\nx\u271d\u00b9 : M\nx\u271d : N\n\u22a2 \u2191(\u2191(compr\u2082 (mk R M N) (map (f\u2081 + f\u2082) g)) x\u271d\u00b9) x\u271d = \u2191(\u2191(compr\u2082 (mk R M N) (map f\u2081 g + map f\u2082 g)) x\u271d\u00b9) x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/WithTop.lean", "full_name": "WithBot.add_bot", "start": [611, 1], "end": [611, 66], "traced_tactics": [{"tactic": "cases a <;> rfl", "annotated_tactic": ["cases a <;> rfl", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Add \u03b1\na\u271d b c d : WithBot \u03b1\nx y : \u03b1\na : WithBot \u03b1\n\u22a2 a + \u22a5 = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioc_diff_Ioo_same", "start": [823, 1], "end": [824, 93], "traced_tactics": [{"tactic": "rw [\u2190 Ioc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 <| right_mem_Ioc.2 h)]", "annotated_tactic": ["rw [\u2190 <a>Ioc_diff_right</a>, <a>diff_diff_cancel_left</a> (<a>singleton_subset_iff</a>.2 <| <a>right_mem_Ioc</a>.2 h)]", [{"full_name": "Set.Ioc_diff_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [798, 9], "def_end_pos": [798, 23]}, {"full_name": "Set.diff_diff_cancel_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2090, 9], "def_end_pos": [2090, 30]}, {"full_name": "Set.singleton_subset_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1323, 9], "def_end_pos": [1323, 29]}, {"full_name": "Set.right_mem_Ioc", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [219, 9], "def_end_pos": [219, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b c : \u03b1\nh : a < b\n\u22a2 Ioc a b \\ Ioo a b = {b}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.natAbs_ediv", "start": [214, 1], "end": [223, 61], "traced_tactics": [{"tactic": "rcases Nat.eq_zero_or_pos (natAbs b) with (h | h)", "annotated_tactic": ["rcases <a>Nat.eq_zero_or_pos</a> (<a>natAbs</a> b) with (h | h)", [{"full_name": "Nat.eq_zero_or_pos", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [288, 9], "def_end_pos": [288, 23]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}]], "state_before": "a b : \u2124\nH : b \u2223 a\n\u22a2 natAbs (a / b) = natAbs a / natAbs b", "state_after": "case inl\na b : \u2124\nH : b \u2223 a\nh : natAbs b = 0\n\u22a2 natAbs (a / b) = natAbs a / natAbs b\n\ncase inr\na b : \u2124\nH : b \u2223 a\nh : natAbs b > 0\n\u22a2 natAbs (a / b) = natAbs a / natAbs b"}, {"tactic": "calc\n  natAbs (a / b) = natAbs (a / b) * 1 := by rw [mul_one]\n  _ = natAbs (a / b) * (natAbs b / natAbs b) := by rw [Nat.div_self h]\n  _ = natAbs (a / b) * natAbs b / natAbs b := by rw [Nat.mul_div_assoc _ dvd_rfl]\n  _ = natAbs (a / b * b) / natAbs b := by rw [natAbs_mul (a / b) b]\n  _ = natAbs a / natAbs b := by rw [Int.ediv_mul_cancel H]", "annotated_tactic": ["calc\n    <a>natAbs</a> (a / b) = <a>natAbs</a> (a / b) * 1 := by rw [<a>mul_one</a>]\n    _ = <a>natAbs</a> (a / b) * (<a>natAbs</a> b / <a>natAbs</a> b) := by rw [<a>Nat.div_self</a> h]\n    _ = <a>natAbs</a> (a / b) * <a>natAbs</a> b / <a>natAbs</a> b := by rw [<a>Nat.mul_div_assoc</a> _ <a>dvd_rfl</a>]\n    _ = <a>natAbs</a> (a / b * b) / <a>natAbs</a> b := by rw [<a>natAbs_mul</a> (a / b) b]\n    _ = <a>natAbs</a> a / <a>natAbs</a> b := by rw [<a>Int.ediv_mul_cancel</a> H]", [{"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Nat.div_self", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [828, 19], "def_end_pos": [828, 27]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Nat.mul_div_assoc", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [1149, 19], "def_end_pos": [1149, 32]}, {"full_name": "dvd_rfl", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [125, 9], "def_end_pos": [125, 16]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs_mul", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [171, 9], "def_end_pos": [171, 19]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.natAbs", "def_path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "def_pos": [242, 5], "def_end_pos": [242, 11]}, {"full_name": "Int.ediv_mul_cancel", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [711, 19], "def_end_pos": [711, 34]}]], "state_before": "case inr\na b : \u2124\nH : b \u2223 a\nh : natAbs b > 0\n\u22a2 natAbs (a / b) = natAbs a / natAbs b", "state_after": "no goals"}, {"tactic": "rw [natAbs_eq_zero.1 h]", "annotated_tactic": ["rw [<a>natAbs_eq_zero</a>.1 h]", [{"full_name": "Int.natAbs_eq_zero", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [143, 17], "def_end_pos": [143, 31]}]], "state_before": "case inl\na b : \u2124\nH : b \u2223 a\nh : natAbs b = 0\n\u22a2 natAbs (a / b) = natAbs a / natAbs b", "state_after": "case inl\na b : \u2124\nH : b \u2223 a\nh : natAbs b = 0\n\u22a2 natAbs (a / 0) = natAbs a / natAbs 0"}, {"tactic": "simp [Int.ediv_zero]", "annotated_tactic": ["simp [<a>Int.ediv_zero</a>]", [{"full_name": "Int.ediv_zero", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [46, 33], "def_end_pos": [46, 42]}]], "state_before": "case inl\na b : \u2124\nH : b \u2223 a\nh : natAbs b = 0\n\u22a2 natAbs (a / 0) = natAbs a / natAbs 0", "state_after": "no goals"}, {"tactic": "rw [mul_one]", "annotated_tactic": ["rw [<a>mul_one</a>]", [{"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "a b : \u2124\nH : b \u2223 a\nh : natAbs b > 0\n\u22a2 natAbs (a / b) = natAbs (a / b) * 1", "state_after": "no goals"}, {"tactic": "rw [Nat.div_self h]", "annotated_tactic": ["rw [<a>Nat.div_self</a> h]", [{"full_name": "Nat.div_self", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [828, 19], "def_end_pos": [828, 27]}]], "state_before": "a b : \u2124\nH : b \u2223 a\nh : natAbs b > 0\n\u22a2 natAbs (a / b) * 1 = natAbs (a / b) * (natAbs b / natAbs b)", "state_after": "no goals"}, {"tactic": "rw [Nat.mul_div_assoc _ dvd_rfl]", "annotated_tactic": ["rw [<a>Nat.mul_div_assoc</a> _ <a>dvd_rfl</a>]", [{"full_name": "Nat.mul_div_assoc", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [1149, 19], "def_end_pos": [1149, 32]}, {"full_name": "dvd_rfl", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [125, 9], "def_end_pos": [125, 16]}]], "state_before": "a b : \u2124\nH : b \u2223 a\nh : natAbs b > 0\n\u22a2 natAbs (a / b) * (natAbs b / natAbs b) = natAbs (a / b) * natAbs b / natAbs b", "state_after": "no goals"}, {"tactic": "rw [natAbs_mul (a / b) b]", "annotated_tactic": ["rw [<a>natAbs_mul</a> (a / b) b]", [{"full_name": "Int.natAbs_mul", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [171, 9], "def_end_pos": [171, 19]}]], "state_before": "a b : \u2124\nH : b \u2223 a\nh : natAbs b > 0\n\u22a2 natAbs (a / b) * natAbs b / natAbs b = natAbs (a / b * b) / natAbs b", "state_after": "no goals"}, {"tactic": "rw [Int.ediv_mul_cancel H]", "annotated_tactic": ["rw [<a>Int.ediv_mul_cancel</a> H]", [{"full_name": "Int.ediv_mul_cancel", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [711, 19], "def_end_pos": [711, 34]}]], "state_before": "a b : \u2124\nH : b \u2223 a\nh : natAbs b > 0\n\u22a2 natAbs (a / b * b) / natAbs b = natAbs a / natAbs b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/LinearMap.lean", "full_name": "LinearMap.toAddMonoidHom_coe", "start": [442, 1], "end": [443, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.row_empty", "start": [196, 1], "end": [198, 6], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\n\u22a2 row ![] = fun x => ![]", "state_after": "case a.h\n\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ni\u271d : Unit\nx\u271d : Fin 0\n\u22a2 row ![] i\u271d x\u271d = ![]"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case a.h\n\u03b1 : Type u\no n m : \u2115\nm' : Type u\u2098\nn' : Type u\u2099\no' : Type u\u2092\na b : \u2115\ni\u271d : Unit\nx\u271d : Fin 0\n\u22a2 row ![] i\u271d x\u271d = ![]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.map_swap_add", "start": [688, 1], "end": [693, 95], "traced_tactics": [{"tactic": "rw [Equiv.comp_swap_eq_update]", "annotated_tactic": ["rw [<a>Equiv.comp_swap_eq_update</a>]", [{"full_name": "Equiv.comp_swap_eq_update", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Basic.lean", "def_pos": [1680, 9], "def_end_pos": [1680, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2075 : Semiring R\nM : Type u_2\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : Module R N\nP : Type u_4\ninst\u271d\u00b9\u2070 : AddCommMonoid P\ninst\u271d\u2079 : Module R P\nM' : Type u_5\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\nN' : Type u_6\ninst\u271d\u2076 : AddCommGroup N'\ninst\u271d\u2075 : Module R N'\n\u03b9 : Type u_7\n\u03b9' : Type u_8\n\u03b9'' : Type u_9\nM\u2082 : Type u_10\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2082\nM\u2083 : Type u_11\ninst\u271d\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9 : Module R M\u2083\nf f' : AlternatingMap R M N \u03b9\ng g\u2082 : AlternatingMap R M N' \u03b9\ng' : AlternatingMap R M' N' \u03b9\nv : \u03b9 \u2192 M\nv' : \u03b9 \u2192 M'\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 \u2191f (v \u2218 \u2191(Equiv.swap i j)) + \u2191f v = 0", "state_after": "R : Type u_1\ninst\u271d\u00b9\u2075 : Semiring R\nM : Type u_2\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : Module R N\nP : Type u_4\ninst\u271d\u00b9\u2070 : AddCommMonoid P\ninst\u271d\u2079 : Module R P\nM' : Type u_5\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\nN' : Type u_6\ninst\u271d\u2076 : AddCommGroup N'\ninst\u271d\u2075 : Module R N'\n\u03b9 : Type u_7\n\u03b9' : Type u_8\n\u03b9'' : Type u_9\nM\u2082 : Type u_10\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2082\nM\u2083 : Type u_11\ninst\u271d\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9 : Module R M\u2083\nf f' : AlternatingMap R M N \u03b9\ng g\u2082 : AlternatingMap R M N' \u03b9\ng' : AlternatingMap R M' N' \u03b9\nv : \u03b9 \u2192 M\nv' : \u03b9 \u2192 M'\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 \u2191f (update (update v j (v i)) i (v j)) + \u2191f v = 0"}, {"tactic": "convert f.map_update_update v hij (v i + v j)", "annotated_tactic": ["convert f.map_update_update v hij (v i + v j)", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2075 : Semiring R\nM : Type u_2\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : Module R N\nP : Type u_4\ninst\u271d\u00b9\u2070 : AddCommMonoid P\ninst\u271d\u2079 : Module R P\nM' : Type u_5\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\nN' : Type u_6\ninst\u271d\u2076 : AddCommGroup N'\ninst\u271d\u2075 : Module R N'\n\u03b9 : Type u_7\n\u03b9' : Type u_8\n\u03b9'' : Type u_9\nM\u2082 : Type u_10\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2082\nM\u2083 : Type u_11\ninst\u271d\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9 : Module R M\u2083\nf f' : AlternatingMap R M N \u03b9\ng g\u2082 : AlternatingMap R M N' \u03b9\ng' : AlternatingMap R M' N' \u03b9\nv : \u03b9 \u2192 M\nv' : \u03b9 \u2192 M'\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 \u2191f (update (update v j (v i)) i (v j)) + \u2191f v = 0", "state_after": "case h.e'_2\nR : Type u_1\ninst\u271d\u00b9\u2075 : Semiring R\nM : Type u_2\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : Module R N\nP : Type u_4\ninst\u271d\u00b9\u2070 : AddCommMonoid P\ninst\u271d\u2079 : Module R P\nM' : Type u_5\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\nN' : Type u_6\ninst\u271d\u2076 : AddCommGroup N'\ninst\u271d\u2075 : Module R N'\n\u03b9 : Type u_7\n\u03b9' : Type u_8\n\u03b9'' : Type u_9\nM\u2082 : Type u_10\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2082\nM\u2083 : Type u_11\ninst\u271d\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9 : Module R M\u2083\nf f' : AlternatingMap R M N \u03b9\ng g\u2082 : AlternatingMap R M N' \u03b9\ng' : AlternatingMap R M' N' \u03b9\nv : \u03b9 \u2192 M\nv' : \u03b9 \u2192 M'\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 \u2191f (update (update v j (v i)) i (v j)) + \u2191f v = \u2191f (update (update v i (v i + v j)) j (v i + v j))"}, {"tactic": "simp [f.map_update_self _ hij, f.map_update_self _ hij.symm,\n  Function.update_comm hij (v i + v j) (v _) v, Function.update_comm hij.symm (v i) (v i) v]", "annotated_tactic": ["simp [f.map_update_self _ hij, f.map_update_self _ hij.symm,\n    <a>Function.update_comm</a> hij (v i + v j) (v _) v, <a>Function.update_comm</a> hij.symm (v i) (v i) v]", [{"full_name": "Function.update_comm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [683, 9], "def_end_pos": [683, 20]}, {"full_name": "Function.update_comm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [683, 9], "def_end_pos": [683, 20]}]], "state_before": "case h.e'_2\nR : Type u_1\ninst\u271d\u00b9\u2075 : Semiring R\nM : Type u_2\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : Module R M\nN : Type u_3\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : Module R N\nP : Type u_4\ninst\u271d\u00b9\u2070 : AddCommMonoid P\ninst\u271d\u2079 : Module R P\nM' : Type u_5\ninst\u271d\u2078 : AddCommGroup M'\ninst\u271d\u2077 : Module R M'\nN' : Type u_6\ninst\u271d\u2076 : AddCommGroup N'\ninst\u271d\u2075 : Module R N'\n\u03b9 : Type u_7\n\u03b9' : Type u_8\n\u03b9'' : Type u_9\nM\u2082 : Type u_10\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2082\nM\u2083 : Type u_11\ninst\u271d\u00b2 : AddCommMonoid M\u2083\ninst\u271d\u00b9 : Module R M\u2083\nf f' : AlternatingMap R M N \u03b9\ng g\u2082 : AlternatingMap R M N' \u03b9\ng' : AlternatingMap R M' N' \u03b9\nv : \u03b9 \u2192 M\nv' : \u03b9 \u2192 M'\ninst\u271d : DecidableEq \u03b9\ni j : \u03b9\nhij : i \u2260 j\n\u22a2 \u2191f (update (update v j (v i)) i (v j)) + \u2191f v = \u2191f (update (update v i (v i + v j)) j (v i + v j))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Polynomial/BigOperators.lean", "full_name": "Polynomial.coeff_prod_of_natDegree_le", "start": [221, 1], "end": [227, 18], "traced_tactics": [{"tactic": "cases' s with l hl", "annotated_tactic": ["cases' s with l hl", []], "state_before": "R : Type u\n\u03b9 : Type w\ns : Finset \u03b9\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nh : \u2200 p \u2208 s, natDegree (f p) \u2264 n\n\u22a2 coeff (\u220f i in s, f i) (Finset.card s * n) = \u220f i in s, coeff (f i) n", "state_after": "case mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 coeff (\u220f i in { val := l, nodup := hl }, f i) (Finset.card { val := l, nodup := hl } * n) =\n    \u220f i in { val := l, nodup := hl }, coeff (f i) n"}, {"tactic": "convert coeff_multiset_prod_of_natDegree_le (l.map f) n ?_", "annotated_tactic": ["convert <a>coeff_multiset_prod_of_natDegree_le</a> (l.map f) n ?_", [{"full_name": "Polynomial.coeff_multiset_prod_of_natDegree_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Polynomial/BigOperators.lean", "def_pos": [215, 9], "def_end_pos": [215, 44]}]], "state_before": "case mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 coeff (\u220f i in { val := l, nodup := hl }, f i) (Finset.card { val := l, nodup := hl } * n) =\n    \u220f i in { val := l, nodup := hl }, coeff (f i) n", "state_after": "case h.e'_2.h.e'_4.h.e'_5\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 Finset.card { val := l, nodup := hl } = \u2191Multiset.card (Multiset.map f l)\n\ncase h.e'_3\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 \u220f i in { val := l, nodup := hl }, coeff (f i) n = prod (Multiset.map (fun p => coeff p n) (Multiset.map f l))\n\ncase mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 \u2200 p \u2208 Multiset.map f l, natDegree p \u2264 n"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_2.h.e'_4.h.e'_5\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 Finset.card { val := l, nodup := hl } = \u2191Multiset.card (Multiset.map f l)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_3\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 \u220f i in { val := l, nodup := hl }, coeff (f i) n = prod (Multiset.map (fun p => coeff p n) (Multiset.map f l))", "state_after": "no goals"}, {"tactic": "simpa using h", "annotated_tactic": ["simpa using h", []], "state_before": "case mk\nR : Type u\n\u03b9 : Type w\ninst\u271d : CommSemiring R\nf\u271d : \u03b9 \u2192 R[X]\nt : Multiset R[X]\nf : \u03b9 \u2192 R[X]\nn : \u2115\nl : Multiset \u03b9\nhl : Nodup l\nh : \u2200 p \u2208 { val := l, nodup := hl }, natDegree (f p) \u2264 n\n\u22a2 \u2200 p \u2208 Multiset.map f l, natDegree p \u2264 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "full_name": "SubMulAction.stabilizer_of_subMul", "start": [346, 1], "end": [349, 41], "traced_tactics": [{"tactic": "rw [\u2190 Subgroup.toSubmonoid_eq]", "annotated_tactic": ["rw [\u2190 <a>Subgroup.toSubmonoid_eq</a>]", [{"full_name": "Subgroup.toSubmonoid_eq", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [458, 9], "def_end_pos": [458, 23]}]], "state_before": "S : Type u'\nT : Type u''\nR : Type u\nM : Type v\ninst\u271d\u00b9 : Group R\ninst\u271d : MulAction R M\np : SubMulAction R M\nm : \u21a5p\n\u22a2 MulAction.stabilizer R m = MulAction.stabilizer R \u2191m", "state_after": "S : Type u'\nT : Type u''\nR : Type u\nM : Type v\ninst\u271d\u00b9 : Group R\ninst\u271d : MulAction R M\np : SubMulAction R M\nm : \u21a5p\n\u22a2 (MulAction.stabilizer R m).toSubmonoid = (MulAction.stabilizer R \u2191m).toSubmonoid"}, {"tactic": "exact stabilizer_of_subMul.submonoid m", "annotated_tactic": ["exact <a>stabilizer_of_subMul.submonoid</a> m", [{"full_name": "SubMulAction.stabilizer_of_subMul.submonoid", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "def_pos": [333, 9], "def_end_pos": [333, 39]}]], "state_before": "S : Type u'\nT : Type u''\nR : Type u\nM : Type v\ninst\u271d\u00b9 : Group R\ninst\u271d : MulAction R M\np : SubMulAction R M\nm : \u21a5p\n\u22a2 (MulAction.stabilizer R m).toSubmonoid = (MulAction.stabilizer R \u2191m).toSubmonoid", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Pointwise.lean", "full_name": "Submodule.coe_set_neg", "start": [63, 1], "end": [64, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.map_inf_eq_map_inf_comap", "start": [404, 1], "end": [407, 73], "traced_tactics": [{"tactic": "rintro _ \u27e8\u27e8x, h\u2081, rfl\u27e9, h\u2082\u27e9", "annotated_tactic": ["rintro _ \u27e8\u27e8x, h\u2081, rfl\u27e9, h\u2082\u27e9", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring R\u2082\ninst\u271d\u00b9\u2070 : Semiring R\u2083\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R\u2082 M\u2082\ninst\u271d\u2074 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\np\u271d p'\u271d : Submodule R M\nq q' : Submodule R\u2082 M\u2082\nx : M\nF : Type u_10\nsc : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ninst\u271d : RingHomSurjective \u03c3\u2081\u2082\nf : F\np : Submodule R M\np' : Submodule R\u2082 M\u2082\n\u22a2 map f p \u2293 p' \u2264 map f (p \u2293 comap f p')", "state_after": "case intro.intro.intro\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring R\u2082\ninst\u271d\u00b9\u2070 : Semiring R\u2083\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R\u2082 M\u2082\ninst\u271d\u2074 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\np\u271d p'\u271d : Submodule R M\nq q' : Submodule R\u2082 M\u2082\nx\u271d : M\nF : Type u_10\nsc : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ninst\u271d : RingHomSurjective \u03c3\u2081\u2082\nf : F\np : Submodule R M\np' : Submodule R\u2082 M\u2082\nx : M\nh\u2081 : x \u2208 \u2191p\nh\u2082 : \u2191f x \u2208 \u2191p'\n\u22a2 \u2191f x \u2208 map f (p \u2293 comap f p')"}, {"tactic": "exact \u27e8_, \u27e8h\u2081, h\u2082\u27e9, rfl\u27e9", "annotated_tactic": ["exact \u27e8_, \u27e8h\u2081, h\u2082\u27e9, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case intro.intro.intro\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring R\u2082\ninst\u271d\u00b9\u2070 : Semiring R\u2083\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R\u2082 M\u2082\ninst\u271d\u2074 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\np\u271d p'\u271d : Submodule R M\nq q' : Submodule R\u2082 M\u2082\nx\u271d : M\nF : Type u_10\nsc : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ninst\u271d : RingHomSurjective \u03c3\u2081\u2082\nf : F\np : Submodule R M\np' : Submodule R\u2082 M\u2082\nx : M\nh\u2081 : x \u2208 \u2191p\nh\u2082 : \u2191f x \u2208 \u2191p'\n\u22a2 \u2191f x \u2208 map f (p \u2293 comap f p')", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.map_eq_cons", "start": [1261, 1], "end": [1274, 37], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\n\u22a2 (\u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t) \u2194 map f s = b ::\u2098 t", "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\n\u22a2 (\u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t) \u2192 map f s = b ::\u2098 t\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\n\u22a2 map f s = b ::\u2098 t \u2192 \u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t"}, {"tactic": "rintro \u27e8a, ha, rfl, rfl\u27e9", "annotated_tactic": ["rintro \u27e8a, ha, rfl, rfl\u27e9", []], "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\n\u22a2 (\u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t) \u2192 map f s = b ::\u2098 t", "state_after": "case mp.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\na : \u03b1\nha : a \u2208 s\n\u22a2 map f s = f a ::\u2098 map f (erase s a)"}, {"tactic": "rw [\u2190 map_cons, Multiset.cons_erase ha]", "annotated_tactic": ["rw [\u2190 <a>map_cons</a>, <a>Multiset.cons_erase</a> ha]", [{"full_name": "Multiset.map_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1180, 9], "def_end_pos": [1180, 17]}, {"full_name": "Multiset.cons_erase", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1032, 9], "def_end_pos": [1032, 19]}]], "state_before": "case mp.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\na : \u03b1\nha : a \u2208 s\n\u22a2 map f s = f a ::\u2098 map f (erase s a)", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\n\u22a2 map f s = b ::\u2098 t \u2192 \u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t", "state_after": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\nh : map f s = b ::\u2098 t\n\u22a2 \u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t"}, {"tactic": "have : b \u2208 s.map f := by\n  rw [h]\n  exact mem_cons_self _ _", "annotated_tactic": ["have : b \u2208 s.map f := by\n      rw [h]\n      exact <a>mem_cons_self</a> _ _", [{"full_name": "Multiset.mem_cons_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [244, 9], "def_end_pos": [244, 22]}]], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\nh : map f s = b ::\u2098 t\n\u22a2 \u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t", "state_after": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\nh : map f s = b ::\u2098 t\nthis : b \u2208 map f s\n\u22a2 \u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t"}, {"tactic": "obtain \u27e8a, h1, rfl\u27e9 := mem_map.mp this", "annotated_tactic": ["obtain \u27e8a, h1, rfl\u27e9 := mem_map.mp this", []], "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\nh : map f s = b ::\u2098 t\nthis : b \u2208 map f s\n\u22a2 \u2203 a \u2208 s, f a = b \u2227 map f (erase s a) = t", "state_after": "case mpr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\na : \u03b1\nh1 : a \u2208 s\nh : map f s = f a ::\u2098 t\nthis : f a \u2208 map f s\n\u22a2 \u2203 a_1 \u2208 s, f a_1 = f a \u2227 map f (erase s a_1) = t"}, {"tactic": "obtain \u27e8u, rfl\u27e9 := exists_cons_of_mem h1", "annotated_tactic": ["obtain \u27e8u, rfl\u27e9 := <a>exists_cons_of_mem</a> h1", [{"full_name": "Multiset.exists_cons_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [253, 9], "def_end_pos": [253, 27]}]], "state_before": "case mpr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\na : \u03b1\nh1 : a \u2208 s\nh : map f s = f a ::\u2098 t\nthis : f a \u2208 map f s\n\u22a2 \u2203 a_1 \u2208 s, f a_1 = f a \u2227 map f (erase s a_1) = t", "state_after": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\nt : Multiset \u03b2\na : \u03b1\nu : Multiset \u03b1\nh1 : a \u2208 a ::\u2098 u\nh : map f (a ::\u2098 u) = f a ::\u2098 t\nthis : f a \u2208 map f (a ::\u2098 u)\n\u22a2 \u2203 a_1 \u2208 a ::\u2098 u, f a_1 = f a \u2227 map f (erase (a ::\u2098 u) a_1) = t"}, {"tactic": "rw [map_cons, cons_inj_right] at h", "annotated_tactic": ["rw [<a>map_cons</a>, <a>cons_inj_right</a>] at h", [{"full_name": "Multiset.map_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1180, 9], "def_end_pos": [1180, 17]}, {"full_name": "Multiset.cons_inj_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [149, 9], "def_end_pos": [149, 23]}]], "state_before": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\nt : Multiset \u03b2\na : \u03b1\nu : Multiset \u03b1\nh1 : a \u2208 a ::\u2098 u\nh : map f (a ::\u2098 u) = f a ::\u2098 t\nthis : f a \u2208 map f (a ::\u2098 u)\n\u22a2 \u2203 a_1 \u2208 a ::\u2098 u, f a_1 = f a \u2227 map f (erase (a ::\u2098 u) a_1) = t", "state_after": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\nt : Multiset \u03b2\na : \u03b1\nu : Multiset \u03b1\nh1 : a \u2208 a ::\u2098 u\nh : map f u = t\nthis : f a \u2208 map f (a ::\u2098 u)\n\u22a2 \u2203 a_1 \u2208 a ::\u2098 u, f a_1 = f a \u2227 map f (erase (a ::\u2098 u) a_1) = t"}, {"tactic": "refine' \u27e8a, mem_cons_self _ _, rfl, _\u27e9", "annotated_tactic": ["refine' \u27e8a, <a>mem_cons_self</a> _ _, <a>rfl</a>, _\u27e9", [{"full_name": "Multiset.mem_cons_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [244, 9], "def_end_pos": [244, 22]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\nt : Multiset \u03b2\na : \u03b1\nu : Multiset \u03b1\nh1 : a \u2208 a ::\u2098 u\nh : map f u = t\nthis : f a \u2208 map f (a ::\u2098 u)\n\u22a2 \u2203 a_1 \u2208 a ::\u2098 u, f a_1 = f a \u2227 map f (erase (a ::\u2098 u) a_1) = t", "state_after": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\nt : Multiset \u03b2\na : \u03b1\nu : Multiset \u03b1\nh1 : a \u2208 a ::\u2098 u\nh : map f u = t\nthis : f a \u2208 map f (a ::\u2098 u)\n\u22a2 map f (erase (a ::\u2098 u) a) = t"}, {"tactic": "rw [Multiset.erase_cons_head, h]", "annotated_tactic": ["rw [<a>Multiset.erase_cons_head</a>, h]", [{"full_name": "Multiset.erase_cons_head", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1011, 9], "def_end_pos": [1011, 24]}]], "state_before": "case mpr.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\nt : Multiset \u03b2\na : \u03b1\nu : Multiset \u03b1\nh1 : a \u2208 a ::\u2098 u\nh : map f u = t\nthis : f a \u2208 map f (a ::\u2098 u)\n\u22a2 map f (erase (a ::\u2098 u) a) = t", "state_after": "no goals"}, {"tactic": "rw [h]", "annotated_tactic": ["rw [h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\nh : map f s = b ::\u2098 t\n\u22a2 b \u2208 map f s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\nh : map f s = b ::\u2098 t\n\u22a2 b \u2208 b ::\u2098 t"}, {"tactic": "exact mem_cons_self _ _", "annotated_tactic": ["exact <a>mem_cons_self</a> _ _", [{"full_name": "Multiset.mem_cons_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [244, 9], "def_end_pos": [244, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\nb : \u03b2\nh : map f s = b ::\u2098 t\n\u22a2 b \u2208 b ::\u2098 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.sum_update_add", "start": [648, 1], "end": [656, 66], "traced_tactics": [{"tactic": "rw [update_eq_erase_add_single, sum_add_index' hg hgg]", "annotated_tactic": ["rw [<a>update_eq_erase_add_single</a>, <a>sum_add_index'</a> hg hgg]", [{"full_name": "Finsupp.update_eq_erase_add_single", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1056, 9], "def_end_pos": [1056, 35]}, {"full_name": "Finsupp.sum_add_index'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [401, 3], "def_end_pos": [401, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 sum (update f i a) g + g i (\u2191f i) = sum f g + g i a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 ((sum (erase i f) fun a => g a) + sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i) = sum f g + g i a"}, {"tactic": "conv_rhs => rw [\u2190 Finsupp.update_self f i]", "annotated_tactic": ["conv_rhs => rw [\u2190 <a>Finsupp.update_self</a> f i]", [{"full_name": "Finsupp.update_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [568, 9], "def_end_pos": [568, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 ((sum (erase i f) fun a => g a) + sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i) = sum f g + g i a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 ((sum (erase i f) fun a => g a) + sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i) = sum (update f i (\u2191f i)) g + g i a"}, {"tactic": "rw [update_eq_erase_add_single, sum_add_index' hg hgg, add_assoc, add_assoc]", "annotated_tactic": ["rw [<a>update_eq_erase_add_single</a>, <a>sum_add_index'</a> hg hgg, <a>add_assoc</a>, <a>add_assoc</a>]", [{"full_name": "Finsupp.update_eq_erase_add_single", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [1056, 9], "def_end_pos": [1056, 35]}, {"full_name": "Finsupp.sum_add_index'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [401, 3], "def_end_pos": [401, 14]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 ((sum (erase i f) fun a => g a) + sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i) = sum (update f i (\u2191f i)) g + g i a", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 (sum (erase i f) fun a => g a) + ((sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i)) =\n    (sum (erase i f) fun a => g a) + ((sum (fun\u2080 | i => \u2191f i) fun a => g a) + g i a)"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 (sum (erase i f) fun a => g a) + ((sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i)) =\n    (sum (erase i f) fun a => g a) + ((sum (fun\u2080 | i => \u2191f i) fun a => g a) + g i a)", "state_after": "case e_a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 (sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i) = (sum (fun\u2080 | i => \u2191f i) fun a => g a) + g i a"}, {"tactic": "rw [add_comm, sum_single_index (hg _), sum_single_index (hg _)]", "annotated_tactic": ["rw [<a>add_comm</a>, <a>sum_single_index</a> (hg _), <a>sum_single_index</a> (hg _)]", [{"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}, {"full_name": "Finsupp.sum_single_index", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [74, 3], "def_end_pos": [74, 14]}, {"full_name": "Finsupp.sum_single_index", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [74, 3], "def_end_pos": [74, 14]}]], "state_before": "case e_a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d\u00b2 : AddCommMonoid M\nv v\u2081 v\u2082 : \u03b1 \u2192\u2080 M\ninst\u271d\u00b9 : AddCommMonoid \u03b1\ninst\u271d : AddCommMonoid \u03b2\nf : \u03b9 \u2192\u2080 \u03b1\ni : \u03b9\na : \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nhg : \u2200 (i : \u03b9), g i 0 = 0\nhgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082\n\u22a2 (sum (fun\u2080 | i => a) fun a => g a) + g i (\u2191f i) = (sum (fun\u2080 | i => \u2191f i) fun a => g a) + g i a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Basic.lean", "full_name": "Nat.lt_mul_of_div_lt", "start": [662, 1], "end": [663, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.dotProduct_neg", "start": [905, 1], "end": [905, 69], "traced_tactics": [{"tactic": "simp [dotProduct]", "annotated_tactic": ["simp [<a>dotProduct</a>]", [{"full_name": "Matrix.dotProduct", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [748, 5], "def_end_pos": [748, 15]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : Fintype n\ninst\u271d : NonUnitalNonAssocRing \u03b1\nu v w : m \u2192 \u03b1\n\u22a2 v \u2b1d\u1d65 -w = -(v \u2b1d\u1d65 w)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "List.one_le_prod_of_one_le", "start": [368, 1], "end": [375, 95], "traced_tactics": [{"tactic": "induction' l with hd tl ih", "annotated_tactic": ["induction' l with hd tl ih", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : Monoid N\ninst\u271d\u00b2 : Monoid P\nl\u271d l\u2081 l\u2082 : List M\na : M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nl : List M\nhl\u2081 : \u2200 (x : M), x \u2208 l \u2192 1 \u2264 x\n\u22a2 1 \u2264 prod l", "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : Monoid N\ninst\u271d\u00b2 : Monoid P\nl l\u2081 l\u2082 : List M\na : M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nhl\u2081 : \u2200 (x : M), x \u2208 [] \u2192 1 \u2264 x\n\u22a2 1 \u2264 prod []\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : Monoid N\ninst\u271d\u00b2 : Monoid P\nl l\u2081 l\u2082 : List M\na : M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nhd : M\ntl : List M\nih : (\u2200 (x : M), x \u2208 tl \u2192 1 \u2264 x) \u2192 1 \u2264 prod tl\nhl\u2081 : \u2200 (x : M), x \u2208 hd :: tl \u2192 1 \u2264 x\n\u22a2 1 \u2264 prod (hd :: tl)"}, {"tactic": "rw [prod_cons]", "annotated_tactic": ["rw [<a>prod_cons</a>]", [{"full_name": "List.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 18]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : Monoid N\ninst\u271d\u00b2 : Monoid P\nl l\u2081 l\u2082 : List M\na : M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nhd : M\ntl : List M\nih : (\u2200 (x : M), x \u2208 tl \u2192 1 \u2264 x) \u2192 1 \u2264 prod tl\nhl\u2081 : \u2200 (x : M), x \u2208 hd :: tl \u2192 1 \u2264 x\n\u22a2 1 \u2264 prod (hd :: tl)", "state_after": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : Monoid N\ninst\u271d\u00b2 : Monoid P\nl l\u2081 l\u2082 : List M\na : M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nhd : M\ntl : List M\nih : (\u2200 (x : M), x \u2208 tl \u2192 1 \u2264 x) \u2192 1 \u2264 prod tl\nhl\u2081 : \u2200 (x : M), x \u2208 hd :: tl \u2192 1 \u2264 x\n\u22a2 1 \u2264 hd * prod tl"}, {"tactic": "exact one_le_mul (hl\u2081 hd (mem_cons_self hd tl)) (ih fun x h => hl\u2081 x (mem_cons_of_mem hd h))", "annotated_tactic": ["exact <a>one_le_mul</a> (hl\u2081 hd (<a>mem_cons_self</a> hd tl)) (ih fun x h => hl\u2081 x (<a>mem_cons_of_mem</a> hd h))", [{"full_name": "one_le_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [1077, 7], "def_end_pos": [1077, 17]}, {"full_name": "List.mem_cons_self", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [61, 9], "def_end_pos": [61, 22]}, {"full_name": "List.mem_cons_of_mem", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [63, 9], "def_end_pos": [63, 24]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : Monoid N\ninst\u271d\u00b2 : Monoid P\nl l\u2081 l\u2082 : List M\na : M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nhd : M\ntl : List M\nih : (\u2200 (x : M), x \u2208 tl \u2192 1 \u2264 x) \u2192 1 \u2264 prod tl\nhl\u2081 : \u2200 (x : M), x \u2208 hd :: tl \u2192 1 \u2264 x\n\u22a2 1 \u2264 hd * prod tl", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : Monoid N\ninst\u271d\u00b2 : Monoid P\nl l\u2081 l\u2082 : List M\na : M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nhl\u2081 : \u2200 (x : M), x \u2208 [] \u2192 1 \u2264 x\n\u22a2 1 \u2264 prod []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Lattice.lean", "full_name": "InfHom.comp_apply", "start": [596, 1], "end": [597, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.sUnion_image", "start": [1307, 1], "end": [1308, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/ULift.lean", "full_name": "PLift.up_inj", "start": [54, 1], "end": [55, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Equiv.lean", "full_name": "MvPolynomial.mapEquiv_trans", "start": [116, 1], "end": [120, 15], "traced_tactics": [{"tactic": "simp only [RingEquiv.coe_trans, comp_apply, mapEquiv_apply, RingEquiv.coe_ringHom_trans,\n  map_map]", "annotated_tactic": ["simp only [<a>RingEquiv.coe_trans</a>, <a>comp_apply</a>, <a>mapEquiv_apply</a>, <a>RingEquiv.coe_ringHom_trans</a>,\n      <a>map_map</a>]", [{"full_name": "RingEquiv.coe_trans", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [328, 9], "def_end_pos": [328, 18]}, {"full_name": "Function.comp_apply", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [33, 17], "def_end_pos": [33, 36]}, {"full_name": "MvPolynomial.mapEquiv_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Equiv.lean", "def_pos": [94, 9], "def_end_pos": [94, 14]}, {"full_name": "RingEquiv.coe_ringHom_trans", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Equiv.lean", "def_pos": [569, 9], "def_end_pos": [569, 26]}, {"full_name": "MvPolynomial.map_map", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [1251, 9], "def_end_pos": [1251, 16]}]], "state_before": "R : Type u\nS\u2081 : Type v\nS\u2082 : Type w\nS\u2083 : Type x\n\u03c3 : Type u_1\na a' a\u2081 a\u2082 : R\ne\u271d : \u2115\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : CommSemiring S\u2081\ninst\u271d\u00b9 : CommSemiring S\u2082\ninst\u271d : CommSemiring S\u2083\ne : S\u2081 \u2243+* S\u2082\nf : S\u2082 \u2243+* S\u2083\np : MvPolynomial \u03c3 S\u2081\n\u22a2 \u2191(RingEquiv.trans (mapEquiv \u03c3 e) (mapEquiv \u03c3 f)) p = \u2191(mapEquiv \u03c3 (RingEquiv.trans e f)) p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.span_singleton_smul_eq", "start": [466, 1], "end": [469, 43], "traced_tactics": [{"tactic": "lift r to R\u02e3 using hr", "annotated_tactic": ["lift r to R\u02e3 using hr", []], "state_before": "R : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nr : R\nhr : IsUnit r\nx : M\n\u22a2 span R {r \u2022 x} = span R {x}", "state_after": "case intro\nR : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx : M\nr : R\u02e3\n\u22a2 span R {\u2191r \u2022 x} = span R {x}"}, {"tactic": "rw [\u2190 Units.smul_def]", "annotated_tactic": ["rw [\u2190 <a>Units.smul_def</a>]", [{"full_name": "Units.smul_def", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Units.lean", "def_pos": [36, 9], "def_end_pos": [36, 17]}]], "state_before": "case intro\nR : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx : M\nr : R\u02e3\n\u22a2 span R {\u2191r \u2022 x} = span R {x}", "state_after": "case intro\nR : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx : M\nr : R\u02e3\n\u22a2 span R {r \u2022 x} = span R {x}"}, {"tactic": "exact span_singleton_group_smul_eq R r x", "annotated_tactic": ["exact <a>span_singleton_group_smul_eq</a> R r x", [{"full_name": "Submodule.span_singleton_group_smul_eq", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [457, 9], "def_end_pos": [457, 37]}]], "state_before": "case intro\nR : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\nx\u271d : M\np p' : Submodule R M\ninst\u271d\u00b3 : Semiring R\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ns t : Set M\nx : M\nr : R\u02e3\n\u22a2 span R {r \u2022 x} = span R {x}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Init/Lemmas.lean", "full_name": "List.get_cons_zero", "start": [26, 9], "end": [26, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Reverse.lean", "full_name": "Polynomial.reflect_neg", "start": [402, 1], "end": [403, 91], "traced_tactics": [{"tactic": "rw [neg_eq_neg_one_mul, \u2190 C_1, \u2190 C_neg, reflect_C_mul, C_neg, C_1, \u2190 neg_eq_neg_one_mul]", "annotated_tactic": ["rw [<a>neg_eq_neg_one_mul</a>, \u2190 <a>C_1</a>, \u2190 <a>C_neg</a>, <a>reflect_C_mul</a>, <a>C_neg</a>, <a>C_1</a>, \u2190 <a>neg_eq_neg_one_mul</a>]", [{"full_name": "neg_eq_neg_one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [318, 9], "def_end_pos": [318, 27]}, {"full_name": "Polynomial.C_1", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [518, 9], "def_end_pos": [518, 12]}, {"full_name": "Polynomial.C_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1226, 9], "def_end_pos": [1226, 14]}, {"full_name": "Polynomial.reflect_C_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Reverse.lean", "def_pos": [140, 9], "def_end_pos": [140, 22]}, {"full_name": "Polynomial.C_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [1226, 9], "def_end_pos": [1226, 14]}, {"full_name": "Polynomial.C_1", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [518, 9], "def_end_pos": [518, 12]}, {"full_name": "neg_eq_neg_one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [318, 9], "def_end_pos": [318, 27]}]], "state_before": "R : Type u_1\ninst\u271d : Ring R\nf : R[X]\nN : \u2115\n\u22a2 reflect N (-f) = -reflect N f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Bool/Basic.lean", "full_name": "Bool.or_inr", "start": [155, 1], "end": [155, 72], "traced_tactics": [{"tactic": "cases a <;> simp [H]", "annotated_tactic": ["cases a <;> simp [H]", []], "state_before": "a b : Bool\nH : b = true\n\u22a2 (a || b) = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csInf_image2_eq_csSup_csSup", "start": [1596, 1], "end": [1599, 63], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Semiconj/Units.lean", "full_name": "SemiconjBy.units_of_val", "start": [79, 1], "end": [80, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Subperm.antisymm", "start": [441, 1], "end": [442, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.sigmaCurry_smul", "start": [1517, 1], "end": [1521, 6], "traced_tactics": [{"tactic": "ext (i j)", "annotated_tactic": ["ext (i j)", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\n\u03ba : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b4 : (i : \u03b9) \u2192 \u03b1 i \u2192 Type v\ninst\u271d\u00b2 : Monoid \u03b3\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (j : \u03b1 i) \u2192 AddMonoid (\u03b4 i j)\ninst\u271d : (i : \u03b9) \u2192 (j : \u03b1 i) \u2192 DistribMulAction \u03b3 (\u03b4 i j)\nr : \u03b3\nf : \u03a0\u2080 (i : (x : \u03b9) \u00d7 \u03b1 x), \u03b4 i.fst i.snd\n\u22a2 sigmaCurry (r \u2022 f) = r \u2022 sigmaCurry f", "state_after": "case h.h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\n\u03ba : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b4 : (i : \u03b9) \u2192 \u03b1 i \u2192 Type v\ninst\u271d\u00b2 : Monoid \u03b3\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (j : \u03b1 i) \u2192 AddMonoid (\u03b4 i j)\ninst\u271d : (i : \u03b9) \u2192 (j : \u03b1 i) \u2192 DistribMulAction \u03b3 (\u03b4 i j)\nr : \u03b3\nf : \u03a0\u2080 (i : (x : \u03b9) \u00d7 \u03b1 x), \u03b4 i.fst i.snd\ni : \u03b9\nj : \u03b1 i\n\u22a2 \u2191(\u2191(sigmaCurry (r \u2022 f)) i) j = \u2191(\u2191(r \u2022 sigmaCurry f) i) j"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.h\n\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\n\u03ba : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b4 : (i : \u03b9) \u2192 \u03b1 i \u2192 Type v\ninst\u271d\u00b2 : Monoid \u03b3\ninst\u271d\u00b9 : (i : \u03b9) \u2192 (j : \u03b1 i) \u2192 AddMonoid (\u03b4 i j)\ninst\u271d : (i : \u03b9) \u2192 (j : \u03b1 i) \u2192 DistribMulAction \u03b3 (\u03b4 i j)\nr : \u03b3\nf : \u03a0\u2080 (i : (x : \u03b9) \u00d7 \u03b1 x), \u03b4 i.fst i.snd\ni : \u03b9\nj : \u03b1 i\n\u22a2 \u2191(\u2191(sigmaCurry (r \u2022 f)) i) j = \u2191(\u2191(r \u2022 sigmaCurry f) i) j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "full_name": "DoubleQuot.ker_quotLeftToQuotSup", "start": [640, 1], "end": [643, 99], "traced_tactics": [{"tactic": "simp only [mk_ker, sup_idem, sup_comm, quotLeftToQuotSup, Quotient.factor, ker_quotient_lift,\n  map_eq_iff_sup_ker_eq_of_surjective (Ideal.Quotient.mk I) Quotient.mk_surjective, \u2190 sup_assoc]", "annotated_tactic": ["simp only [<a>mk_ker</a>, <a>sup_idem</a>, <a>sup_comm</a>, <a>quotLeftToQuotSup</a>, <a>Quotient.factor</a>, <a>ker_quotient_lift</a>,\n    <a>map_eq_iff_sup_ker_eq_of_surjective</a> (<a>Ideal.Quotient.mk</a> I) <a>Quotient.mk_surjective</a>, \u2190 <a>sup_assoc</a>]", [{"full_name": "Ideal.mk_ker", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [113, 9], "def_end_pos": [113, 15]}, {"full_name": "sup_idem", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [244, 9], "def_end_pos": [244, 17]}, {"full_name": "sup_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [250, 9], "def_end_pos": [250, 17]}, {"full_name": "DoubleQuot.quotLeftToQuotSup", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [635, 5], "def_end_pos": [635, 22]}, {"full_name": "Ideal.Quotient.factor", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [281, 5], "def_end_pos": [281, 11]}, {"full_name": "Ideal.ker_quotient_lift", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/QuotientOperations.lean", "def_pos": [124, 9], "def_end_pos": [124, 26]}, {"full_name": "Ideal.map_eq_iff_sup_ker_eq_of_surjective", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [2261, 9], "def_end_pos": [2261, 44]}, {"full_name": "Ideal.Quotient.mk", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [96, 5], "def_end_pos": [96, 7]}, {"full_name": "Ideal.Quotient.mk_surjective", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Quotient.lean", "def_pos": [160, 9], "def_end_pos": [160, 22]}, {"full_name": "sup_assoc", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [256, 9], "def_end_pos": [256, 18]}]], "state_before": "R : Type u\ninst\u271d : CommRing R\nI J : Ideal R\n\u22a2 RingHom.ker (quotLeftToQuotSup I J) = map (Ideal.Quotient.mk I) J", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Commute/Defs.lean", "full_name": "Commute.pow_right", "start": [167, 1], "end": [168, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "Submodule.comap_bot", "start": [1130, 1], "end": [1131, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.right_inv'", "start": [172, 1], "end": [172, 79], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Congruence.lean", "full_name": "Con.coe_mk'", "start": [867, 1], "end": [868, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/FractionRing.lean", "full_name": "IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors", "start": [100, 11], "end": [102, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.sumAssoc_apply_inr", "start": [421, 1], "end": [422, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.mem_union", "start": [1734, 1], "end": [1736, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iio_diff_Iio", "start": [1125, 1], "end": [1126, 53], "traced_tactics": [{"tactic": "rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iio]", "annotated_tactic": ["rw [<a>diff_eq</a>, <a>compl_Iio</a>, <a>inter_comm</a>, <a>Ici_inter_Iio</a>]", [{"full_name": "Set.diff_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1807, 9], "def_end_pos": [1807, 16]}, {"full_name": "Set.compl_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [1084, 9], "def_end_pos": [1084, 18]}, {"full_name": "Set.inter_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [933, 9], "def_end_pos": [933, 19]}, {"full_name": "Set.Ici_inter_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [622, 9], "def_end_pos": [622, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\n\u22a2 Iio b \\ Iio a = Ico a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/LocallyFinite.lean", "full_name": "Ioi_toDual", "start": [943, 1], "end": [944, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Int.sub_floor_div_mul_nonneg", "start": [1102, 1], "end": [1103, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Option/Lemmas.lean", "full_name": "Option.ne_none_iff_exists", "start": [78, 1], "end": [78, 79], "traced_tactics": [{"tactic": "cases o <;> simp", "annotated_tactic": ["cases o <;> simp", []], "state_before": "\u03b1\u271d : Type u_1\no : Option \u03b1\u271d\n\u22a2 o \u2260 none \u2194 \u2203 x, some x = o", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Choose/Basic.lean", "full_name": "Nat.ascFactorial_eq_factorial_mul_choose", "start": [235, 1], "end": [241, 28], "traced_tactics": [{"tactic": "rw [mul_comm]", "annotated_tactic": ["rw [<a>mul_comm</a>]", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "n k : \u2115\n\u22a2 ascFactorial n k = k ! * choose (n + k) k", "state_after": "n k : \u2115\n\u22a2 ascFactorial n k = choose (n + k) k * k !"}, {"tactic": "apply mul_right_cancel\u2080 (factorial_ne_zero (n + k - k))", "annotated_tactic": ["apply <a>mul_right_cancel\u2080</a> (<a>factorial_ne_zero</a> (n + k - k))", [{"full_name": "mul_right_cancel\u2080", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [71, 9], "def_end_pos": [71, 26]}, {"full_name": "Nat.factorial_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [71, 9], "def_end_pos": [71, 26]}]], "state_before": "n k : \u2115\n\u22a2 ascFactorial n k = choose (n + k) k * k !", "state_after": "n k : \u2115\n\u22a2 ascFactorial n k * (n + k - k)! = choose (n + k) k * k ! * (n + k - k)!"}, {"tactic": "rw [choose_mul_factorial_mul_factorial, add_tsub_cancel_right, \u2190 factorial_mul_ascFactorial,\n  mul_comm]", "annotated_tactic": ["rw [<a>choose_mul_factorial_mul_factorial</a>, <a>add_tsub_cancel_right</a>, \u2190 <a>factorial_mul_ascFactorial</a>,\n    <a>mul_comm</a>]", [{"full_name": "Nat.choose_mul_factorial_mul_factorial", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [126, 9], "def_end_pos": [126, 43]}, {"full_name": "add_tsub_cancel_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [356, 9], "def_end_pos": [356, 30]}, {"full_name": "Nat.factorial_mul_ascFactorial", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [266, 9], "def_end_pos": [266, 35]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "n k : \u2115\n\u22a2 ascFactorial n k * (n + k - k)! = choose (n + k) k * k ! * (n + k - k)!", "state_after": "n k : \u2115\n\u22a2 k \u2264 n + k"}, {"tactic": "exact Nat.le_add_left k n", "annotated_tactic": ["exact <a>Nat.le_add_left</a> k n", [{"full_name": "Nat.le_add_left", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 20]}]], "state_before": "n k : \u2115\n\u22a2 k \u2264 n + k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "FilterBasis.mem_filter_of_mem", "start": [179, 1], "end": [180, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "full_name": "LinearIndependent.of_comp", "start": [259, 1], "end": [264, 48], "traced_tactics": [{"tactic": "simp_rw [\u2190 map_smul, \u2190 map_sum, hg, f.map_zero]", "annotated_tactic": ["simp_rw [\u2190 <a>map_smul</a>, \u2190 <a>map_sum</a>, hg, f.map_zero]", [{"full_name": "SMulHomClass.map_smul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Hom.lean", "def_pos": [81, 3], "def_end_pos": [81, 11]}, {"full_name": "map_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [204, 3], "def_end_pos": [204, 14]}]], "state_before": "\u03b9 : Type u'\n\u03b9' : Type u_1\nR : Type u_2\nK : Type u_3\nM : Type u_4\nM' : Type u_5\nM'' : Type u_6\nV : Type u\nV' : Type u_7\nv : \u03b9 \u2192 M\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M''\na b : R\nx y : M\nf : M \u2192\u2097[R] M'\nhfv : LinearIndependent R (\u2191f \u2218 v)\ns : Finset \u03b9\ng : \u03b9 \u2192 R\nhg : \u2211 i in s, g i \u2022 v i = 0\ni : \u03b9\nhis : i \u2208 s\n\u22a2 \u2211 i in s, g i \u2022 \u2191f (v i) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Real/CauSeq.lean", "full_name": "CauSeq.inf_le_right", "start": [962, 11], "end": [963, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.natCast_pow", "start": [1349, 1], "end": [1350, 58], "traced_tactics": [{"tactic": "induction n <;> simp [pow_succ', power_add, *, Pow.pow]", "annotated_tactic": ["induction n <;> simp [<a>pow_succ'</a>, <a>power_add</a>, *, <a>Pow.pow</a>]", [{"full_name": "pow_succ'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [213, 9], "def_end_pos": [213, 25]}, {"full_name": "Cardinal.power_add", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [520, 9], "def_end_pos": [520, 18]}, {"full_name": "Pow.pow", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1303, 3], "def_end_pos": [1303, 6]}]], "state_before": "\u03b1 \u03b2 : Type u\nm n : \u2115\n\u22a2 \u2191(m ^ n) = \u2191m ^ \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/HashMap/WF.lean", "full_name": "Std.HashMap.Imp.Buckets.update_update", "start": [29, 1], "end": [31, 45], "traced_tactics": [{"tactic": "simp [update]", "annotated_tactic": ["simp [<a>update</a>]", [{"full_name": "Std.HashMap.Imp.Buckets.update", "def_path": "lake-packages/std/Std/Data/HashMap/Basic.lean", "def_pos": [32, 5], "def_end_pos": [32, 11]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nself : Buckets \u03b1 \u03b2\ni : USize\nd d' : AssocList \u03b1 \u03b2\nh : USize.toNat i < Array.size self.val\nh' : USize.toNat i < Array.size (update self i d h).val\n\u22a2 update (update self i d h) i d' h' = update self i d' h", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nself : Buckets \u03b1 \u03b2\ni : USize\nd d' : AssocList \u03b1 \u03b2\nh : USize.toNat i < Array.size self.val\nh' : USize.toNat i < Array.size (update self i d h).val\n\u22a2 { val := Array.set (Array.set self.val { val := USize.toNat i, isLt := h } d) { val := USize.toNat i, isLt := h' } d',\n      property :=\n        (_ :\n          (fun b => 0 < Array.size b)\n            (Array.set (Array.set self.val { val := USize.toNat i, isLt := h } d) { val := USize.toNat i, isLt := h' }\n              d')) } =\n    { val := Array.set self.val { val := USize.toNat i, isLt := h } d',\n      property := (_ : (fun b => 0 < Array.size b) (Array.set self.val { val := USize.toNat i, isLt := h } d')) }"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nself : Buckets \u03b1 \u03b2\ni : USize\nd d' : AssocList \u03b1 \u03b2\nh : USize.toNat i < Array.size self.val\nh' : USize.toNat i < Array.size (update self i d h).val\n\u22a2 { val := Array.set (Array.set self.val { val := USize.toNat i, isLt := h } d) { val := USize.toNat i, isLt := h' } d',\n      property :=\n        (_ :\n          (fun b => 0 < Array.size b)\n            (Array.set (Array.set self.val { val := USize.toNat i, isLt := h } d) { val := USize.toNat i, isLt := h' }\n              d')) } =\n    { val := Array.set self.val { val := USize.toNat i, isLt := h } d',\n      property := (_ : (fun b => 0 < Array.size b) (Array.set self.val { val := USize.toNat i, isLt := h } d')) }", "state_after": "case e_val\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nself : Buckets \u03b1 \u03b2\ni : USize\nd d' : AssocList \u03b1 \u03b2\nh : USize.toNat i < Array.size self.val\nh' : USize.toNat i < Array.size (update self i d h).val\n\u22a2 Array.set (Array.set self.val { val := USize.toNat i, isLt := h } d) { val := USize.toNat i, isLt := h' } d' =\n    Array.set self.val { val := USize.toNat i, isLt := h } d'"}, {"tactic": "rw [Array.set_set]", "annotated_tactic": ["rw [<a>Array.set_set</a>]", [{"full_name": "Array.set_set", "def_path": "lake-packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [110, 9], "def_end_pos": [110, 16]}]], "state_before": "case e_val\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nself : Buckets \u03b1 \u03b2\ni : USize\nd d' : AssocList \u03b1 \u03b2\nh : USize.toNat i < Array.size self.val\nh' : USize.toNat i < Array.size (update self i d h).val\n\u22a2 Array.set (Array.set self.val { val := USize.toNat i, isLt := h } d) { val := USize.toNat i, isLt := h' } d' =\n    Array.set self.val { val := USize.toNat i, isLt := h } d'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "max_mul_of_nonneg", "start": [970, 1], "end": [971, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "Int.coe_nat_succ_pos", "start": [45, 1], "end": [46, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.lt_of_floor_lt", "start": [146, 1], "end": [147, 48], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Bool.lean", "full_name": "Bool.not_and_self", "start": [43, 9], "end": [43, 76], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u2200 (x : Bool), (!x && x) = false", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.bijective_iff_surjective_and_card", "start": [694, 1], "end": [697, 58], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/PeriodicPts.lean", "full_name": "Function.iUnion_pNat_ptsOfPeriod", "start": [251, 1], "end": [252, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Synonym.lean", "full_name": "OrderDual.ofDual_le_ofDual", "start": [100, 1], "end": [101, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "mul_nonpos_of_nonneg_of_nonpos", "start": [383, 1], "end": [384, 62], "traced_tactics": [{"tactic": "simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha", "annotated_tactic": ["simpa only [<a>mul_zero</a>] using <a>mul_le_mul_of_nonneg_left</a> hb ha", [{"full_name": "MulZeroClass.mul_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Defs.lean", "def_pos": [38, 3], "def_end_pos": [38, 11]}, {"full_name": "mul_le_mul_of_nonneg_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [152, 9], "def_end_pos": [152, 34]}]], "state_before": "\u03b1 : Type u_1\na b c d : \u03b1\ninst\u271d\u00b2 : MulZeroClass \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulMono \u03b1\nha : 0 \u2264 a\nhb : b \u2264 0\n\u22a2 a * b \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Algebra.iInf_toSubmodule", "start": [896, 1], "end": [898, 35], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\n\u03b9 : Sort u_1\nS : \u03b9 \u2192 Subalgebra R A\n\u22a2 \u2191(\u2191toSubmodule (\u2a05 i, S i)) = \u2191(\u2a05 i, \u2191toSubmodule (S i))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Atoms.lean", "full_name": "OrderIso.isSimpleOrder_iff", "start": [900, 1], "end": [903, 15], "traced_tactics": [{"tactic": "rw [isSimpleOrder_iff_isAtom_top, isSimpleOrder_iff_isAtom_top, \u2190 f.isAtom_iff \u22a4,\n  f.map_top]", "annotated_tactic": ["rw [<a>isSimpleOrder_iff_isAtom_top</a>, <a>isSimpleOrder_iff_isAtom_top</a>, \u2190 f.isAtom_iff \u22a4,\n    f.map_top]", [{"full_name": "isSimpleOrder_iff_isAtom_top", "def_path": "lake-packages/mathlib/Mathlib/Order/Atoms.lean", "def_pos": [749, 9], "def_end_pos": [749, 37]}, {"full_name": "isSimpleOrder_iff_isAtom_top", "def_path": "lake-packages/mathlib/Mathlib/Order/Atoms.lean", "def_pos": [749, 9], "def_end_pos": [749, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b2\ninst\u271d\u00b9 : BoundedOrder \u03b1\ninst\u271d : BoundedOrder \u03b2\nf : \u03b1 \u2243o \u03b2\n\u22a2 IsSimpleOrder \u03b1 \u2194 IsSimpleOrder \u03b2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.mul_le", "start": [167, 1], "end": [168, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.Prime.eq_one_of_pow", "start": [596, 1], "end": [597, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Max.lean", "full_name": "IsTop.fst", "start": [425, 1], "end": [425, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iInf_exists", "start": [1383, 1], "end": [1384, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.eq_zero_or_eq_succ", "start": [119, 1], "end": [121, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.foldl_swap", "start": [1440, 1], "end": [1442, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GeomSum.lean", "full_name": "Commute.geom_sum\u2082_succ_eq", "start": [302, 11], "end": [313, 62], "traced_tactics": [{"tactic": "simp_rw [mul_sum, sum_range_succ_comm, tsub_self, pow_zero, mul_one, add_right_inj, \u2190 mul_assoc,\n  (h.symm.pow_right _).eq, mul_assoc, \u2190 pow_succ]", "annotated_tactic": ["simp_rw [<a>mul_sum</a>, <a>sum_range_succ_comm</a>, <a>tsub_self</a>, <a>pow_zero</a>, <a>mul_one</a>, <a>add_right_inj</a>, \u2190 <a>mul_assoc</a>,\n    (h.symm.pow_right _).<a>eq</a>, <a>mul_assoc</a>, \u2190 <a>pow_succ</a>]", [{"full_name": "Finset.mul_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [55, 9], "def_end_pos": [55, 16]}, {"full_name": "Finset.sum_range_succ_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1218, 3], "def_end_pos": [1218, 14]}, {"full_name": "tsub_self", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [333, 9], "def_end_pos": [333, 18]}, {"full_name": "pow_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [639, 9], "def_end_pos": [639, 17]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}, {"full_name": "add_right_inj", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [188, 3], "def_end_pos": [188, 14]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "Commute.eq", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [47, 19], "def_end_pos": [47, 21]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}]], "state_before": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\n\u22a2 \u2211 i in range (n + 1), x ^ i * y ^ (n - i) = x ^ n + y * \u2211 i in range n, x ^ i * y ^ (n - 1 - i)", "state_after": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\n\u22a2 \u2211 i in range n, x ^ i * y ^ (n - i) = \u2211 x_1 in range n, x ^ x_1 * y ^ (n - 1 - x_1 + 1)"}, {"tactic": "refine' sum_congr rfl fun i hi => _", "annotated_tactic": ["refine' <a>sum_congr</a> <a>rfl</a> fun i hi => _", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn : \u2115\n\u22a2 \u2211 i in range n, x ^ i * y ^ (n - i) = \u2211 x_1 in range n, x ^ x_1 * y ^ (n - 1 - x_1 + 1)", "state_after": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn i : \u2115\nhi : i \u2208 range n\n\u22a2 x ^ i * y ^ (n - i) = x ^ i * y ^ (n - 1 - i + 1)"}, {"tactic": "suffices n - 1 - i + 1 = n - i by rw [this]", "annotated_tactic": ["suffices n - 1 - i + 1 = n - i by rw [this]", []], "state_before": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn i : \u2115\nhi : i \u2208 range n\n\u22a2 x ^ i * y ^ (n - i) = x ^ i * y ^ (n - 1 - i + 1)", "state_after": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn i : \u2115\nhi : i \u2208 range n\n\u22a2 n - 1 - i + 1 = n - i"}, {"tactic": "cases' n with n", "annotated_tactic": ["cases' n with n", []], "state_before": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn i : \u2115\nhi : i \u2208 range n\n\u22a2 n - 1 - i + 1 = n - i", "state_after": "case zero\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\ni : \u2115\nhi : i \u2208 range Nat.zero\n\u22a2 Nat.zero - 1 - i + 1 = Nat.zero - i\n\ncase succ\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\ni n : \u2115\nhi : i \u2208 range (Nat.succ n)\n\u22a2 Nat.succ n - 1 - i + 1 = Nat.succ n - i"}, {"tactic": "rw [this]", "annotated_tactic": ["rw [this]", []], "state_before": "\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\nn i : \u2115\nhi : i \u2208 range n\nthis : n - 1 - i + 1 = n - i\n\u22a2 x ^ i * y ^ (n - i) = x ^ i * y ^ (n - 1 - i + 1)", "state_after": "no goals"}, {"tactic": "exact absurd (List.mem_range.mp hi) i.not_lt_zero", "annotated_tactic": ["exact <a>absurd</a> (List.mem_range.mp hi) i.not_lt_zero", [{"full_name": "absurd", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [233, 21], "def_end_pos": [233, 27]}]], "state_before": "case zero\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\ni : \u2115\nhi : i \u2208 range Nat.zero\n\u22a2 Nat.zero - 1 - i + 1 = Nat.zero - i", "state_after": "no goals"}, {"tactic": "rw [tsub_add_eq_add_tsub (Nat.le_sub_one_of_lt (List.mem_range.mp hi)),\n  tsub_add_cancel_of_le (Nat.succ_le_iff.mpr n.succ_pos)]", "annotated_tactic": ["rw [<a>tsub_add_eq_add_tsub</a> (<a>Nat.le_sub_one_of_lt</a> (List.mem_range.mp hi)),\n      <a>tsub_add_cancel_of_le</a> (Nat.succ_le_iff.mpr n.succ_pos)]", [{"full_name": "tsub_add_eq_add_tsub", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [218, 9], "def_end_pos": [218, 29]}, {"full_name": "Nat.le_sub_one_of_lt", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [521, 9], "def_end_pos": [521, 25]}, {"full_name": "tsub_add_cancel_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}]], "state_before": "case succ\n\u03b1\u271d \u03b1 : Type u\ninst\u271d : Ring \u03b1\nx y : \u03b1\nh : Commute x y\ni n : \u2115\nhi : i \u2208 range (Nat.succ n)\n\u22a2 Nat.succ n - 1 - i + 1 = Nat.succ n - i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "MonoidHom.coe_comp", "start": [1086, 1], "end": [1087, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.card_disjiUnion", "start": [1874, 1], "end": [1876, 25], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "UniqueFactorizationMonoid.dvd_of_mem_factors", "start": [449, 1], "end": [450, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_image_eq_of_injOn", "start": [2285, 1], "end": [2287, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Adjoin/Basic.lean", "full_name": "Algebra.adjoin_image", "start": [215, 1], "end": [221, 51], "traced_tactics": [{"tactic": "simp only [Set.image_id', coe_carrier_toSubmonoid, Subalgebra.coe_toSubsemiring,\n  Subalgebra.coe_comap]", "annotated_tactic": ["simp only [<a>Set.image_id'</a>, <a>coe_carrier_toSubmonoid</a>, <a>Subalgebra.coe_toSubsemiring</a>,\n        <a>Subalgebra.coe_comap</a>]", [{"full_name": "Set.image_id'", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [396, 9], "def_end_pos": [396, 18]}, {"full_name": "Subsemiring.coe_carrier_toSubmonoid", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Subsemiring/Basic.lean", "def_pos": [490, 9], "def_end_pos": [490, 32]}, {"full_name": "Subalgebra.coe_toSubsemiring", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "def_pos": [72, 9], "def_end_pos": [72, 26]}, {"full_name": "Subalgebra.coe_comap", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "def_pos": [536, 9], "def_end_pos": [536, 18]}]], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns\u271d t : Set A\nf : A \u2192\u2090[R] B\ns : Set A\n\u22a2 (fun x => x) '' s \u2286 (Subalgebra.comap f (adjoin R (\u2191f '' s))).toSubsemiring.toSubmonoid.toSubsemigroup.carrier", "state_after": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns\u271d t : Set A\nf : A \u2192\u2090[R] B\ns : Set A\n\u22a2 s \u2286 \u2191f \u207b\u00b9' \u2191(adjoin R ((fun a => \u2191f a) '' s))"}, {"tactic": "exact fun x hx => subset_adjoin \u27e8x, hx, rfl\u27e9", "annotated_tactic": ["exact fun x hx => <a>subset_adjoin</a> \u27e8x, hx, <a>rfl</a>\u27e9", [{"full_name": "Algebra.subset_adjoin", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Adjoin/Basic.lean", "def_pos": [44, 9], "def_end_pos": [44, 22]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns\u271d t : Set A\nf : A \u2192\u2090[R] B\ns : Set A\n\u22a2 s \u2286 \u2191f \u207b\u00b9' \u2191(adjoin R ((fun a => \u2191f a) '' s))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/FixedPoints.lean", "full_name": "OrderHom.gfp_le_map", "start": [131, 1], "end": [132, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Icc_diff_both", "start": [803, 1], "end": [804, 61], "traced_tactics": [{"tactic": "rw [insert_eq, \u2190 diff_diff, Icc_diff_left, Ioc_diff_right]", "annotated_tactic": ["rw [<a>insert_eq</a>, \u2190 <a>diff_diff</a>, <a>Icc_diff_left</a>, <a>Ioc_diff_right</a>]", [{"full_name": "Set.insert_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1303, 9], "def_end_pos": [1303, 18]}, {"full_name": "Set.diff_diff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1932, 9], "def_end_pos": [1932, 18]}, {"full_name": "Set.Icc_diff_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [783, 9], "def_end_pos": [783, 22]}, {"full_name": "Set.Ioc_diff_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [798, 9], "def_end_pos": [798, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b c : \u03b1\n\u22a2 Icc a b \\ {a, b} = Ioo a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.erase_biUnion", "start": [3749, 1], "end": [3753, 8], "traced_tactics": [{"tactic": "ext a", "annotated_tactic": ["ext a", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns\u271d s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 f : \u03b1 \u2192 Finset \u03b2\ns : Finset \u03b1\nb : \u03b2\n\u22a2 erase (Finset.biUnion s f) b = Finset.biUnion s fun x => erase (f x) b", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns\u271d s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 f : \u03b1 \u2192 Finset \u03b2\ns : Finset \u03b1\nb a : \u03b2\n\u22a2 a \u2208 erase (Finset.biUnion s f) b \u2194 a \u2208 Finset.biUnion s fun x => erase (f x) b"}, {"tactic": "simp only [mem_biUnion, not_exists, not_and, mem_erase, ne_eq]", "annotated_tactic": ["simp only [<a>mem_biUnion</a>, <a>not_exists</a>, <a>not_and</a>, <a>mem_erase</a>, <a>ne_eq</a>]", [{"full_name": "Finset.mem_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3636, 9], "def_end_pos": [3636, 20]}, {"full_name": "not_exists", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [428, 17], "def_end_pos": [428, 27]}, {"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}, {"full_name": "Finset.mem_erase", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1904, 9], "def_end_pos": [1904, 18]}, {"full_name": "ne_eq", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [82, 17], "def_end_pos": [82, 22]}]], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns\u271d s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 f : \u03b1 \u2192 Finset \u03b2\ns : Finset \u03b1\nb a : \u03b2\n\u22a2 a \u2208 erase (Finset.biUnion s f) b \u2194 a \u2208 Finset.biUnion s fun x => erase (f x) b", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns\u271d s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 f : \u03b1 \u2192 Finset \u03b2\ns : Finset \u03b1\nb a : \u03b2\n\u22a2 (\u00aca = b \u2227 \u2203 a_1 \u2208 s, a \u2208 f a_1) \u2194 \u2203 a_1 \u2208 s, \u00aca = b \u2227 a \u2208 f a_1"}, {"tactic": "tauto", "annotated_tactic": ["tauto", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\ns\u271d s\u2081 s\u2082 : Finset \u03b1\nt t\u2081 t\u2082 f : \u03b1 \u2192 Finset \u03b2\ns : Finset \u03b1\nb a : \u03b2\n\u22a2 (\u00aca = b \u2227 \u2203 a_1 \u2208 s, a \u2208 f a_1) \u2194 \u2203 a_1 \u2208 s, \u00aca = b \u2227 a \u2208 f a_1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/BigOperators.lean", "full_name": "Fintype.prod_eq_single", "start": [80, 1], "end": [81, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.utf8GetAux_add_right_cancel", "start": [198, 1], "end": [207, 11], "traced_tactics": [{"tactic": "apply utf8InductionOn s \u27e8i\u27e9 \u27e8p\u27e9 (motive := fun s i =>\n  utf8GetAux s \u27e8i.byteIdx + n\u27e9 \u27e8p + n\u27e9 = utf8GetAux s i \u27e8p\u27e9) <;>\nsimp [utf8GetAux]", "annotated_tactic": ["apply <a>utf8InductionOn</a> s \u27e8i\u27e9 \u27e8p\u27e9 (motive := fun s i =>\n    <a>utf8GetAux</a> s \u27e8i.byteIdx + n\u27e9 \u27e8p + n\u27e9 = <a>utf8GetAux</a> s i \u27e8p\u27e9) <;>\n  simp [<a>utf8GetAux</a>]", [{"full_name": "String.utf8InductionOn", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [185, 5], "def_end_pos": [185, 20]}, {"full_name": "String.utf8GetAux", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [47, 5], "def_end_pos": [47, 15]}, {"full_name": "String.utf8GetAux", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [47, 5], "def_end_pos": [47, 15]}, {"full_name": "String.utf8GetAux", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [47, 5], "def_end_pos": [47, 15]}]], "state_before": "s : List Char\ni p n : Nat\n\u22a2 utf8GetAux s { byteIdx := i + n } { byteIdx := p + n } = utf8GetAux s { byteIdx := i } { byteIdx := p }", "state_after": "case ind\ns : List Char\ni p n : Nat\n\u22a2 \u2200 (c : Char) (cs : List Char) (i : Pos),\n    \u00aci = { byteIdx := p } \u2192\n      utf8GetAux cs { byteIdx := i.byteIdx + csize c + n } { byteIdx := p + n } =\n          utf8GetAux cs (i + c) { byteIdx := p } \u2192\n        (if { byteIdx := i.byteIdx + n } = { byteIdx := p + n } then c\n          else utf8GetAux cs ({ byteIdx := i.byteIdx + n } + c) { byteIdx := p + n }) =\n          if i = { byteIdx := p } then c else utf8GetAux cs (i + c) { byteIdx := p }"}, {"tactic": "intro c cs \u27e8i\u27e9 h ih", "annotated_tactic": ["intro c cs \u27e8i\u27e9 h ih", []], "state_before": "case ind\ns : List Char\ni p n : Nat\n\u22a2 \u2200 (c : Char) (cs : List Char) (i : Pos),\n    \u00aci = { byteIdx := p } \u2192\n      utf8GetAux cs { byteIdx := i.byteIdx + csize c + n } { byteIdx := p + n } =\n          utf8GetAux cs (i + c) { byteIdx := p } \u2192\n        (if { byteIdx := i.byteIdx + n } = { byteIdx := p + n } then c\n          else utf8GetAux cs ({ byteIdx := i.byteIdx + n } + c) { byteIdx := p + n }) =\n          if i = { byteIdx := p } then c else utf8GetAux cs (i + c) { byteIdx := p }", "state_after": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nh : \u00ac{ byteIdx := i } = { byteIdx := p }\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\n\u22a2 (if { byteIdx := { byteIdx := i }.byteIdx + n } = { byteIdx := p + n } then c\n    else utf8GetAux cs ({ byteIdx := { byteIdx := i }.byteIdx + n } + c) { byteIdx := p + n }) =\n    if { byteIdx := i } = { byteIdx := p } then c else utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }"}, {"tactic": "simp [Pos.ext_iff, Pos.addChar_eq] at h \u22a2", "annotated_tactic": ["simp [<a>Pos.ext_iff</a>, <a>Pos.addChar_eq</a>] at h \u22a2", [{"full_name": "String.Pos.ext_iff", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [108, 9], "def_end_pos": [108, 16]}, {"full_name": "String.Pos.addChar_eq", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [120, 9], "def_end_pos": [120, 19]}]], "state_before": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nh : \u00ac{ byteIdx := i } = { byteIdx := p }\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\n\u22a2 (if { byteIdx := { byteIdx := i }.byteIdx + n } = { byteIdx := p + n } then c\n    else utf8GetAux cs ({ byteIdx := { byteIdx := i }.byteIdx + n } + c) { byteIdx := p + n }) =\n    if { byteIdx := i } = { byteIdx := p } then c else utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }", "state_after": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\nh : \u00aci = p\n\u22a2 (if i + n = p + n then c else utf8GetAux cs { byteIdx := i + n + csize c } { byteIdx := p + n }) =\n    if i = p then c else utf8GetAux cs { byteIdx := i + csize c } { byteIdx := p }"}, {"tactic": "simp [Nat.add_right_cancel_iff, h]", "annotated_tactic": ["simp [<a>Nat.add_right_cancel_iff</a>, h]", [{"full_name": "Nat.add_right_cancel_iff", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [360, 19], "def_end_pos": [360, 39]}]], "state_before": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\nh : \u00aci = p\n\u22a2 (if i + n = p + n then c else utf8GetAux cs { byteIdx := i + n + csize c } { byteIdx := p + n }) =\n    if i = p then c else utf8GetAux cs { byteIdx := i + csize c } { byteIdx := p }", "state_after": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\nh : \u00aci = p\n\u22a2 utf8GetAux cs { byteIdx := i + n + csize c } { byteIdx := p + n } =\n    utf8GetAux cs { byteIdx := i + csize c } { byteIdx := p }"}, {"tactic": "rw [Nat.add_right_comm]", "annotated_tactic": ["rw [<a>Nat.add_right_comm</a>]", [{"full_name": "Nat.add_right_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}]], "state_before": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\nh : \u00aci = p\n\u22a2 utf8GetAux cs { byteIdx := i + n + csize c } { byteIdx := p + n } =\n    utf8GetAux cs { byteIdx := i + csize c } { byteIdx := p }", "state_after": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\nh : \u00aci = p\n\u22a2 utf8GetAux cs { byteIdx := i + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs { byteIdx := i + csize c } { byteIdx := p }"}, {"tactic": "exact ih", "annotated_tactic": ["exact ih", []], "state_before": "case ind\ns : List Char\ni\u271d p n : Nat\nc : Char\ncs : List Char\ni : Nat\nih :\n  utf8GetAux cs { byteIdx := { byteIdx := i }.byteIdx + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs ({ byteIdx := i } + c) { byteIdx := p }\nh : \u00aci = p\n\u22a2 utf8GetAux cs { byteIdx := i + csize c + n } { byteIdx := p + n } =\n    utf8GetAux cs { byteIdx := i + csize c } { byteIdx := p }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/FractionRing.lean", "full_name": "IsFractionRing.mk'_eq_zero_iff_eq_zero", "start": [178, 1], "end": [182, 34], "traced_tactics": [{"tactic": "refine' \u27e8fun hxy => _, fun h => by rw [h, mk'_zero]\u27e9", "annotated_tactic": ["refine' \u27e8fun hxy => _, fun h => by rw [h, <a>mk'_zero</a>]\u27e9", [{"full_name": "IsLocalization.mk'_zero", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [349, 9], "def_end_pos": [349, 17]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b9\u00b2 : CommRing S\ninst\u271d\u00b9\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9\u2070 : CommRing P\nA : Type u_4\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u2077 : CommRing B\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Field K\nL : Type u_7\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Algebra A K\ninst\u271d\u00b2 : IsFractionRing A K\ng : A \u2192+* L\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nx : R\ny : \u21a5nonZeroDivisors R\n\u22a2 mk' K x y = 0 \u2194 x = 0", "state_after": "R : Type u_1\ninst\u271d\u00b9\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b9\u00b2 : CommRing S\ninst\u271d\u00b9\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9\u2070 : CommRing P\nA : Type u_4\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u2077 : CommRing B\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Field K\nL : Type u_7\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Algebra A K\ninst\u271d\u00b2 : IsFractionRing A K\ng : A \u2192+* L\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nx : R\ny : \u21a5nonZeroDivisors R\nhxy : mk' K x y = 0\n\u22a2 x = 0"}, {"tactic": "rw [h, mk'_zero]", "annotated_tactic": ["rw [h, <a>mk'_zero</a>]", [{"full_name": "IsLocalization.mk'_zero", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [349, 9], "def_end_pos": [349, 17]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b9\u00b2 : CommRing S\ninst\u271d\u00b9\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9\u2070 : CommRing P\nA : Type u_4\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u2077 : CommRing B\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Field K\nL : Type u_7\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Algebra A K\ninst\u271d\u00b2 : IsFractionRing A K\ng : A \u2192+* L\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nx : R\ny : \u21a5nonZeroDivisors R\nh : x = 0\n\u22a2 mk' K x y = 0", "state_after": "no goals"}, {"tactic": "simp_rw [mk'_eq_zero_iff, mul_left_coe_nonZeroDivisors_eq_zero_iff] at hxy", "annotated_tactic": ["simp_rw [<a>mk'_eq_zero_iff</a>, <a>mul_left_coe_nonZeroDivisors_eq_zero_iff</a>] at hxy", [{"full_name": "IsLocalization.mk'_eq_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Localization/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 24]}, {"full_name": "mul_left_coe_nonZeroDivisors_eq_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/NonZeroDivisors.lean", "def_pos": [61, 9], "def_end_pos": [61, 49]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b9\u00b2 : CommRing S\ninst\u271d\u00b9\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9\u2070 : CommRing P\nA : Type u_4\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u2077 : CommRing B\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Field K\nL : Type u_7\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Algebra A K\ninst\u271d\u00b2 : IsFractionRing A K\ng : A \u2192+* L\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nx : R\ny : \u21a5nonZeroDivisors R\nhxy : mk' K x y = 0\n\u22a2 x = 0", "state_after": "R : Type u_1\ninst\u271d\u00b9\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b9\u00b2 : CommRing S\ninst\u271d\u00b9\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9\u2070 : CommRing P\nA : Type u_4\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u2077 : CommRing B\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Field K\nL : Type u_7\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Algebra A K\ninst\u271d\u00b2 : IsFractionRing A K\ng : A \u2192+* L\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nx : R\ny : \u21a5nonZeroDivisors R\nhxy : \u2203 m, x = 0\n\u22a2 x = 0"}, {"tactic": "exact (exists_const _).mp hxy", "annotated_tactic": ["exact (<a>exists_const</a> _).<a>mp</a> hxy", [{"full_name": "exists_const", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [375, 17], "def_end_pos": [375, 29]}, {"full_name": "Iff.mp", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [90, 3], "def_end_pos": [90, 5]}]], "state_before": "R : Type u_1\ninst\u271d\u00b9\u00b3 : CommRing R\nM : Submonoid R\nS : Type u_2\ninst\u271d\u00b9\u00b2 : CommRing S\ninst\u271d\u00b9\u00b9 : Algebra R S\nP : Type u_3\ninst\u271d\u00b9\u2070 : CommRing P\nA : Type u_4\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : IsDomain A\nK : Type u_5\nB : Type u_6\ninst\u271d\u2077 : CommRing B\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Field K\nL : Type u_7\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Algebra A K\ninst\u271d\u00b2 : IsFractionRing A K\ng : A \u2192+* L\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nx : R\ny : \u21a5nonZeroDivisors R\nhxy : \u2203 m, x = 0\n\u22a2 x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.eq_C_coeff_zero_iff_natDegree_eq_zero", "start": [1163, 1], "end": [1164, 62], "traced_tactics": [{"tactic": "rw [h, natDegree_C]", "annotated_tactic": ["rw [h, <a>natDegree_C</a>]", [{"full_name": "Polynomial.natDegree_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [265, 9], "def_end_pos": [265, 20]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np q : R[X]\n\u03b9 : Type u_1\nh : p = \u2191C (coeff p 0)\n\u22a2 natDegree p = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "strongLT_of_le_of_strongLT", "start": [859, 1], "end": [860, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Zip.lean", "full_name": "List.unzip_zip", "start": [187, 1], "end": [190, 63], "traced_tactics": [{"tactic": "rw [\u2190 Prod.mk.eta (p := unzip (zip l\u2081 l\u2082)),\n  unzip_zip_left (le_of_eq h), unzip_zip_right (ge_of_eq h)]", "annotated_tactic": ["rw [\u2190 <a>Prod.mk.eta</a> (p := <a>unzip</a> (<a>zip</a> l\u2081 l\u2082)),\n    <a>unzip_zip_left</a> (<a>le_of_eq</a> h), <a>unzip_zip_right</a> (<a>ge_of_eq</a> h)]", [{"full_name": "Prod.mk.eta", "def_path": "lake-packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [32, 9], "def_end_pos": [32, 15]}, {"full_name": "List.unzip", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [564, 5], "def_end_pos": [564, 10]}, {"full_name": "List.zip", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [557, 5], "def_end_pos": [557, 8]}, {"full_name": "List.unzip_zip_left", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Zip.lean", "def_pos": [175, 9], "def_end_pos": [175, 23]}, {"full_name": "le_of_eq", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [72, 9], "def_end_pos": [72, 17]}, {"full_name": "List.unzip_zip_right", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Zip.lean", "def_pos": [183, 9], "def_end_pos": [183, 24]}, {"full_name": "ge_of_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [352, 9], "def_end_pos": [352, 17]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl\u2081 : List \u03b1\nl\u2082 : List \u03b2\nh : length l\u2081 = length l\u2082\n\u22a2 unzip (zip l\u2081 l\u2082) = (l\u2081, l\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.sep_eq_empty_iff_mem_false", "start": [1448, 1], "end": [1449, 78], "traced_tactics": [{"tactic": "simp_rw [ext_iff, mem_sep_iff, mem_empty_iff_false, iff_false_iff, not_and]", "annotated_tactic": ["simp_rw [<a>ext_iff</a>, <a>mem_sep_iff</a>, <a>mem_empty_iff_false</a>, <a>iff_false_iff</a>, <a>not_and</a>]", [{"full_name": "Set.ext_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [242, 9], "def_end_pos": [242, 16]}, {"full_name": "Set.mem_sep_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1426, 9], "def_end_pos": [1426, 20]}, {"full_name": "Set.mem_empty_iff_false", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [555, 9], "def_end_pos": [555, 28]}, {"full_name": "iff_false_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [199, 9], "def_end_pos": [199, 22]}, {"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\na b : \u03b1\ns s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1\np q : \u03b1 \u2192 Prop\nx : \u03b1\n\u22a2 {x | x \u2208 s \u2227 p x} = \u2205 \u2194 \u2200 x \u2208 s, \u00acp x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.quot_out", "start": [1887, 1], "end": [1888, 75], "traced_tactics": [{"tactic": "rw [\u2190 quot_mk_eq_mk, Quot.out_eq]", "annotated_tactic": ["rw [\u2190 <a>quot_mk_eq_mk</a>, <a>Quot.out_eq</a>]", [{"full_name": "Associates.quot_mk_eq_mk", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [777, 9], "def_end_pos": [777, 22]}, {"full_name": "Quot.out_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [368, 9], "def_end_pos": [368, 20]}]], "state_before": "\u03b1\u271d : Type u_1\n\u03b1 : Type u_2\ninst\u271d : CommMonoid \u03b1\na : Associates \u03b1\n\u22a2 Associates.mk (Quot.out a) = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Bool.lean", "full_name": "Bool.xor_assoc", "start": [124, 1], "end": [124, 85], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u2200 (x y z : Bool), xor (xor x y) z = xor x (xor y z)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "Codisjoint.bihimp_left", "start": [698, 11], "end": [700, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/OrderIso.lean", "full_name": "OrderIso.preimage_Ici", "start": [32, 1], "end": [34, 23], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 \u2191e \u207b\u00b9' Ici b = Ici (\u2191(symm e) b)", "state_after": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u2191e \u207b\u00b9' Ici b \u2194 x \u2208 Ici (\u2191(symm e) b)"}, {"tactic": "simp [\u2190 e.le_iff_le]", "annotated_tactic": ["simp [\u2190 e.le_iff_le]", []], "state_before": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u2191e \u207b\u00b9' Ici b \u2194 x \u2208 Ici (\u2191(symm e) b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Matrix/Adjugate.lean", "full_name": "Matrix.adjugate_zero", "start": [328, 1], "end": [333, 29], "traced_tactics": [{"tactic": "ext i j", "annotated_tactic": ["ext i j", []], "state_before": "m : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\n\u22a2 adjugate 0 = 0", "state_after": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j : n\n\u22a2 adjugate 0 i j = OfNat.ofNat 0 i j"}, {"tactic": "obtain \u27e8j', hj'\u27e9 : \u2203 j', j' \u2260 j := exists_ne j", "annotated_tactic": ["obtain \u27e8j', hj'\u27e9 : \u2203 j', j' \u2260 j := <a>exists_ne</a> j", [{"full_name": "exists_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [51, 9], "def_end_pos": [51, 18]}]], "state_before": "case a.h\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j : n\n\u22a2 adjugate 0 i j = OfNat.ofNat 0 i j", "state_after": "case a.h.intro\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j j' : n\nhj' : j' \u2260 j\n\u22a2 adjugate 0 i j = OfNat.ofNat 0 i j"}, {"tactic": "apply det_eq_zero_of_column_eq_zero j'", "annotated_tactic": ["apply <a>det_eq_zero_of_column_eq_zero</a> j'", [{"full_name": "Matrix.det_eq_zero_of_column_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [367, 9], "def_end_pos": [367, 38]}]], "state_before": "case a.h.intro\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j j' : n\nhj' : j' \u2260 j\n\u22a2 adjugate 0 i j = OfNat.ofNat 0 i j", "state_after": "case a.h.intro\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j j' : n\nhj' : j' \u2260 j\n\u22a2 \u2200 (i_1 : n), updateColumn 0\u1d40 j (Pi.single i 1) i_1 j' = 0"}, {"tactic": "intro j''", "annotated_tactic": ["intro j''", []], "state_before": "case a.h.intro\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j j' : n\nhj' : j' \u2260 j\n\u22a2 \u2200 (i_1 : n), updateColumn 0\u1d40 j (Pi.single i 1) i_1 j' = 0", "state_after": "case a.h.intro\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j j' : n\nhj' : j' \u2260 j\nj'' : n\n\u22a2 updateColumn 0\u1d40 j (Pi.single i 1) j'' j' = 0"}, {"tactic": "simp [updateColumn_ne hj']", "annotated_tactic": ["simp [<a>updateColumn_ne</a> hj']", [{"full_name": "Matrix.updateColumn_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/RowCol.lean", "def_pos": [194, 9], "def_end_pos": [194, 24]}]], "state_before": "case a.h.intro\nm : Type u\nn : Type v\n\u03b1 : Type w\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : Nontrivial n\ni j j' : n\nhj' : j' \u2260 j\nj'' : n\n\u22a2 updateColumn 0\u1d40 j (Pi.single i 1) j'' j' = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Basic.lean", "full_name": "Algebra.algebraMap_ofSubring_apply", "start": [544, 1], "end": [546, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Injective.comp_left", "start": [152, 1], "end": [154, 59], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.coe_coeMonoidHom", "start": [832, 1], "end": [833, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Commute/Defs.lean", "full_name": "mul_inv_cancel_comm_assoc", "start": [267, 1], "end": [268, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_mul_le_div_mul_of_div_le_div", "start": [559, 1], "end": [562, 59], "traced_tactics": [{"tactic": "rw [div_mul_eq_div_mul_one_div, div_mul_eq_div_mul_one_div]", "annotated_tactic": ["rw [<a>div_mul_eq_div_mul_one_div</a>, <a>div_mul_eq_div_mul_one_div</a>]", [{"full_name": "div_mul_eq_div_mul_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [567, 9], "def_end_pos": [567, 35]}, {"full_name": "div_mul_eq_div_mul_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [567, 9], "def_end_pos": [567, 35]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh : a / b \u2264 c / d\nhe : 0 \u2264 e\n\u22a2 a / (b * e) \u2264 c / (d * e)", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh : a / b \u2264 c / d\nhe : 0 \u2264 e\n\u22a2 a / b * (1 / e) \u2264 c / d * (1 / e)"}, {"tactic": "exact mul_le_mul_of_nonneg_right h (one_div_nonneg.2 he)", "annotated_tactic": ["exact <a>mul_le_mul_of_nonneg_right</a> h (<a>one_div_nonneg</a>.2 he)", [{"full_name": "mul_le_mul_of_nonneg_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [156, 9], "def_end_pos": [156, 35]}, {"full_name": "one_div_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [81, 9], "def_end_pos": [81, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh : a / b \u2264 c / d\nhe : 0 \u2264 e\n\u22a2 a / b * (1 / e) \u2264 c / d * (1 / e)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/AbsoluteValue.lean", "full_name": "IsAbsoluteValue.abv_div", "start": [477, 1], "end": [478, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Iterate.lean", "full_name": "Monotone.iterate_le_of_le", "start": [110, 1], "end": [111, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.getLast_eq_get", "start": [722, 1], "end": [726, 99], "traced_tactics": [{"tactic": "rw [getLast_singleton, get_singleton]", "annotated_tactic": ["rw [<a>getLast_singleton</a>, <a>get_singleton</a>]", [{"full_name": "List.getLast_singleton", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [568, 9], "def_end_pos": [568, 26]}, {"full_name": "List.get_singleton", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [681, 17], "def_end_pos": [681, 30]}]], "state_before": "\u03b1 : Type u_1\na : \u03b1\nh : [a] \u2260 []\n\u22a2 getLast [a] h = get [a] { val := length [a] - 1, isLt := (_ : length [a] - 1 < length [a]) }", "state_after": "no goals"}, {"tactic": "rw [getLast_cons', getLast_eq_get (b :: l)]", "annotated_tactic": ["rw [<a>getLast_cons'</a>, getLast_eq_get (b :: l)]", [{"full_name": "List.getLast_cons'", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [366, 9], "def_end_pos": [366, 22]}]], "state_before": "\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 getLast (a :: b :: l) h =\n    get (a :: b :: l) { val := length (a :: b :: l) - 1, isLt := (_ : length (a :: b :: l) - 1 < length (a :: b :: l)) }", "state_after": "\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 get (b :: l) { val := length (b :: l) - 1, isLt := (_ : length (b :: l) - 1 < length (b :: l)) } =\n    get (a :: b :: l) { val := length (a :: b :: l) - 1, isLt := (_ : length (a :: b :: l) - 1 < length (a :: b :: l)) }\n\n\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 b :: l \u2260 []"}, {"tactic": "{rfl}", "annotated_tactic": ["{rfl}", []], "state_before": "\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 get (b :: l) { val := length (b :: l) - 1, isLt := (_ : length (b :: l) - 1 < length (b :: l)) } =\n    get (a :: b :: l) { val := length (a :: b :: l) - 1, isLt := (_ : length (a :: b :: l) - 1 < length (a :: b :: l)) }\n\n\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 b :: l \u2260 []", "state_after": "\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 b :: l \u2260 []"}, {"tactic": "exact cons_ne_nil b l", "annotated_tactic": ["exact <a>cons_ne_nil</a> b l", [{"full_name": "List.cons_ne_nil", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [21, 9], "def_end_pos": [21, 20]}]], "state_before": "\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 b :: l \u2260 []", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\na b : \u03b1\nl : List \u03b1\nh : a :: b :: l \u2260 []\n\u22a2 get (b :: l) { val := length (b :: l) - 1, isLt := (_ : length (b :: l) - 1 < length (b :: l)) } =\n    get (a :: b :: l) { val := length (a :: b :: l) - 1, isLt := (_ : length (a :: b :: l) - 1 < length (a :: b :: l)) }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "compl_ne_self", "start": [903, 9], "end": [904, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.union_def", "start": [1642, 1], "end": [1642, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Ultrafilter.lean", "full_name": "Ultrafilter.coe_pure", "start": [289, 1], "end": [290, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Vector.lean", "full_name": "Vector.toList_cons", "start": [264, 1], "end": [265, 15], "traced_tactics": [{"tactic": "cases v", "annotated_tactic": ["cases v", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03c6 : Type w\nn : \u2115\na : \u03b1\nv : Vector \u03b1 n\n\u22a2 toList (cons a v) = a :: toList v", "state_after": "case mk\n\u03b1 : Type u\n\u03b2 : Type v\n\u03c6 : Type w\nn : \u2115\na : \u03b1\nval\u271d : List \u03b1\nproperty\u271d : List.length val\u271d = n\n\u22a2 toList (cons a { val := val\u271d, property := property\u271d }) = a :: toList { val := val\u271d, property := property\u271d }"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\n\u03b1 : Type u\n\u03b2 : Type v\n\u03c6 : Type w\nn : \u2115\na : \u03b1\nval\u271d : List \u03b1\nproperty\u271d : List.length val\u271d = n\n\u22a2 toList (cons a { val := val\u271d, property := property\u271d }) = a :: toList { val := val\u271d, property := property\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/List.lean", "full_name": "List.formPerm_cons_concat_apply_last", "start": [125, 1], "end": [129, 14], "traced_tactics": [{"tactic": "induction' xs with z xs IH generalizing x y", "annotated_tactic": ["induction' xs with z xs IH generalizing x y", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\nxs : List \u03b1\n\u22a2 \u2191(formPerm (x :: (xs ++ [y]))) y = x", "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\n\u22a2 \u2191(formPerm (x :: ([] ++ [y]))) y = x\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d z : \u03b1\nxs : List \u03b1\nIH : \u2200 (x y : \u03b1), \u2191(formPerm (x :: (xs ++ [y]))) y = x\nx y : \u03b1\n\u22a2 \u2191(formPerm (x :: (z :: xs ++ [y]))) y = x"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\n\u22a2 \u2191(formPerm (x :: ([] ++ [y]))) y = x", "state_after": "no goals"}, {"tactic": "simp [IH]", "annotated_tactic": ["simp [IH]", []], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d z : \u03b1\nxs : List \u03b1\nIH : \u2200 (x y : \u03b1), \u2191(formPerm (x :: (xs ++ [y]))) y = x\nx y : \u03b1\n\u22a2 \u2191(formPerm (x :: (z :: xs ++ [y]))) y = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "full_name": "div_eq_of_eq_mul", "start": [105, 1], "end": [106, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.gcd_eq_right", "start": [366, 1], "end": [366, 99], "traced_tactics": [{"tactic": "rw [gcd_comm, gcd_eq_left H]", "annotated_tactic": ["rw [<a>gcd_comm</a>, <a>gcd_eq_left</a> H]", [{"full_name": "Int.gcd_comm", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/GCD.lean", "def_pos": [264, 9], "def_end_pos": [264, 17]}, {"full_name": "Int.gcd_eq_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/GCD.lean", "def_pos": [362, 9], "def_end_pos": [362, 20]}]], "state_before": "i j : \u2124\nH : j \u2223 i\n\u22a2 gcd i j = natAbs j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.support_add", "start": [1310, 1], "end": [1312, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Int/Basic.lean", "full_name": "Int.eq_zero_of_natAbs_eq_zero", "start": [91, 1], "end": [91, 88], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.sameCycle_inv_apply_right", "start": [164, 1], "end": [165, 47], "traced_tactics": [{"tactic": "rw [\u2190 sameCycle_apply_right, apply_inv_self]", "annotated_tactic": ["rw [\u2190 <a>sameCycle_apply_right</a>, <a>apply_inv_self</a>]", [{"full_name": "Equiv.Perm.sameCycle_apply_right", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "def_pos": [154, 9], "def_end_pos": [154, 30]}, {"full_name": "Equiv.Perm.apply_inv_self", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Basic.lean", "def_pos": [81, 9], "def_end_pos": [81, 23]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf g : Perm \u03b1\np : \u03b1 \u2192 Prop\nx y z : \u03b1\n\u22a2 SameCycle f x (\u2191f\u207b\u00b9 y) \u2194 SameCycle f x y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Sign.lean", "full_name": "Equiv.Perm.closure_isSwap", "start": [268, 1], "end": [273, 79], "traced_tactics": [{"tactic": "cases nonempty_fintype \u03b1", "annotated_tactic": ["cases <a>nonempty_fintype</a> \u03b1", [{"full_name": "nonempty_fintype", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 Subgroup.closure {\u03c3 | IsSwap \u03c3} = \u22a4", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\n\u22a2 Subgroup.closure {\u03c3 | IsSwap \u03c3} = \u22a4"}, {"tactic": "refine' eq_top_iff.mpr fun x _ => _", "annotated_tactic": ["refine' eq_top_iff.mpr fun x _ => _", []], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\n\u22a2 Subgroup.closure {\u03c3 | IsSwap \u03c3} = \u22a4", "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\nx : Perm \u03b1\nx\u271d : x \u2208 \u22a4\n\u22a2 x \u2208 Subgroup.closure {\u03c3 | IsSwap \u03c3}"}, {"tactic": "obtain \u27e8h1, h2\u27e9 := Subtype.mem (truncSwapFactors x).out", "annotated_tactic": ["obtain \u27e8h1, h2\u27e9 := <a>Subtype.mem</a> (<a>truncSwapFactors</a> x).<a>out</a>", [{"full_name": "Subtype.mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [223, 9], "def_end_pos": [223, 20]}, {"full_name": "Equiv.Perm.truncSwapFactors", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [245, 5], "def_end_pos": [245, 21]}, {"full_name": "Trunc.out", "def_path": "lake-packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [578, 19], "def_end_pos": [578, 22]}]], "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\nx : Perm \u03b1\nx\u271d : x \u2208 \u22a4\n\u22a2 x \u2208 Subgroup.closure {\u03c3 | IsSwap \u03c3}", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\nx : Perm \u03b1\nx\u271d : x \u2208 \u22a4\nh1 : List.prod \u2191(Trunc.out (truncSwapFactors x)) = x\nh2 : \u2200 g \u2208 \u2191(Trunc.out (truncSwapFactors x)), IsSwap g\n\u22a2 x \u2208 Subgroup.closure {\u03c3 | IsSwap \u03c3}"}, {"tactic": "rw [\u2190 h1]", "annotated_tactic": ["rw [\u2190 h1]", []], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\nx : Perm \u03b1\nx\u271d : x \u2208 \u22a4\nh1 : List.prod \u2191(Trunc.out (truncSwapFactors x)) = x\nh2 : \u2200 g \u2208 \u2191(Trunc.out (truncSwapFactors x)), IsSwap g\n\u22a2 x \u2208 Subgroup.closure {\u03c3 | IsSwap \u03c3}", "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\nx : Perm \u03b1\nx\u271d : x \u2208 \u22a4\nh1 : List.prod \u2191(Trunc.out (truncSwapFactors x)) = x\nh2 : \u2200 g \u2208 \u2191(Trunc.out (truncSwapFactors x)), IsSwap g\n\u22a2 List.prod \u2191(Trunc.out (truncSwapFactors x)) \u2208 Subgroup.closure {\u03c3 | IsSwap \u03c3}"}, {"tactic": "exact Subgroup.list_prod_mem _ fun y hy => Subgroup.subset_closure (h2 y hy)", "annotated_tactic": ["exact <a>Subgroup.list_prod_mem</a> _ fun y hy => <a>Subgroup.subset_closure</a> (h2 y hy)", [{"full_name": "Subgroup.list_prod_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Finite.lean", "def_pos": [50, 19], "def_end_pos": [50, 32]}, {"full_name": "Subgroup.subset_closure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 23]}]], "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Finite \u03b1\nval\u271d : Fintype \u03b1\nx : Perm \u03b1\nx\u271d : x \u2208 \u22a4\nh1 : List.prod \u2191(Trunc.out (truncSwapFactors x)) = x\nh2 : \u2200 g \u2208 \u2191(Trunc.out (truncSwapFactors x)), IsSwap g\n\u22a2 List.prod \u2191(Trunc.out (truncSwapFactors x)) \u2208 Subgroup.closure {\u03c3 | IsSwap \u03c3}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Card.lean", "full_name": "Finset.card_sdiff", "start": [440, 1], "end": [442, 65], "traced_tactics": [{"tactic": "suffices card (t \\ s) = card (t \\ s \u222a s) - s.card by rwa [sdiff_union_of_subset h] at this", "annotated_tactic": ["suffices <a>card</a> (t \\ s) = <a>card</a> (t \\ s \u222a s) - s.card by rwa [<a>sdiff_union_of_subset</a> h] at this", [{"full_name": "Finset.card", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [43, 5], "def_end_pos": [43, 9]}, {"full_name": "Finset.card", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [43, 5], "def_end_pos": [43, 9]}, {"full_name": "Finset.sdiff_union_of_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2126, 9], "def_end_pos": [2126, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\ninst\u271d : DecidableEq \u03b1\nh : s \u2286 t\n\u22a2 card (t \\ s) = card t - card s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\ninst\u271d : DecidableEq \u03b1\nh : s \u2286 t\n\u22a2 card (t \\ s) = card (t \\ s \u222a s) - card s"}, {"tactic": "rw [card_disjoint_union sdiff_disjoint, add_tsub_cancel_right]", "annotated_tactic": ["rw [<a>card_disjoint_union</a> <a>sdiff_disjoint</a>, <a>add_tsub_cancel_right</a>]", [{"full_name": "Finset.card_disjoint_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Card.lean", "def_pos": [436, 9], "def_end_pos": [436, 28]}, {"full_name": "Finset.sdiff_disjoint", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2411, 9], "def_end_pos": [2411, 23]}, {"full_name": "add_tsub_cancel_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [356, 9], "def_end_pos": [356, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\ninst\u271d : DecidableEq \u03b1\nh : s \u2286 t\n\u22a2 card (t \\ s) = card (t \\ s \u222a s) - card s", "state_after": "no goals"}, {"tactic": "rwa [sdiff_union_of_subset h] at this", "annotated_tactic": ["rwa [<a>sdiff_union_of_subset</a> h] at this", [{"full_name": "Finset.sdiff_union_of_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2126, 9], "def_end_pos": [2126, 30]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\ninst\u271d : DecidableEq \u03b1\nh : s \u2286 t\nthis : card (t \\ s) = card (t \\ s \u222a s) - card s\n\u22a2 card (t \\ s) = card t - card s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.takeList_eq_takeListTR", "start": [1563, 10], "end": [1569, 24], "traced_tactics": [{"tactic": "funext \u03b1 xs ns", "annotated_tactic": ["funext \u03b1 xs ns", []], "state_before": "\u22a2 @takeList = @takeListTR", "state_after": "case h.h.h\n\u03b1 : Type u_1\nxs : List \u03b1\nns : List Nat\n\u22a2 takeList xs ns = takeListTR xs ns"}, {"tactic": "simp [takeListTR]", "annotated_tactic": ["simp [<a>takeListTR</a>]", [{"full_name": "List.takeListTR", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1554, 15], "def_end_pos": [1554, 25]}]], "state_before": "case h.h.h\n\u03b1 : Type u_1\nxs : List \u03b1\nns : List Nat\n\u22a2 takeList xs ns = takeListTR xs ns", "state_after": "case h.h.h\n\u03b1 : Type u_1\nxs : List \u03b1\nns : List Nat\n\u22a2 takeList xs ns = takeListTR.go ns xs #[]"}, {"tactic": "simp [takeListTR, go]", "annotated_tactic": ["simp [<a>takeListTR</a>, go]", [{"full_name": "List.takeListTR", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1554, 15], "def_end_pos": [1554, 25]}]], "state_before": "case h.h.h\n\u03b1 : Type u_1\nxs : List \u03b1\nns : List Nat\n\u22a2 takeList xs ns = takeListTR.go ns xs #[]", "state_after": "no goals"}, {"tactic": "simp [takeListTR.go, takeList]", "annotated_tactic": ["simp [<a>takeListTR.go</a>, <a>takeList</a>]", [{"full_name": "List.takeListTR.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1557, 3], "def_end_pos": [1557, 5]}, {"full_name": "List.takeList", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1546, 5], "def_end_pos": [1546, 13]}]], "state_before": "\u03b1 : Type u_1\nxs\u271d : List \u03b1\nns : List Nat\nacc : Array (List \u03b1)\nxs : List \u03b1\n\u22a2 takeListTR.go [] xs acc =\n    match takeList xs [] with\n    | (l, r) => (Array.toList acc ++ l, r)", "state_after": "no goals"}, {"tactic": "simp [takeListTR.go, takeList, go _ ns]", "annotated_tactic": ["simp [<a>takeListTR.go</a>, <a>takeList</a>, go _ ns]", [{"full_name": "List.takeListTR.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1557, 3], "def_end_pos": [1557, 5]}, {"full_name": "List.takeList", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [1546, 5], "def_end_pos": [1546, 13]}]], "state_before": "\u03b1 : Type u_1\nxs\u271d : List \u03b1\nns\u271d : List Nat\nacc : Array (List \u03b1)\nn : Nat\nns : List Nat\nxs : List \u03b1\n\u22a2 takeListTR.go (n :: ns) xs acc =\n    match takeList xs (n :: ns) with\n    | (l, r) => (Array.toList acc ++ l, r)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.span_eq_span", "start": [84, 1], "end": [85, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.ofDual_le_ofDual_iff", "start": [840, 1], "end": [841, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.insert_ne_empty", "start": [1186, 1], "end": [1187, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Quotient.lean", "full_name": "Ideal.Quotient.lift_mk", "start": [265, 1], "end": [267, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.mk_subset_ge_of_subset_image_lift", "start": [2342, 1], "end": [2347, 6], "traced_tactics": [{"tactic": "rw [image_eq_range] at h", "annotated_tactic": ["rw [<a>image_eq_range</a>] at h", [{"full_name": "Set.image_eq_range", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [1080, 9], "def_end_pos": [1080, 23]}]], "state_before": "\u03b1\u271d \u03b2\u271d \u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 f '' s\n\u22a2 lift.{u, v} #\u2191t \u2264 lift.{v, u} #\u2191{x | x \u2208 s \u2227 f x \u2208 t}", "state_after": "\u03b1\u271d \u03b2\u271d \u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 range fun x => f \u2191x\n\u22a2 lift.{u, v} #\u2191t \u2264 lift.{v, u} #\u2191{x | x \u2208 s \u2227 f x \u2208 t}"}, {"tactic": "convert mk_preimage_of_subset_range_lift _ _ h using 1", "annotated_tactic": ["convert <a>mk_preimage_of_subset_range_lift</a> _ _ h using 1", [{"full_name": "Cardinal.mk_preimage_of_subset_range_lift", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2307, 9], "def_end_pos": [2307, 41]}]], "state_before": "\u03b1\u271d \u03b2\u271d \u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 range fun x => f \u2191x\n\u22a2 lift.{u, v} #\u2191t \u2264 lift.{v, u} #\u2191{x | x \u2208 s \u2227 f x \u2208 t}", "state_after": "case h.e'_4\n\u03b1\u271d \u03b2\u271d \u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 range fun x => f \u2191x\n\u22a2 lift.{v, u} #\u2191{x | x \u2208 s \u2227 f x \u2208 t} = lift.{v, u} #\u2191((fun x => f \u2191x) \u207b\u00b9' t)"}, {"tactic": "rw [mk_sep]", "annotated_tactic": ["rw [<a>mk_sep</a>]", [{"full_name": "Cardinal.mk_sep", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [2295, 9], "def_end_pos": [2295, 15]}]], "state_before": "case h.e'_4\n\u03b1\u271d \u03b2\u271d \u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 range fun x => f \u2191x\n\u22a2 lift.{v, u} #\u2191{x | x \u2208 s \u2227 f x \u2208 t} = lift.{v, u} #\u2191((fun x => f \u2191x) \u207b\u00b9' t)", "state_after": "case h.e'_4\n\u03b1\u271d \u03b2\u271d \u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 range fun x => f \u2191x\n\u22a2 lift.{v, u} #\u2191{x | f \u2191x \u2208 t} = lift.{v, u} #\u2191((fun x => f \u2191x) \u207b\u00b9' t)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.e'_4\n\u03b1\u271d \u03b2\u271d \u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 range fun x => f \u2191x\n\u22a2 lift.{v, u} #\u2191{x | f \u2191x \u2208 t} = lift.{v, u} #\u2191((fun x => f \u2191x) \u207b\u00b9' t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.derivative_C_mul_X", "start": [94, 1], "end": [95, 73], "traced_tactics": [{"tactic": "simp [C_mul_X_eq_monomial, derivative_monomial, Nat.cast_one, mul_one]", "annotated_tactic": ["simp [<a>C_mul_X_eq_monomial</a>, <a>derivative_monomial</a>, <a>Nat.cast_one</a>, <a>mul_one</a>]", [{"full_name": "Polynomial.C_mul_X_eq_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [785, 9], "def_end_pos": [785, 28]}, {"full_name": "Polynomial.derivative_monomial", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [88, 9], "def_end_pos": [88, 28]}, {"full_name": "Nat.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [147, 9], "def_end_pos": [147, 17]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : Semiring R\na : R\n\u22a2 \u2191derivative (\u2191C a * X) = \u2191C a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Subsingleton.lean", "full_name": "Filter.Subsingleton.exists_eq_pure", "start": [51, 1], "end": [55, 20], "traced_tactics": [{"tactic": "rcases hl with \u27e8s, hsl, hs\u27e9", "annotated_tactic": ["rcases hl with \u27e8s, hsl, hs\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : NeBot l\nhl : Filter.Subsingleton l\n\u22a2 \u2203 a, l = pure a", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : NeBot l\ns : Set \u03b1\nhsl : s \u2208 l\nhs : Set.Subsingleton s\n\u22a2 \u2203 a, l = pure a"}, {"tactic": "rcases exists_eq_singleton_iff_nonempty_subsingleton.2 \u27e8nonempty_of_mem hsl, hs\u27e9 with \u27e8a, rfl\u27e9", "annotated_tactic": ["rcases <a>exists_eq_singleton_iff_nonempty_subsingleton</a>.2 \u27e8<a>nonempty_of_mem</a> hsl, hs\u27e9 with \u27e8a, rfl\u27e9", [{"full_name": "Set.exists_eq_singleton_iff_nonempty_subsingleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [2423, 9], "def_end_pos": [2423, 54]}, {"full_name": "Filter.nonempty_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [697, 9], "def_end_pos": [697, 24]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : NeBot l\ns : Set \u03b1\nhsl : s \u2208 l\nhs : Set.Subsingleton s\n\u22a2 \u2203 a, l = pure a", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : NeBot l\na : \u03b1\nhsl : {a} \u2208 l\nhs : Set.Subsingleton {a}\n\u22a2 \u2203 a, l = pure a"}, {"tactic": "refine \u27e8a, (NeBot.le_pure_iff \u2039_\u203a).1 ?_\u27e9", "annotated_tactic": ["refine \u27e8a, (<a>NeBot.le_pure_iff</a> \u2039_\u203a).1 ?_\u27e9", [{"full_name": "Filter.NeBot.le_pure_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Ultrafilter.lean", "def_pos": [413, 19], "def_end_pos": [413, 36]}]], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : NeBot l\na : \u03b1\nhsl : {a} \u2208 l\nhs : Set.Subsingleton {a}\n\u22a2 \u2203 a, l = pure a", "state_after": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : NeBot l\na : \u03b1\nhsl : {a} \u2208 l\nhs : Set.Subsingleton {a}\n\u22a2 l \u2264 pure a"}, {"tactic": "rwa [le_pure_iff]", "annotated_tactic": ["rwa [<a>le_pure_iff</a>]", [{"full_name": "Filter.le_pure_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [2694, 9], "def_end_pos": [2694, 20]}]], "state_before": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\ninst\u271d : NeBot l\na : \u03b1\nhsl : {a} \u2208 l\nhs : Set.Subsingleton {a}\n\u22a2 l \u2264 pure a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.map_inf_principal_preimage", "start": [3200, 1], "end": [3202, 93], "traced_tactics": [{"tactic": "simp only [mem_map', mem_inf_principal, mem_setOf_eq, mem_preimage]", "annotated_tactic": ["simp only [<a>mem_map'</a>, <a>mem_inf_principal</a>, <a>mem_setOf_eq</a>, <a>mem_preimage</a>]", [{"full_name": "Filter.mem_map'", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1865, 9], "def_end_pos": [1865, 17]}, {"full_name": "Filter.mem_inf_principal", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1013, 7], "def_end_pos": [1013, 24]}, {"full_name": "Set.mem_setOf_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [257, 29], "def_end_pos": [257, 41]}, {"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nl : Filter \u03b1\nt : Set \u03b2\n\u22a2 t \u2208 map f (l \u2293 \ud835\udcdf (f \u207b\u00b9' s)) \u2194 t \u2208 map f l \u2293 \ud835\udcdf s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Pi.lean", "full_name": "Submodule.iSup_map_single", "start": [309, 1], "end": [317, 62], "traced_tactics": [{"tactic": "cases nonempty_fintype \u03b9", "annotated_tactic": ["cases <a>nonempty_fintype</a> \u03b9", [{"full_name": "nonempty_fintype", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Card.lean", "def_pos": [442, 9], "def_end_pos": [442, 25]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\n\u22a2 \u2a06 i, map (single i) (p i) = pi Set.univ p", "state_after": "case intro\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\n\u22a2 \u2a06 i, map (single i) (p i) = pi Set.univ p"}, {"tactic": "refine' (iSup_le fun i => _).antisymm _", "annotated_tactic": ["refine' (<a>iSup_le</a> fun i => _).<a>antisymm</a> _", [{"full_name": "iSup_le", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [883, 9], "def_end_pos": [883, 16]}, {"full_name": "LE.le.antisymm", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [128, 7], "def_end_pos": [128, 21]}]], "state_before": "case intro\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\n\u22a2 \u2a06 i, map (single i) (p i) = pi Set.univ p", "state_after": "case intro.refine'_1\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\ni : \u03b9\n\u22a2 map (single i) (p i) \u2264 pi Set.univ p\n\ncase intro.refine'_2\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\n\u22a2 pi Set.univ p \u2264 \u2a06 i, map (single i) (p i)"}, {"tactic": "rintro _ \u27e8x, hx : x \u2208 p i, rfl\u27e9 j -", "annotated_tactic": ["rintro _ \u27e8x, hx : x \u2208 p i, rfl\u27e9 j -", []], "state_before": "case intro.refine'_1\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\ni : \u03b9\n\u22a2 map (single i) (p i) \u2264 pi Set.univ p", "state_after": "case intro.refine'_1.intro.intro\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx\u271d : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\nj : \u03b9\n\u22a2 \u2191(single i) x j \u2208 (fun i => \u2191(p i)) j"}, {"tactic": "rcases em (j = i) with (rfl | hj) <;> simp [*]", "annotated_tactic": ["rcases <a>em</a> (j = i) with (rfl | hj) <;> simp [*]", [{"full_name": "em", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [193, 7], "def_end_pos": [193, 9]}]], "state_before": "case intro.refine'_1.intro.intro\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx\u271d : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\ni : \u03b9\nx : \u03c6 i\nhx : x \u2208 p i\nj : \u03b9\n\u22a2 \u2191(single i) x j \u2208 (fun i => \u2191(p i)) j", "state_after": "no goals"}, {"tactic": "intro x hx", "annotated_tactic": ["intro x hx", []], "state_before": "case intro.refine'_2\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\n\u22a2 pi Set.univ p \u2264 \u2a06 i, map (single i) (p i)", "state_after": "case intro.refine'_2\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx\u271d : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\nx : (i : \u03b9) \u2192 \u03c6 i\nhx : x \u2208 pi Set.univ p\n\u22a2 x \u2208 \u2a06 i, map (single i) (p i)"}, {"tactic": "rw [\u2190 Finset.univ_sum_single x]", "annotated_tactic": ["rw [\u2190 <a>Finset.univ_sum_single</a> x]", [{"full_name": "Finset.univ_sum_single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Pi.lean", "def_pos": [77, 3], "def_end_pos": [77, 14]}]], "state_before": "case intro.refine'_2\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx\u271d : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\nx : (i : \u03b9) \u2192 \u03c6 i\nhx : x \u2208 pi Set.univ p\n\u22a2 x \u2208 \u2a06 i, map (single i) (p i)", "state_after": "case intro.refine'_2\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx\u271d : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\nx : (i : \u03b9) \u2192 \u03c6 i\nhx : x \u2208 pi Set.univ p\n\u22a2 \u2211 i : \u03b9, Pi.single i (x i) \u2208 \u2a06 i, map (single i) (p i)"}, {"tactic": "exact sum_mem_iSup fun i => mem_map_of_mem (hx i trivial)", "annotated_tactic": ["exact <a>sum_mem_iSup</a> fun i => <a>mem_map_of_mem</a> (hx i <a>trivial</a>)", [{"full_name": "Submodule.sum_mem_iSup", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Lattice.lean", "def_pos": [323, 9], "def_end_pos": [323, 21]}, {"full_name": "Submodule.mem_map_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [95, 9], "def_end_pos": [95, 23]}, {"full_name": "trivial", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [514, 31], "def_end_pos": [514, 38]}]], "state_before": "case intro.refine'_2\nR : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\n\u03b9' : Type x'\ninst\u271d\u2074 : Semiring R\n\u03c6 : \u03b9 \u2192 Type u_1\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03c6 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03c6 i)\nI : Set \u03b9\np q : (i : \u03b9) \u2192 Submodule R (\u03c6 i)\nx\u271d : (i : \u03b9) \u2192 \u03c6 i\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Finite \u03b9\nval\u271d : Fintype \u03b9\nx : (i : \u03b9) \u2192 \u03c6 i\nhx : x \u2208 pi Set.univ p\n\u22a2 \u2211 i : \u03b9, Pi.single i (x i) \u2208 \u2a06 i, map (single i) (p i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "ssubset_iff_subset_not_subset", "start": [741, 1], "end": [742, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Finiteness.lean", "full_name": "Submodule.exists_mem_and_smul_eq_self_of_fg_of_le_smul", "start": [137, 1], "end": [141, 81], "traced_tactics": [{"tactic": "obtain \u27e8r, hr, hr'\u27e9 := exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul I N hn hin", "annotated_tactic": ["obtain \u27e8r, hr, hr'\u27e9 := <a>exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul</a> I N hn hin", [{"full_name": "Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Finiteness.lean", "def_pos": [82, 9], "def_end_pos": [82, 61]}]], "state_before": "R\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u2075 : Semiring R\u271d\ninst\u271d\u2074 : AddCommMonoid M\u271d\ninst\u271d\u00b3 : Module R\u271d M\u271d\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\nM : Type u_4\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nhn : FG N\nhin : N \u2264 I \u2022 N\n\u22a2 \u2203 r \u2208 I, \u2200 n \u2208 N, r \u2022 n = n", "state_after": "case intro.intro\nR\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u2075 : Semiring R\u271d\ninst\u271d\u2074 : AddCommMonoid M\u271d\ninst\u271d\u00b3 : Module R\u271d M\u271d\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\nM : Type u_4\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nhn : FG N\nhin : N \u2264 I \u2022 N\nr : R\nhr : r - 1 \u2208 I\nhr' : \u2200 n \u2208 N, r \u2022 n = 0\n\u22a2 \u2203 r \u2208 I, \u2200 n \u2208 N, r \u2022 n = n"}, {"tactic": "exact \u27e8-(r - 1), I.neg_mem hr, fun n hn => by simpa [sub_smul] using hr' n hn\u27e9", "annotated_tactic": ["exact \u27e8-(r - 1), I.neg_mem hr, fun n hn => by simpa [<a>sub_smul</a>] using hr' n hn\u27e9", [{"full_name": "sub_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [299, 9], "def_end_pos": [299, 17]}]], "state_before": "case intro.intro\nR\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u2075 : Semiring R\u271d\ninst\u271d\u2074 : AddCommMonoid M\u271d\ninst\u271d\u00b3 : Module R\u271d M\u271d\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\nM : Type u_4\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nhn : FG N\nhin : N \u2264 I \u2022 N\nr : R\nhr : r - 1 \u2208 I\nhr' : \u2200 n \u2208 N, r \u2022 n = 0\n\u22a2 \u2203 r \u2208 I, \u2200 n \u2208 N, r \u2022 n = n", "state_after": "no goals"}, {"tactic": "simpa [sub_smul] using hr' n hn", "annotated_tactic": ["simpa [<a>sub_smul</a>] using hr' n hn", [{"full_name": "sub_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [299, 9], "def_end_pos": [299, 17]}]], "state_before": "R\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u2075 : Semiring R\u271d\ninst\u271d\u2074 : AddCommMonoid M\u271d\ninst\u271d\u00b3 : Module R\u271d M\u271d\nR : Type u_3\ninst\u271d\u00b2 : CommRing R\nM : Type u_4\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nI : Ideal R\nN : Submodule R M\nhn\u271d : FG N\nhin : N \u2264 I \u2022 N\nr : R\nhr : r - 1 \u2208 I\nhr' : \u2200 n \u2208 N, r \u2022 n = 0\nn : M\nhn : n \u2208 N\n\u22a2 -(r - 1) \u2022 n = n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.Ioc_pred_right", "start": [760, 1], "end": [761, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.domLCongr_symm", "start": [624, 1], "end": [625, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/FunLike/Basic.lean", "full_name": "FunLike.congr_fun", "start": [185, 11], "end": [186, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Denumerable.lean", "full_name": "Denumerable.ofNat_of_decode", "start": [60, 1], "end": [61, 56], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.mul_mul_left", "start": [1242, 1], "end": [1244, 17], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.characteristic_iff_le_comap", "start": [2039, 1], "end": [2042, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/IndicatorFunction.lean", "full_name": "Set.mulIndicator_eq_one_or_self", "start": [80, 1], "end": [84, 47], "traced_tactics": [{"tactic": "by_cases h : a \u2208 s", "annotated_tactic": ["by_cases h : a \u2208 s", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns\u271d t : Set \u03b1\nf\u271d g : \u03b1 \u2192 M\na\u271d : \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns\u271d t : Set \u03b1\nf\u271d g : \u03b1 \u2192 M\na\u271d : \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\nh : a \u2208 s\n\u22a2 mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns\u271d t : Set \u03b1\nf\u271d g : \u03b1 \u2192 M\na\u271d : \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\nh : a \u2209 s\n\u22a2 mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a"}, {"tactic": "exact Or.inr (mulIndicator_of_mem h f)", "annotated_tactic": ["exact <a>Or.inr</a> (<a>mulIndicator_of_mem</a> h f)", [{"full_name": "Or.inr", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [519, 5], "def_end_pos": [519, 8]}, {"full_name": "Set.mulIndicator_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Algebra/IndicatorFunction.lean", "def_pos": [68, 9], "def_end_pos": [68, 28]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns\u271d t : Set \u03b1\nf\u271d g : \u03b1 \u2192 M\na\u271d : \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\nh : a \u2208 s\n\u22a2 mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a", "state_after": "no goals"}, {"tactic": "exact Or.inl (mulIndicator_of_not_mem h f)", "annotated_tactic": ["exact <a>Or.inl</a> (<a>mulIndicator_of_not_mem</a> h f)", [{"full_name": "Or.inl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 5], "def_end_pos": [517, 8]}, {"full_name": "Set.mulIndicator_of_not_mem", "def_path": "lake-packages/mathlib/Mathlib/Algebra/IndicatorFunction.lean", "def_pos": [74, 9], "def_end_pos": [74, 32]}]], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : One M\ninst\u271d : One N\ns\u271d t : Set \u03b1\nf\u271d g : \u03b1 \u2192 M\na\u271d : \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\nh : a \u2209 s\n\u22a2 mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.mem_Iic_of_Iio", "start": [674, 1], "end": [675, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Kleene.lean", "full_name": "add_idem", "start": [141, 1], "end": [141, 48], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : IdemSemiring \u03b1\na\u271d b c a : \u03b1\n\u22a2 a + a = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "bddBelow_singleton", "start": [636, 1], "end": [637, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Irreducible.dvd_comm", "start": [245, 1], "end": [247, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.utf8ByteSize_mk", "start": [58, 9], "end": [58, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Closure.lean", "full_name": "ClosureOperator.ext", "start": [94, 1], "end": [96, 10], "traced_tactics": [{"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_3\ninst\u271d\u00b9 inst\u271d : PartialOrder \u03b1\nc : ClosureOperator \u03b1\nc\u2081 : \u03b1 \u2192 \u03b1\nmonotone'\u271d\u00b9 : Monotone c\u2081\nle_closure'\u271d\u00b9 : \u2200 (x : \u03b1), x \u2264 OrderHom.toFun { toFun := c\u2081, monotone' := monotone'\u271d\u00b9 } x\nidempotent'\u271d\u00b9 :\n  \u2200 (x : \u03b1),\n    OrderHom.toFun { toFun := c\u2081, monotone' := monotone'\u271d\u00b9 }\n        (OrderHom.toFun { toFun := c\u2081, monotone' := monotone'\u271d\u00b9 } x) =\n      OrderHom.toFun { toFun := c\u2081, monotone' := monotone'\u271d\u00b9 } x\nc\u2082 : \u03b1 \u2192 \u03b1\nmonotone'\u271d : Monotone c\u2082\nle_closure'\u271d : \u2200 (x : \u03b1), x \u2264 OrderHom.toFun { toFun := c\u2082, monotone' := monotone'\u271d } x\nidempotent'\u271d :\n  \u2200 (x : \u03b1),\n    OrderHom.toFun { toFun := c\u2082, monotone' := monotone'\u271d }\n        (OrderHom.toFun { toFun := c\u2082, monotone' := monotone'\u271d } x) =\n      OrderHom.toFun { toFun := c\u2082, monotone' := monotone'\u271d } x\nh :\n  \u2191{ toOrderHom := { toFun := c\u2081, monotone' := monotone'\u271d\u00b9 }, le_closure' := le_closure'\u271d\u00b9,\n        idempotent' := idempotent'\u271d\u00b9 } =\n    \u2191{ toOrderHom := { toFun := c\u2082, monotone' := monotone'\u271d }, le_closure' := le_closure'\u271d,\n        idempotent' := idempotent'\u271d }\n\u22a2 { toOrderHom := { toFun := c\u2081, monotone' := monotone'\u271d\u00b9 }, le_closure' := le_closure'\u271d\u00b9,\n      idempotent' := idempotent'\u271d\u00b9 } =\n    { toOrderHom := { toFun := c\u2082, monotone' := monotone'\u271d }, le_closure' := le_closure'\u271d, idempotent' := idempotent'\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Archimedean.lean", "full_name": "existsUnique_sub_zsmul_mem_Ico", "start": [88, 1], "end": [91, 47], "traced_tactics": [{"tactic": "simpa only [mem_Ico, le_sub_iff_add_le, zero_add, add_comm c, sub_lt_iff_lt_add', add_assoc] using\n  existsUnique_zsmul_near_of_pos' ha (b - c)", "annotated_tactic": ["simpa only [<a>mem_Ico</a>, <a>le_sub_iff_add_le</a>, <a>zero_add</a>, <a>add_comm</a> c, <a>sub_lt_iff_lt_add'</a>, <a>add_assoc</a>] using\n    <a>existsUnique_zsmul_near_of_pos'</a> ha (b - c)", [{"full_name": "Set.mem_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [121, 9], "def_end_pos": [121, 16]}, {"full_name": "le_sub_iff_add_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [740, 3], "def_end_pos": [740, 14]}, {"full_name": "zero_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [463, 3], "def_end_pos": [463, 14]}, {"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}, {"full_name": "sub_lt_iff_lt_add'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [979, 3], "def_end_pos": [979, 14]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}, {"full_name": "existsUnique_zsmul_near_of_pos'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Archimedean.lean", "def_pos": [82, 9], "def_end_pos": [82, 40]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup \u03b1\ninst\u271d : Archimedean \u03b1\na : \u03b1\nha : 0 < a\nb c : \u03b1\n\u22a2 \u2203! m, b - m \u2022 a \u2208 Ico c (c + a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ULift.lean", "full_name": "ULift.up_lt", "start": [27, 9], "end": [27, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Invertible/Defs.lean", "full_name": "mul_mul_invOf_self_cancel'", "start": [141, 1], "end": [142, 19], "traced_tactics": [{"tactic": "simp [mul_assoc]", "annotated_tactic": ["simp [<a>mul_assoc</a>]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}]], "state_before": "\u03b1 : Type u\ninst\u271d : Monoid \u03b1\na b : \u03b1\nx\u271d : Invertible b\n\u22a2 a * b * \u215fb = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "WithBot.pred_coe_of_ne_bot", "start": [1286, 1], "end": [1287, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Basic.lean", "full_name": "Nat.decreasingInduction_trans", "start": [542, 1], "end": [548, 83], "traced_tactics": [{"tactic": "induction' nk with k nk ih", "annotated_tactic": ["induction' nk with k nk ih", []], "state_before": "m\u271d n\u271d k\u271d : \u2115\nP : \u2115 \u2192 Sort u_1\nh : (n : \u2115) \u2192 P (n + 1) \u2192 P n\nm n k : \u2115\nmn : m \u2264 n\nnk : n \u2264 k\nhP : P k\n\u22a2 decreasingInduction h (_ : m \u2264 k) hP = decreasingInduction h mn (decreasingInduction h nk hP)", "state_after": "case refl\nm\u271d n\u271d k\u271d : \u2115\nP : \u2115 \u2192 Sort u_1\nh : (n : \u2115) \u2192 P (n + 1) \u2192 P n\nm n k : \u2115\nmn : m \u2264 n\nhP : P n\n\u22a2 decreasingInduction h (_ : m \u2264 n) hP = decreasingInduction h mn (decreasingInduction h (_ : Nat.le n n) hP)\n\ncase step\nm\u271d n\u271d k\u271d\u00b9 : \u2115\nP : \u2115 \u2192 Sort u_1\nh : (n : \u2115) \u2192 P (n + 1) \u2192 P n\nm n k\u271d : \u2115\nmn : m \u2264 n\nk : \u2115\nnk : Nat.le n k\nih : \u2200 (hP : P k), decreasingInduction h (_ : m \u2264 k) hP = decreasingInduction h mn (decreasingInduction h nk hP)\nhP : P (succ k)\n\u22a2 decreasingInduction h (_ : m \u2264 succ k) hP =\n    decreasingInduction h mn (decreasingInduction h (_ : Nat.le n (succ k)) hP)"}, {"tactic": "rw [decreasingInduction_self]", "annotated_tactic": ["rw [<a>decreasingInduction_self</a>]", [{"full_name": "Nat.decreasingInduction_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [521, 9], "def_end_pos": [521, 33]}]], "state_before": "case refl\nm\u271d n\u271d k\u271d : \u2115\nP : \u2115 \u2192 Sort u_1\nh : (n : \u2115) \u2192 P (n + 1) \u2192 P n\nm n k : \u2115\nmn : m \u2264 n\nhP : P n\n\u22a2 decreasingInduction h (_ : m \u2264 n) hP = decreasingInduction h mn (decreasingInduction h (_ : Nat.le n n) hP)", "state_after": "no goals"}, {"tactic": "rw [decreasingInduction_succ h (le_trans mn nk), ih, decreasingInduction_succ]", "annotated_tactic": ["rw [<a>decreasingInduction_succ</a> h (<a>le_trans</a> mn nk), ih, <a>decreasingInduction_succ</a>]", [{"full_name": "Nat.decreasingInduction_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [528, 9], "def_end_pos": [528, 33]}, {"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}, {"full_name": "Nat.decreasingInduction_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [528, 9], "def_end_pos": [528, 33]}]], "state_before": "case step\nm\u271d n\u271d k\u271d\u00b9 : \u2115\nP : \u2115 \u2192 Sort u_1\nh : (n : \u2115) \u2192 P (n + 1) \u2192 P n\nm n k\u271d : \u2115\nmn : m \u2264 n\nk : \u2115\nnk : Nat.le n k\nih : \u2200 (hP : P k), decreasingInduction h (_ : m \u2264 k) hP = decreasingInduction h mn (decreasingInduction h nk hP)\nhP : P (succ k)\n\u22a2 decreasingInduction h (_ : m \u2264 succ k) hP =\n    decreasingInduction h mn (decreasingInduction h (_ : Nat.le n (succ k)) hP)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "le_sInf", "start": [269, 1], "end": [270, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "Int.ediv_le_of_le_mul", "start": [422, 11], "end": [423, 74], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.preimage_const", "start": [147, 1], "end": [150, 66], "traced_tactics": [{"tactic": "split_ifs with hb", "annotated_tactic": ["split_ifs with hb", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\n\u22a2 (fun x => b) \u207b\u00b9' s = if b \u2208 s then univ else \u2205", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\nhb : b \u2208 s\n\u22a2 (fun x => b) \u207b\u00b9' s = univ\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\nhb : b \u2209 s\n\u22a2 (fun x => b) \u207b\u00b9' s = \u2205"}, {"tactic": "exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb]", "annotated_tactic": ["exacts [<a>preimage_const_of_mem</a> hb, <a>preimage_const_of_not_mem</a> hb]", [{"full_name": "Set.preimage_const_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [138, 9], "def_end_pos": [138, 30]}, {"full_name": "Set.preimage_const_of_not_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [143, 9], "def_end_pos": [143, 34]}]], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\nhb : b \u2208 s\n\u22a2 (fun x => b) \u207b\u00b9' s = univ\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\nhb : b \u2209 s\n\u22a2 (fun x => b) \u207b\u00b9' s = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/GCD/Basic.lean", "full_name": "Nat.gcd_greatest", "start": [28, 1], "end": [30, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/LocallyFinite.lean", "full_name": "Finset.card_Ioo_eq_card_Icc_sub_two", "start": [679, 1], "end": [681, 6], "traced_tactics": [{"tactic": "rw [card_Ioo_eq_card_Ico_sub_one, card_Ico_eq_card_Icc_sub_one]", "annotated_tactic": ["rw [<a>card_Ioo_eq_card_Ico_sub_one</a>, <a>card_Ico_eq_card_Icc_sub_one</a>]", [{"full_name": "Finset.card_Ioo_eq_card_Ico_sub_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/LocallyFinite.lean", "def_pos": [667, 9], "def_end_pos": [667, 37]}, {"full_name": "Finset.card_Ico_eq_card_Icc_sub_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/LocallyFinite.lean", "def_pos": [655, 9], "def_end_pos": [655, 37]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na\u271d b\u271d c a b : \u03b1\n\u22a2 card (Ioo a b) = card (Icc a b) - 2", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na\u271d b\u271d c a b : \u03b1\n\u22a2 card (Icc a b) - 1 - 1 = card (Icc a b) - 2"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na\u271d b\u271d c a b : \u03b1\n\u22a2 card (Icc a b) - 1 - 1 = card (Icc a b) - 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Count.lean", "full_name": "List.countP_eq_zero", "start": [78, 1], "end": [79, 69], "traced_tactics": [{"tactic": "simp only [countP_eq_length_filter, length_eq_zero, filter_eq_nil]", "annotated_tactic": ["simp only [<a>countP_eq_length_filter</a>, <a>length_eq_zero</a>, <a>filter_eq_nil</a>]", [{"full_name": "List.countP_eq_length_filter", "def_path": "lake-packages/std/Std/Data/List/Count.lean", "def_pos": [60, 9], "def_end_pos": [60, 32]}, {"full_name": "List.length_eq_zero", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [52, 9], "def_end_pos": [52, 23]}, {"full_name": "List.filter_eq_nil", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1394, 9], "def_end_pos": [1394, 22]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nl : List \u03b1\n\u22a2 countP p l = 0 \u2194 \u2200 (a : \u03b1), a \u2208 l \u2192 \u00acp a = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Nodup.subperm", "start": [729, 11], "end": [734, 45], "traced_tactics": [{"tactic": "induction' d with a l\u2081' h d IH", "annotated_tactic": ["induction' d with a l\u2081' h d IH", []], "state_before": "\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\nd : Nodup l\u2081\nH : l\u2081 \u2286 l\u2082\n\u22a2 l\u2081 <+~ l\u2082", "state_after": "case nil\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\nH : [] \u2286 l\u2082\n\u22a2 [] <+~ l\u2082\n\ncase cons\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl\u2081' : List \u03b1\nh : \u2200 a' \u2208 l\u2081', a \u2260 a'\nd : Pairwise (fun x x_1 => x \u2260 x_1) l\u2081'\nIH : l\u2081' \u2286 l\u2082 \u2192 l\u2081' <+~ l\u2082\nH : a :: l\u2081' \u2286 l\u2082\n\u22a2 a :: l\u2081' <+~ l\u2082"}, {"tactic": "exact \u27e8nil, Perm.nil, nil_sublist _\u27e9", "annotated_tactic": ["exact \u27e8<a>nil</a>, <a>Perm.nil</a>, <a>nil_sublist</a> _\u27e9", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.Perm.nil", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [36, 5], "def_end_pos": [36, 8]}, {"full_name": "List.nil_sublist", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [386, 17], "def_end_pos": [386, 28]}]], "state_before": "case nil\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\nH : [] \u2286 l\u2082\n\u22a2 [] <+~ l\u2082", "state_after": "no goals"}, {"tactic": "cases' forall_mem_cons.1 H with H\u2081 H\u2082", "annotated_tactic": ["cases' <a>forall_mem_cons</a>.1 H with H\u2081 H\u2082", [{"full_name": "List.forall_mem_cons", "def_path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "def_pos": [130, 9], "def_end_pos": [130, 24]}]], "state_before": "case cons\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl\u2081' : List \u03b1\nh : \u2200 a' \u2208 l\u2081', a \u2260 a'\nd : Pairwise (fun x x_1 => x \u2260 x_1) l\u2081'\nIH : l\u2081' \u2286 l\u2082 \u2192 l\u2081' <+~ l\u2082\nH : a :: l\u2081' \u2286 l\u2082\n\u22a2 a :: l\u2081' <+~ l\u2082", "state_after": "case cons.intro\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl\u2081' : List \u03b1\nh : \u2200 a' \u2208 l\u2081', a \u2260 a'\nd : Pairwise (fun x x_1 => x \u2260 x_1) l\u2081'\nIH : l\u2081' \u2286 l\u2082 \u2192 l\u2081' <+~ l\u2082\nH : a :: l\u2081' \u2286 l\u2082\nH\u2081 : a \u2208 l\u2082\nH\u2082 : \u2200 x \u2208 l\u2081', x \u2208 l\u2082\n\u22a2 a :: l\u2081' <+~ l\u2082"}, {"tactic": "simp at h", "annotated_tactic": ["simp at h", []], "state_before": "case cons.intro\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl\u2081' : List \u03b1\nh : \u2200 a' \u2208 l\u2081', a \u2260 a'\nd : Pairwise (fun x x_1 => x \u2260 x_1) l\u2081'\nIH : l\u2081' \u2286 l\u2082 \u2192 l\u2081' <+~ l\u2082\nH : a :: l\u2081' \u2286 l\u2082\nH\u2081 : a \u2208 l\u2082\nH\u2082 : \u2200 x \u2208 l\u2081', x \u2208 l\u2082\n\u22a2 a :: l\u2081' <+~ l\u2082", "state_after": "case cons.intro\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl\u2081' : List \u03b1\nd : Pairwise (fun x x_1 => x \u2260 x_1) l\u2081'\nIH : l\u2081' \u2286 l\u2082 \u2192 l\u2081' <+~ l\u2082\nH : a :: l\u2081' \u2286 l\u2082\nH\u2081 : a \u2208 l\u2082\nH\u2082 : \u2200 x \u2208 l\u2081', x \u2208 l\u2082\nh : a \u2209 l\u2081'\n\u22a2 a :: l\u2081' <+~ l\u2082"}, {"tactic": "exact cons_subperm_of_mem d h H\u2081 (IH H\u2082)", "annotated_tactic": ["exact <a>cons_subperm_of_mem</a> d h H\u2081 (IH H\u2082)", [{"full_name": "List.cons_subperm_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Perm.lean", "def_pos": [679, 9], "def_end_pos": [679, 28]}]], "state_before": "case cons.intro\n\u03b1 : Type uu\n\u03b2 : Type vv\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl\u2081' : List \u03b1\nd : Pairwise (fun x x_1 => x \u2260 x_1) l\u2081'\nIH : l\u2081' \u2286 l\u2082 \u2192 l\u2081' <+~ l\u2082\nH : a :: l\u2081' \u2286 l\u2082\nH\u2081 : a \u2208 l\u2082\nH\u2082 : \u2200 x \u2208 l\u2081', x \u2208 l\u2082\nh : a \u2209 l\u2081'\n\u22a2 a :: l\u2081' <+~ l\u2082", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.coeSubtype", "start": [793, 1], "end": [794, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Adjoin/Basic.lean", "full_name": "Algebra.adjoin_empty", "start": [151, 1], "end": [154, 21], "traced_tactics": [{"tactic": "apply GaloisConnection.l_bot", "annotated_tactic": ["apply <a>GaloisConnection.l_bot</a>", [{"full_name": "GaloisConnection.l_bot", "def_path": "lake-packages/mathlib/Mathlib/Order/GaloisConnection.lean", "def_pos": [255, 9], "def_end_pos": [255, 14]}]], "state_before": "R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns t : Set A\n\u22a2 adjoin R \u22a5 = \u22a5", "state_after": "case gc\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns t : Set A\n\u22a2 GaloisConnection (adjoin R) ?u\n\ncase u\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns t : Set A\n\u22a2 Subalgebra R A \u2192 Set A"}, {"tactic": "exact Algebra.gc", "annotated_tactic": ["exact <a>Algebra.gc</a>", [{"full_name": "Algebra.gc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "def_pos": [772, 19], "def_end_pos": [772, 21]}]], "state_before": "case gc\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns t : Set A\n\u22a2 GaloisConnection (adjoin R) ?u\n\ncase u\nR : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : CommSemiring S\ninst\u271d\u2076 : Semiring A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra S A\ninst\u271d\u00b9 : Algebra R B\ninst\u271d : IsScalarTower R S A\ns t : Set A\n\u22a2 Subalgebra R A \u2192 Set A", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Projection.lean", "full_name": "Submodule.coe_isComplEquivProj_symm_apply", "start": [360, 1], "end": [361, 77], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.self_trans_symm", "start": [463, 1], "end": [465, 7], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nM : Type u_7\nM\u2081 : Type u_8\nM\u2082 : Type u_9\nM\u2083 : Type u_10\nN\u2081 : Type u_11\nN\u2082 : Type u_12\nN\u2083 : Type u_13\nN\u2084 : Type u_14\n\u03b9 : Type u_15\nM\u2084 : Type u_16\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : Semiring S\ninst\u271d\u00b9\u2075 : Semiring R\u2081\ninst\u271d\u00b9\u2074 : Semiring R\u2082\ninst\u271d\u00b9\u00b3 : Semiring R\u2083\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : AddCommMonoid M\u2083\ninst\u271d\u2078 : AddCommMonoid M\u2084\ninst\u271d\u2077 : AddCommMonoid N\u2081\ninst\u271d\u2076 : AddCommMonoid N\u2082\nmodule_M : Module R M\nmodule_S_M\u2082 : Module S M\u2082\n\u03c3 : R \u2192+* S\n\u03c3' : S \u2192+* R\nre\u2081 : RingHomInvPair \u03c3 \u03c3'\nre\u2082 : RingHomInvPair \u03c3' \u03c3\ne e' : M \u2243\u209b\u2097[\u03c3] M\u2082\nmodule_M\u2081 : Module R\u2081 M\u2081\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\nmodule_N\u2081 : Module R\u2081 N\u2081\nmodule_N\u2082 : Module R\u2081 N\u2082\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ne\u2081\u2082 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ne\u2082\u2083 : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2082\u2081 \u03c3\u2081\u2083 \u03c3\u2082\u2083\ninst\u271d : RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082\nf : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\n\u22a2 trans f (symm f) = refl R\u2081 M\u2081", "state_after": "case h\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nM : Type u_7\nM\u2081 : Type u_8\nM\u2082 : Type u_9\nM\u2083 : Type u_10\nN\u2081 : Type u_11\nN\u2082 : Type u_12\nN\u2083 : Type u_13\nN\u2084 : Type u_14\n\u03b9 : Type u_15\nM\u2084 : Type u_16\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : Semiring S\ninst\u271d\u00b9\u2075 : Semiring R\u2081\ninst\u271d\u00b9\u2074 : Semiring R\u2082\ninst\u271d\u00b9\u00b3 : Semiring R\u2083\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : AddCommMonoid M\u2083\ninst\u271d\u2078 : AddCommMonoid M\u2084\ninst\u271d\u2077 : AddCommMonoid N\u2081\ninst\u271d\u2076 : AddCommMonoid N\u2082\nmodule_M : Module R M\nmodule_S_M\u2082 : Module S M\u2082\n\u03c3 : R \u2192+* S\n\u03c3' : S \u2192+* R\nre\u2081 : RingHomInvPair \u03c3 \u03c3'\nre\u2082 : RingHomInvPair \u03c3' \u03c3\ne e' : M \u2243\u209b\u2097[\u03c3] M\u2082\nmodule_M\u2081 : Module R\u2081 M\u2081\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\nmodule_N\u2081 : Module R\u2081 N\u2081\nmodule_N\u2082 : Module R\u2081 N\u2082\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ne\u2081\u2082 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ne\u2082\u2083 : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2082\u2081 \u03c3\u2081\u2083 \u03c3\u2082\u2083\ninst\u271d : RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082\nf : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\nx : M\u2081\n\u22a2 \u2191(trans f (symm f)) x = \u2191(refl R\u2081 M\u2081) x"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h\nR : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nk : Type u_5\nS : Type u_6\nM : Type u_7\nM\u2081 : Type u_8\nM\u2082 : Type u_9\nM\u2083 : Type u_10\nN\u2081 : Type u_11\nN\u2082 : Type u_12\nN\u2083 : Type u_13\nN\u2084 : Type u_14\n\u03b9 : Type u_15\nM\u2084 : Type u_16\ninst\u271d\u00b9\u2077 : Semiring R\ninst\u271d\u00b9\u2076 : Semiring S\ninst\u271d\u00b9\u2075 : Semiring R\u2081\ninst\u271d\u00b9\u2074 : Semiring R\u2082\ninst\u271d\u00b9\u00b3 : Semiring R\u2083\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\u2081\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : AddCommMonoid M\u2083\ninst\u271d\u2078 : AddCommMonoid M\u2084\ninst\u271d\u2077 : AddCommMonoid N\u2081\ninst\u271d\u2076 : AddCommMonoid N\u2082\nmodule_M : Module R M\nmodule_S_M\u2082 : Module S M\u2082\n\u03c3 : R \u2192+* S\n\u03c3' : S \u2192+* R\nre\u2081 : RingHomInvPair \u03c3 \u03c3'\nre\u2082 : RingHomInvPair \u03c3' \u03c3\ne e' : M \u2243\u209b\u2097[\u03c3] M\u2082\nmodule_M\u2081 : Module R\u2081 M\u2081\nmodule_M\u2082 : Module R\u2082 M\u2082\nmodule_M\u2083 : Module R\u2083 M\u2083\nmodule_N\u2081 : Module R\u2081 N\u2081\nmodule_N\u2082 : Module R\u2081 N\u2082\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\n\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082\n\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081\ninst\u271d\u2075 : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\ninst\u271d\u2074 : RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082\ninst\u271d\u00b3 : RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nre\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083\ne\u2081\u2082 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ne\u2082\u2083 : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083\ninst\u271d\u00b9 : RingHomCompTriple \u03c3\u2082\u2081 \u03c3\u2081\u2083 \u03c3\u2082\u2083\ninst\u271d : RingHomCompTriple \u03c3\u2083\u2081 \u03c3\u2081\u2082 \u03c3\u2083\u2082\nf : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\nx : M\u2081\n\u22a2 \u2191(trans f (symm f)) x = \u2191(refl R\u2081 M\u2081) x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis/Bilinear.lean", "full_name": "LinearMap.sum_repr_mul_repr_mul", "start": [62, 1], "end": [67, 24], "traced_tactics": [{"tactic": "conv_rhs => rw [\u2190 b\u2081'.total_repr x, \u2190 b\u2082'.total_repr y]", "annotated_tactic": ["conv_rhs => rw [\u2190 b\u2081'.total_repr x, \u2190 b\u2082'.total_repr y]", []], "state_before": "\u03b9\u2081 : Type u_1\n\u03b9\u2082 : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nS : Type u_5\nS\u2082 : Type u_6\nM : Type u_7\nN : Type u_8\nP : Type u_9\nM\u2097 : Type u_10\nN\u2097 : Type u_11\nP\u2097 : Type u_12\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : CommSemiring S\ninst\u271d\u00b9\u2075 : CommSemiring R\u2082\ninst\u271d\u00b9\u2074 : CommSemiring S\u2082\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : AddCommMonoid P\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2097\ninst\u271d\u2079 : AddCommMonoid N\u2097\ninst\u271d\u2078 : AddCommMonoid P\u2097\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module S N\ninst\u271d\u2075 : Module R\u2082 P\ninst\u271d\u2074 : Module S\u2082 P\ninst\u271d\u00b3 : Module R M\u2097\ninst\u271d\u00b2 : Module R N\u2097\ninst\u271d\u00b9 : Module R P\u2097\ninst\u271d : SMulCommClass S\u2082 R\u2082 P\n\u03c1\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2081\u2082 : S \u2192+* S\u2082\nb\u2081 : Basis \u03b9\u2081 R M\nb\u2082 : Basis \u03b9\u2082 S N\nb\u2081' : Basis \u03b9\u2081 R M\u2097\nb\u2082' : Basis \u03b9\u2082 R N\u2097\nB : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097\nx : M\u2097\ny : N\u2097\n\u22a2 (Finsupp.sum (\u2191b\u2081'.repr x) fun i xi => Finsupp.sum (\u2191b\u2082'.repr y) fun j yj => xi \u2022 yj \u2022 \u2191(\u2191B (\u2191b\u2081' i)) (\u2191b\u2082' j)) =\n    \u2191(\u2191B x) y", "state_after": "\u03b9\u2081 : Type u_1\n\u03b9\u2082 : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nS : Type u_5\nS\u2082 : Type u_6\nM : Type u_7\nN : Type u_8\nP : Type u_9\nM\u2097 : Type u_10\nN\u2097 : Type u_11\nP\u2097 : Type u_12\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : CommSemiring S\ninst\u271d\u00b9\u2075 : CommSemiring R\u2082\ninst\u271d\u00b9\u2074 : CommSemiring S\u2082\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : AddCommMonoid P\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2097\ninst\u271d\u2079 : AddCommMonoid N\u2097\ninst\u271d\u2078 : AddCommMonoid P\u2097\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module S N\ninst\u271d\u2075 : Module R\u2082 P\ninst\u271d\u2074 : Module S\u2082 P\ninst\u271d\u00b3 : Module R M\u2097\ninst\u271d\u00b2 : Module R N\u2097\ninst\u271d\u00b9 : Module R P\u2097\ninst\u271d : SMulCommClass S\u2082 R\u2082 P\n\u03c1\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2081\u2082 : S \u2192+* S\u2082\nb\u2081 : Basis \u03b9\u2081 R M\nb\u2082 : Basis \u03b9\u2082 S N\nb\u2081' : Basis \u03b9\u2081 R M\u2097\nb\u2082' : Basis \u03b9\u2082 R N\u2097\nB : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097\nx : M\u2097\ny : N\u2097\n\u22a2 (Finsupp.sum (\u2191b\u2081'.repr x) fun i xi => Finsupp.sum (\u2191b\u2082'.repr y) fun j yj => xi \u2022 yj \u2022 \u2191(\u2191B (\u2191b\u2081' i)) (\u2191b\u2082' j)) =\n    \u2191(\u2191B (\u2191(Finsupp.total \u03b9\u2081 M\u2097 R \u2191b\u2081') (\u2191b\u2081'.repr x))) (\u2191(Finsupp.total \u03b9\u2082 N\u2097 R \u2191b\u2082') (\u2191b\u2082'.repr y))"}, {"tactic": "simp_rw [Finsupp.total_apply, Finsupp.sum, map_sum\u2082, map_sum, LinearMap.map_smul\u2082,\n  LinearMap.map_smul]", "annotated_tactic": ["simp_rw [<a>Finsupp.total_apply</a>, <a>Finsupp.sum</a>, <a>map_sum\u2082</a>, <a>map_sum</a>, <a>LinearMap.map_smul\u2082</a>,\n    <a>LinearMap.map_smul</a>]", [{"full_name": "Finsupp.total_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Finsupp.lean", "def_pos": [549, 9], "def_end_pos": [549, 20]}, {"full_name": "Finsupp.sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finsupp.lean", "def_pos": [51, 3], "def_end_pos": [51, 14]}, {"full_name": "LinearMap.map_sum\u2082", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/BilinearMap.lean", "def_pos": [181, 9], "def_end_pos": [181, 17]}, {"full_name": "map_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [204, 3], "def_end_pos": [204, 14]}, {"full_name": "LinearMap.map_smul\u2082", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/BilinearMap.lean", "def_pos": [173, 9], "def_end_pos": [173, 18]}, {"full_name": "LinearMap.map_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/LinearMap.lean", "def_pos": [350, 19], "def_end_pos": [350, 27]}]], "state_before": "\u03b9\u2081 : Type u_1\n\u03b9\u2082 : Type u_2\nR : Type u_3\nR\u2082 : Type u_4\nS : Type u_5\nS\u2082 : Type u_6\nM : Type u_7\nN : Type u_8\nP : Type u_9\nM\u2097 : Type u_10\nN\u2097 : Type u_11\nP\u2097 : Type u_12\ninst\u271d\u00b9\u2077 : CommSemiring R\ninst\u271d\u00b9\u2076 : CommSemiring S\ninst\u271d\u00b9\u2075 : CommSemiring R\u2082\ninst\u271d\u00b9\u2074 : CommSemiring S\u2082\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : AddCommMonoid N\ninst\u271d\u00b9\u00b9 : AddCommMonoid P\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2097\ninst\u271d\u2079 : AddCommMonoid N\u2097\ninst\u271d\u2078 : AddCommMonoid P\u2097\ninst\u271d\u2077 : Module R M\ninst\u271d\u2076 : Module S N\ninst\u271d\u2075 : Module R\u2082 P\ninst\u271d\u2074 : Module S\u2082 P\ninst\u271d\u00b3 : Module R M\u2097\ninst\u271d\u00b2 : Module R N\u2097\ninst\u271d\u00b9 : Module R P\u2097\ninst\u271d : SMulCommClass S\u2082 R\u2082 P\n\u03c1\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2081\u2082 : S \u2192+* S\u2082\nb\u2081 : Basis \u03b9\u2081 R M\nb\u2082 : Basis \u03b9\u2082 S N\nb\u2081' : Basis \u03b9\u2081 R M\u2097\nb\u2082' : Basis \u03b9\u2082 R N\u2097\nB : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097\nx : M\u2097\ny : N\u2097\n\u22a2 (Finsupp.sum (\u2191b\u2081'.repr x) fun i xi => Finsupp.sum (\u2191b\u2082'.repr y) fun j yj => xi \u2022 yj \u2022 \u2191(\u2191B (\u2191b\u2081' i)) (\u2191b\u2082' j)) =\n    \u2191(\u2191B (\u2191(Finsupp.total \u03b9\u2081 M\u2097 R \u2191b\u2081') (\u2191b\u2081'.repr x))) (\u2191(Finsupp.total \u03b9\u2082 N\u2097 R \u2191b\u2082') (\u2191b\u2082'.repr y))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "MulAction.mapsTo_smul_orbit", "start": [80, 1], "end": [81, 60], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Regular/Pow.lean", "full_name": "IsRightRegular.pow_iff", "start": [54, 1], "end": [58, 30], "traced_tactics": [{"tactic": "refine' \u27e8_, IsRightRegular.pow n\u27e9", "annotated_tactic": ["refine' \u27e8_, <a>IsRightRegular.pow</a> n\u27e9", [{"full_name": "IsRightRegular.pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Regular/Pow.lean", "def_pos": [36, 9], "def_end_pos": [36, 27]}]], "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a ^ n) \u2194 IsRightRegular a", "state_after": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a ^ n) \u2192 IsRightRegular a"}, {"tactic": "rw [\u2190 Nat.succ_pred_eq_of_pos n0, pow_succ]", "annotated_tactic": ["rw [\u2190 <a>Nat.succ_pred_eq_of_pos</a> n0, <a>pow_succ</a>]", [{"full_name": "Nat.succ_pred_eq_of_pos", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [281, 9], "def_end_pos": [281, 28]}, {"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}]], "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a ^ n) \u2192 IsRightRegular a", "state_after": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a * a ^ Nat.pred n) \u2192 IsRightRegular a"}, {"tactic": "exact IsRightRegular.of_mul", "annotated_tactic": ["exact <a>IsRightRegular.of_mul</a>", [{"full_name": "IsRightRegular.of_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Regular/Basic.lean", "def_pos": [140, 9], "def_end_pos": [140, 30]}]], "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a * a ^ Nat.pred n) \u2192 IsRightRegular a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "pow_ne_one_of_lt_orderOf'", "start": [215, 1], "end": [216, 95], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.EventuallyLE.le_sup_of_le_right", "start": [1822, 1], "end": [1824, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "sq_le_sq", "start": [350, 1], "end": [352, 78], "traced_tactics": [{"tactic": "simpa only [sq_abs] using\n  (@strictMonoOn_pow R _ _ two_pos).le_iff_le (abs_nonneg x) (abs_nonneg y)", "annotated_tactic": ["simpa only [<a>sq_abs</a>] using\n    (@<a>strictMonoOn_pow</a> R _ _ <a>two_pos</a>).<a>le_iff_le</a> (<a>abs_nonneg</a> x) (<a>abs_nonneg</a> y)", [{"full_name": "sq_abs", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [335, 9], "def_end_pos": [335, 15]}, {"full_name": "strictMonoOn_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Order.lean", "def_pos": [133, 9], "def_end_pos": [133, 25]}, {"full_name": "two_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [113, 7], "def_end_pos": [113, 14]}, {"full_name": "StrictMonoOn.le_iff_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Monotone/Basic.lean", "def_pos": [808, 9], "def_end_pos": [808, 31]}, {"full_name": "abs_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [169, 9], "def_end_pos": [169, 19]}, {"full_name": "abs_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [169, 9], "def_end_pos": [169, 19]}]], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : LinearOrderedRing R\nx y : R\n\u22a2 x ^ 2 \u2264 y ^ 2 \u2194 |x| \u2264 |y|", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basic.lean", "full_name": "LinearMap.ker_smul'", "start": [1066, 1], "end": [1067, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.comap_map_eq_self", "start": [3143, 1], "end": [3144, 37], "traced_tactics": [{"tactic": "rwa [comap_map_eq, sup_eq_left]", "annotated_tactic": ["rwa [<a>comap_map_eq</a>, <a>sup_eq_left</a>]", [{"full_name": "Subgroup.comap_map_eq", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [3094, 9], "def_end_pos": [3094, 21]}, {"full_name": "sup_eq_left", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [178, 9], "def_end_pos": [178, 20]}]], "state_before": "G : Type u_1\nG' : Type u_2\nG'' : Type u_3\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Group G'\ninst\u271d\u00b2 : Group G''\nA : Type u_4\ninst\u271d\u00b9 : AddGroup A\nN : Type u_5\ninst\u271d : Group N\nf\u271d f : G \u2192* N\nH : Subgroup G\nh : ker f \u2264 H\n\u22a2 comap f (map f H) = H", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/BilinearMap.lean", "full_name": "LinearMap.map_zero\u2082", "start": [157, 1], "end": [158, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/VecNotation.lean", "full_name": "Matrix.cons_sub", "start": [502, 1], "end": [505, 54], "traced_tactics": [{"tactic": "ext i", "annotated_tactic": ["ext i", []], "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Sub \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nw : Fin (Nat.succ n) \u2192 \u03b1\n\u22a2 vecCons x v - w = vecCons (x - vecHead w) (v - vecTail w)", "state_after": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Sub \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nw : Fin (Nat.succ n) \u2192 \u03b1\ni : Fin (Nat.succ n)\n\u22a2 (vecCons x v - w) i = vecCons (x - vecHead w) (v - vecTail w) i"}, {"tactic": "refine' Fin.cases _ _ i <;> simp [vecHead, vecTail]", "annotated_tactic": ["refine' <a>Fin.cases</a> _ _ i <;> simp [<a>vecHead</a>, <a>vecTail</a>]", [{"full_name": "Fin.cases", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [614, 21], "def_end_pos": [614, 26]}, {"full_name": "Matrix.vecHead", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [93, 5], "def_end_pos": [93, 12]}, {"full_name": "Matrix.vecTail", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/VecNotation.lean", "def_pos": [98, 5], "def_end_pos": [98, 12]}]], "state_before": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Sub \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\nw : Fin (Nat.succ n) \u2192 \u03b1\ni : Fin (Nat.succ n)\n\u22a2 (vecCons x v - w) i = vecCons (x - vecHead w) (v - vecTail w) i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.single_eq_zero", "start": [1251, 1], "end": [1251, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.reduceOption_singleton", "start": [3376, 1], "end": [3376, 98], "traced_tactics": [{"tactic": "cases x <;> rfl", "annotated_tactic": ["cases x <;> rfl", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nx : Option \u03b1\n\u22a2 reduceOption [x] = Option.toList x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "full_name": "multiset_prod_mem", "start": [84, 1], "end": [88, 24], "traced_tactics": [{"tactic": "lift m to Multiset S using hm", "annotated_tactic": ["lift m to <a>Multiset</a> S using hm", [{"full_name": "Multiset", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [27, 5], "def_end_pos": [27, 13]}]], "state_before": "M\u271d : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2075 : Monoid M\u271d\ninst\u271d\u2074 : SetLike B M\u271d\ninst\u271d\u00b3 : SubmonoidClass B M\u271d\nS : B\nM : Type u_4\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nm : Multiset M\nhm : \u2200 a \u2208 m, a \u2208 S\n\u22a2 Multiset.prod m \u2208 S", "state_after": "case intro\nM\u271d : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2075 : Monoid M\u271d\ninst\u271d\u2074 : SetLike B M\u271d\ninst\u271d\u00b3 : SubmonoidClass B M\u271d\nS : B\nM : Type u_4\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nm : Multiset (\u21a5S)\n\u22a2 Multiset.prod (Multiset.map Subtype.val m) \u2208 S"}, {"tactic": "rw [\u2190 coe_multiset_prod]", "annotated_tactic": ["rw [\u2190 <a>coe_multiset_prod</a>]", [{"full_name": "SubmonoidClass.coe_multiset_prod", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [54, 9], "def_end_pos": [54, 26]}]], "state_before": "case intro\nM\u271d : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2075 : Monoid M\u271d\ninst\u271d\u2074 : SetLike B M\u271d\ninst\u271d\u00b3 : SubmonoidClass B M\u271d\nS : B\nM : Type u_4\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nm : Multiset (\u21a5S)\n\u22a2 Multiset.prod (Multiset.map Subtype.val m) \u2208 S", "state_after": "case intro\nM\u271d : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2075 : Monoid M\u271d\ninst\u271d\u2074 : SetLike B M\u271d\ninst\u271d\u00b3 : SubmonoidClass B M\u271d\nS : B\nM : Type u_4\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nm : Multiset (\u21a5S)\n\u22a2 \u2191(Multiset.prod m) \u2208 S"}, {"tactic": "exact m.prod.coe_prop", "annotated_tactic": ["exact m.prod.coe_prop", []], "state_before": "case intro\nM\u271d : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2075 : Monoid M\u271d\ninst\u271d\u2074 : SetLike B M\u271d\ninst\u271d\u00b3 : SubmonoidClass B M\u271d\nS : B\nM : Type u_4\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nm : Multiset (\u21a5S)\n\u22a2 \u2191(Multiset.prod m) \u2208 S", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_mem_smul", "start": [1289, 1], "end": [1290, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/GCD/Basic.lean", "full_name": "Nat.Coprime.eq_of_mul_eq_zero", "start": [273, 1], "end": [277, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "comap_prime", "start": [87, 1], "end": [95, 46], "traced_tactics": [{"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\nF : Type u_5\nG : Type u_6\ninst\u271d\u00b9 : MonoidWithZeroHomClass F \u03b1 \u03b2\ninst\u271d : MulHomClass G \u03b2 \u03b1\nf : F\ng : G\np : \u03b1\nhinv : \u2200 (a : \u03b1), \u2191g (\u2191f a) = a\nhp : Prime (\u2191f p)\nh : p = 0\n\u22a2 \u2191f p = 0", "state_after": "no goals"}, {"tactic": "convert map_dvd f h", "annotated_tactic": ["convert <a>map_dvd</a> f h", [{"full_name": "map_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [100, 9], "def_end_pos": [100, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\nF : Type u_5\nG : Type u_6\ninst\u271d\u00b9 : MonoidWithZeroHomClass F \u03b1 \u03b2\ninst\u271d : MulHomClass G \u03b2 \u03b1\nf : F\ng : G\np : \u03b1\nhinv : \u2200 (a : \u03b1), \u2191g (\u2191f a) = a\nhp : Prime (\u2191f p)\na b : \u03b1\nh : p \u2223 a * b\n\u22a2 \u2191f p \u2223 \u2191f a * \u2191f b", "state_after": "case h.e'_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\nF : Type u_5\nG : Type u_6\ninst\u271d\u00b9 : MonoidWithZeroHomClass F \u03b1 \u03b2\ninst\u271d : MulHomClass G \u03b2 \u03b1\nf : F\ng : G\np : \u03b1\nhinv : \u2200 (a : \u03b1), \u2191g (\u2191f a) = a\nhp : Prime (\u2191f p)\na b : \u03b1\nh : p \u2223 a * b\n\u22a2 \u2191f a * \u2191f b = \u2191f (a * b)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.e'_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\nF : Type u_5\nG : Type u_6\ninst\u271d\u00b9 : MonoidWithZeroHomClass F \u03b1 \u03b2\ninst\u271d : MulHomClass G \u03b2 \u03b1\nf : F\ng : G\np : \u03b1\nhinv : \u2200 (a : \u03b1), \u2191g (\u2191f a) = a\nhp : Prime (\u2191f p)\na b : \u03b1\nh : p \u2223 a * b\n\u22a2 \u2191f a * \u2191f b = \u2191f (a * b)", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\nF : Type u_5\nG : Type u_6\ninst\u271d\u00b9 : MonoidWithZeroHomClass F \u03b1 \u03b2\ninst\u271d : MulHomClass G \u03b2 \u03b1\nf : F\ng : G\np : \u03b1\nhinv : \u2200 (a : \u03b1), \u2191g (\u2191f a) = a\nhp : Prime (\u2191f p)\na b : \u03b1\nh : p \u2223 a * b\n\u22a2 \u2191f p \u2223 \u2191f b \u2192 p \u2223 b", "state_after": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\nF : Type u_5\nG : Type u_6\ninst\u271d\u00b9 : MonoidWithZeroHomClass F \u03b1 \u03b2\ninst\u271d : MulHomClass G \u03b2 \u03b1\nf : F\ng : G\np : \u03b1\nhinv : \u2200 (a : \u03b1), \u2191g (\u2191f a) = a\nhp : Prime (\u2191f p)\na b : \u03b1\nh\u271d : p \u2223 a * b\nh : \u2191f p \u2223 \u2191f b\n\u22a2 p \u2223 b"}, {"tactic": "convert \u2190 map_dvd g h <;> apply hinv", "annotated_tactic": ["convert \u2190 <a>map_dvd</a> g h <;> apply hinv", [{"full_name": "map_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [100, 9], "def_end_pos": [100, 16]}]], "state_before": "case refine'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoidWithZero \u03b2\nF : Type u_5\nG : Type u_6\ninst\u271d\u00b9 : MonoidWithZeroHomClass F \u03b1 \u03b2\ninst\u271d : MulHomClass G \u03b2 \u03b1\nf : F\ng : G\np : \u03b1\nhinv : \u2200 (a : \u03b1), \u2191g (\u2191f a) = a\nhp : Prime (\u2191f p)\na b : \u03b1\nh\u271d : p \u2223 a * b\nh : \u2191f p \u2223 \u2191f b\n\u22a2 p \u2223 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.image\u2082_eq_empty_iff", "start": [146, 1], "end": [147, 73], "traced_tactics": [{"tactic": "simp_rw [\u2190 not_nonempty_iff_eq_empty, image\u2082_nonempty_iff, not_and_or]", "annotated_tactic": ["simp_rw [\u2190 <a>not_nonempty_iff_eq_empty</a>, <a>image\u2082_nonempty_iff</a>, <a>not_and_or</a>]", [{"full_name": "Finset.not_nonempty_iff_eq_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [610, 9], "def_end_pos": [610, 34]}, {"full_name": "Finset.image\u2082_nonempty_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [118, 9], "def_end_pos": [118, 28]}, {"full_name": "not_and_or", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [470, 9], "def_end_pos": [470, 19]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\n\u22a2 image\u2082 f s t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.le_iff_count", "start": [2537, 1], "end": [2539, 92], "traced_tactics": [{"tactic": "rw [\u2190 (ext.2 fun a => by simp [max_eq_right (al a)] : s \u222a t = t)]", "annotated_tactic": ["rw [\u2190 (<a>ext</a>.2 fun a => by simp [<a>max_eq_right</a> (al a)] : s \u222a t = t)]", [{"full_name": "Multiset.ext", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [2522, 9], "def_end_pos": [2522, 12]}, {"full_name": "max_eq_right", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [137, 9], "def_end_pos": [137, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nal : \u2200 (a : \u03b1), count a s \u2264 count a t\n\u22a2 s \u2264 t", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nal : \u2200 (a : \u03b1), count a s \u2264 count a t\n\u22a2 s \u2264 s \u222a t"}, {"tactic": "apply le_union_left", "annotated_tactic": ["apply <a>le_union_left</a>", [{"full_name": "Multiset.le_union_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1713, 9], "def_end_pos": [1713, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nal : \u2200 (a : \u03b1), count a s \u2264 count a t\n\u22a2 s \u2264 s \u222a t", "state_after": "no goals"}, {"tactic": "simp [max_eq_right (al a)]", "annotated_tactic": ["simp [<a>max_eq_right</a> (al a)]", [{"full_name": "max_eq_right", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/LinearOrder.lean", "def_pos": [137, 9], "def_end_pos": [137, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nal : \u2200 (a : \u03b1), count a s \u2264 count a t\na : \u03b1\n\u22a2 count a (s \u222a t) = count a t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/Basic.lean", "full_name": "Fin.coe_neg_one", "start": [1225, 1], "end": [1229, 14], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "n m : \u2115\n\u22a2 \u2191(-1) = n", "state_after": "case zero\nm : \u2115\n\u22a2 \u2191(-1) = zero\n\ncase succ\nm n\u271d : \u2115\n\u22a2 \u2191(-1) = Nat.succ n\u271d"}, {"tactic": "rw [Fin.coe_neg, Fin.val_one, Nat.succ_sub_one, Nat.mod_eq_of_lt]", "annotated_tactic": ["rw [<a>Fin.coe_neg</a>, <a>Fin.val_one</a>, <a>Nat.succ_sub_one</a>, <a>Nat.mod_eq_of_lt</a>]", [{"full_name": "Fin.coe_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [1209, 19], "def_end_pos": [1209, 26]}, {"full_name": "Fin.val_one", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [161, 17], "def_end_pos": [161, 24]}, {"full_name": "Nat.succ_sub_one", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [443, 9], "def_end_pos": [443, 21]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [111, 9], "def_end_pos": [111, 21]}]], "state_before": "case succ\nm n\u271d : \u2115\n\u22a2 \u2191(-1) = Nat.succ n\u271d", "state_after": "case succ\nm n\u271d : \u2115\n\u22a2 n\u271d + 1 < Nat.succ n\u271d + 1"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case succ\nm n\u271d : \u2115\n\u22a2 n\u271d + 1 < Nat.succ n\u271d + 1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\nm : \u2115\n\u22a2 \u2191(-1) = zero", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Disjoint.lean", "full_name": "Set.iUnion_Ioc_left", "start": [121, 1], "end": [122, 70], "traced_tactics": [{"tactic": "simp only [\u2190 Ioi_inter_Iic, \u2190 iUnion_inter, iUnion_Ioi, univ_inter]", "annotated_tactic": ["simp only [\u2190 <a>Ioi_inter_Iic</a>, \u2190 <a>iUnion_inter</a>, <a>iUnion_Ioi</a>, <a>univ_inter</a>]", [{"full_name": "Set.Ioi_inter_Iic", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [626, 9], "def_end_pos": [626, 22]}, {"full_name": "Set.iUnion_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Lattice.lean", "def_pos": [639, 9], "def_end_pos": [639, 21]}, {"full_name": "Set.iUnion_Ioi", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Disjoint.lean", "def_pos": [106, 9], "def_end_pos": [106, 19]}, {"full_name": "Set.univ_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [1010, 9], "def_end_pos": [1010, 19]}]], "state_before": "\u03b9 : Sort u\n\u03b1 : Type v\n\u03b2 : Type w\ninst\u271d\u00b9 : Preorder \u03b1\na b\u271d c : \u03b1\ninst\u271d : NoMinOrder \u03b1\nb : \u03b1\n\u22a2 \u22c3 a, Ioc a b = Iic b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Monotone.iUnion_nat_add", "start": [2358, 1], "end": [2360, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.map_X", "start": [1243, 1], "end": [1244, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/CovariantClass.lean", "full_name": "Right.pow_le_one_of_le", "start": [140, 1], "end": [144, 59], "traced_tactics": [{"tactic": "rw [pow_succ]", "annotated_tactic": ["rw [<a>pow_succ</a>]", [{"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}]], "state_before": "\u03b2 : Type u_1\nG : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (swap fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nx : M\nhx : x \u2264 1\nn : \u2115\n\u22a2 x ^ (n + 1) \u2264 1", "state_after": "\u03b2 : Type u_1\nG : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (swap fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nx : M\nhx : x \u2264 1\nn : \u2115\n\u22a2 x * x ^ n \u2264 1"}, {"tactic": "exact Right.mul_le_one hx <| Right.pow_le_one_of_le hx", "annotated_tactic": ["exact <a>Right.mul_le_one</a> hx <| Right.pow_le_one_of_le hx", [{"full_name": "Right.mul_le_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [879, 9], "def_end_pos": [879, 25]}]], "state_before": "\u03b2 : Type u_1\nG : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Preorder M\ninst\u271d : CovariantClass M M (swap fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\nx : M\nhx : x \u2264 1\nn : \u2115\n\u22a2 x * x ^ n \u2264 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "full_name": "AddSubmonoid.toNatSubmodule_symm", "start": [419, 1], "end": [421, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "NoMinOrder.lowerBounds_univ", "start": [845, 1], "end": [846, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Control/Applicative.lean", "full_name": "Functor.Comp.pure_seq_eq_map", "start": [106, 1], "end": [107, 67], "traced_tactics": [{"tactic": "simp [Applicative.pure_seq_eq_map', functor_norm]", "annotated_tactic": ["simp [<a>Applicative.pure_seq_eq_map'</a>, functor_norm]", [{"full_name": "Applicative.pure_seq_eq_map'", "def_path": "lake-packages/mathlib/Mathlib/Control/Applicative.lean", "def_pos": [37, 9], "def_end_pos": [37, 37]}]], "state_before": "F : Type u \u2192 Type w\nG : Type v \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 \u03b2 \u03b3 : Type v\nf : \u03b1 \u2192 \u03b2\nx : Comp F G \u03b1\n\u22a2 run (Seq.seq (pure f) fun x_1 => x) = run (f <$> x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.empty_union", "start": [775, 1], "end": [776, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.sep_false", "start": [1458, 1], "end": [1459, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.floor_congr", "start": [1604, 1], "end": [1608, 99], "traced_tactics": [{"tactic": "have h\u2080 : 0 \u2264 a \u2194 0 \u2264 b := by simpa only [cast_zero] using h 0", "annotated_tactic": ["have h\u2080 : 0 \u2264 a \u2194 0 \u2264 b := by simpa only [<a>cast_zero</a>] using h 0", [{"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\n\u22a2 \u230aa\u230b\u208a = \u230ab\u230b\u208a", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\nh\u2080 : 0 \u2264 a \u2194 0 \u2264 b\n\u22a2 \u230aa\u230b\u208a = \u230ab\u230b\u208a"}, {"tactic": "obtain ha | ha := lt_or_le a 0", "annotated_tactic": ["obtain ha | ha := <a>lt_or_le</a> a 0", [{"full_name": "lt_or_le", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [336, 9], "def_end_pos": [336, 17]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\nh\u2080 : 0 \u2264 a \u2194 0 \u2264 b\n\u22a2 \u230aa\u230b\u208a = \u230ab\u230b\u208a", "state_after": "case inl\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\nh\u2080 : 0 \u2264 a \u2194 0 \u2264 b\nha : a < 0\n\u22a2 \u230aa\u230b\u208a = \u230ab\u230b\u208a\n\ncase inr\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\nh\u2080 : 0 \u2264 a \u2194 0 \u2264 b\nha : 0 \u2264 a\n\u22a2 \u230aa\u230b\u208a = \u230ab\u230b\u208a"}, {"tactic": "exact (le_floor <| (h _).1 <| floor_le ha).antisymm (le_floor <| (h _).2 <| floor_le <| h\u2080.1 ha)", "annotated_tactic": ["exact (<a>le_floor</a> <| (h _).1 <| <a>floor_le</a> ha).<a>antisymm</a> (<a>le_floor</a> <| (h _).2 <| <a>floor_le</a> <| h\u2080.1 ha)", [{"full_name": "Nat.le_floor", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [134, 9], "def_end_pos": [134, 17]}, {"full_name": "Nat.floor_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [153, 9], "def_end_pos": [153, 17]}, {"full_name": "LE.le.antisymm", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [128, 7], "def_end_pos": [128, 21]}, {"full_name": "Nat.le_floor", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [134, 9], "def_end_pos": [134, 17]}, {"full_name": "Nat.floor_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [153, 9], "def_end_pos": [153, 17]}]], "state_before": "case inr\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\nh\u2080 : 0 \u2264 a \u2194 0 \u2264 b\nha : 0 \u2264 a\n\u22a2 \u230aa\u230b\u208a = \u230ab\u230b\u208a", "state_after": "no goals"}, {"tactic": "simpa only [cast_zero] using h 0", "annotated_tactic": ["simpa only [<a>cast_zero</a>] using h 0", [{"full_name": "Nat.cast_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [120, 9], "def_end_pos": [120, 18]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\n\u22a2 0 \u2264 a \u2194 0 \u2264 b", "state_after": "no goals"}, {"tactic": "rw [floor_of_nonpos ha.le, floor_of_nonpos (le_of_not_le <| h\u2080.not.mp ha.not_le)]", "annotated_tactic": ["rw [<a>floor_of_nonpos</a> ha.le, <a>floor_of_nonpos</a> (<a>le_of_not_le</a> <| h\u2080.not.mp ha.not_le)]", [{"full_name": "Nat.floor_of_nonpos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [179, 9], "def_end_pos": [179, 24]}, {"full_name": "Nat.floor_of_nonpos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [179, 9], "def_end_pos": [179, 24]}, {"full_name": "le_of_not_le", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [303, 9], "def_end_pos": [303, 21]}]], "state_before": "case inl\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2074 : LinearOrderedSemiring \u03b1\ninst\u271d\u00b3 : LinearOrderedSemiring \u03b2\ninst\u271d\u00b2 : FloorSemiring \u03b1\ninst\u271d\u00b9 : FloorSemiring \u03b2\ninst\u271d : RingHomClass F \u03b1 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2200 (n : \u2115), \u2191n \u2264 a \u2194 \u2191n \u2264 b\nh\u2080 : 0 \u2264 a \u2194 0 \u2264 b\nha : a < 0\n\u22a2 \u230aa\u230b\u208a = \u230ab\u230b\u208a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "IsLeast.nonempty", "start": [347, 1], "end": [348, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Fold.lean", "full_name": "Finset.fold_op_distrib", "start": [79, 1], "end": [81, 33], "traced_tactics": [{"tactic": "simp only [fold, fold_distrib]", "annotated_tactic": ["simp only [<a>fold</a>, <a>fold_distrib</a>]", [{"full_name": "Finset.fold", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Fold.lean", "def_pos": [34, 5], "def_end_pos": [34, 9]}, {"full_name": "Multiset.fold_distrib", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Fold.lean", "def_pos": [95, 9], "def_end_pos": [95, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf\u271d : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\nf g : \u03b1 \u2192 \u03b2\nb\u2081 b\u2082 : \u03b2\n\u22a2 fold op (op b\u2081 b\u2082) (fun x => op (f x) (g x)) s = op (fold op b\u2081 f s) (fold op b\u2082 g s)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.sdiff_insert_insert_of_mem_of_not_mem", "start": [2375, 1], "end": [2377, 61], "traced_tactics": [{"tactic": "rw [sdiff_insert, insert_erase (mem_sdiff.mpr \u27e8hxs, hxt\u27e9)]", "annotated_tactic": ["rw [<a>sdiff_insert</a>, <a>insert_erase</a> (mem_sdiff.mpr \u27e8hxs, hxt\u27e9)]", [{"full_name": "Finset.sdiff_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2370, 9], "def_end_pos": [2370, 21]}, {"full_name": "Finset.insert_erase", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1974, 17], "def_end_pos": [1974, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t\u271d u v : Finset \u03b1\na b : \u03b1\ns t : Finset \u03b1\nx : \u03b1\nhxs : x \u2208 s\nhxt : x \u2209 t\n\u22a2 insert x (s \\ insert x t) = s \\ t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/AssocList.lean", "full_name": "Std.AssocList.forIn_eq", "start": [215, 9], "end": [219, 38], "traced_tactics": [{"tactic": "simp [forIn, List.forIn]", "annotated_tactic": ["simp [<a>forIn</a>, <a>List.forIn</a>]", [{"full_name": "ForIn.forIn", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [248, 3], "def_end_pos": [248, 8]}, {"full_name": "List.forIn", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Control.lean", "def_pos": [141, 25], "def_end_pos": [141, 30]}]], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nl : AssocList \u03b1 \u03b2\ninit : \u03b4\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\n\u22a2 forIn l init f = forIn (toList l) init f", "state_after": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nl : AssocList \u03b1 \u03b2\ninit : \u03b4\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\n\u22a2 AssocList.forIn l init f = List.forIn.loop f (toList l) init"}, {"tactic": "induction l generalizing init <;> simp [AssocList.forIn, List.forIn.loop]", "annotated_tactic": ["induction l generalizing init <;> simp [<a>AssocList.forIn</a>, <a>List.forIn.loop</a>]", [{"full_name": "Std.AssocList.forIn", "def_path": "lake-packages/std/Std/Data/AssocList.lean", "def_pos": [203, 29], "def_end_pos": [203, 34]}, {"full_name": "List.forIn.loop", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Control.lean", "def_pos": [142, 25], "def_end_pos": [142, 29]}]], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nl : AssocList \u03b1 \u03b2\ninit : \u03b4\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\n\u22a2 AssocList.forIn l init f = List.forIn.loop f (toList l) init", "state_after": "case cons\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\nkey\u271d : \u03b1\nvalue\u271d : \u03b2\ntail\u271d : AssocList \u03b1 \u03b2\ntail_ih\u271d : \u2200 (init : \u03b4), AssocList.forIn tail\u271d init f = List.forIn.loop f (toList tail\u271d) init\ninit : \u03b4\n\u22a2 (do\n      let __do_lift \u2190 f (key\u271d, value\u271d) init\n      match __do_lift with\n        | ForInStep.done d => pure d\n        | ForInStep.yield d => AssocList.forIn tail\u271d d f) =\n    do\n    let __do_lift \u2190 f (key\u271d, value\u271d) init\n    match __do_lift with\n      | ForInStep.done d => pure d\n      | ForInStep.yield b => List.forIn.loop f (toList tail\u271d) b"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "case cons\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\nkey\u271d : \u03b1\nvalue\u271d : \u03b2\ntail\u271d : AssocList \u03b1 \u03b2\ntail_ih\u271d : \u2200 (init : \u03b4), AssocList.forIn tail\u271d init f = List.forIn.loop f (toList tail\u271d) init\ninit : \u03b4\n\u22a2 (do\n      let __do_lift \u2190 f (key\u271d, value\u271d) init\n      match __do_lift with\n        | ForInStep.done d => pure d\n        | ForInStep.yield d => AssocList.forIn tail\u271d d f) =\n    do\n    let __do_lift \u2190 f (key\u271d, value\u271d) init\n    match __do_lift with\n      | ForInStep.done d => pure d\n      | ForInStep.yield b => List.forIn.loop f (toList tail\u271d) b", "state_after": "case cons.e_a\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\nkey\u271d : \u03b1\nvalue\u271d : \u03b2\ntail\u271d : AssocList \u03b1 \u03b2\ntail_ih\u271d : \u2200 (init : \u03b4), AssocList.forIn tail\u271d init f = List.forIn.loop f (toList tail\u271d) init\ninit : \u03b4\n\u22a2 (fun __do_lift =>\n      match __do_lift with\n      | ForInStep.done d => pure d\n      | ForInStep.yield d => AssocList.forIn tail\u271d d f) =\n    fun __do_lift =>\n    match __do_lift with\n    | ForInStep.done d => pure d\n    | ForInStep.yield b => List.forIn.loop f (toList tail\u271d) b"}, {"tactic": "funext a", "annotated_tactic": ["funext a", []], "state_before": "case cons.e_a\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\nkey\u271d : \u03b1\nvalue\u271d : \u03b2\ntail\u271d : AssocList \u03b1 \u03b2\ntail_ih\u271d : \u2200 (init : \u03b4), AssocList.forIn tail\u271d init f = List.forIn.loop f (toList tail\u271d) init\ninit : \u03b4\n\u22a2 (fun __do_lift =>\n      match __do_lift with\n      | ForInStep.done d => pure d\n      | ForInStep.yield d => AssocList.forIn tail\u271d d f) =\n    fun __do_lift =>\n    match __do_lift with\n    | ForInStep.done d => pure d\n    | ForInStep.yield b => List.forIn.loop f (toList tail\u271d) b", "state_after": "case cons.e_a.h\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\nkey\u271d : \u03b1\nvalue\u271d : \u03b2\ntail\u271d : AssocList \u03b1 \u03b2\ntail_ih\u271d : \u2200 (init : \u03b4), AssocList.forIn tail\u271d init f = List.forIn.loop f (toList tail\u271d) init\ninit : \u03b4\na : ForInStep \u03b4\n\u22a2 (match a with\n    | ForInStep.done d => pure d\n    | ForInStep.yield d => AssocList.forIn tail\u271d d f) =\n    match a with\n    | ForInStep.done d => pure d\n    | ForInStep.yield b => List.forIn.loop f (toList tail\u271d) b"}, {"tactic": "split <;> simp [*]", "annotated_tactic": ["split <;> simp [*]", []], "state_before": "case cons.e_a.h\nm : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b4 : Type u_1\ninst\u271d : Monad m\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b4 \u2192 m (ForInStep \u03b4)\nkey\u271d : \u03b1\nvalue\u271d : \u03b2\ntail\u271d : AssocList \u03b1 \u03b2\ntail_ih\u271d : \u2200 (init : \u03b4), AssocList.forIn tail\u271d init f = List.forIn.loop f (toList tail\u271d) init\ninit : \u03b4\na : ForInStep \u03b4\n\u22a2 (match a with\n    | ForInStep.done d => pure d\n    | ForInStep.yield d => AssocList.forIn tail\u271d d f) =\n    match a with\n    | ForInStep.done d => pure d\n    | ForInStep.yield b => List.forIn.loop f (toList tail\u271d) b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atTop_add_left_of_le'", "start": [817, 1], "end": [820, 15], "traced_tactics": [{"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : OrderedAddCommGroup \u03b2\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u03b2\nC : \u03b2\nhf : \u2200\u1da0 (x : \u03b1) in l, C \u2264 f x\nhg : Tendsto g l atTop\n\u22a2 \u2200\u1da0 (x : \u03b1) in l, (fun x => -f x) x \u2264 -C", "state_after": "no goals"}, {"tactic": "simpa", "annotated_tactic": ["simpa", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : OrderedAddCommGroup \u03b2\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u03b2\nC : \u03b2\nhf : \u2200\u1da0 (x : \u03b1) in l, C \u2264 f x\nhg : Tendsto g l atTop\n\u22a2 Tendsto (fun x => (fun x => -f x) x + (fun x => f x + g x) x) l atTop", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Congruence.lean", "full_name": "RingCon.coe_one", "start": [218, 1], "end": [219, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupRingAction/Basic.lean", "full_name": "toRingHom_injective", "start": [64, 1], "end": [66, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Fin.lean", "full_name": "finSuccEquiv'_succAbove", "start": [142, 1], "end": [144, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Defs.lean", "full_name": "Finsupp.embDomain_add", "start": [1201, 1], "end": [1203, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Semiring.lean", "full_name": "Set.up_union", "start": [126, 1], "end": [127, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Defs.lean", "full_name": "Monotone.mul", "start": [293, 1], "end": [294, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "full_name": "Equiv.Perm.IsCycle.inv", "start": [315, 1], "end": [317, 86], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "toDual_covby_toDual_iff", "start": [254, 1], "end": [255, 57], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Order/Lemmas.lean", "full_name": "Nat.dvd_add_self_left", "start": [106, 11], "end": [107, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Span.lean", "full_name": "Submodule.sup_toAddSubgroup", "start": [396, 1], "end": [400, 6], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "R\u271d : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM\u271d : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2079 : Semiring R\u271d\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\nx : M\u271d\np\u271d p'\u271d : Submodule R\u271d M\u271d\ninst\u271d\u2076 : Semiring R\u2082\n\u03c3\u2081\u2082 : R\u271d \u2192+* R\u2082\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b3 : SemilinearMapClass F \u03c3\u2081\u2082 M\u271d M\u2082\ns t : Set M\u271d\nR : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' : Submodule R M\n\u22a2 toAddSubgroup (p \u2294 p') = toAddSubgroup p \u2294 toAddSubgroup p'", "state_after": "case h\nR\u271d : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM\u271d : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2079 : Semiring R\u271d\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\nx\u271d : M\u271d\np\u271d p'\u271d : Submodule R\u271d M\u271d\ninst\u271d\u2076 : Semiring R\u2082\n\u03c3\u2081\u2082 : R\u271d \u2192+* R\u2082\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b3 : SemilinearMapClass F \u03c3\u2081\u2082 M\u271d M\u2082\ns t : Set M\u271d\nR : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' : Submodule R M\nx : M\n\u22a2 x \u2208 toAddSubgroup (p \u2294 p') \u2194 x \u2208 toAddSubgroup p \u2294 toAddSubgroup p'"}, {"tactic": "rw [mem_toAddSubgroup, mem_sup, AddSubgroup.mem_sup]", "annotated_tactic": ["rw [<a>mem_toAddSubgroup</a>, <a>mem_sup</a>, <a>AddSubgroup.mem_sup</a>]", [{"full_name": "Submodule.mem_toAddSubgroup", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [530, 9], "def_end_pos": [530, 26]}, {"full_name": "Submodule.mem_sup", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [356, 9], "def_end_pos": [356, 16]}, {"full_name": "AddSubgroup.mem_sup", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [3574, 3], "def_end_pos": [3574, 14]}]], "state_before": "case h\nR\u271d : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM\u271d : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2079 : Semiring R\u271d\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\nx\u271d : M\u271d\np\u271d p'\u271d : Submodule R\u271d M\u271d\ninst\u271d\u2076 : Semiring R\u2082\n\u03c3\u2081\u2082 : R\u271d \u2192+* R\u2082\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b3 : SemilinearMapClass F \u03c3\u2081\u2082 M\u271d M\u2082\ns t : Set M\u271d\nR : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' : Submodule R M\nx : M\n\u22a2 x \u2208 toAddSubgroup (p \u2294 p') \u2194 x \u2208 toAddSubgroup p \u2294 toAddSubgroup p'", "state_after": "case h\nR\u271d : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM\u271d : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2079 : Semiring R\u271d\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\nx\u271d : M\u271d\np\u271d p'\u271d : Submodule R\u271d M\u271d\ninst\u271d\u2076 : Semiring R\u2082\n\u03c3\u2081\u2082 : R\u271d \u2192+* R\u2082\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b3 : SemilinearMapClass F \u03c3\u2081\u2082 M\u271d M\u2082\ns t : Set M\u271d\nR : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' : Submodule R M\nx : M\n\u22a2 (\u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x) \u2194 \u2203 y \u2208 toAddSubgroup p, \u2203 z \u2208 toAddSubgroup p', y + z = x"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h\nR\u271d : Type u_1\nR\u2082 : Type u_2\nK : Type u_3\nM\u271d : Type u_4\nM\u2082 : Type u_5\nV : Type u_6\nS : Type u_7\ninst\u271d\u2079 : Semiring R\u271d\ninst\u271d\u2078 : AddCommMonoid M\u271d\ninst\u271d\u2077 : Module R\u271d M\u271d\nx\u271d : M\u271d\np\u271d p'\u271d : Submodule R\u271d M\u271d\ninst\u271d\u2076 : Semiring R\u2082\n\u03c3\u2081\u2082 : R\u271d \u2192+* R\u2082\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : Module R\u2082 M\u2082\nF : Type u_8\ninst\u271d\u00b3 : SemilinearMapClass F \u03c3\u2081\u2082 M\u271d M\u2082\ns t : Set M\u271d\nR : Type u_9\nM : Type u_10\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\np p' : Submodule R M\nx : M\n\u22a2 (\u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x) \u2194 \u2203 y \u2208 toAddSubgroup p, \u2203 z \u2208 toAddSubgroup p', y + z = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean", "full_name": "Multiset.gcd_singleton", "start": [144, 1], "end": [145, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/BigOperators.lean", "full_name": "Rat.cast_multiset_sum", "start": [30, 1], "end": [31, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.unitsSMul_apply", "start": [1244, 1], "end": [1246, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.Ioc_pred_left", "start": [745, 1], "end": [746, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Basic.lean", "full_name": "Nat.mul_div_le_mul_div_assoc", "start": [666, 1], "end": [670, 81], "traced_tactics": [{"tactic": "simp [hc0]", "annotated_tactic": ["simp [hc0]", []], "state_before": "m n k a b c : \u2115\nhc0 : c = 0\n\u22a2 a * (b / c) \u2264 a * b / c", "state_after": "no goals"}, {"tactic": "rw [mul_assoc]", "annotated_tactic": ["rw [<a>mul_assoc</a>]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}]], "state_before": "m n k a b c : \u2115\nhc0 : \u00acc = 0\n\u22a2 a * (b / c) * c \u2264 a * b", "state_after": "m n k a b c : \u2115\nhc0 : \u00acc = 0\n\u22a2 a * (b / c * c) \u2264 a * b"}, {"tactic": "exact Nat.mul_le_mul_left _ (Nat.div_mul_le_self _ _)", "annotated_tactic": ["exact <a>Nat.mul_le_mul_left</a> _ (<a>Nat.div_mul_le_self</a> _ _)", [{"full_name": "Nat.mul_le_mul_left", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [437, 9], "def_end_pos": [437, 24]}, {"full_name": "Nat.div_mul_le_self", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [812, 9], "def_end_pos": [812, 24]}]], "state_before": "m n k a b c : \u2115\nhc0 : \u00acc = 0\n\u22a2 a * (b / c * c) \u2264 a * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.diag_zero", "start": [665, 1], "end": [666, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "round_add_nat", "start": [1473, 1], "end": [1474, 35], "traced_tactics": [{"tactic": "exact_mod_cast round_add_int x y", "annotated_tactic": ["exact_mod_cast <a>round_add_int</a> x y", [{"full_name": "round_add_int", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1449, 9], "def_end_pos": [1449, 22]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2115\n\u22a2 round (x + \u2191y) = round x + \u2191y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pairwise/Basic.lean", "full_name": "Set.pairwise_insert_of_symmetric", "start": [173, 1], "end": [175, 54], "traced_tactics": [{"tactic": "simp only [pairwise_insert, hr.iff a, and_self_iff]", "annotated_tactic": ["simp only [<a>pairwise_insert</a>, hr.iff a, <a>and_self_iff</a>]", [{"full_name": "Set.pairwise_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pairwise/Basic.lean", "def_pos": [151, 9], "def_end_pos": [151, 24]}, {"full_name": "and_self_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [149, 9], "def_end_pos": [149, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\n\u03b9' : Type u_5\nr p q : \u03b1 \u2192 \u03b1 \u2192 Prop\nf g : \u03b9 \u2192 \u03b1\ns t u : Set \u03b1\na b : \u03b1\nhr : Symmetric r\n\u22a2 Set.Pairwise (insert a s) r \u2194 Set.Pairwise s r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Sum/Basic.lean", "full_name": "Sum.getRight_inr", "start": [84, 9], "end": [84, 91], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Support.lean", "full_name": "Function.mulSupport_min", "start": [182, 1], "end": [184, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Commute/Defs.lean", "full_name": "Commute.pow_self", "start": [198, 1], "end": [199, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Associates.dvdNotUnit_of_lt", "start": [1085, 1], "end": [1094, 7], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na b : Associates \u03b1\nhlt : a < b\n\u22a2 DvdNotUnit a b", "state_after": "case left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na b : Associates \u03b1\nhlt : a < b\n\u22a2 a \u2260 0\n\ncase right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na b : Associates \u03b1\nhlt : a < b\n\u22a2 \u2203 x, \u00acIsUnit x \u2227 b = a * x"}, {"tactic": "rcases hlt with \u27e8\u27e8x, rfl\u27e9, ndvd\u27e9", "annotated_tactic": ["rcases hlt with \u27e8\u27e8x, rfl\u27e9, ndvd\u27e9", []], "state_before": "case right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na b : Associates \u03b1\nhlt : a < b\n\u22a2 \u2203 x, \u00acIsUnit x \u2227 b = a * x", "state_after": "case right.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nx : Associates \u03b1\nndvd : \u00aca * x \u2223 a\n\u22a2 \u2203 x_1, \u00acIsUnit x_1 \u2227 a * x = a * x_1"}, {"tactic": "refine' \u27e8x, _, rfl\u27e9", "annotated_tactic": ["refine' \u27e8x, _, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case right.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nx : Associates \u03b1\nndvd : \u00aca * x \u2223 a\n\u22a2 \u2203 x_1, \u00acIsUnit x_1 \u2227 a * x = a * x_1", "state_after": "case right.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nx : Associates \u03b1\nndvd : \u00aca * x \u2223 a\n\u22a2 \u00acIsUnit x"}, {"tactic": "contrapose! ndvd", "annotated_tactic": ["contrapose! ndvd", []], "state_before": "case right.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nx : Associates \u03b1\nndvd : \u00aca * x \u2223 a\n\u22a2 \u00acIsUnit x", "state_after": "case right.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nx : Associates \u03b1\nndvd : IsUnit x\n\u22a2 a * x \u2223 a"}, {"tactic": "rcases ndvd with \u27e8u, rfl\u27e9", "annotated_tactic": ["rcases ndvd with \u27e8u, rfl\u27e9", []], "state_before": "case right.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nx : Associates \u03b1\nndvd : IsUnit x\n\u22a2 a * x \u2223 a", "state_after": "case right.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nu : (Associates \u03b1)\u02e3\n\u22a2 a * \u2191u \u2223 a"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case right.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na : Associates \u03b1\nu : (Associates \u03b1)\u02e3\n\u22a2 a * \u2191u \u2223 a", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "case left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\na b : Associates \u03b1\nhlt : a < b\n\u22a2 a \u2260 0", "state_after": "case left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\nb : Associates \u03b1\nhlt : 0 < b\n\u22a2 False"}, {"tactic": "apply not_lt_of_le _ hlt", "annotated_tactic": ["apply <a>not_lt_of_le</a> _ hlt", [{"full_name": "not_lt_of_le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [376, 9], "def_end_pos": [376, 21]}]], "state_before": "case left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\nb : Associates \u03b1\nhlt : 0 < b\n\u22a2 False", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\nb : Associates \u03b1\nhlt : 0 < b\n\u22a2 b \u2264 0"}, {"tactic": "apply dvd_zero", "annotated_tactic": ["apply <a>dvd_zero</a>", [{"full_name": "dvd_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [40, 9], "def_end_pos": [40, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CommMonoidWithZero \u03b1\nb : Associates \u03b1\nhlt : 0 < b\n\u22a2 b \u2264 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.removeNth_insertNth", "start": [1558, 1], "end": [1560, 29], "traced_tactics": [{"tactic": "rw [removeNth_eq_nth_tail, insertNth, modifyNthTail_modifyNthTail_same]", "annotated_tactic": ["rw [<a>removeNth_eq_nth_tail</a>, <a>insertNth</a>, <a>modifyNthTail_modifyNthTail_same</a>]", [{"full_name": "List.removeNth_eq_nth_tail", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [849, 9], "def_end_pos": [849, 30]}, {"full_name": "List.insertNth", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [574, 5], "def_end_pos": [574, 14]}, {"full_name": "List.modifyNthTail_modifyNthTail_same", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1462, 9], "def_end_pos": [1462, 41]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nn : \u2115\nl : List \u03b1\n\u22a2 removeNth (insertNth n a l) n = l", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nn : \u2115\nl : List \u03b1\n\u22a2 modifyNthTail (tail \u2218 cons a) n l = l"}, {"tactic": "exact modifyNthTail_id _ _", "annotated_tactic": ["exact <a>modifyNthTail_id</a> _ _", [{"full_name": "List.modifyNthTail_id", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [844, 9], "def_end_pos": [844, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nn : \u2115\nl : List \u03b1\n\u22a2 modifyNthTail (tail \u2218 cons a) n l = l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "le_iSup_inf_iSup", "start": [2023, 1], "end": [2024, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Sum/Basic.lean", "full_name": "Sum.liftRel_inr_inr", "start": [135, 9], "end": [136, 49], "traced_tactics": [{"tactic": "cases h", "annotated_tactic": ["cases h", []], "state_before": "\u03b1\u271d : Type u_1\n\u03b3\u271d : Type u_2\nr : \u03b1\u271d \u2192 \u03b3\u271d \u2192 Prop\n\u03b2\u271d : Type u_3\n\u03b4\u271d : Type u_4\ns : \u03b2\u271d \u2192 \u03b4\u271d \u2192 Prop\nb : \u03b2\u271d\nd : \u03b4\u271d\nh : LiftRel r s (inr b) (inr d)\n\u22a2 s b d", "state_after": "case inr\n\u03b1\u271d : Type u_1\n\u03b3\u271d : Type u_2\nr : \u03b1\u271d \u2192 \u03b3\u271d \u2192 Prop\n\u03b2\u271d : Type u_3\n\u03b4\u271d : Type u_4\ns : \u03b2\u271d \u2192 \u03b4\u271d \u2192 Prop\nb : \u03b2\u271d\nd : \u03b4\u271d\na\u271d : s b d\n\u22a2 s b d"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "case inr\n\u03b1\u271d : Type u_1\n\u03b3\u271d : Type u_2\nr : \u03b1\u271d \u2192 \u03b3\u271d \u2192 Prop\n\u03b2\u271d : Type u_3\n\u03b4\u271d : Type u_4\ns : \u03b2\u271d \u2192 \u03b4\u271d \u2192 Prop\nb : \u03b2\u271d\nd : \u03b4\u271d\na\u271d : s b d\n\u22a2 s b d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.sigmaCurry_zero", "start": [1504, 1], "end": [1506, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "full_name": "Subgroup.exists_zpowers", "start": [65, 1], "end": [66, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Hom/Defs.lean", "full_name": "OneHom.congr_fun", "start": [678, 1], "end": [679, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Prop.forall_iff", "start": [873, 1], "end": [874, 78], "traced_tactics": [{"tactic": "by_cases H : h <;> simpa only [H]", "annotated_tactic": ["by_cases H : h <;> simpa only [H]", []], "state_before": "\u03b9 : Sort ?u.21245\n\u03b1 : Sort ?u.21250\n\u03ba : \u03b9 \u2192 Sort u_1\np\u271d q : \u03b1 \u2192 Prop\np : Prop \u2192 Prop\nx\u271d : p False \u2227 p True\nh : Prop\nh\u2081 : p False\nh\u2082 : p True\n\u22a2 p h", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.card_empty", "start": [360, 1], "end": [361, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Pairwise.lean", "full_name": "Pairwise.set_pairwise", "start": [89, 1], "end": [89, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/SetTheory/Cardinal/Basic.lean", "full_name": "Cardinal.sum_le_iSup", "start": [1003, 1], "end": [1005, 27], "traced_tactics": [{"tactic": "rw [\u2190 lift_id #\u03b9]", "annotated_tactic": ["rw [\u2190 <a>lift_id</a> #\u03b9]", [{"full_name": "Cardinal.lift_id", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [224, 9], "def_end_pos": [224, 16]}]], "state_before": "\u03b1 \u03b2 \u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{u}\n\u22a2 sum f \u2264 #\u03b9 * iSup f", "state_after": "\u03b1 \u03b2 \u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{u}\n\u22a2 sum f \u2264 lift.{u, u} #\u03b9 * iSup f"}, {"tactic": "exact sum_le_iSup_lift f", "annotated_tactic": ["exact <a>sum_le_iSup_lift</a> f", [{"full_name": "Cardinal.sum_le_iSup_lift", "def_path": "lake-packages/mathlib/Mathlib/SetTheory/Cardinal/Basic.lean", "def_pos": [997, 9], "def_end_pos": [997, 25]}]], "state_before": "\u03b1 \u03b2 \u03b9 : Type u\nf : \u03b9 \u2192 Cardinal.{u}\n\u22a2 sum f \u2264 lift.{u, u} #\u03b9 * iSup f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.casesAuxOn_zero", "start": [33, 9], "end": [35, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Log.lean", "full_name": "Nat.le_pow_iff_clog_le", "start": [292, 1], "end": [306, 18], "traced_tactics": [{"tactic": "induction' x using Nat.strong_induction_on with x ih generalizing y", "annotated_tactic": ["induction' x using <a>Nat.strong_induction_on</a> with x ih generalizing y", [{"full_name": "Nat.strong_induction_on", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Lemmas.lean", "def_pos": [500, 19], "def_end_pos": [500, 38]}]], "state_before": "b : \u2115\nhb : 1 < b\nx y : \u2115\n\u22a2 x \u2264 b ^ y \u2194 clog b x \u2264 y", "state_after": "case h\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\ny : \u2115\n\u22a2 x \u2264 b ^ y \u2194 clog b x \u2264 y"}, {"tactic": "cases y", "annotated_tactic": ["cases y", []], "state_before": "case h\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\ny : \u2115\n\u22a2 x \u2264 b ^ y \u2194 clog b x \u2264 y", "state_after": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 x \u2264 b ^ zero \u2194 clog b x \u2264 zero\n\ncase h.succ\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\n\u22a2 x \u2264 b ^ succ n\u271d \u2194 clog b x \u2264 succ n\u271d"}, {"tactic": "have b_pos : 0 < b := (zero_lt_one' \u2115).trans hb", "annotated_tactic": ["have b_pos : 0 < b := (<a>zero_lt_one'</a> \u2115).<a>trans</a> hb", [{"full_name": "zero_lt_one'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/ZeroLEOne.lean", "def_pos": [45, 7], "def_end_pos": [45, 19]}, {"full_name": "LT.lt.trans", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [144, 7], "def_end_pos": [144, 18]}]], "state_before": "case h.succ\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\n\u22a2 x \u2264 b ^ succ n\u271d \u2194 clog b x \u2264 succ n\u271d", "state_after": "case h.succ\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\n\u22a2 x \u2264 b ^ succ n\u271d \u2194 clog b x \u2264 succ n\u271d"}, {"tactic": "rw [clog]", "annotated_tactic": ["rw [<a>clog</a>]", [{"full_name": "Nat.clog", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [238, 5], "def_end_pos": [238, 9]}]], "state_before": "case h.succ\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\n\u22a2 x \u2264 b ^ succ n\u271d \u2194 clog b x \u2264 succ n\u271d", "state_after": "case h.succ\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\n\u22a2 x \u2264 b ^ succ n\u271d \u2194\n    (if h : 1 < b \u2227 1 < x then\n        let_fun this := (_ : (x + b - 1) / b < x);\n        clog b ((x + b - 1) / b) + 1\n      else 0) \u2264\n      succ n\u271d"}, {"tactic": "split_ifs with h", "annotated_tactic": ["split_ifs with h", []], "state_before": "case h.succ\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\n\u22a2 x \u2264 b ^ succ n\u271d \u2194\n    (if h : 1 < b \u2227 1 < x then\n        let_fun this := (_ : (x + b - 1) / b < x);\n        clog b ((x + b - 1) / b) + 1\n      else 0) \u2264\n      succ n\u271d", "state_after": "case pos\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\nh : 1 < b \u2227 1 < x\n\u22a2 x \u2264 b ^ succ n\u271d \u2194\n    (let_fun this := (_ : (x + b - 1) / b < x);\n      clog b ((x + b - 1) / b) + 1) \u2264\n      succ n\u271d\n\ncase neg\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\nh : \u00ac(1 < b \u2227 1 < x)\n\u22a2 x \u2264 b ^ succ n\u271d \u2194 0 \u2264 succ n\u271d"}, {"tactic": "rw [pow_zero]", "annotated_tactic": ["rw [<a>pow_zero</a>]", [{"full_name": "Nat.pow_zero", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [476, 9], "def_end_pos": [476, 17]}]], "state_before": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 x \u2264 b ^ zero \u2194 clog b x \u2264 zero", "state_after": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 x \u2264 1 \u2194 clog b x \u2264 zero"}, {"tactic": "refine' \u27e8fun h => (clog_of_right_le_one h b).le, _\u27e9", "annotated_tactic": ["refine' \u27e8fun h => (<a>clog_of_right_le_one</a> h b).<a>le</a>, _\u27e9", [{"full_name": "Nat.clog_of_right_le_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [250, 9], "def_end_pos": [250, 29]}, {"full_name": "Eq.le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [159, 7], "def_end_pos": [159, 12]}]], "state_before": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 x \u2264 1 \u2194 clog b x \u2264 zero", "state_after": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 clog b x \u2264 zero \u2192 x \u2264 1"}, {"tactic": "simp_rw [\u2190 not_lt]", "annotated_tactic": ["simp_rw [\u2190 <a>not_lt</a>]", [{"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}]], "state_before": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 clog b x \u2264 zero \u2192 x \u2264 1", "state_after": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 \u00aczero < clog b x \u2192 \u00ac1 < x"}, {"tactic": "contrapose!", "annotated_tactic": ["contrapose!", []], "state_before": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 \u00aczero < clog b x \u2192 \u00ac1 < x", "state_after": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 1 < x \u2192 zero < clog b x"}, {"tactic": "exact clog_pos hb", "annotated_tactic": ["exact <a>clog_pos</a> hb", [{"full_name": "Nat.clog_pos", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [278, 9], "def_end_pos": [278, 17]}]], "state_before": "case h.zero\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\n\u22a2 1 < x \u2192 zero < clog b x", "state_after": "no goals"}, {"tactic": "rw [succ_eq_add_one, add_le_add_iff_right, \u2190 ih ((x + b - 1) / b) (add_pred_div_lt hb h.2),\n  Nat.div_le_iff_le_mul_add_pred b_pos, mul_comm b, \u2190 pow_succ,\n  add_tsub_assoc_of_le (Nat.succ_le_of_lt b_pos), add_le_add_iff_right]", "annotated_tactic": ["rw [<a>succ_eq_add_one</a>, <a>add_le_add_iff_right</a>, \u2190 ih ((x + b - 1) / b) (<a>add_pred_div_lt</a> hb h.2),\n      <a>Nat.div_le_iff_le_mul_add_pred</a> b_pos, <a>mul_comm</a> b, \u2190 <a>pow_succ</a>,\n      <a>add_tsub_assoc_of_le</a> (<a>Nat.succ_le_of_lt</a> b_pos), <a>add_le_add_iff_right</a>]", [{"full_name": "Nat.succ_eq_add_one", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}, {"full_name": "add_le_add_iff_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [90, 3], "def_end_pos": [90, 14]}, {"full_name": "Nat.add_pred_div_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [225, 9], "def_end_pos": [225, 24]}, {"full_name": "Nat.div_le_iff_le_mul_add_pred", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 35]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}, {"full_name": "add_tsub_assoc_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [214, 9], "def_end_pos": [214, 29]}, {"full_name": "Nat.succ_le_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 22]}, {"full_name": "add_le_add_iff_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [90, 3], "def_end_pos": [90, 14]}]], "state_before": "case pos\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\nh : 1 < b \u2227 1 < x\n\u22a2 x \u2264 b ^ succ n\u271d \u2194\n    (let_fun this := (_ : (x + b - 1) / b < x);\n      clog b ((x + b - 1) / b) + 1) \u2264\n      succ n\u271d", "state_after": "no goals"}, {"tactic": "exact iff_of_true ((not_lt.1 (not_and.1 h hb)).trans <| succ_le_of_lt <| pow_pos b_pos _)\n  (zero_le _)", "annotated_tactic": ["exact <a>iff_of_true</a> ((<a>not_lt</a>.1 (<a>not_and</a>.1 h hb)).<a>trans</a> <| <a>succ_le_of_lt</a> <| <a>pow_pos</a> b_pos _)\n      (<a>zero_le</a> _)", [{"full_name": "iff_of_true", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 20]}, {"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}, {"full_name": "not_and", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [322, 17], "def_end_pos": [322, 24]}, {"full_name": "LE.le.trans", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [120, 7], "def_end_pos": [120, 18]}, {"full_name": "Nat.succ_le_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 22]}, {"full_name": "pow_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [530, 9], "def_end_pos": [530, 16]}, {"full_name": "Nat.zero_le", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1578, 9], "def_end_pos": [1578, 20]}]], "state_before": "case neg\nb : \u2115\nhb : 1 < b\nx : \u2115\nih : \u2200 m < x, \u2200 {y : \u2115}, m \u2264 b ^ y \u2194 clog b m \u2264 y\nn\u271d : \u2115\nb_pos : 0 < b\nh : \u00ac(1 < b \u2227 1 < x)\n\u22a2 x \u2264 b ^ succ n\u271d \u2194 0 \u2264 succ n\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Finset.card_univ_diff", "start": [282, 1], "end": [284, 36], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Count.lean", "full_name": "List.countP_go_eq_add", "start": [28, 11], "end": [34, 61], "traced_tactics": [{"tactic": "induction l generalizing n with\n| nil => rfl\n| cons head tail ih =>\n  unfold countP.go\n  rw [ih (n := n + 1), ih (n := n), ih (n := 1)]\n  if h : p head then simp [h, Nat.add_assoc] else simp [h]", "annotated_tactic": ["induction l generalizing n with\n  | <a>nil</a> => rfl\n  | <a>cons</a> head tail ih =>\n    unfold <a>countP.go</a>\n    rw [ih (n := n + 1), ih (n := n), ih (n := 1)]\n    if h : p head then simp [h, <a>Nat.add_assoc</a>] else simp [h]", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.countP.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [799, 17], "def_end_pos": [799, 19]}, {"full_name": "Nat.add_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nn : Nat\nl : List \u03b1\n\u22a2 countP.go p l n = n + countP.go p l 0", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nn : Nat\n\u22a2 countP.go p [] n = n + countP.go p [] 0", "state_after": "no goals"}, {"tactic": "unfold countP.go", "annotated_tactic": ["unfold <a>countP.go</a>", [{"full_name": "List.countP.go", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [799, 17], "def_end_pos": [799, 19]}]], "state_before": "case cons\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 {n : Nat}, countP.go p tail n = n + countP.go p tail 0\nn : Nat\n\u22a2 countP.go p (head :: tail) n = n + countP.go p (head :: tail) 0", "state_after": "case cons\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 {n : Nat}, countP.go p tail n = n + countP.go p tail 0\nn : Nat\n\u22a2 (bif p head then countP.go p tail (n + 1) else countP.go p tail n) =\n    n + bif p head then countP.go p tail (0 + 1) else countP.go p tail 0"}, {"tactic": "rw [ih (n := n + 1), ih (n := n), ih (n := 1)]", "annotated_tactic": ["rw [ih (n := n + 1), ih (n := n), ih (n := 1)]", []], "state_before": "case cons\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 {n : Nat}, countP.go p tail n = n + countP.go p tail 0\nn : Nat\n\u22a2 (bif p head then countP.go p tail (n + 1) else countP.go p tail n) =\n    n + bif p head then countP.go p tail (0 + 1) else countP.go p tail 0", "state_after": "case cons\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 {n : Nat}, countP.go p tail n = n + countP.go p tail 0\nn : Nat\n\u22a2 (bif p head then n + 1 + countP.go p tail 0 else n + countP.go p tail 0) =\n    n + bif p head then 1 + countP.go p tail 0 else countP.go p tail 0"}, {"tactic": "if h : p head then simp [h, Nat.add_assoc] else simp [h]", "annotated_tactic": ["if h : p head then simp [h, <a>Nat.add_assoc</a>] else simp [h]", [{"full_name": "Nat.add_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "case cons\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 {n : Nat}, countP.go p tail n = n + countP.go p tail 0\nn : Nat\n\u22a2 (bif p head then n + 1 + countP.go p tail 0 else n + countP.go p tail 0) =\n    n + bif p head then 1 + countP.go p tail 0 else countP.go p tail 0", "state_after": "no goals"}, {"tactic": "simp [h, Nat.add_assoc]", "annotated_tactic": ["simp [h, <a>Nat.add_assoc</a>]", [{"full_name": "Nat.add_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}]], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 {n : Nat}, countP.go p tail n = n + countP.go p tail 0\nn : Nat\nh : p head = true\n\u22a2 (bif p head then n + 1 + countP.go p tail 0 else n + countP.go p tail 0) =\n    n + bif p head then 1 + countP.go p tail 0 else countP.go p tail 0", "state_after": "no goals"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Bool\nhead : \u03b1\ntail : List \u03b1\nih : \u2200 {n : Nat}, countP.go p tail n = n + countP.go p tail 0\nn : Nat\nh : \u00acp head = true\n\u22a2 (bif p head then n + 1 + countP.go p tail 0 else n + countP.go p tail 0) =\n    n + bif p head then 1 + countP.go p tail 0 else countP.go p tail 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "MonotoneOn.congr", "start": [260, 1], "end": [263, 21], "traced_tactics": [{"tactic": "intro a ha b hb hab", "annotated_tactic": ["intro a ha b hb hab", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : EqOn f\u2081 f\u2082 s\n\u22a2 MonotoneOn f\u2082 s", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na\u271d : \u03b1\nb\u271d : \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2264 b\n\u22a2 f\u2082 a \u2264 f\u2082 b"}, {"tactic": "rw [\u2190 h ha, \u2190 h hb]", "annotated_tactic": ["rw [\u2190 h ha, \u2190 h hb]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na\u271d : \u03b1\nb\u271d : \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2264 b\n\u22a2 f\u2082 a \u2264 f\u2082 b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na\u271d : \u03b1\nb\u271d : \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2264 b\n\u22a2 f\u2081 a \u2264 f\u2081 b"}, {"tactic": "exact h\u2081 ha hb hab", "annotated_tactic": ["exact h\u2081 ha hb hab", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\np : Set \u03b3\nf f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2\ng g\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nf' f\u2081' f\u2082' : \u03b2 \u2192 \u03b1\ng' : \u03b3 \u2192 \u03b2\na\u271d : \u03b1\nb\u271d : \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2264 b\n\u22a2 f\u2081 a \u2264 f\u2081 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.preimage_comp_eq", "start": [167, 1], "end": [168, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Support.lean", "full_name": "Function.mulSupport_div", "start": [307, 1], "end": [308, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/BinomialHeap/Basic.lean", "full_name": "Std.BinomialHeap.Imp.Heap.realSize_deleteMin", "start": [248, 1], "end": [258, 96], "traced_tactics": [{"tactic": "cases s with cases eq | cons r a c s => ?_", "annotated_tactic": ["cases s with cases eq | <a>cons</a> r a c s => ?_", [{"full_name": "Std.BinomialHeap.Imp.Heap.cons", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [77, 5], "def_end_pos": [77, 9]}]], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na : \u03b1\ns' s : Heap \u03b1\neq : deleteMin le s = some (a, s')\n\u22a2 realSize s = realSize s' + 1", "state_after": "case cons.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).node)\n          (FindMin.before (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n            (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).next)) +\n      1"}, {"tactic": "have : (s.findMin le (cons r a c) \u27e8id, a, c, s\u27e9).HasSize (c.realSize + s.realSize + 1) :=\n  Heap.realSize_findMin (c.realSize + 1) (by simp) (Nat.add_right_comm ..) \u27e80, by simp\u27e9", "annotated_tactic": ["have : (s.findMin le (<a>cons</a> r a c) \u27e8<a>id</a>, a, c, s\u27e9).<a>HasSize</a> (c.realSize + s.realSize + 1) :=\n    <a>Heap.realSize_findMin</a> (c.realSize + 1) (by simp) (<a>Nat.add_right_comm</a> ..) \u27e80, by simp\u27e9", [{"full_name": "Std.BinomialHeap.Imp.Heap.cons", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [77, 5], "def_end_pos": [77, 9]}, {"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.Data.BinomialHeap.Basic.0.Std.BinomialHeap.Imp.FindMin.HasSize", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [224, 13], "def_end_pos": [224, 28]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.Data.BinomialHeap.Basic.0.Std.BinomialHeap.Imp.Heap.realSize_findMin", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [229, 17], "def_end_pos": [229, 38]}, {"full_name": "Nat.add_right_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}]], "state_before": "case cons.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).node)\n          (FindMin.before (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n            (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).next)) +\n      1", "state_after": "case cons.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nthis :\n  Std.BinomialHeap.Imp.FindMin.HasSize (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n    (HeapNode.realSize c + realSize s + 1)\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).node)\n          (FindMin.before (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n            (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).next)) +\n      1"}, {"tactic": "revert this", "annotated_tactic": ["revert this", []], "state_before": "case cons.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nthis :\n  Std.BinomialHeap.Imp.FindMin.HasSize (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n    (HeapNode.realSize c + realSize s + 1)\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).node)\n          (FindMin.before (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n            (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).next)) +\n      1", "state_after": "case cons.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\n\u22a2 Std.BinomialHeap.Imp.FindMin.HasSize (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n      (HeapNode.realSize c + realSize s + 1) \u2192\n    realSize (cons r a c s) =\n      realSize\n          (merge le (HeapNode.toHeap (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).node)\n            (FindMin.before (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n              (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).next)) +\n        1"}, {"tactic": "match s.findMin le (cons r a c) \u27e8id, a, c, s\u27e9 with\n| { before, val, node, next } =>\n  intro \u27e8m, ih\u2081, ih\u2082\u27e9; dsimp only at ih\u2081 ih\u2082\n  rw [realSize, Nat.add_right_comm, ih\u2082]\n  simp only [realSize_merge, HeapNode.realSize_toHeap, ih\u2081, Nat.add_assoc, Nat.add_left_comm]", "annotated_tactic": ["match s.findMin le (<a>cons</a> r a c) \u27e8<a>id</a>, a, c, s\u27e9 with\n  | { before, val, node, next } =>\n    intro \u27e8m, ih\u2081, ih\u2082\u27e9; dsimp only at ih\u2081 ih\u2082\n    rw [<a>realSize</a>, <a>Nat.add_right_comm</a>, ih\u2082]\n    simp only [<a>realSize_merge</a>, <a>HeapNode.realSize_toHeap</a>, ih\u2081, <a>Nat.add_assoc</a>, <a>Nat.add_left_comm</a>]", [{"full_name": "Std.BinomialHeap.Imp.Heap.cons", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [77, 5], "def_end_pos": [77, 9]}, {"full_name": "id", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [33, 15], "def_end_pos": [33, 17]}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [85, 13], "def_end_pos": [85, 26]}, {"full_name": "Nat.add_right_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize_merge", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [206, 9], "def_end_pos": [206, 28]}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.realSize_toHeap", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [243, 9], "def_end_pos": [243, 33]}, {"full_name": "Nat.add_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}, {"full_name": "Nat.add_left_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [142, 19], "def_end_pos": [142, 32]}]], "state_before": "case cons.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\n\u22a2 Std.BinomialHeap.Imp.FindMin.HasSize (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n      (HeapNode.realSize c + realSize s + 1) \u2192\n    realSize (cons r a c s) =\n      realSize\n          (merge le (HeapNode.toHeap (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).node)\n            (FindMin.before (findMin le (cons r a c) s { before := id, val := a, node := c, next := s })\n              (findMin le (cons r a c) s { before := id, val := a, node := c, next := s }).next)) +\n        1", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\n\u22a2 \u2200 (s : Heap \u03b1), realSize (cons r a c s) = HeapNode.realSize c + 1 + realSize s", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\n\u22a2 (\u2200 (s_1 : Heap \u03b1),\n      realSize (FindMin.before { before := id, val := a, node := c, next := s } s_1) = 0 + realSize s_1) \u2227\n    HeapNode.realSize c + realSize s + 1 =\n      0 + HeapNode.realSize { before := id, val := a, node := c, next := s }.node +\n          realSize { before := id, val := a, node := c, next := s }.next +\n        1", "state_after": "no goals"}, {"tactic": "intro \u27e8m, ih\u2081, ih\u2082\u27e9", "annotated_tactic": ["intro \u27e8m, ih\u2081, ih\u2082\u27e9", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nbefore : Heap \u03b1 \u2192 Heap \u03b1\nval : \u03b1\nnode : HeapNode \u03b1\nnext : Heap \u03b1\n\u22a2 Std.BinomialHeap.Imp.FindMin.HasSize { before := before, val := val, node := node, next := next }\n      (HeapNode.realSize c + realSize s + 1) \u2192\n    realSize (cons r a c s) =\n      realSize\n          (merge le (HeapNode.toHeap { before := before, val := val, node := node, next := next }.node)\n            (FindMin.before { before := before, val := val, node := node, next := next }\n              { before := before, val := val, node := node, next := next }.next)) +\n        1", "state_after": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nbefore : Heap \u03b1 \u2192 Heap \u03b1\nval : \u03b1\nnode : HeapNode \u03b1\nnext : Heap \u03b1\nm : Nat\nih\u2081 :\n  \u2200 (s : Heap \u03b1),\n    realSize (FindMin.before { before := before, val := val, node := node, next := next } s) = m + realSize s\nih\u2082 :\n  HeapNode.realSize c + realSize s + 1 =\n    m + HeapNode.realSize { before := before, val := val, node := node, next := next }.node +\n        realSize { before := before, val := val, node := node, next := next }.next +\n      1\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap { before := before, val := val, node := node, next := next }.node)\n          (FindMin.before { before := before, val := val, node := node, next := next }\n            { before := before, val := val, node := node, next := next }.next)) +\n      1"}, {"tactic": "dsimp only at ih\u2081 ih\u2082", "annotated_tactic": ["dsimp only at ih\u2081 ih\u2082", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nbefore : Heap \u03b1 \u2192 Heap \u03b1\nval : \u03b1\nnode : HeapNode \u03b1\nnext : Heap \u03b1\nm : Nat\nih\u2081 :\n  \u2200 (s : Heap \u03b1),\n    realSize (FindMin.before { before := before, val := val, node := node, next := next } s) = m + realSize s\nih\u2082 :\n  HeapNode.realSize c + realSize s + 1 =\n    m + HeapNode.realSize { before := before, val := val, node := node, next := next }.node +\n        realSize { before := before, val := val, node := node, next := next }.next +\n      1\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap { before := before, val := val, node := node, next := next }.node)\n          (FindMin.before { before := before, val := val, node := node, next := next }\n            { before := before, val := val, node := node, next := next }.next)) +\n      1", "state_after": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nbefore : Heap \u03b1 \u2192 Heap \u03b1\nval : \u03b1\nnode : HeapNode \u03b1\nnext : Heap \u03b1\nm : Nat\nih\u2081 : \u2200 (s : Heap \u03b1), realSize (before s) = m + realSize s\nih\u2082 : HeapNode.realSize c + realSize s + 1 = m + HeapNode.realSize node + realSize next + 1\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap { before := before, val := val, node := node, next := next }.node)\n          (FindMin.before { before := before, val := val, node := node, next := next }\n            { before := before, val := val, node := node, next := next }.next)) +\n      1"}, {"tactic": "rw [realSize, Nat.add_right_comm, ih\u2082]", "annotated_tactic": ["rw [<a>realSize</a>, <a>Nat.add_right_comm</a>, ih\u2082]", [{"full_name": "Std.BinomialHeap.Imp.Heap.realSize", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [85, 13], "def_end_pos": [85, 26]}, {"full_name": "Nat.add_right_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [145, 19], "def_end_pos": [145, 33]}]], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nbefore : Heap \u03b1 \u2192 Heap \u03b1\nval : \u03b1\nnode : HeapNode \u03b1\nnext : Heap \u03b1\nm : Nat\nih\u2081 : \u2200 (s : Heap \u03b1), realSize (before s) = m + realSize s\nih\u2082 : HeapNode.realSize c + realSize s + 1 = m + HeapNode.realSize node + realSize next + 1\n\u22a2 realSize (cons r a c s) =\n    realSize\n        (merge le (HeapNode.toHeap { before := before, val := val, node := node, next := next }.node)\n          (FindMin.before { before := before, val := val, node := node, next := next }\n            { before := before, val := val, node := node, next := next }.next)) +\n      1", "state_after": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nbefore : Heap \u03b1 \u2192 Heap \u03b1\nval : \u03b1\nnode : HeapNode \u03b1\nnext : Heap \u03b1\nm : Nat\nih\u2081 : \u2200 (s : Heap \u03b1), realSize (before s) = m + realSize s\nih\u2082 : HeapNode.realSize c + realSize s + 1 = m + HeapNode.realSize node + realSize next + 1\n\u22a2 m + HeapNode.realSize node + realSize next + 1 =\n    realSize\n        (merge le (HeapNode.toHeap { before := before, val := val, node := node, next := next }.node)\n          (FindMin.before { before := before, val := val, node := node, next := next }\n            { before := before, val := val, node := node, next := next }.next)) +\n      1"}, {"tactic": "simp only [realSize_merge, HeapNode.realSize_toHeap, ih\u2081, Nat.add_assoc, Nat.add_left_comm]", "annotated_tactic": ["simp only [<a>realSize_merge</a>, <a>HeapNode.realSize_toHeap</a>, ih\u2081, <a>Nat.add_assoc</a>, <a>Nat.add_left_comm</a>]", [{"full_name": "Std.BinomialHeap.Imp.Heap.realSize_merge", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [206, 9], "def_end_pos": [206, 28]}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.realSize_toHeap", "def_path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "def_pos": [243, 9], "def_end_pos": [243, 33]}, {"full_name": "Nat.add_assoc", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [138, 19], "def_end_pos": [138, 28]}, {"full_name": "Nat.add_left_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [142, 19], "def_end_pos": [142, 32]}]], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nr : Nat\na : \u03b1\nc : HeapNode \u03b1\ns : Heap \u03b1\nbefore : Heap \u03b1 \u2192 Heap \u03b1\nval : \u03b1\nnode : HeapNode \u03b1\nnext : Heap \u03b1\nm : Nat\nih\u2081 : \u2200 (s : Heap \u03b1), realSize (before s) = m + realSize s\nih\u2082 : HeapNode.realSize c + realSize s + 1 = m + HeapNode.realSize node + realSize next + 1\n\u22a2 m + HeapNode.realSize node + realSize next + 1 =\n    realSize\n        (merge le (HeapNode.toHeap { before := before, val := val, node := node, next := next }.node)\n          (FindMin.before { before := before, val := val, node := node, next := next }\n            { before := before, val := val, node := node, next := next }.next)) +\n      1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "Set.not_unbounded_iff", "start": [561, 1], "end": [562, 37], "traced_tactics": [{"tactic": "rw [not_iff_comm, not_bounded_iff]", "annotated_tactic": ["rw [<a>not_iff_comm</a>, <a>not_bounded_iff</a>]", [{"full_name": "not_iff_comm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [439, 9], "def_end_pos": [439, 21]}, {"full_name": "Set.not_bounded_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/RelClasses.lean", "def_pos": [556, 9], "def_end_pos": [556, 24]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d : \u03b2 \u2192 \u03b2 \u2192 Prop\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\n\u22a2 \u00acUnbounded r s \u2194 Bounded r s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/RelClasses.lean", "full_name": "antisymm_of", "start": [50, 1], "end": [51, 11], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.mul_inter_subset", "start": [454, 1], "end": [455, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Fold.lean", "full_name": "Finset.fold_empty", "start": [41, 1], "end": [42, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "Odd.pow_neg_iff", "start": [542, 1], "end": [543, 76], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.symm_bijective", "start": [346, 1], "end": [347, 53], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "monotone_fst", "start": [1185, 1], "end": [1185, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Basic.lean", "full_name": "List.takeD_zero", "start": [602, 9], "end": [602, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "IsUnit.eq_mul_inv_iff_mul_eq", "start": [322, 11], "end": [323, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.mk_one", "start": [163, 9], "end": [163, 101], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean", "full_name": "Nat.ascFactorial_pos", "start": [331, 1], "end": [332, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Function.lean", "full_name": "Function.invFunOn_pos", "start": [1240, 1], "end": [1242, 32], "traced_tactics": [{"tactic": "rw [invFunOn, dif_pos h]", "annotated_tactic": ["rw [<a>invFunOn</a>, <a>dif_pos</a> h]", [{"full_name": "Function.invFunOn", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Function.lean", "def_pos": [1236, 19], "def_end_pos": [1236, 27]}, {"full_name": "dif_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [807, 9], "def_end_pos": [807, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2203 a \u2208 s, f a = b\n\u22a2 invFunOn f s b \u2208 s \u2227 f (invFunOn f s b) = b", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2203 a \u2208 s, f a = b\n\u22a2 Classical.choose h \u2208 s \u2227 f (Classical.choose h) = b"}, {"tactic": "exact Classical.choose_spec h", "annotated_tactic": ["exact <a>Classical.choose_spec</a> h", [{"full_name": "Classical.choose_spec", "def_path": "lake-packages/lean4/src/lean/Init/Classical.lean", "def_pos": [22, 9], "def_end_pos": [22, 20]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nb : \u03b2\nh : \u2203 a \u2208 s, f a = b\n\u22a2 Classical.choose h \u2208 s \u2227 f (Classical.choose h) = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Cast/Commute.lean", "full_name": "Nat.commute_cast", "start": [37, 1], "end": [38, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "full_name": "Associates.factors_0", "start": [1421, 1], "end": [1422, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_iInf_le_iInf_iSup", "start": [957, 1], "end": [958, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "full_name": "MulAction.mem_orbit_smul", "start": [268, 1], "end": [269, 41], "traced_tactics": [{"tactic": "simp only [orbit_smul, mem_orbit_self]", "annotated_tactic": ["simp only [<a>orbit_smul</a>, <a>mem_orbit_self</a>]", [{"full_name": "MulAction.orbit_smul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Basic.lean", "def_pos": [244, 9], "def_end_pos": [244, 19]}, {"full_name": "MulAction.mem_orbit_self", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Basic.lean", "def_pos": [68, 9], "def_end_pos": [68, 23]}]], "state_before": "G : Type u\ninst\u271d\u00b9 : Group G\n\u03b1 : Type v\ninst\u271d : MulAction G \u03b1\ng : G\na : \u03b1\n\u22a2 a \u2208 orbit G (g \u2022 a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Control/ForInStep/Lemmas.lean", "full_name": "ForInStep.bind_yield_bindList", "start": [31, 9], "end": [33, 85], "traced_tactics": [{"tactic": "cases s <;> simp", "annotated_tactic": ["cases s <;> simp", []], "state_before": "m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_1\ninst\u271d : Monad m\nf : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)\ns : ForInStep \u03b2\nl : List \u03b1\n\u22a2 (ForInStep.bind s fun a => bindList f l (yield a)) = bindList f l s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.subset_cons_of_subset", "start": [311, 1], "end": [312, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "csInf_image2_eq_csSup_csInf", "start": [1590, 1], "end": [1593, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Nontrivial/Basic.lean", "full_name": "Function.Injective.exists_ne", "start": [71, 11], "end": [76, 18], "traced_tactics": [{"tactic": "rcases exists_pair_ne \u03b1 with \u27e8x\u2081, x\u2082, hx\u27e9", "annotated_tactic": ["rcases <a>exists_pair_ne</a> \u03b1 with \u27e8x\u2081, x\u2082, hx\u27e9", [{"full_name": "exists_pair_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [38, 9], "def_end_pos": [38, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nontrivial \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ny : \u03b2\n\u22a2 \u2203 x, f x \u2260 y", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nontrivial \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ny : \u03b2\nx\u2081 x\u2082 : \u03b1\nhx : x\u2081 \u2260 x\u2082\n\u22a2 \u2203 x, f x \u2260 y"}, {"tactic": "by_cases h:f x\u2082 = y", "annotated_tactic": ["by_cases h:f x\u2082 = y", []], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nontrivial \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ny : \u03b2\nx\u2081 x\u2082 : \u03b1\nhx : x\u2081 \u2260 x\u2082\n\u22a2 \u2203 x, f x \u2260 y", "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nontrivial \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ny : \u03b2\nx\u2081 x\u2082 : \u03b1\nhx : x\u2081 \u2260 x\u2082\nh : f x\u2082 = y\n\u22a2 \u2203 x, f x \u2260 y\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nontrivial \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ny : \u03b2\nx\u2081 x\u2082 : \u03b1\nhx : x\u2081 \u2260 x\u2082\nh : \u00acf x\u2082 = y\n\u22a2 \u2203 x, f x \u2260 y"}, {"tactic": "exact \u27e8x\u2081, (hf.ne_iff' h).2 hx\u27e9", "annotated_tactic": ["exact \u27e8x\u2081, (hf.ne_iff' h).2 hx\u27e9", []], "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nontrivial \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ny : \u03b2\nx\u2081 x\u2082 : \u03b1\nhx : x\u2081 \u2260 x\u2082\nh : f x\u2082 = y\n\u22a2 \u2203 x, f x \u2260 y", "state_after": "no goals"}, {"tactic": "exact \u27e8x\u2082, h\u27e9", "annotated_tactic": ["exact \u27e8x\u2082, h\u27e9", []], "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nontrivial \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ny : \u03b2\nx\u2081 x\u2082 : \u03b1\nhx : x\u2081 \u2260 x\u2082\nh : \u00acf x\u2082 = y\n\u22a2 \u2203 x, f x \u2260 y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/MinMax.lean", "full_name": "List.mem_argmin_iff", "start": [252, 1], "end": [255, 34], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/SMul.lean", "full_name": "Set.smul_set_subset_iff", "start": [360, 1], "end": [361, 19], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "odd_bit1", "start": [348, 9], "end": [349, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Prod.lean", "full_name": "Set.prod_eq_iff_eq", "start": [450, 1], "end": [454, 6], "traced_tactics": [{"tactic": "simp_rw [prod_eq_prod_iff, ht.ne_empty, and_true_iff, or_iff_left_iff_imp,\n  or_false_iff]", "annotated_tactic": ["simp_rw [<a>prod_eq_prod_iff</a>, ht.ne_empty, <a>and_true_iff</a>, <a>or_iff_left_iff_imp</a>,\n    <a>or_false_iff</a>]", [{"full_name": "Set.prod_eq_prod_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Prod.lean", "def_pos": [436, 9], "def_end_pos": [436, 25]}, {"full_name": "and_true_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [145, 9], "def_end_pos": [145, 21]}, {"full_name": "or_iff_left_iff_imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [301, 17], "def_end_pos": [301, 36]}, {"full_name": "or_false_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [187, 9], "def_end_pos": [187, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nht : Set.Nonempty t\n\u22a2 s \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2194 s = s\u2081", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nht : Set.Nonempty t\n\u22a2 s = \u2205 \u2227 s\u2081 = \u2205 \u2192 s = s\u2081"}, {"tactic": "rintro \u27e8rfl, rfl\u27e9", "annotated_tactic": ["rintro \u27e8rfl, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns s\u2081 s\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nht : Set.Nonempty t\n\u22a2 s = \u2205 \u2227 s\u2081 = \u2205 \u2192 s = s\u2081", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nht : Set.Nonempty t\n\u22a2 \u2205 = \u2205"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ns\u2082 : Set \u03b1\nt t\u2081 t\u2082 : Set \u03b2\na : \u03b1\nb : \u03b2\nht : Set.Nonempty t\n\u22a2 \u2205 = \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.withTopEquiv_symm_zero", "start": [728, 1], "end": [729, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.coe_ofRepr", "start": [128, 1], "end": [129, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean", "full_name": "Finsupp.toDFinsupp_single", "start": [88, 1], "end": [91, 53], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero M\ni : \u03b9\nm : M\n\u22a2 (toDFinsupp fun\u2080 | i => m) = DFinsupp.single i m", "state_after": "case h\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero M\ni : \u03b9\nm : M\ni\u271d : \u03b9\n\u22a2 \u2191(toDFinsupp fun\u2080 | i => m) i\u271d = \u2191(DFinsupp.single i m) i\u271d"}, {"tactic": "simp [Finsupp.single_apply, DFinsupp.single_apply]", "annotated_tactic": ["simp [<a>Finsupp.single_apply</a>, <a>DFinsupp.single_apply</a>]", [{"full_name": "Finsupp.single_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [307, 9], "def_end_pos": [307, 21]}, {"full_name": "DFinsupp.single_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/DFinsupp/Basic.lean", "def_pos": [649, 9], "def_end_pos": [649, 21]}]], "state_before": "case h\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero M\ni : \u03b9\nm : M\ni\u271d : \u03b9\n\u22a2 \u2191(toDFinsupp fun\u2080 | i => m) i\u271d = \u2191(DFinsupp.single i m) i\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "associated_eq_eq", "start": [720, 1], "end": [722, 25], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Unique \u03b1\u02e3\n\u22a2 Associated = Eq", "state_after": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Unique \u03b1\u02e3\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 x\u271d\u00b9 ~\u1d64 x\u271d \u2194 x\u271d\u00b9 = x\u271d"}, {"tactic": "rw [associated_iff_eq]", "annotated_tactic": ["rw [<a>associated_iff_eq</a>]", [{"full_name": "associated_iff_eq", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Associated.lean", "def_pos": [712, 9], "def_end_pos": [712, 26]}]], "state_before": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Unique \u03b1\u02e3\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 x\u271d\u00b9 ~\u1d64 x\u271d \u2194 x\u271d\u00b9 = x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Max.lean", "full_name": "isMin_ofDual_iff", "start": [262, 1], "end": [263, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Projection.lean", "full_name": "LinearMap.coe_equivProdOfSurjectiveOfIsCompl", "start": [328, 1], "end": [330, 85], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "iSup_emptyset", "start": [1471, 1], "end": [1471, 74], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b2\u2082 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\n\u03ba : \u03b9 \u2192 Sort u_7\n\u03ba' : \u03b9' \u2192 Sort u_8\ninst\u271d : CompleteLattice \u03b1\nf\u271d g s t : \u03b9 \u2192 \u03b1\na b : \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2a06 x \u2208 \u2205, f x = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.castSucc_pos", "start": [384, 1], "end": [385, 25], "traced_tactics": [{"tactic": "simpa [lt_def] using h", "annotated_tactic": ["simpa [<a>lt_def</a>] using h", [{"full_name": "Fin.lt_def", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [82, 9], "def_end_pos": [82, 15]}]], "state_before": "n : Nat\ni : Fin (n + 1)\nh : 0 < i\n\u22a2 0 < castSucc i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.seq_eq_filter_seq", "start": [2780, 1], "end": [2782, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "IsCompl.sup_eq_top", "start": [503, 1], "end": [504, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Ring/Equiv.lean", "full_name": "RingEquiv.symm_trans_self", "start": [872, 1], "end": [873, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "List.SublistForall\u2082.prod_le_prod'", "start": [299, 1], "end": [304, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Log.lean", "full_name": "Nat.clog_one_left", "start": [265, 1], "end": [266, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.ball_image_iff", "start": [249, 1], "end": [250, 54], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b1 \u2192 \u03b2\ns\u271d t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 y \u2208 f '' s, p y) \u2194 \u2200 x \u2208 s, p (f x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Vandermonde.lean", "full_name": "Matrix.det_vandermonde_eq_zero_iff", "start": [140, 1], "end": [148, 50], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 det (vandermonde v) = 0 \u2194 \u2203 i j, v i = v j \u2227 i \u2260 j", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 det (vandermonde v) = 0 \u2192 \u2203 i j, v i = v j \u2227 i \u2260 j\n\ncase mpr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 (\u2203 i j, v i = v j \u2227 i \u2260 j) \u2192 det (vandermonde v) = 0"}, {"tactic": "simp only [det_vandermonde v, Finset.prod_eq_zero_iff, sub_eq_zero, forall_exists_index]", "annotated_tactic": ["simp only [<a>det_vandermonde</a> v, <a>Finset.prod_eq_zero_iff</a>, <a>sub_eq_zero</a>, <a>forall_exists_index</a>]", [{"full_name": "Matrix.det_vandermonde", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Vandermonde.lean", "def_pos": [75, 9], "def_end_pos": [75, 24]}, {"full_name": "Finset.prod_eq_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1939, 9], "def_end_pos": [1939, 25]}, {"full_name": "sub_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [801, 3], "def_end_pos": [801, 14]}, {"full_name": "forall_exists_index", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [362, 17], "def_end_pos": [362, 36]}]], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 det (vandermonde v) = 0 \u2192 \u2203 i j, v i = v j \u2227 i \u2260 j", "state_after": "case mp\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 \u2200 (x : Fin n), (x \u2208 univ \u2227 \u2203 a \u2208 Ioi x, v a = v x) \u2192 \u2203 i j, v i = v j \u2227 i \u2260 j"}, {"tactic": "rintro i \u27e8_, j, h\u2081, h\u2082\u27e9", "annotated_tactic": ["rintro i \u27e8_, j, h\u2081, h\u2082\u27e9", []], "state_before": "case mp\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 \u2200 (x : Fin n), (x \u2208 univ \u2227 \u2203 a \u2208 Ioi x, v a = v x) \u2192 \u2203 i j, v i = v j \u2227 i \u2260 j", "state_after": "case mp.intro.intro.intro\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\ni : Fin n\nleft\u271d : i \u2208 univ\nj : Fin n\nh\u2081 : j \u2208 Ioi i\nh\u2082 : v j = v i\n\u22a2 \u2203 i j, v i = v j \u2227 i \u2260 j"}, {"tactic": "exact \u27e8j, i, h\u2082, (mem_Ioi.mp h\u2081).ne'\u27e9", "annotated_tactic": ["exact \u27e8j, i, h\u2082, (mem_Ioi.mp h\u2081).<a>ne'</a>\u27e9", [{"full_name": "LT.lt.ne'", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [328, 9], "def_end_pos": [328, 12]}]], "state_before": "case mp.intro.intro.intro\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\ni : Fin n\nleft\u271d : i \u2208 univ\nj : Fin n\nh\u2081 : j \u2208 Ioi i\nh\u2082 : v j = v i\n\u22a2 \u2203 i j, v i = v j \u2227 i \u2260 j", "state_after": "no goals"}, {"tactic": "simp only [Ne.def, forall_exists_index, and_imp]", "annotated_tactic": ["simp only [<a>Ne.def</a>, <a>forall_exists_index</a>, <a>and_imp</a>]", [{"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "forall_exists_index", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [362, 17], "def_end_pos": [362, 36]}, {"full_name": "and_imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [319, 17], "def_end_pos": [319, 24]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 (\u2203 i j, v i = v j \u2227 i \u2260 j) \u2192 det (vandermonde v) = 0", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 \u2200 (x x_1 : Fin n), v x = v x_1 \u2192 \u00acx = x_1 \u2192 det (vandermonde v) = 0"}, {"tactic": "refine' fun i j h\u2081 h\u2082 => Matrix.det_zero_of_row_eq h\u2082 (funext fun k => _)", "annotated_tactic": ["refine' fun i j h\u2081 h\u2082 => <a>Matrix.det_zero_of_row_eq</a> h\u2082 (<a>funext</a> fun k => _)", [{"full_name": "Matrix.det_zero_of_row_eq", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [376, 9], "def_end_pos": [376, 27]}, {"full_name": "funext", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [1555, 9], "def_end_pos": [1555, 15]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\n\u22a2 \u2200 (x x_1 : Fin n), v x = v x_1 \u2192 \u00acx = x_1 \u2192 det (vandermonde v) = 0", "state_after": "case mpr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\ni j : Fin n\nh\u2081 : v i = v j\nh\u2082 : \u00aci = j\nk : Fin n\n\u22a2 vandermonde v i k = vandermonde v j k"}, {"tactic": "rw [vandermonde_apply, vandermonde_apply, h\u2081]", "annotated_tactic": ["rw [<a>vandermonde_apply</a>, <a>vandermonde_apply</a>, h\u2081]", [{"full_name": "Matrix.vandermonde_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Vandermonde.lean", "def_pos": [43, 9], "def_end_pos": [43, 26]}, {"full_name": "Matrix.vandermonde_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Vandermonde.lean", "def_pos": [43, 9], "def_end_pos": [43, 26]}]], "state_before": "case mpr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nn : \u2115\nv : Fin n \u2192 R\ni j : Fin n\nh\u2081 : v i = v j\nh\u2082 : \u00aci = j\nk : Fin n\n\u22a2 vandermonde v i k = vandermonde v j k", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "sInf_singleton", "start": [313, 1], "end": [314, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.characteristic_iff_comap_le", "start": [2031, 1], "end": [2034, 98], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.getI_cons_zero", "start": [4380, 1], "end": [4381, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "full_name": "OrderedCancelCommMonoid.lt_of_mul_lt_mul_left", "start": [57, 1], "end": [58, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "pow_bit0_nonneg", "start": [295, 1], "end": [297, 26], "traced_tactics": [{"tactic": "rw [pow_bit0]", "annotated_tactic": ["rw [<a>pow_bit0</a>]", [{"full_name": "pow_bit0", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [197, 9], "def_end_pos": [197, 17]}]], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : LinearOrderedRing R\na : R\nn : \u2115\n\u22a2 0 \u2264 a ^ bit0 n", "state_after": "M : Type u_1\nR : Type u_2\ninst\u271d : LinearOrderedRing R\na : R\nn : \u2115\n\u22a2 0 \u2264 a ^ n * a ^ n"}, {"tactic": "exact mul_self_nonneg _", "annotated_tactic": ["exact <a>mul_self_nonneg</a> _", [{"full_name": "mul_self_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [1090, 9], "def_end_pos": [1090, 24]}]], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : LinearOrderedRing R\na : R\nn : \u2115\n\u22a2 0 \u2264 a ^ n * a ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Finsupp.lean", "full_name": "Finsupp.mapRange.linearEquiv_refl", "start": [866, 1], "end": [868, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioc_subset_Ioc_union_Ioc", "start": [1612, 1], "end": [1613, 84], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "full_name": "Subgroup.closure_induction_right", "start": [80, 1], "end": [84, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.zipWithAll_get?", "start": [210, 1], "end": [221, 40], "traced_tactics": [{"tactic": "induction as generalizing bs i with\n| nil => induction bs generalizing i with\n  | nil => simp\n  | cons b bs bih => cases i <;> simp_all\n| cons a as aih => cases bs with\n  | nil =>\n    specialize @aih []\n    cases i <;> simp_all\n  | cons b bs => cases i <;> simp_all", "annotated_tactic": ["induction as generalizing bs i with\n  | <a>nil</a> => induction bs generalizing i with\n    | <a>nil</a> => simp\n    | <a>cons</a> b bs bih => cases i <;> simp_all\n  | <a>cons</a> a as aih => cases bs with\n    | <a>nil</a> =>\n      specialize @aih []\n      cases i <;> simp_all\n    | <a>cons</a> b bs => cases i <;> simp_all", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nas : List \u03b1\nbs : List \u03b2\ni : Nat\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\n\u22a2 get? (zipWithAll f as bs) i =\n    match get? as i, get? bs i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "no goals"}, {"tactic": "induction bs generalizing i with\n| nil => simp\n| cons b bs bih => cases i <;> simp_all", "annotated_tactic": ["induction bs generalizing i with\n    | <a>nil</a> => simp\n    | <a>cons</a> b bs bih => cases i <;> simp_all", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nbs : List \u03b2\ni : Nat\n\u22a2 get? (zipWithAll f [] bs) i =\n    match get? [] i, get? bs i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case nil.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\ni : Nat\n\u22a2 get? (zipWithAll f [] []) i =\n    match get? [] i, get? [] i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "no goals"}, {"tactic": "cases i <;> simp_all", "annotated_tactic": ["cases i <;> simp_all", []], "state_before": "case nil.cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\nb : \u03b2\nbs : List \u03b2\nbih :\n  \u2200 {i : Nat},\n    get? (zipWithAll f [] bs) i =\n      match get? [] i, get? bs i with\n      | none, none => none\n      | a?, b? => some (f a? b?)\ni : Nat\n\u22a2 get? (zipWithAll f [] (b :: bs)) i =\n    match get? [] i, get? (b :: bs) i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "no goals"}, {"tactic": "cases bs with\n| nil =>\nspecialize @aih []\ncases i <;> simp_all\n| cons b bs => cases i <;> simp_all", "annotated_tactic": ["cases bs with\n    | <a>nil</a> =>\n      specialize @aih []\n      cases i <;> simp_all\n    | <a>cons</a> b bs => cases i <;> simp_all", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}]], "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\naih :\n  \u2200 {bs : List \u03b2} {i : Nat},\n    get? (zipWithAll f as bs) i =\n      match get? as i, get? bs i with\n      | none, none => none\n      | a?, b? => some (f a? b?)\nbs : List \u03b2\ni : Nat\n\u22a2 get? (zipWithAll f (a :: as) bs) i =\n    match get? (a :: as) i, get? bs i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "no goals"}, {"tactic": "specialize @aih []", "annotated_tactic": ["specialize @aih []", []], "state_before": "case cons.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\naih :\n  \u2200 {bs : List \u03b2} {i : Nat},\n    get? (zipWithAll f as bs) i =\n      match get? as i, get? bs i with\n      | none, none => none\n      | a?, b? => some (f a? b?)\ni : Nat\n\u22a2 get? (zipWithAll f (a :: as) []) i =\n    match get? (a :: as) i, get? [] i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "case cons.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\ni : Nat\naih :\n  \u2200 {i : Nat},\n    get? (zipWithAll f as []) i =\n      match get? as i, get? [] i with\n      | none, none => none\n      | a?, b? => some (f a? b?)\n\u22a2 get? (zipWithAll f (a :: as) []) i =\n    match get? (a :: as) i, get? [] i with\n    | none, none => none\n    | a?, b? => some (f a? b?)"}, {"tactic": "cases i <;> simp_all", "annotated_tactic": ["cases i <;> simp_all", []], "state_before": "case cons.nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\ni : Nat\naih :\n  \u2200 {i : Nat},\n    get? (zipWithAll f as []) i =\n      match get? as i, get? [] i with\n      | none, none => none\n      | a?, b? => some (f a? b?)\n\u22a2 get? (zipWithAll f (a :: as) []) i =\n    match get? (a :: as) i, get? [] i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "no goals"}, {"tactic": "cases i <;> simp_all", "annotated_tactic": ["cases i <;> simp_all", []], "state_before": "case cons.cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3\na : \u03b1\nas : List \u03b1\naih :\n  \u2200 {bs : List \u03b2} {i : Nat},\n    get? (zipWithAll f as bs) i =\n      match get? as i, get? bs i with\n      | none, none => none\n      | a?, b? => some (f a? b?)\ni : Nat\nb : \u03b2\nbs : List \u03b2\n\u22a2 get? (zipWithAll f (a :: as) (b :: bs)) i =\n    match get? (a :: as) i, get? (b :: bs) i with\n    | none, none => none\n    | a?, b? => some (f a? b?)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.natDegree_smul_le", "start": [1140, 1], "end": [1141, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Data/Nat/Bitwise.lean", "full_name": "Nat.bodd_add_div2", "start": [126, 1], "end": [133, 50], "traced_tactics": [{"tactic": "simp only [bodd_succ, Bool.cond_not, div2_succ, Nat.mul_comm]", "annotated_tactic": ["simp only [<a>bodd_succ</a>, <a>Bool.cond_not</a>, <a>div2_succ</a>, <a>Nat.mul_comm</a>]", [{"full_name": "Nat.bodd_succ", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [68, 9], "def_end_pos": [68, 18]}, {"full_name": "Bool.cond_not", "def_path": "lake-packages/mathlib/Mathlib/Data/Bool/Basic.lean", "def_pos": [133, 9], "def_end_pos": [133, 17]}, {"full_name": "Nat.div2_succ", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [114, 9], "def_end_pos": [114, 18]}, {"full_name": "Nat.mul_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [174, 19], "def_end_pos": [174, 27]}]], "state_before": "n : \u2115\n\u22a2 (bif bodd (succ n) then 1 else 0) + 2 * div2 (succ n) = succ n", "state_after": "n : \u2115\n\u22a2 (bif bodd n then 0 else 1) + (bif bodd n then succ (div2 n) else div2 n) * 2 = succ n"}, {"tactic": "refine' Eq.trans _ (congr_arg succ (bodd_add_div2 n))", "annotated_tactic": ["refine' <a>Eq.trans</a> _ (<a>congr_arg</a> <a>succ</a> (bodd_add_div2 n))", [{"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}, {"full_name": "congr_arg", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [43, 7], "def_end_pos": [43, 16]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}]], "state_before": "n : \u2115\n\u22a2 (bif bodd n then 0 else 1) + (bif bodd n then succ (div2 n) else div2 n) * 2 = succ n", "state_after": "n : \u2115\n\u22a2 (bif bodd n then 0 else 1) + (bif bodd n then succ (div2 n) else div2 n) * 2 =\n    succ ((bif bodd n then 1 else 0) + 2 * div2 n)"}, {"tactic": "cases bodd n <;> simp [cond, not]", "annotated_tactic": ["cases <a>bodd</a> n <;> simp [<a>cond</a>, <a>not</a>]", [{"full_name": "Nat.bodd", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [50, 5], "def_end_pos": [50, 9]}, {"full_name": "cond", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [971, 21], "def_end_pos": [971, 25]}, {"full_name": "not", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1002, 15], "def_end_pos": [1002, 18]}]], "state_before": "n : \u2115\n\u22a2 (bif bodd n then 0 else 1) + (bif bodd n then succ (div2 n) else div2 n) * 2 =\n    succ ((bif bodd n then 1 else 0) + 2 * div2 n)", "state_after": "case false\nn : \u2115\n\u22a2 1 + div2 n * 2 = succ (div2 n * 2)\n\ncase true\nn : \u2115\n\u22a2 succ (div2 n) * 2 = succ (1 + div2 n * 2)"}, {"tactic": "rw [Nat.add_comm, Nat.add_succ]", "annotated_tactic": ["rw [<a>Nat.add_comm</a>, <a>Nat.add_succ</a>]", [{"full_name": "Nat.add_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "Nat.add_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}]], "state_before": "case false\nn : \u2115\n\u22a2 1 + div2 n * 2 = succ (div2 n * 2)", "state_after": "no goals"}, {"tactic": "rw [succ_mul, Nat.add_comm 1, Nat.add_succ]", "annotated_tactic": ["rw [<a>succ_mul</a>, <a>Nat.add_comm</a> 1, <a>Nat.add_succ</a>]", [{"full_name": "Nat.succ_mul", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [169, 9], "def_end_pos": [169, 17]}, {"full_name": "Nat.add_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "Nat.add_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [122, 9], "def_end_pos": [122, 17]}]], "state_before": "case true\nn : \u2115\n\u22a2 succ (div2 n) * 2 = succ (1 + div2 n * 2)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Sort.lean", "full_name": "Multiset.sort_sorted", "start": [40, 1], "end": [41, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.nonempty_of_ssubset", "start": [478, 1], "end": [479, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Regular/Basic.lean", "full_name": "not_isRightRegular_zero", "start": [265, 1], "end": [266, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.image_eq_preimage", "start": [563, 11], "end": [564, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "full_name": "Polynomial.le_trailingDegree_mul", "start": [358, 1], "end": [366, 66], "traced_tactics": [{"tactic": "refine' Finset.le_min fun n hn => _", "annotated_tactic": ["refine' <a>Finset.le_min</a> fun n hn => _", [{"full_name": "Finset.le_min", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1395, 19], "def_end_pos": [1395, 25]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\n\u22a2 trailingDegree p + trailingDegree q \u2264 trailingDegree (p * q)", "state_after": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : n \u2208 support (p * q)\n\u22a2 trailingDegree p + trailingDegree q \u2264 \u2191n"}, {"tactic": "rw [mem_support_iff, coeff_mul] at hn", "annotated_tactic": ["rw [<a>mem_support_iff</a>, <a>coeff_mul</a>] at hn", [{"full_name": "Polynomial.mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [732, 9], "def_end_pos": [732, 24]}, {"full_name": "Polynomial.coeff_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Coeff.lean", "def_pos": [116, 9], "def_end_pos": [116, 18]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : n \u2208 support (p * q)\n\u22a2 trailingDegree p + trailingDegree q \u2264 \u2191n", "state_after": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : \u2211 x in antidiagonal n, coeff p x.1 * coeff q x.2 \u2260 0\n\u22a2 trailingDegree p + trailingDegree q \u2264 \u2191n"}, {"tactic": "obtain \u27e8\u27e8i, j\u27e9, hij, hpq\u27e9 := exists_ne_zero_of_sum_ne_zero hn", "annotated_tactic": ["obtain \u27e8\u27e8i, j\u27e9, hij, hpq\u27e9 := <a>exists_ne_zero_of_sum_ne_zero</a> hn", [{"full_name": "Finset.exists_ne_zero_of_sum_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1209, 3], "def_end_pos": [1209, 14]}]], "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : \u2211 x in antidiagonal n, coeff p x.1 * coeff q x.2 \u2260 0\n\u22a2 trailingDegree p + trailingDegree q \u2264 \u2191n", "state_after": "case intro.mk.intro\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : \u2211 x in antidiagonal n, coeff p x.1 * coeff q x.2 \u2260 0\ni j : \u2115\nhij : (i, j) \u2208 antidiagonal n\nhpq : coeff p (i, j).1 * coeff q (i, j).2 \u2260 0\n\u22a2 trailingDegree p + trailingDegree q \u2264 \u2191n"}, {"tactic": "refine'\n  (add_le_add (min_le (mem_support_iff.mpr (left_ne_zero_of_mul hpq)))\n        (min_le (mem_support_iff.mpr (right_ne_zero_of_mul hpq)))).trans\n    (le_of_eq _)", "annotated_tactic": ["refine'\n    (<a>add_le_add</a> (<a>min_le</a> (mem_support_iff.mpr (<a>left_ne_zero_of_mul</a> hpq)))\n          (<a>min_le</a> (mem_support_iff.mpr (<a>right_ne_zero_of_mul</a> hpq)))).<a>trans</a>\n      (<a>le_of_eq</a> _)", [{"full_name": "add_le_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 15], "def_end_pos": [205, 25]}, {"full_name": "Finset.min_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1375, 9], "def_end_pos": [1375, 15]}, {"full_name": "left_ne_zero_of_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [51, 9], "def_end_pos": [51, 28]}, {"full_name": "Finset.min_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1375, 9], "def_end_pos": [1375, 15]}, {"full_name": "right_ne_zero_of_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Basic.lean", "def_pos": [55, 9], "def_end_pos": [55, 29]}, {"full_name": "LE.le.trans", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [120, 7], "def_end_pos": [120, 18]}, {"full_name": "le_of_eq", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [72, 9], "def_end_pos": [72, 17]}]], "state_before": "case intro.mk.intro\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : \u2211 x in antidiagonal n, coeff p x.1 * coeff q x.2 \u2260 0\ni j : \u2115\nhij : (i, j) \u2208 antidiagonal n\nhpq : coeff p (i, j).1 * coeff q (i, j).2 \u2260 0\n\u22a2 trailingDegree p + trailingDegree q \u2264 \u2191n", "state_after": "case intro.mk.intro\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : \u2211 x in antidiagonal n, coeff p x.1 * coeff q x.2 \u2260 0\ni j : \u2115\nhij : (i, j) \u2208 antidiagonal n\nhpq : coeff p (i, j).1 * coeff q (i, j).2 \u2260 0\n\u22a2 \u2191(i, j).1 + \u2191(i, j).2 = \u2191n"}, {"tactic": "rwa [\u2190 WithTop.coe_add, WithTop.coe_eq_coe, \u2190 mem_antidiagonal]", "annotated_tactic": ["rwa [\u2190 <a>WithTop.coe_add</a>, <a>WithTop.coe_eq_coe</a>, \u2190 <a>mem_antidiagonal</a>]", [{"full_name": "WithTop.coe_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/WithTop.lean", "def_pos": [122, 9], "def_end_pos": [122, 16]}, {"full_name": "WithTop.coe_eq_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [728, 9], "def_end_pos": [728, 19]}, {"full_name": "Finset.HasAntidiagonal.mem_antidiagonal", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Antidiagonal.lean", "def_pos": [62, 3], "def_end_pos": [62, 19]}]], "state_before": "case intro.mk.intro\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : \u2211 x in antidiagonal n, coeff p x.1 * coeff q x.2 \u2260 0\ni j : \u2115\nhij : (i, j) \u2208 antidiagonal n\nhpq : coeff p (i, j).1 * coeff q (i, j).2 \u2260 0\n\u22a2 \u2191(i, j).1 + \u2191(i, j).2 = \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.mem_of_mem_inter_right", "start": [914, 1], "end": [915, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "full_name": "Left.neg_of_mul_neg_right", "start": [588, 1], "end": [589, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.mem_seq_def", "start": [2698, 1], "end": [2700, 10], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Dynamics/FixedPoints/Basic.lean", "full_name": "Function.bijOn_fixedPoints_comp", "start": [176, 1], "end": [178, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.eventually_inf", "start": [1245, 1], "end": [1247, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Finite.lean", "full_name": "Set.Finite.toFinset_subset_toFinset", "start": [218, 11], "end": [219, 55], "traced_tactics": [{"tactic": "simp only [\u2190 Finset.coe_subset, Finite.coe_toFinset]", "annotated_tactic": ["simp only [\u2190 <a>Finset.coe_subset</a>, <a>Finite.coe_toFinset</a>]", [{"full_name": "Finset.coe_subset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [377, 9], "def_end_pos": [377, 19]}, {"full_name": "Set.Finite.coe_toFinset", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Finite.lean", "def_pos": [178, 19], "def_end_pos": [178, 31]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns t : Set \u03b1\na : \u03b1\nhs : Set.Finite s\nht : Set.Finite t\n\u22a2 Finite.toFinset hs \u2286 Finite.toFinset ht \u2194 s \u2286 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Finite.lean", "full_name": "Subgroup.val_list_prod", "start": [90, 1], "end": [91, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Equiv.lean", "full_name": "LinearEquiv.toFun_eq_coe", "start": [226, 1], "end": [226, 42], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Lattice.lean", "full_name": "Set.iUnion_subset", "start": [390, 1], "end": [391, 12], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "full_name": "Matrix.toLinAlgEquiv_apply", "start": [769, 1], "end": [772, 61], "traced_tactics": [{"tactic": "rw [Matrix.toLinAlgEquiv'_apply, v\u2081.equivFun_symm_apply]", "annotated_tactic": ["rw [<a>Matrix.toLinAlgEquiv'_apply</a>, v\u2081.equivFun_symm_apply]", [{"full_name": "Matrix.toLinAlgEquiv'_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Matrix/ToLin.lean", "def_pos": [481, 9], "def_end_pos": [481, 36]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst\u271d\u2078 : Fintype n\ninst\u271d\u2077 : Fintype m\ninst\u271d\u2076 : DecidableEq n\nM\u2081 : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\u2081\ninst\u271d\u00b2 : Module R M\u2082\nv\u2081 : Basis n R M\u2081\nv\u2082 : Basis m R M\u2082\nM\u2083 : Type u_7\ninst\u271d\u00b9 : AddCommMonoid M\u2083\ninst\u271d : Module R M\u2083\nv\u2083 : Basis l R M\u2083\nM : Matrix n n R\nv : M\u2081\n\u22a2 \u2191(LinearEquiv.symm (Basis.equivFun v\u2081)) (\u2191(\u2191toLinAlgEquiv' M) \u2191(\u2191v\u2081.repr v)) =\n    \u2211 j : n, mulVec M (\u2191(\u2191v\u2081.repr v)) j \u2022 \u2191v\u2081 j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/OrderOfElement.lean", "full_name": "isOfFinOrder_iff_coe", "start": [89, 1], "end": [91, 12], "traced_tactics": [{"tactic": "rw [isOfFinOrder_iff_pow_eq_one, isOfFinOrder_iff_pow_eq_one]", "annotated_tactic": ["rw [<a>isOfFinOrder_iff_pow_eq_one</a>, <a>isOfFinOrder_iff_pow_eq_one</a>]", [{"full_name": "isOfFinOrder_iff_pow_eq_one", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [70, 9], "def_end_pos": [70, 36]}, {"full_name": "isOfFinOrder_iff_pow_eq_one", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/OrderOfElement.lean", "def_pos": [70, 9], "def_end_pos": [70, 36]}]], "state_before": "G : Type u_1\nH\u271d : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn m : \u2115\nH : Submonoid G\nx : \u21a5H\n\u22a2 IsOfFinOrder x \u2194 IsOfFinOrder \u2191x", "state_after": "G : Type u_1\nH\u271d : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn m : \u2115\nH : Submonoid G\nx : \u21a5H\n\u22a2 (\u2203 n, 0 < n \u2227 x ^ n = 1) \u2194 \u2203 n, 0 < n \u2227 \u2191x ^ n = 1"}, {"tactic": "norm_cast", "annotated_tactic": ["norm_cast", []], "state_before": "G : Type u_1\nH\u271d : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid G\ninst\u271d : AddMonoid A\nx\u271d y : G\na b : A\nn m : \u2115\nH : Submonoid G\nx : \u21a5H\n\u22a2 (\u2203 n, 0 < n \u2227 x ^ n = 1) \u2194 \u2203 n, 0 < n \u2227 \u2191x ^ n = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Embedding/Basic.lean", "full_name": "Equiv.embeddingCongr_refl", "start": [427, 1], "end": [429, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/ModEq.lean", "full_name": "Nat.ModEq.dvd_iff", "start": [254, 1], "end": [257, 32], "traced_tactics": [{"tactic": "simp only [\u2190 modEq_zero_iff_dvd]", "annotated_tactic": ["simp only [\u2190 <a>modEq_zero_iff_dvd</a>]", [{"full_name": "Nat.modEq_zero_iff_dvd", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/ModEq.lean", "def_pos": [77, 9], "def_end_pos": [77, 27]}]], "state_before": "m n a b c d : \u2115\nh : a \u2261 b [MOD m]\nhdm : d \u2223 m\n\u22a2 d \u2223 a \u2194 d \u2223 b", "state_after": "m n a b c d : \u2115\nh : a \u2261 b [MOD m]\nhdm : d \u2223 m\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]"}, {"tactic": "replace h := h.of_dvd hdm", "annotated_tactic": ["replace h := h.of_dvd hdm", []], "state_before": "m n a b c d : \u2115\nh : a \u2261 b [MOD m]\nhdm : d \u2223 m\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]", "state_after": "m n a b c d : \u2115\nhdm : d \u2223 m\nh : a \u2261 b [MOD d]\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]"}, {"tactic": "exact \u27e8h.symm.trans, h.trans\u27e9", "annotated_tactic": ["exact \u27e8h.symm.trans, h.trans\u27e9", []], "state_before": "m n a b c d : \u2115\nhdm : d \u2223 m\nh : a \u2261 b [MOD d]\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.prod_inv", "start": [1824, 1], "end": [1826, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/BinomialHeap/Basic.lean", "full_name": "Std.BinomialHeap.Imp.HeapNode.WF.toHeap", "start": [414, 1], "end": [420, 75], "traced_tactics": [{"tactic": "rw [\u2190 h'.rank_eq] at h", "annotated_tactic": ["rw [\u2190 h'.rank_eq] at h", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na\u271d : \u03b1\nn\u271d : Nat\ns\u271d : HeapNode \u03b1\nh\u271d : WF le a\u271d s\u271d n\u271d\nres : Heap \u03b1\na : \u03b1\nc s : HeapNode \u03b1\nn : Nat\nleft\u271d : \u2200 [inst : TotalBLE le], le a\u271d a = true\nh : WF le a c n\nh' : WF le a\u271d s n\nhr : Heap.WF le (rank (node a c s)) res\n\u22a2 WF le a c (rank (node a c s) - 1)", "state_after": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na\u271d : \u03b1\nn\u271d : Nat\ns\u271d : HeapNode \u03b1\nh\u271d : WF le a\u271d s\u271d n\u271d\nres : Heap \u03b1\na : \u03b1\nc s : HeapNode \u03b1\nn : Nat\nleft\u271d : \u2200 [inst : TotalBLE le], le a\u271d a = true\nh : WF le a c (rank s)\nh' : WF le a\u271d s n\nhr : Heap.WF le (rank (node a c s)) res\n\u22a2 WF le a c (rank (node a c s) - 1)"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na\u271d : \u03b1\nn\u271d : Nat\ns\u271d : HeapNode \u03b1\nh\u271d : WF le a\u271d s\u271d n\u271d\nres : Heap \u03b1\na : \u03b1\nc s : HeapNode \u03b1\nn : Nat\nleft\u271d : \u2200 [inst : TotalBLE le], le a\u271d a = true\nh : WF le a c (rank s)\nh' : WF le a\u271d s n\nhr : Heap.WF le (rank (node a c s)) res\n\u22a2 WF le a c (rank (node a c s) - 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.subtypeDomain_sum", "start": [1100, 1], "end": [1102, 64], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.ringHom_ext", "start": [763, 1], "end": [770, 96], "traced_tactics": [{"tactic": "rw [\u2190 single, \u2190 one_mul a, \u2190 mul_one b, \u2190 single_mul_single]", "annotated_tactic": ["rw [\u2190 <a>single</a>, \u2190 <a>one_mul</a> a, \u2190 <a>mul_one</a> b, \u2190 <a>single_mul_single</a>]", [{"full_name": "MonoidAlgebra.single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [113, 8], "def_end_pos": [113, 14]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}, {"full_name": "MonoidAlgebra.single_mul_single", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [449, 9], "def_end_pos": [449, 26]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR\u271d : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : MulOneClass G\ninst\u271d : Semiring R\nf g : MonoidAlgebra k G \u2192+* R\nh\u2081 : \u2200 (b : k), \u2191f (single 1 b) = \u2191g (single 1 b)\nh_of : \u2200 (a : G), \u2191f (single a 1) = \u2191g (single a 1)\na : G\nb : k\n\u22a2 (\u2191((fun f => \u2191f) f) fun\u2080 | a => b) = \u2191((fun f => \u2191f) g) fun\u2080 | a => b", "state_after": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR\u271d : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : MulOneClass G\ninst\u271d : Semiring R\nf g : MonoidAlgebra k G \u2192+* R\nh\u2081 : \u2200 (b : k), \u2191f (single 1 b) = \u2191g (single 1 b)\nh_of : \u2200 (a : G), \u2191f (single a 1) = \u2191g (single a 1)\na : G\nb : k\n\u22a2 \u2191((fun f => \u2191f) f) (single 1 b * single a 1) = \u2191((fun f => \u2191f) g) (single 1 b * single a 1)"}, {"tactic": "erw [AddMonoidHom.coe_coe f, AddMonoidHom.coe_coe g]", "annotated_tactic": ["erw [<a>AddMonoidHom.coe_coe</a> f, <a>AddMonoidHom.coe_coe</a> g]", [{"full_name": "AddMonoidHom.coe_coe", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [394, 3], "def_end_pos": [394, 14]}, {"full_name": "AddMonoidHom.coe_coe", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [394, 3], "def_end_pos": [394, 14]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR\u271d : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : MulOneClass G\ninst\u271d : Semiring R\nf g : MonoidAlgebra k G \u2192+* R\nh\u2081 : \u2200 (b : k), \u2191f (single 1 b) = \u2191g (single 1 b)\nh_of : \u2200 (a : G), \u2191f (single a 1) = \u2191g (single a 1)\na : G\nb : k\n\u22a2 \u2191((fun f => \u2191f) f) (single 1 b * single a 1) = \u2191((fun f => \u2191f) g) (single 1 b * single a 1)", "state_after": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR\u271d : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : MulOneClass G\ninst\u271d : Semiring R\nf g : MonoidAlgebra k G \u2192+* R\nh\u2081 : \u2200 (b : k), \u2191f (single 1 b) = \u2191g (single 1 b)\nh_of : \u2200 (a : G), \u2191f (single a 1) = \u2191g (single a 1)\na : G\nb : k\n\u22a2 \u2191f (single 1 b * single a 1) = \u2191g (single 1 b * single a 1)"}, {"tactic": "rw [f.map_mul, g.map_mul, h\u2081, h_of]", "annotated_tactic": ["rw [f.map_mul, g.map_mul, h\u2081, h_of]", []], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR\u271d : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : MulOneClass G\ninst\u271d : Semiring R\nf g : MonoidAlgebra k G \u2192+* R\nh\u2081 : \u2200 (b : k), \u2191f (single 1 b) = \u2191g (single 1 b)\nh_of : \u2200 (a : G), \u2191f (single a 1) = \u2191g (single a 1)\na : G\nb : k\n\u22a2 \u2191f (single 1 b * single a 1) = \u2191g (single 1 b * single a 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Matrix/Determinant.lean", "full_name": "Matrix.coe_det_isEmpty", "start": [104, 1], "end": [106, 20], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "m : Type u_1\nn : Type u_2\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nR : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsEmpty n\n\u22a2 det = const (Matrix n n R) 1", "state_after": "case h\nm : Type u_1\nn : Type u_2\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nR : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsEmpty n\nx\u271d : Matrix n n R\n\u22a2 det x\u271d = const (Matrix n n R) 1 x\u271d"}, {"tactic": "exact det_isEmpty", "annotated_tactic": ["exact <a>det_isEmpty</a>", [{"full_name": "Matrix.det_isEmpty", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Matrix/Determinant.lean", "def_pos": [100, 9], "def_end_pos": [100, 20]}]], "state_before": "case h\nm : Type u_1\nn : Type u_2\ninst\u271d\u2075 : DecidableEq n\ninst\u271d\u2074 : Fintype n\ninst\u271d\u00b3 : DecidableEq m\ninst\u271d\u00b2 : Fintype m\nR : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsEmpty n\nx\u271d : Matrix n n R\n\u22a2 det x\u271d = const (Matrix n n R) 1 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.coe_restrictScalars", "start": [1603, 1], "end": [1605, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "antitone_int_of_succ_le", "start": [1094, 1], "end": [1095, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.mem_inter_of_mem", "start": [1630, 1], "end": [1631, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/PairingHeap.lean", "full_name": "Std.PairingHeapImp.Heap.size_combine", "start": [130, 1], "end": [137, 8], "traced_tactics": [{"tactic": "unfold combine", "annotated_tactic": ["unfold <a>combine</a>", [{"full_name": "Std.PairingHeapImp.Heap.combine", "def_path": "lake-packages/std/Std/Data/PairingHeap.lean", "def_pos": [51, 19], "def_end_pos": [51, 31]}]], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns : Heap \u03b1\n\u22a2 size (combine le s) = size s", "state_after": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns : Heap \u03b1\n\u22a2 size\n      (match s with\n      | h\u2081@h_1:(node a child h\u2082@h:(node a_1 child_1 s)) => merge le (merge le h\u2081 h\u2082) (combine le s)\n      | h => h) =\n    size s"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns : Heap \u03b1\n\u22a2 size\n      (match s with\n      | h\u2081@h_1:(node a child h\u2082@h:(node a_1 child_1 s)) => merge le (merge le h\u2081 h\u2082) (combine le s)\n      | h => h) =\n    size s", "state_after": "case h_1\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d : Heap \u03b1\na\u271d\u00b9 : \u03b1\nchild\u271d\u00b9 : Heap \u03b1\na\u271d : \u03b1\nchild\u271d s\u271d : Heap \u03b1\n\u22a2 size (merge le (merge le (node a\u271d\u00b9 child\u271d\u00b9 (node a\u271d child\u271d s\u271d)) (node a\u271d child\u271d s\u271d)) (combine le s\u271d)) =\n    size (node a\u271d\u00b9 child\u271d\u00b9 (node a\u271d child\u271d s\u271d))\n\ncase h_2\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns x\u271d\u00b9 : Heap \u03b1\nx\u271d : \u2200 (a : \u03b1) (child : Heap \u03b1) (a_1 : \u03b1) (child_1 s_1 : Heap \u03b1), s = node a child (node a_1 child_1 s_1) \u2192 False\n\u22a2 size s = size s"}, {"tactic": "rename_i a\u2081 c\u2081 a\u2082 c\u2082 s", "annotated_tactic": ["rename_i a\u2081 c\u2081 a\u2082 c\u2082 s", []], "state_before": "case h_1\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d : Heap \u03b1\na\u271d\u00b9 : \u03b1\nchild\u271d\u00b9 : Heap \u03b1\na\u271d : \u03b1\nchild\u271d s\u271d : Heap \u03b1\n\u22a2 size (merge le (merge le (node a\u271d\u00b9 child\u271d\u00b9 (node a\u271d child\u271d s\u271d)) (node a\u271d child\u271d s\u271d)) (combine le s\u271d)) =\n    size (node a\u271d\u00b9 child\u271d\u00b9 (node a\u271d child\u271d s\u271d))", "state_after": "case h_1\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d : Heap \u03b1\na\u2081 : \u03b1\nc\u2081 : Heap \u03b1\na\u2082 : \u03b1\nc\u2082 s : Heap \u03b1\n\u22a2 size (merge le (merge le (node a\u2081 c\u2081 (node a\u2082 c\u2082 s)) (node a\u2082 c\u2082 s)) (combine le s)) =\n    size (node a\u2081 c\u2081 (node a\u2082 c\u2082 s))"}, {"tactic": "rw [size_merge le (noSibling_merge _ _ _) (noSibling_combine _ _),\n  size_merge_node, size_combine le s]", "annotated_tactic": ["rw [<a>size_merge</a> le (<a>noSibling_merge</a> _ _ _) (<a>noSibling_combine</a> _ _),\n      <a>size_merge_node</a>, size_combine le s]", [{"full_name": "Std.PairingHeapImp.Heap.size_merge", "def_path": "lake-packages/std/Std/Data/PairingHeap.lean", "def_pos": [124, 9], "def_end_pos": [124, 24]}, {"full_name": "Std.PairingHeapImp.Heap.noSibling_merge", "def_path": "lake-packages/std/Std/Data/PairingHeap.lean", "def_pos": [91, 9], "def_end_pos": [91, 29]}, {"full_name": "Std.PairingHeapImp.Heap.noSibling_combine", "def_path": "lake-packages/std/Std/Data/PairingHeap.lean", "def_pos": [96, 9], "def_end_pos": [96, 31]}, {"full_name": "Std.PairingHeapImp.Heap.size_merge_node", "def_path": "lake-packages/std/Std/Data/PairingHeap.lean", "def_pos": [120, 9], "def_end_pos": [120, 29]}]], "state_before": "case h_1\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d : Heap \u03b1\na\u2081 : \u03b1\nc\u2081 : Heap \u03b1\na\u2082 : \u03b1\nc\u2082 s : Heap \u03b1\n\u22a2 size (merge le (merge le (node a\u2081 c\u2081 (node a\u2082 c\u2082 s)) (node a\u2082 c\u2082 s)) (combine le s)) =\n    size (node a\u2081 c\u2081 (node a\u2082 c\u2082 s))", "state_after": "case h_1\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d : Heap \u03b1\na\u2081 : \u03b1\nc\u2081 : Heap \u03b1\na\u2082 : \u03b1\nc\u2082 s : Heap \u03b1\n\u22a2 size c\u2081 + size c\u2082 + 2 + size s = size (node a\u2081 c\u2081 (node a\u2082 c\u2082 s))"}, {"tactic": "simp_arith [size]", "annotated_tactic": ["simp_arith [<a>size</a>]", [{"full_name": "Std.PairingHeapImp.Heap.size", "def_path": "lake-packages/std/Std/Data/PairingHeap.lean", "def_pos": [30, 5], "def_end_pos": [30, 14]}]], "state_before": "case h_1\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\nx\u271d : Heap \u03b1\na\u2081 : \u03b1\nc\u2081 : Heap \u03b1\na\u2082 : \u03b1\nc\u2082 s : Heap \u03b1\n\u22a2 size c\u2081 + size c\u2082 + 2 + size s = size (node a\u2081 c\u2081 (node a\u2082 c\u2082 s))", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h_2\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\ns x\u271d\u00b9 : Heap \u03b1\nx\u271d : \u2200 (a : \u03b1) (child : Heap \u03b1) (a_1 : \u03b1) (child_1 s_1 : Heap \u03b1), s = node a child (node a_1 child_1 s_1) \u2192 False\n\u22a2 size s = size s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Defs.lean", "full_name": "Equiv.arrowCongr'_trans", "start": [549, 9], "end": [552, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Odd.mod_even", "start": [354, 1], "end": [355, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/PNat/Basic.lean", "full_name": "PNat.natPred_lt_natPred", "start": [58, 1], "end": [59, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Basic.lean", "full_name": "Nat.pred_eq_succ_iff", "start": [306, 1], "end": [307, 48], "traced_tactics": [{"tactic": "cases n <;> constructor <;> rintro \u27e8\u27e9 <;> rfl", "annotated_tactic": ["cases n <;> constructor <;> rintro \u27e8\u27e9 <;> rfl", []], "state_before": "m\u271d n\u271d k n m : \u2115\n\u22a2 pred n = succ m \u2194 n = m + 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Digits.lean", "full_name": "Nat.digits_two_eq_bits", "start": [592, 1], "end": [601, 97], "traced_tactics": [{"tactic": "induction' n using Nat.binaryRecFromOne with b n h ih", "annotated_tactic": ["induction' n using <a>Nat.binaryRecFromOne</a> with b n h ih", [{"full_name": "Nat.binaryRecFromOne", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bits.lean", "def_pos": [201, 5], "def_end_pos": [201, 21]}]], "state_before": "n\u271d n : \u2115\n\u22a2 digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)", "state_after": "case z\u2080\nn : \u2115\n\u22a2 digits 2 0 = List.map (fun b => bif b then 1 else 0) (bits 0)\n\ncase z\u2081\nn : \u2115\n\u22a2 digits 2 1 = List.map (fun b => bif b then 1 else 0) (bits 1)\n\ncase f\nn\u271d : \u2115\nb : Bool\nn : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit b n) = List.map (fun b => bif b then 1 else 0) (bits (bit b n))"}, {"tactic": "rw [bits_append_bit _ _ fun hn => absurd hn h]", "annotated_tactic": ["rw [<a>bits_append_bit</a> _ _ fun hn => <a>absurd</a> hn h]", [{"full_name": "Nat.bits_append_bit", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bits.lean", "def_pos": [215, 9], "def_end_pos": [215, 24]}, {"full_name": "absurd", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [233, 21], "def_end_pos": [233, 27]}]], "state_before": "case f\nn\u271d : \u2115\nb : Bool\nn : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit b n) = List.map (fun b => bif b then 1 else 0) (bits (bit b n))", "state_after": "case f\nn\u271d : \u2115\nb : Bool\nn : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit b n) = List.map (fun b => bif b then 1 else 0) (b :: bits n)"}, {"tactic": "cases b", "annotated_tactic": ["cases b", []], "state_before": "case f\nn\u271d : \u2115\nb : Bool\nn : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit b n) = List.map (fun b => bif b then 1 else 0) (b :: bits n)", "state_after": "case f.false\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit false n) = List.map (fun b => bif b then 1 else 0) (false :: bits n)\n\ncase f.true\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit true n) = List.map (fun b => bif b then 1 else 0) (true :: bits n)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case z\u2080\nn : \u2115\n\u22a2 digits 2 0 = List.map (fun b => bif b then 1 else 0) (bits 0)", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case z\u2081\nn : \u2115\n\u22a2 digits 2 1 = List.map (fun b => bif b then 1 else 0) (bits 1)", "state_after": "no goals"}, {"tactic": "rw [digits_def' one_lt_two]", "annotated_tactic": ["rw [<a>digits_def'</a> <a>one_lt_two</a>]", [{"full_name": "Nat.digits_def'", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [128, 9], "def_end_pos": [128, 20]}, {"full_name": "one_lt_two", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [106, 7], "def_end_pos": [106, 17]}]], "state_before": "case f.false\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit false n) = List.map (fun b => bif b then 1 else 0) (false :: bits n)", "state_after": "case f.false\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 bit false n % 2 :: digits 2 (bit false n / 2) = List.map (fun b => bif b then 1 else 0) (false :: bits n)\n\ncase f.false\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 0 < bit false n"}, {"tactic": "simpa [Nat.bit, Nat.bit0_val n]", "annotated_tactic": ["simpa [<a>Nat.bit</a>, <a>Nat.bit0_val</a> n]", [{"full_name": "Nat.bit", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [145, 5], "def_end_pos": [145, 8]}, {"full_name": "Nat.bit0_val", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [149, 9], "def_end_pos": [149, 17]}]], "state_before": "case f.false\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 bit false n % 2 :: digits 2 (bit false n / 2) = List.map (fun b => bif b then 1 else 0) (false :: bits n)", "state_after": "no goals"}, {"tactic": "simpa [pos_iff_ne_zero, bit_eq_zero_iff]", "annotated_tactic": ["simpa [<a>pos_iff_ne_zero</a>, <a>bit_eq_zero_iff</a>]", [{"full_name": "pos_iff_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "def_pos": [243, 3], "def_end_pos": [243, 14]}, {"full_name": "Nat.bit_eq_zero_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Bits.lean", "def_pos": [155, 9], "def_end_pos": [155, 24]}]], "state_before": "case f.false\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 0 < bit false n", "state_after": "no goals"}, {"tactic": "simpa [Nat.bit, Nat.bit1_val n, add_comm, digits_add 2 one_lt_two 1 n, Nat.add_mul_div_left]", "annotated_tactic": ["simpa [<a>Nat.bit</a>, <a>Nat.bit1_val</a> n, <a>add_comm</a>, <a>digits_add</a> 2 <a>one_lt_two</a> 1 n, <a>Nat.add_mul_div_left</a>]", [{"full_name": "Nat.bit", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [145, 5], "def_end_pos": [145, 8]}, {"full_name": "Nat.bit1_val", "def_path": "lake-packages/mathlib/Mathlib/Init/Data/Nat/Bitwise.lean", "def_pos": [156, 9], "def_end_pos": [156, 17]}, {"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}, {"full_name": "Nat.digits_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Digits.lean", "def_pos": [142, 9], "def_end_pos": [142, 19]}, {"full_name": "one_lt_two", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/NatCast.lean", "def_pos": [106, 7], "def_end_pos": [106, 17]}, {"full_name": "Nat.add_mul_div_left", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [832, 9], "def_end_pos": [832, 25]}]], "state_before": "case f.true\nn\u271d n : \u2115\nh : n \u2260 0\nih : digits 2 n = List.map (fun b => bif b then 1 else 0) (bits n)\n\u22a2 digits 2 (bit true n) = List.map (fun b => bif b then 1 else 0) (true :: bits n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/Alter.lean", "full_name": "Std.RBNode.Ordered.alter", "start": [343, 11], "end": [358, 94], "traced_tactics": [{"tactic": "simp [alter]", "annotated_tactic": ["simp [<a>alter</a>]", [{"full_name": "Std.RBNode.alter", "def_path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [530, 19], "def_end_pos": [530, 24]}]], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\n\u22a2 Ordered cmp (alter cut f t)", "state_after": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\n\u22a2 Ordered cmp\n    (match RBNode.zoom cut t Path.root with\n    | (nil, path) =>\n      match f none with\n      | none => t\n      | some y => Path.insertNew path y\n    | (node c a x b, path) =>\n      match f (some x) with\n      | none => Path.del path (append a b) c\n      | some y => Path.fill path (node c a y b))"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\n\u22a2 Ordered cmp\n    (match RBNode.zoom cut t Path.root with\n    | (nil, path) =>\n      match f none with\n      | none => t\n      | some y => Path.insertNew path y\n    | (node c a x b, path) =>\n      match f (some x) with\n      | none => Path.del path (append a b) c\n      | some y => Path.fill path (node c a y b))", "state_after": "case h_1\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d : RBNode \u03b1 \u00d7 Path \u03b1\nsnd\u271d : Path \u03b1\nheq\u271d : RBNode.zoom cut t Path.root = (nil, snd\u271d)\n\u22a2 Ordered cmp\n    (match f none with\n    | none => t\n    | some y => Path.insertNew snd\u271d y)\n\ncase h_2\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d : \u03b1\nb\u271d : RBNode \u03b1\npath\u271d : Path \u03b1\nheq\u271d : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d b\u271d, path\u271d)\n\u22a2 Ordered cmp\n    (match f (some x\u271d) with\n    | none => Path.del path\u271d (append a\u271d b\u271d) c\u271d\n    | some y => Path.fill path\u271d (node c\u271d a\u271d y b\u271d))"}, {"tactic": "have \u27e8_, hp, _, _\u27e9 := h.zoom eq", "annotated_tactic": ["have \u27e8_, hp, _, _\u27e9 := h.zoom eq", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\n\u22a2 Ordered cmp\n    (match f none with\n    | none => t\n    | some y => Path.insertNew path y)", "state_after": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\nleft\u271d\u00b9 : Ordered cmp nil\nhp : Path.Ordered cmp path\nleft\u271d : All (Path.RootOrdered cmp path) nil\nright\u271d : Path.Zoomed cut path\n\u22a2 Ordered cmp\n    (match f none with\n    | none => t\n    | some y => Path.insertNew path y)"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\nleft\u271d\u00b9 : Ordered cmp nil\nhp : Path.Ordered cmp path\nleft\u271d : All (Path.RootOrdered cmp path) nil\nright\u271d : Path.Zoomed cut path\n\u22a2 Ordered cmp\n    (match f none with\n    | none => t\n    | some y => Path.insertNew path y)", "state_after": "case h_1\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\nleft\u271d\u00b9 : Ordered cmp nil\nhp : Path.Ordered cmp path\nleft\u271d : All (Path.RootOrdered cmp path) nil\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\nheq\u271d : f none = none\n\u22a2 Ordered cmp t\n\ncase h_2\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\nleft\u271d\u00b9 : Ordered cmp nil\nhp : Path.Ordered cmp path\nleft\u271d : All (Path.RootOrdered cmp path) nil\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nheq\u271d : f none = some y\u271d\n\u22a2 Ordered cmp (Path.insertNew path y\u271d)"}, {"tactic": "exact h", "annotated_tactic": ["exact h", []], "state_before": "case h_1\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\nleft\u271d\u00b9 : Ordered cmp nil\nhp : Path.Ordered cmp path\nleft\u271d : All (Path.RootOrdered cmp path) nil\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\nheq\u271d : f none = none\n\u22a2 Ordered cmp t", "state_after": "no goals"}, {"tactic": "next hf => exact hp.insertNew (H eq hf).1", "annotated_tactic": ["next hf => exact hp.insertNew (H eq hf).1", []], "state_before": "case h_2\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\nleft\u271d\u00b9 : Ordered cmp nil\nhp : Path.Ordered cmp path\nleft\u271d : All (Path.RootOrdered cmp path) nil\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nheq\u271d : f none = some y\u271d\n\u22a2 Ordered cmp (Path.insertNew path y\u271d)", "state_after": "no goals"}, {"tactic": "exact hp.insertNew (H eq hf).1", "annotated_tactic": ["exact hp.insertNew (H eq hf).1", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (nil, path)\nleft\u271d\u00b9 : Ordered cmp nil\nhp : Path.Ordered cmp path\nleft\u271d : All (Path.RootOrdered cmp path) nil\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nhf : f none = some y\u271d\n\u22a2 Ordered cmp (Path.insertNew path y\u271d)", "state_after": "no goals"}, {"tactic": "have \u27e8\u27e8ax, xb, ha, hb\u27e9, hp, \u27e8_, ap, bp\u27e9, _\u27e9 := h.zoom eq", "annotated_tactic": ["have \u27e8\u27e8ax, xb, ha, hb\u27e9, hp, \u27e8_, ap, bp\u27e9, _\u27e9 := h.zoom eq", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d b\u271d, path)\n\u22a2 Ordered cmp\n    (match f (some x\u271d) with\n    | none => Path.del path (append a\u271d b\u271d) c\u271d\n    | some y => Path.fill path (node c\u271d a\u271d y b\u271d))", "state_after": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\n\u22a2 Ordered cmp\n    (match f (some x\u271d) with\n    | none => Path.del path (append a\u271d b\u271d) c\u271d\n    | some y => Path.fill path (node c\u271d a\u271d y b\u271d))"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b9 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\n\u22a2 Ordered cmp\n    (match f (some x\u271d) with\n    | none => Path.del path (append a\u271d b\u271d) c\u271d\n    | some y => Path.fill path (node c\u271d a\u271d y b\u271d))", "state_after": "case h_1\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\nheq\u271d : f (some x\u271d\u00b9) = none\n\u22a2 Ordered cmp (Path.del path (append a\u271d b\u271d) c\u271d)\n\ncase h_2\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nheq\u271d : f (some x\u271d\u00b9) = some y\u271d\n\u22a2 Ordered cmp (Path.fill path (node c\u271d a\u271d y\u271d b\u271d))"}, {"tactic": "exact hp.del (ha.append ax xb hb) (ap.append bp)", "annotated_tactic": ["exact hp.del (ha.append ax xb hb) (ap.append bp)", []], "state_before": "case h_1\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\nheq\u271d : f (some x\u271d\u00b9) = none\n\u22a2 Ordered cmp (Path.del path (append a\u271d b\u271d) c\u271d)", "state_after": "no goals"}, {"tactic": "next hf =>\nhave \u27e8yp, xy\u27e9 := H eq hf\napply Path.Ordered.fill.2\nexact \u27e8hp, \u27e8ax.imp xy.lt_congr_right.2, xb.imp xy.lt_congr_left.2, ha, hb\u27e9, yp, ap, bp\u27e9", "annotated_tactic": ["next hf =>\n      have \u27e8yp, xy\u27e9 := H eq hf\n      apply <a>Path.Ordered.fill</a>.2\n      exact \u27e8hp, \u27e8ax.imp xy.lt_congr_right.2, xb.imp xy.lt_congr_left.2, ha, hb\u27e9, yp, ap, bp\u27e9", [{"full_name": "Std.RBNode.Path.Ordered.fill", "def_path": "lake-packages/std/Std/Data/RBMap/Alter.lean", "def_pos": [268, 19], "def_end_pos": [268, 31]}]], "state_before": "case h_2\n\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nheq\u271d : f (some x\u271d\u00b9) = some y\u271d\n\u22a2 Ordered cmp (Path.fill path (node c\u271d a\u271d y\u271d b\u271d))", "state_after": "no goals"}, {"tactic": "have \u27e8yp, xy\u27e9 := H eq hf", "annotated_tactic": ["have \u27e8yp, xy\u27e9 := H eq hf", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nhf : f (some x\u271d\u00b9) = some y\u271d\n\u22a2 Ordered cmp (Path.fill path (node c\u271d a\u271d y\u271d b\u271d))", "state_after": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nhf : f (some x\u271d\u00b9) = some y\u271d\nyp : Path.RootOrdered cmp path y\u271d\nxy : OnRoot (cmpEq cmp y\u271d) (node c\u271d a\u271d x\u271d\u00b9 b\u271d)\n\u22a2 Ordered cmp (Path.fill path (node c\u271d a\u271d y\u271d b\u271d))"}, {"tactic": "apply Path.Ordered.fill.2", "annotated_tactic": ["apply <a>Path.Ordered.fill</a>.2", [{"full_name": "Std.RBNode.Path.Ordered.fill", "def_path": "lake-packages/std/Std/Data/RBMap/Alter.lean", "def_pos": [268, 19], "def_end_pos": [268, 31]}]], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nhf : f (some x\u271d\u00b9) = some y\u271d\nyp : Path.RootOrdered cmp path y\u271d\nxy : OnRoot (cmpEq cmp y\u271d) (node c\u271d a\u271d x\u271d\u00b9 b\u271d)\n\u22a2 Ordered cmp (Path.fill path (node c\u271d a\u271d y\u271d b\u271d))", "state_after": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nhf : f (some x\u271d\u00b9) = some y\u271d\nyp : Path.RootOrdered cmp path y\u271d\nxy : OnRoot (cmpEq cmp y\u271d) (node c\u271d a\u271d x\u271d\u00b9 b\u271d)\n\u22a2 Path.Ordered cmp path \u2227 Ordered cmp (node c\u271d a\u271d y\u271d b\u271d) \u2227 All (Path.RootOrdered cmp path) (node c\u271d a\u271d y\u271d b\u271d)"}, {"tactic": "exact \u27e8hp, \u27e8ax.imp xy.lt_congr_right.2, xb.imp xy.lt_congr_left.2, ha, hb\u27e9, yp, ap, bp\u27e9", "annotated_tactic": ["exact \u27e8hp, \u27e8ax.imp xy.lt_congr_right.2, xb.imp xy.lt_congr_left.2, ha, hb\u27e9, yp, ap, bp\u27e9", []], "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\nf : Option \u03b1 \u2192 Option \u03b1\ncmp : \u03b1 \u2192 \u03b1 \u2192 Ordering\nt : RBNode \u03b1\nH :\n  \u2200 {x : \u03b1} {t' : RBNode \u03b1} {p : Path \u03b1},\n    RBNode.zoom cut t Path.root = (t', p) \u2192 f (root? t') = some x \u2192 Path.RootOrdered cmp p x \u2227 OnRoot (cmpEq cmp x) t'\nh : Ordered cmp t\nx\u271d\u00b2 : RBNode \u03b1 \u00d7 Path \u03b1\nc\u271d : RBColor\na\u271d : RBNode \u03b1\nx\u271d\u00b9 : \u03b1\nb\u271d : RBNode \u03b1\npath : Path \u03b1\neq : RBNode.zoom cut t Path.root = (node c\u271d a\u271d x\u271d\u00b9 b\u271d, path)\nax : All (fun x => cmpLT cmp x x\u271d\u00b9) a\u271d\nxb : All (fun x => cmpLT cmp x\u271d\u00b9 x) b\u271d\nha : Ordered cmp a\u271d\nhb : Ordered cmp b\u271d\nhp : Path.Ordered cmp path\nleft\u271d : Path.RootOrdered cmp path x\u271d\u00b9\nap : All (Path.RootOrdered cmp path) a\u271d\nbp : All (Path.RootOrdered cmp path) b\u271d\nright\u271d : Path.Zoomed cut path\nx\u271d : Option \u03b1\ny\u271d : \u03b1\nhf : f (some x\u271d\u00b9) = some y\u271d\nyp : Path.RootOrdered cmp path y\u271d\nxy : OnRoot (cmpEq cmp y\u271d) (node c\u271d a\u271d x\u271d\u00b9 b\u271d)\n\u22a2 Path.Ordered cmp path \u2227 Ordered cmp (node c\u271d a\u271d y\u271d b\u271d) \u2227 All (Path.RootOrdered cmp path) (node c\u271d a\u271d y\u271d b\u271d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "MonoidHom.coe_toAdditive_ker", "start": [2955, 1], "end": [2956, 71], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Array/Lemmas.lean", "full_name": "Array.get?_push_eq", "start": [82, 1], "end": [83, 33], "traced_tactics": [{"tactic": "rw [getElem?_pos, get_push_eq]", "annotated_tactic": ["rw [<a>getElem?_pos</a>, <a>get_push_eq</a>]", [{"full_name": "getElem?_pos", "def_path": "lake-packages/std/Std/Data/Array/Lemmas.lean", "def_pos": [23, 9], "def_end_pos": [23, 21]}, {"full_name": "Array.get_push_eq", "def_path": "lake-packages/std/Std/Data/Array/Init/Lemmas.lean", "def_pos": [132, 17], "def_end_pos": [132, 28]}]], "state_before": "\u03b1 : Type u_1\na : Array \u03b1\nx : \u03b1\n\u22a2 (push a x)[size a]? = some x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "Imp.swap", "start": [270, 1], "end": [270, 75], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_lt_iff_tsub_lt", "start": [246, 1], "end": [247, 90], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.le_succ_bot_iff", "start": [548, 1], "end": [549, 49], "traced_tactics": [{"tactic": "rw [le_succ_iff_eq_or_le, le_bot_iff, or_comm]", "annotated_tactic": ["rw [<a>le_succ_iff_eq_or_le</a>, <a>le_bot_iff</a>, <a>or_comm</a>]", [{"full_name": "Order.le_succ_iff_eq_or_le", "def_path": "lake-packages/mathlib/Mathlib/Order/SuccPred/Basic.lean", "def_pos": [440, 9], "def_end_pos": [440, 29]}, {"full_name": "le_bot_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [355, 9], "def_end_pos": [355, 19]}, {"full_name": "or_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [269, 9], "def_end_pos": [269, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : SuccOrder \u03b1\na b : \u03b1\ninst\u271d : OrderBot \u03b1\n\u22a2 a \u2264 succ \u22a5 \u2194 a = \u22a5 \u2228 a = succ \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Polynomial/Content.lean", "full_name": "Polynomial.degree_gcd_le_left", "start": [501, 1], "end": [503, 31], "traced_tactics": [{"tactic": "have := natDegree_le_iff_degree_le.mp (natDegree_le_of_dvd (gcd_dvd_left p q) hp)", "annotated_tactic": ["have := natDegree_le_iff_degree_le.mp (<a>natDegree_le_of_dvd</a> (<a>gcd_dvd_left</a> p q) hp)", [{"full_name": "Polynomial.natDegree_le_of_dvd", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [175, 9], "def_end_pos": [175, 28]}, {"full_name": "GCDMonoid.gcd_dvd_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GCDMonoid/Basic.lean", "def_pos": [278, 3], "def_end_pos": [278, 15]}]], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : p \u2260 0\nq : R[X]\n\u22a2 degree (gcd p q) \u2264 degree p", "state_after": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : p \u2260 0\nq : R[X]\nthis : degree (gcd p q) \u2264 \u2191(natDegree p)\n\u22a2 degree (gcd p q) \u2264 degree p"}, {"tactic": "rwa [degree_eq_natDegree hp]", "annotated_tactic": ["rwa [<a>degree_eq_natDegree</a> hp]", [{"full_name": "Polynomial.degree_eq_natDegree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [130, 9], "def_end_pos": [130, 28]}]], "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nhp : p \u2260 0\nq : R[X]\nthis : degree (gcd p q) \u2264 \u2191(natDegree p)\n\u22a2 degree (gcd p q) \u2264 degree p", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/RingDivision.lean", "full_name": "Polynomial.ne_zero_of_mem_rootSet", "start": [1083, 1], "end": [1084, 78], "traced_tactics": [{"tactic": "rwa [hf, rootSet_zero] at h", "annotated_tactic": ["rwa [hf, <a>rootSet_zero</a>] at h", [{"full_name": "Polynomial.rootSet_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/RingDivision.lean", "def_pos": [1027, 9], "def_end_pos": [1027, 21]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\na\u271d b : R\nn : \u2115\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : IsDomain R\np\u271d q : R[X]\ninst\u271d\u00b3 : CommRing T\np : T[X]\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Algebra T S\na : S\nh : a \u2208 rootSet p S\nhf : p = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/WithBot.lean", "full_name": "WithTop.le_coe_iff", "start": [884, 1], "end": [885, 43], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Chain.lean", "full_name": "Flag.coe_mk", "start": [328, 1], "end": [329, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/CharP/Basic.lean", "full_name": "multiset_sum_pow_char", "start": [414, 1], "end": [415, 37], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "not_bddAbove_iff'", "start": [120, 1], "end": [121, 45], "traced_tactics": [{"tactic": "simp [BddAbove, upperBounds, Set.Nonempty]", "annotated_tactic": ["simp [<a>BddAbove</a>, <a>upperBounds</a>, <a>Set.Nonempty</a>]", [{"full_name": "BddAbove", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [56, 5], "def_end_pos": [56, 13]}, {"full_name": "upperBounds", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/Basic.lean", "def_pos": [46, 5], "def_end_pos": [46, 16]}, {"full_name": "Set.Nonempty", "def_path": "lake-packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [133, 15], "def_end_pos": [133, 23]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\n\u22a2 \u00acBddAbove s \u2194 \u2200 (x : \u03b1), \u2203 y \u2208 s, \u00acy \u2264 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Prod/Basic.lean", "full_name": "Prod.swap_inj", "start": [214, 1], "end": [215, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Basic.lean", "full_name": "MvPolynomial.eval_add", "start": [1178, 1], "end": [1179, 16], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/PartENat.lean", "full_name": "PartENat.get_eq_iff_eq_coe", "start": [199, 1], "end": [201, 6], "traced_tactics": [{"tactic": "rw [get_eq_iff_eq_some]", "annotated_tactic": ["rw [<a>get_eq_iff_eq_some</a>]", [{"full_name": "PartENat.get_eq_iff_eq_some", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/PartENat.lean", "def_pos": [195, 16], "def_end_pos": [195, 34]}]], "state_before": "a : PartENat\nha : a.Dom\nb : \u2115\n\u22a2 Part.get a ha = b \u2194 a = \u2191b", "state_after": "a : PartENat\nha : a.Dom\nb : \u2115\n\u22a2 a = \u2191b \u2194 a = \u2191b"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "a : PartENat\nha : a.Dom\nb : \u2115\n\u22a2 a = \u2191b \u2194 a = \u2191b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.filter_smul", "start": [1564, 1], "end": [1566, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Prime.pow_dvd_of_dvd_mul_left", "start": [116, 1], "end": [124, 88], "traced_tactics": [{"tactic": "induction' n with n ih", "annotated_tactic": ["induction' n with n ih", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nn : \u2115\nh : \u00acp \u2223 a\nh' : p ^ n \u2223 a * b\n\u22a2 p ^ n \u2223 b", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nh' : p ^ Nat.zero \u2223 a * b\n\u22a2 p ^ Nat.zero \u2223 b\n\ncase succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nih : p ^ n \u2223 a * b \u2192 p ^ n \u2223 b\nh' : p ^ Nat.succ n \u2223 a * b\n\u22a2 p ^ Nat.succ n \u2223 b"}, {"tactic": "rw [pow_zero]", "annotated_tactic": ["rw [<a>pow_zero</a>]", [{"full_name": "pow_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [639, 9], "def_end_pos": [639, 17]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nh' : p ^ Nat.zero \u2223 a * b\n\u22a2 p ^ Nat.zero \u2223 b", "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nh' : p ^ Nat.zero \u2223 a * b\n\u22a2 1 \u2223 b"}, {"tactic": "exact one_dvd b", "annotated_tactic": ["exact <a>one_dvd</a> b", [{"full_name": "one_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [131, 9], "def_end_pos": [131, 16]}]], "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nh' : p ^ Nat.zero \u2223 a * b\n\u22a2 1 \u2223 b", "state_after": "no goals"}, {"tactic": "obtain \u27e8c, rfl\u27e9 := ih (dvd_trans (pow_dvd_pow p n.le_succ) h')", "annotated_tactic": ["obtain \u27e8c, rfl\u27e9 := ih (<a>dvd_trans</a> (<a>pow_dvd_pow</a> p n.le_succ) h')", [{"full_name": "dvd_trans", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [71, 9], "def_end_pos": [71, 18]}, {"full_name": "pow_dvd_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [442, 9], "def_end_pos": [442, 20]}]], "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nih : p ^ n \u2223 a * b \u2192 p ^ n \u2223 b\nh' : p ^ Nat.succ n \u2223 a * b\n\u22a2 p ^ Nat.succ n \u2223 b", "state_after": "case succ.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nc : \u03b1\nih : p ^ n \u2223 a * (p ^ n * c) \u2192 p ^ n \u2223 p ^ n * c\nh' : p ^ Nat.succ n \u2223 a * (p ^ n * c)\n\u22a2 p ^ Nat.succ n \u2223 p ^ n * c"}, {"tactic": "rw [pow_succ']", "annotated_tactic": ["rw [<a>pow_succ'</a>]", [{"full_name": "pow_succ'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [213, 9], "def_end_pos": [213, 25]}]], "state_before": "case succ.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nc : \u03b1\nih : p ^ n \u2223 a * (p ^ n * c) \u2192 p ^ n \u2223 p ^ n * c\nh' : p ^ Nat.succ n \u2223 a * (p ^ n * c)\n\u22a2 p ^ Nat.succ n \u2223 p ^ n * c", "state_after": "case succ.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nc : \u03b1\nih : p ^ n \u2223 a * (p ^ n * c) \u2192 p ^ n \u2223 p ^ n * c\nh' : p ^ Nat.succ n \u2223 a * (p ^ n * c)\n\u22a2 p ^ n * p \u2223 p ^ n * c"}, {"tactic": "apply mul_dvd_mul_left _ ((hp.dvd_or_dvd _).resolve_left h)", "annotated_tactic": ["apply <a>mul_dvd_mul_left</a> _ ((hp.dvd_or_dvd _).<a>resolve_left</a> h)", [{"full_name": "mul_dvd_mul_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [195, 9], "def_end_pos": [195, 25]}, {"full_name": "Or.resolve_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [274, 9], "def_end_pos": [274, 24]}]], "state_before": "case succ.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nc : \u03b1\nih : p ^ n \u2223 a * (p ^ n * c) \u2192 p ^ n \u2223 p ^ n * c\nh' : p ^ Nat.succ n \u2223 a * (p ^ n * c)\n\u22a2 p ^ n * p \u2223 p ^ n * c", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nc : \u03b1\nih : p ^ n \u2223 a * (p ^ n * c) \u2192 p ^ n \u2223 p ^ n * c\nh' : p ^ Nat.succ n \u2223 a * (p ^ n * c)\n\u22a2 p \u2223 a * c"}, {"tactic": "rwa [\u2190 mul_dvd_mul_iff_left (pow_ne_zero n hp.ne_zero), \u2190 pow_succ', mul_left_comm]", "annotated_tactic": ["rwa [\u2190 <a>mul_dvd_mul_iff_left</a> (<a>pow_ne_zero</a> n hp.ne_zero), \u2190 <a>pow_succ'</a>, <a>mul_left_comm</a>]", [{"full_name": "mul_dvd_mul_iff_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupWithZero/Divisibility.lean", "def_pos": [48, 9], "def_end_pos": [48, 29]}, {"full_name": "pow_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Ring.lean", "def_pos": [84, 9], "def_end_pos": [84, 20]}, {"full_name": "pow_succ'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [213, 9], "def_end_pos": [213, 25]}, {"full_name": "mul_left_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [96, 9], "def_end_pos": [96, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a : \u03b1\nhp : Prime p\nh : \u00acp \u2223 a\nn : \u2115\nc : \u03b1\nih : p ^ n \u2223 a * (p ^ n * c) \u2192 p ^ n \u2223 p ^ n * c\nh' : p ^ Nat.succ n \u2223 a * (p ^ n * c)\n\u22a2 p \u2223 a * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_image2_left", "start": [259, 1], "end": [265, 49], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\n\u22a2 image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u", "state_after": "case h\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nx\u271d : \u03b5\n\u22a2 x\u271d \u2208 image2 f (image2 g s t) u \u2194 x\u271d \u2208 image3 (fun a b c => f (g a b) c) s t u"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nx\u271d : \u03b5\n\u22a2 x\u271d \u2208 image2 f (image2 g s t) u \u2194 x\u271d \u2208 image3 (fun a b c => f (g a b) c) s t u", "state_after": "case h.mp\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nx\u271d : \u03b5\n\u22a2 x\u271d \u2208 image2 f (image2 g s t) u \u2192 x\u271d \u2208 image3 (fun a b c => f (g a b) c) s t u\n\ncase h.mpr\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nx\u271d : \u03b5\n\u22a2 x\u271d \u2208 image3 (fun a b c => f (g a b) c) s t u \u2192 x\u271d \u2208 image2 f (image2 g s t) u"}, {"tactic": "rintro \u27e8_, c, \u27e8a, b, ha, hb, rfl\u27e9, hc, rfl\u27e9", "annotated_tactic": ["rintro \u27e8_, c, \u27e8a, b, ha, hb, rfl\u27e9, hc, rfl\u27e9", []], "state_before": "case h.mp\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nx\u271d : \u03b5\n\u22a2 x\u271d \u2208 image2 f (image2 g s t) u \u2192 x\u271d \u2208 image3 (fun a b c => f (g a b) c) s t u", "state_after": "case h.mp.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na\u271d a' : \u03b1\nb\u271d b' : \u03b2\nc\u271d c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nc : \u03b3\na : \u03b1\nb : \u03b2\nha : a \u2208 s\nhb : b \u2208 t\nhc : c \u2208 u\n\u22a2 f (g a b) c \u2208 image3 (fun a b c => f (g a b) c) s t u"}, {"tactic": "refine' \u27e8a, b, c, ha, hb, hc, rfl\u27e9", "annotated_tactic": ["refine' \u27e8a, b, c, ha, hb, hc, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case h.mp.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na\u271d a' : \u03b1\nb\u271d b' : \u03b2\nc\u271d c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nc : \u03b3\na : \u03b1\nb : \u03b2\nha : a \u2208 s\nhb : b \u2208 t\nhc : c \u2208 u\n\u22a2 f (g a b) c \u2208 image3 (fun a b c => f (g a b) c) s t u", "state_after": "no goals"}, {"tactic": "rintro \u27e8a, b, c, ha, hb, hc, rfl\u27e9", "annotated_tactic": ["rintro \u27e8a, b, c, ha, hb, hc, rfl\u27e9", []], "state_before": "case h.mpr\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\nx\u271d : \u03b5\n\u22a2 x\u271d \u2208 image3 (fun a b c => f (g a b) c) s t u \u2192 x\u271d \u2208 image2 f (image2 g s t) u", "state_after": "case h.mpr.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na\u271d a' : \u03b1\nb\u271d b' : \u03b2\nc\u271d c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nha : a \u2208 s\nhb : b \u2208 t\nhc : c \u2208 u\n\u22a2 (fun a b c => f (g a b) c) a b c \u2208 image2 f (image2 g s t) u"}, {"tactic": "refine' \u27e8_, c, \u27e8a, b, ha, hb, rfl\u27e9, hc, rfl\u27e9", "annotated_tactic": ["refine' \u27e8_, c, \u27e8a, b, ha, hb, <a>rfl</a>\u27e9, hc, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case h.mpr.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf\u271d f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng\u271d g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na\u271d a' : \u03b1\nb\u271d b' : \u03b2\nc\u271d c' : \u03b3\nd d' : \u03b4\nf : \u03b4 \u2192 \u03b3 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b2 \u2192 \u03b4\na : \u03b1\nb : \u03b2\nc : \u03b3\nha : a \u2208 s\nhb : b \u2208 t\nhc : c \u2208 u\n\u22a2 (fun a b c => f (g a b) c) a b c \u2208 image2 f (image2 g s t) u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.revFindAux_of_valid", "start": [353, 1], "end": [362, 41], "traced_tactics": [{"tactic": "unfold revFindAux List.dropWhile", "annotated_tactic": ["unfold <a>revFindAux</a> <a>List.dropWhile</a>", [{"full_name": "String.revFindAux", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [191, 5], "def_end_pos": [191, 15]}, {"full_name": "List.dropWhile", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [284, 5], "def_end_pos": [284, 14]}]], "state_before": "p : Char \u2192 Bool\nr : List Char\n\u22a2 revFindAux { data := List.reverse [] ++ r } p { byteIdx := utf8Len [] } =\n    Option.map (fun x => { byteIdx := utf8Len x }) (List.tail? (List.dropWhile (fun x => !p x) []))", "state_after": "p : Char \u2192 Bool\nr : List Char\n\u22a2 (if h : { byteIdx := utf8Len [] } = 0 then none\n    else\n      let_fun this :=\n        (_ :\n          (prev { data := List.reverse [] ++ r } { byteIdx := utf8Len [] }).byteIdx <\n            { byteIdx := utf8Len [] }.byteIdx);\n      let pos := prev { data := List.reverse [] ++ r } { byteIdx := utf8Len [] };\n      if p (get { data := List.reverse [] ++ r } pos) = true then some pos\n      else revFindAux { data := List.reverse [] ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x }) (List.tail? [])"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "p : Char \u2192 Bool\nr : List Char\n\u22a2 (if h : { byteIdx := utf8Len [] } = 0 then none\n    else\n      let_fun this :=\n        (_ :\n          (prev { data := List.reverse [] ++ r } { byteIdx := utf8Len [] }).byteIdx <\n            { byteIdx := utf8Len [] }.byteIdx);\n      let pos := prev { data := List.reverse [] ++ r } { byteIdx := utf8Len [] };\n      if p (get { data := List.reverse [] ++ r } pos) = true then some pos\n      else revFindAux { data := List.reverse [] ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x }) (List.tail? [])", "state_after": "no goals"}, {"tactic": "unfold revFindAux List.dropWhile", "annotated_tactic": ["unfold <a>revFindAux</a> <a>List.dropWhile</a>", [{"full_name": "String.revFindAux", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [191, 5], "def_end_pos": [191, 15]}, {"full_name": "List.dropWhile", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [284, 5], "def_end_pos": [284, 14]}]], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\n\u22a2 revFindAux { data := List.reverse (c :: l) ++ r } p { byteIdx := utf8Len (c :: l) } =\n    Option.map (fun x => { byteIdx := utf8Len x }) (List.tail? (List.dropWhile (fun x => !p x) (c :: l)))", "state_after": "p : Char \u2192 Bool\nc : Char\nl r : List Char\n\u22a2 (if h : { byteIdx := utf8Len (c :: l) } = 0 then none\n    else\n      let_fun this :=\n        (_ :\n          (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n            { byteIdx := utf8Len (c :: l) }.byteIdx);\n      let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n      if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n      else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))"}, {"tactic": "rw [dif_neg (by exact Pos.ne_of_gt add_csize_pos)]", "annotated_tactic": ["rw [<a>dif_neg</a> (by exact <a>Pos.ne_of_gt</a> <a>add_csize_pos</a>)]", [{"full_name": "dif_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [812, 9], "def_end_pos": [812, 16]}, {"full_name": "String.Pos.ne_of_gt", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 17]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.Data.String.Lemmas.0.String.add_csize_pos", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [44, 17], "def_end_pos": [44, 30]}]], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\n\u22a2 (if h : { byteIdx := utf8Len (c :: l) } = 0 then none\n    else\n      let_fun this :=\n        (_ :\n          (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n            { byteIdx := utf8Len (c :: l) }.byteIdx);\n      let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n      if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n      else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))", "state_after": "p : Char \u2192 Bool\nc : Char\nl r : List Char\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))"}, {"tactic": "have h1 := get_of_valid l.reverse (c::r)", "annotated_tactic": ["have h1 := <a>get_of_valid</a> l.reverse (c::r)", [{"full_name": "String.get_of_valid", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [223, 9], "def_end_pos": [223, 21]}]], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))", "state_after": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len (List.reverse l) } = List.headD (c :: r) default\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))"}, {"tactic": "have h2 := prev_of_valid l.reverse c r", "annotated_tactic": ["have h2 := <a>prev_of_valid</a> l.reverse c r", [{"full_name": "String.prev_of_valid", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [296, 9], "def_end_pos": [296, 22]}]], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len (List.reverse l) } = List.headD (c :: r) default\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))", "state_after": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len (List.reverse l) } = List.headD (c :: r) default\nh2 :\n  prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len (List.reverse l) + csize c } =\n    { byteIdx := utf8Len (List.reverse l) }\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))"}, {"tactic": "simp at h1 h2", "annotated_tactic": ["simp at h1 h2", []], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len (List.reverse l) } = List.headD (c :: r) default\nh2 :\n  prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len (List.reverse l) + csize c } =\n    { byteIdx := utf8Len (List.reverse l) }\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))", "state_after": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l } = c\nh2 : prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l + csize c } = { byteIdx := utf8Len l }\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))"}, {"tactic": "simp [h1, h2]", "annotated_tactic": ["simp [h1, h2]", []], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l } = c\nh2 : prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l + csize c } = { byteIdx := utf8Len l }\n\u22a2 (let_fun this :=\n      (_ :\n        (prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) }).byteIdx <\n          { byteIdx := utf8Len (c :: l) }.byteIdx);\n    let pos := prev { data := List.reverse (c :: l) ++ r } { byteIdx := utf8Len (c :: l) };\n    if p (get { data := List.reverse (c :: l) ++ r } pos) = true then some pos\n    else revFindAux { data := List.reverse (c :: l) ++ r } p pos) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))", "state_after": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l } = c\nh2 : prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l + csize c } = { byteIdx := utf8Len l }\n\u22a2 (if p c = true then some { byteIdx := utf8Len l }\n    else revFindAux { data := List.reverse l ++ c :: r } p { byteIdx := utf8Len l }) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))"}, {"tactic": "cases p c <;> simp", "annotated_tactic": ["cases p c <;> simp", []], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l } = c\nh2 : prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l + csize c } = { byteIdx := utf8Len l }\n\u22a2 (if p c = true then some { byteIdx := utf8Len l }\n    else revFindAux { data := List.reverse l ++ c :: r } p { byteIdx := utf8Len l }) =\n    Option.map (fun x => { byteIdx := utf8Len x })\n      (List.tail?\n        (match !p c with\n        | true => List.dropWhile (fun x => !p x) l\n        | false => c :: l))", "state_after": "case false\np : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l } = c\nh2 : prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l + csize c } = { byteIdx := utf8Len l }\n\u22a2 revFindAux { data := List.reverse l ++ c :: r } p { byteIdx := utf8Len l } =\n    Option.map (fun x => { byteIdx := utf8Len x }) (List.tail? (List.dropWhile (fun x => !p x) l))"}, {"tactic": "exact revFindAux_of_valid p l (c::r)", "annotated_tactic": ["exact revFindAux_of_valid p l (c::r)", []], "state_before": "case false\np : Char \u2192 Bool\nc : Char\nl r : List Char\nh1 : get { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l } = c\nh2 : prev { data := List.reverse l ++ c :: r } { byteIdx := utf8Len l + csize c } = { byteIdx := utf8Len l }\n\u22a2 revFindAux { data := List.reverse l ++ c :: r } p { byteIdx := utf8Len l } =\n    Option.map (fun x => { byteIdx := utf8Len x }) (List.tail? (List.dropWhile (fun x => !p x) l))", "state_after": "no goals"}, {"tactic": "exact Pos.ne_of_gt add_csize_pos", "annotated_tactic": ["exact <a>Pos.ne_of_gt</a> <a>add_csize_pos</a>", [{"full_name": "String.Pos.ne_of_gt", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [136, 9], "def_end_pos": [136, 17]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.Data.String.Lemmas.0.String.add_csize_pos", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [44, 17], "def_end_pos": [44, 30]}]], "state_before": "p : Char \u2192 Bool\nc : Char\nl r : List Char\n\u22a2 \u00ac{ byteIdx := utf8Len (c :: l) } = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Multiplicity.lean", "full_name": "multiplicity.multiplicity_lt_iff_neg_dvd", "start": [151, 1], "end": [152, 98], "traced_tactics": [{"tactic": "rw [pow_dvd_iff_le_multiplicity, not_le]", "annotated_tactic": ["rw [<a>pow_dvd_iff_le_multiplicity</a>, <a>not_le</a>]", [{"full_name": "multiplicity.pow_dvd_iff_le_multiplicity", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [146, 9], "def_end_pos": [146, 36]}, {"full_name": "not_le", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [373, 9], "def_end_pos": [373, 15]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : DecidableRel fun x x_1 => x \u2223 x_1\na b : \u03b1\nk : \u2115\n\u22a2 multiplicity a b < \u2191k \u2194 \u00aca ^ k \u2223 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.div_eq_of_eq_mul_right", "start": [749, 11], "end": [750, 92], "traced_tactics": [{"tactic": "rw [H2, Int.mul_div_cancel_left _ H1]", "annotated_tactic": ["rw [H2, <a>Int.mul_div_cancel_left</a> _ H1]", [{"full_name": "Int.mul_div_cancel_left", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [213, 27], "def_end_pos": [213, 46]}]], "state_before": "a b c : Int\nH1 : b \u2260 0\nH2 : a = b * c\n\u22a2 div a b = c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.cons_injective_iff", "start": [191, 1], "end": [197, 62], "traced_tactics": [{"tactic": "refine' \u27e8fun h \u21a6 \u27e8_, _\u27e9, fun h \u21a6 cons_injective_of_injective h.1 h.2\u27e9", "annotated_tactic": ["refine' \u27e8fun h \u21a6 \u27e8_, _\u27e9, fun h \u21a6 <a>cons_injective_of_injective</a> h.1 h.2\u27e9", [{"full_name": "Fin.cons_injective_of_injective", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [172, 9], "def_end_pos": [172, 36]}]], "state_before": "m n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni : Fin n\ny : \u03b1\u271d (succ i)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\n\u22a2 Injective (cons x\u2080 x) \u2194 x\u2080 \u2209 Set.range x \u2227 Injective x", "state_after": "case refine'_1\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni : Fin n\ny : \u03b1\u271d (succ i)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\nh : Injective (cons x\u2080 x)\n\u22a2 x\u2080 \u2209 Set.range x\n\ncase refine'_2\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni : Fin n\ny : \u03b1\u271d (succ i)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\nh : Injective (cons x\u2080 x)\n\u22a2 Injective x"}, {"tactic": "rintro \u27e8i, hi\u27e9", "annotated_tactic": ["rintro \u27e8i, hi\u27e9", []], "state_before": "case refine'_1\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni : Fin n\ny : \u03b1\u271d (succ i)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\nh : Injective (cons x\u2080 x)\n\u22a2 x\u2080 \u2209 Set.range x", "state_after": "case refine'_1.intro\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni\u271d : Fin n\ny : \u03b1\u271d (succ i\u271d)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\nh : Injective (cons x\u2080 x)\ni : Fin n\nhi : x i = x\u2080\n\u22a2 False"}, {"tactic": "replace h := @h i.succ 0", "annotated_tactic": ["replace h := @h i.succ 0", []], "state_before": "case refine'_1.intro\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni\u271d : Fin n\ny : \u03b1\u271d (succ i\u271d)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\nh : Injective (cons x\u2080 x)\ni : Fin n\nhi : x i = x\u2080\n\u22a2 False", "state_after": "case refine'_1.intro\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni\u271d : Fin n\ny : \u03b1\u271d (succ i\u271d)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\ni : Fin n\nhi : x i = x\u2080\nh : cons x\u2080 x (succ i) = cons x\u2080 x 0 \u2192 succ i = 0\n\u22a2 False"}, {"tactic": "simp [hi, succ_ne_zero] at h", "annotated_tactic": ["simp [hi, <a>succ_ne_zero</a>] at h", [{"full_name": "Fin.succ_ne_zero", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [225, 9], "def_end_pos": [225, 21]}]], "state_before": "case refine'_1.intro\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni\u271d : Fin n\ny : \u03b1\u271d (succ i\u271d)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\ni : Fin n\nhi : x i = x\u2080\nh : cons x\u2080 x (succ i) = cons x\u2080 x 0 \u2192 succ i = 0\n\u22a2 False", "state_after": "no goals"}, {"tactic": "simpa [Function.comp] using h.comp (Fin.succ_injective _)", "annotated_tactic": ["simpa [<a>Function.comp</a>] using h.comp (<a>Fin.succ_injective</a> _)", [{"full_name": "Function.comp", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}, {"full_name": "Fin.succ_injective", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Basic.lean", "def_pos": [710, 9], "def_end_pos": [710, 23]}]], "state_before": "case refine'_2\nm n : \u2115\n\u03b1\u271d : Fin (n + 1) \u2192 Type u\nx\u271d : \u03b1\u271d 0\nq : (i : Fin (n + 1)) \u2192 \u03b1\u271d i\np : (i : Fin n) \u2192 \u03b1\u271d (succ i)\ni : Fin n\ny : \u03b1\u271d (succ i)\nz : \u03b1\u271d 0\n\u03b1 : Type u_1\nx\u2080 : \u03b1\nx : Fin n \u2192 \u03b1\nh : Injective (cons x\u2080 x)\n\u22a2 Injective x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean", "full_name": "Nat.ascFactorial_of_sub", "start": [280, 1], "end": [285, 91], "traced_tactics": [{"tactic": "let t := n - k.succ", "annotated_tactic": ["let t := n - k.succ", []], "state_before": "n k : \u2115\nh : k < n\n\u22a2 (n - k) * ascFactorial (n - k) k = ascFactorial (n - (k + 1)) (k + 1)", "state_after": "n k : \u2115\nh : k < n\nt : \u2115 := n - succ k\n\u22a2 (n - k) * ascFactorial (n - k) k = ascFactorial (n - (k + 1)) (k + 1)"}, {"tactic": "let ht : t = n - k.succ := rfl", "annotated_tactic": ["let ht : t = n - k.succ := <a>rfl</a>", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "n k : \u2115\nh : k < n\nt : \u2115 := n - succ k\n\u22a2 (n - k) * ascFactorial (n - k) k = ascFactorial (n - (k + 1)) (k + 1)", "state_after": "n k : \u2115\nh : k < n\nt : \u2115 := n - succ k\nht : t = n - succ k := rfl\n\u22a2 (n - k) * ascFactorial (n - k) k = ascFactorial (n - (k + 1)) (k + 1)"}, {"tactic": "suffices h' : n - k = t.succ by rw [\u2190 ht, h', succ_ascFactorial, ascFactorial_succ]", "annotated_tactic": ["suffices h' : n - k = t.succ by rw [\u2190 ht, h', <a>succ_ascFactorial</a>, <a>ascFactorial_succ</a>]", [{"full_name": "Nat.succ_ascFactorial", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [254, 9], "def_end_pos": [254, 26]}, {"full_name": "Nat.ascFactorial_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [249, 9], "def_end_pos": [249, 26]}]], "state_before": "n k : \u2115\nh : k < n\nt : \u2115 := n - succ k\nht : t = n - succ k := rfl\n\u22a2 (n - k) * ascFactorial (n - k) k = ascFactorial (n - (k + 1)) (k + 1)", "state_after": "n k : \u2115\nh : k < n\nt : \u2115 := n - succ k\nht : t = n - succ k := rfl\n\u22a2 n - k = succ t"}, {"tactic": "rw [ht, succ_eq_add_one, \u2190 tsub_tsub_assoc (succ_le_of_lt h) (succ_pos _), succ_sub_one]", "annotated_tactic": ["rw [ht, <a>succ_eq_add_one</a>, \u2190 <a>tsub_tsub_assoc</a> (<a>succ_le_of_lt</a> h) (<a>succ_pos</a> _), <a>succ_sub_one</a>]", [{"full_name": "Nat.succ_eq_add_one", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [128, 9], "def_end_pos": [128, 24]}, {"full_name": "tsub_tsub_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [222, 9], "def_end_pos": [222, 24]}, {"full_name": "Nat.succ_le_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [313, 9], "def_end_pos": [313, 22]}, {"full_name": "Nat.succ_pos", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1608, 9], "def_end_pos": [1608, 21]}, {"full_name": "Nat.succ_sub_one", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [443, 9], "def_end_pos": [443, 21]}]], "state_before": "n k : \u2115\nh : k < n\nt : \u2115 := n - succ k\nht : t = n - succ k := rfl\n\u22a2 n - k = succ t", "state_after": "no goals"}, {"tactic": "rw [\u2190 ht, h', succ_ascFactorial, ascFactorial_succ]", "annotated_tactic": ["rw [\u2190 ht, h', <a>succ_ascFactorial</a>, <a>ascFactorial_succ</a>]", [{"full_name": "Nat.succ_ascFactorial", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [254, 9], "def_end_pos": [254, 26]}, {"full_name": "Nat.ascFactorial_succ", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Factorial/Basic.lean", "def_pos": [249, 9], "def_end_pos": [249, 26]}]], "state_before": "n k : \u2115\nh : k < n\nt : \u2115 := n - succ k\nht : t = n - succ k := rfl\nh' : n - k = succ t\n\u22a2 (n - k) * ascFactorial (n - k) k = ascFactorial (n - (k + 1)) (k + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Log.lean", "full_name": "Nat.log_mul_base", "start": [169, 1], "end": [172, 77], "traced_tactics": [{"tactic": "apply log_eq_of_pow_le_of_lt_pow <;> rw [pow_succ', mul_comm b]", "annotated_tactic": ["apply <a>log_eq_of_pow_le_of_lt_pow</a> <;> rw [<a>pow_succ'</a>, <a>mul_comm</a> b]", [{"full_name": "Nat.log_eq_of_pow_le_of_lt_pow", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [148, 9], "def_end_pos": [148, 35]}, {"full_name": "Nat.pow_succ'", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [985, 9], "def_end_pos": [985, 18]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}]], "state_before": "b n : \u2115\nhb : 1 < b\nhn : n \u2260 0\n\u22a2 log b (n * b) = log b n + 1", "state_after": "case h\u2081\nb n : \u2115\nhb : 1 < b\nhn : n \u2260 0\n\u22a2 b ^ log b n * b \u2264 n * b\n\ncase h\u2082\nb n : \u2115\nhb : 1 < b\nhn : n \u2260 0\n\u22a2 n * b < b ^ (log b n + 1) * b"}, {"tactic": "exacts [mul_le_mul_right' (pow_log_le_self _ hn) _,\n  (mul_lt_mul_right (zero_lt_one.trans hb)).2 (lt_pow_succ_log_self hb _)]", "annotated_tactic": ["exacts [<a>mul_le_mul_right'</a> (<a>pow_log_le_self</a> _ hn) _,\n    (<a>mul_lt_mul_right</a> (zero_lt_one.trans hb)).2 (<a>lt_pow_succ_log_self</a> hb _)]", [{"full_name": "mul_le_mul_right'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [67, 9], "def_end_pos": [67, 26]}, {"full_name": "Nat.pow_log_le_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [118, 9], "def_end_pos": [118, 24]}, {"full_name": "mul_lt_mul_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [203, 9], "def_end_pos": [203, 25]}, {"full_name": "Nat.lt_pow_succ_log_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Log.lean", "def_pos": [130, 9], "def_end_pos": [130, 29]}]], "state_before": "case h\u2081\nb n : \u2115\nhb : 1 < b\nhn : n \u2260 0\n\u22a2 b ^ log b n * b \u2264 n * b\n\ncase h\u2082\nb n : \u2115\nhb : 1 < b\nhn : n \u2260 0\n\u22a2 n * b < b ^ (log b n + 1) * b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Finprod.lean", "full_name": "finprod_mem_union_inter", "start": [786, 1], "end": [791, 64], "traced_tactics": [{"tactic": "lift s to Finset \u03b1 using hs", "annotated_tactic": ["lift s to <a>Finset</a> \u03b1 using hs", [{"full_name": "Finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [139, 11], "def_end_pos": [139, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\ns t : Set \u03b1\nhs : Set.Finite s\nht : Set.Finite t\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 s \u222a t), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s \u2229 t), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 t), f i", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\nt : Set \u03b1\nht : Set.Finite t\ns : Finset \u03b1\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u222a t), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u2229 t), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 t), f i"}, {"tactic": "lift t to Finset \u03b1 using ht", "annotated_tactic": ["lift t to <a>Finset</a> \u03b1 using ht", [{"full_name": "Finset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [139, 11], "def_end_pos": [139, 17]}]], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\nt : Set \u03b1\nht : Set.Finite t\ns : Finset \u03b1\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u222a t), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u2229 t), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 t), f i", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\ns t : Finset \u03b1\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u222a \u2191t), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u2229 \u2191t), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191t), f i"}, {"tactic": "classical\n  rw [\u2190 Finset.coe_union, \u2190 Finset.coe_inter]\n  simp only [finprod_mem_coe_finset, Finset.prod_union_inter]", "annotated_tactic": ["classical\n    rw [\u2190 <a>Finset.coe_union</a>, \u2190 <a>Finset.coe_inter</a>]\n    simp only [<a>finprod_mem_coe_finset</a>, <a>Finset.prod_union_inter</a>]", [{"full_name": "Finset.coe_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1416, 9], "def_end_pos": [1416, 18]}, {"full_name": "Finset.coe_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1645, 9], "def_end_pos": [1645, 18]}, {"full_name": "finprod_mem_coe_finset", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [526, 9], "def_end_pos": [526, 31]}, {"full_name": "Finset.prod_union_inter", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [408, 9], "def_end_pos": [408, 25]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\ns t : Finset \u03b1\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u222a \u2191t), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u2229 \u2191t), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191t), f i", "state_after": "no goals"}, {"tactic": "rw [\u2190 Finset.coe_union, \u2190 Finset.coe_inter]", "annotated_tactic": ["rw [\u2190 <a>Finset.coe_union</a>, \u2190 <a>Finset.coe_inter</a>]", [{"full_name": "Finset.coe_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1416, 9], "def_end_pos": [1416, 18]}, {"full_name": "Finset.coe_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1645, 9], "def_end_pos": [1645, 18]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\ns t : Finset \u03b1\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u222a \u2191t), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s \u2229 \u2191t), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191t), f i", "state_after": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\ns t : Finset \u03b1\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191(s \u222a t)), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191(s \u2229 t)), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191t), f i"}, {"tactic": "simp only [finprod_mem_coe_finset, Finset.prod_union_inter]", "annotated_tactic": ["simp only [<a>finprod_mem_coe_finset</a>, <a>Finset.prod_union_inter</a>]", [{"full_name": "finprod_mem_coe_finset", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Finprod.lean", "def_pos": [526, 9], "def_end_pos": [526, 31]}, {"full_name": "Finset.prod_union_inter", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [408, 9], "def_end_pos": [408, 25]}]], "state_before": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nG : Type u_4\nM : Type u_5\nN : Type u_6\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192 M\na b : \u03b1\ns t : Finset \u03b1\n\u22a2 (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191(s \u222a t)), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191(s \u2229 t)), f i =\n    (\u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191s), f i) * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191t), f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean", "full_name": "IsCoprime.prod_right_iff", "start": [77, 1], "end": [78, 69], "traced_tactics": [{"tactic": "simpa only [isCoprime_comm] using IsCoprime.prod_left_iff (R := R)", "annotated_tactic": ["simpa only [<a>isCoprime_comm</a>] using <a>IsCoprime.prod_left_iff</a> (R := R)", [{"full_name": "isCoprime_comm", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Coprime/Basic.lean", "def_pos": [50, 9], "def_end_pos": [50, 23]}, {"full_name": "IsCoprime.prod_left_iff", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Coprime/Lemmas.lean", "def_pos": [72, 9], "def_end_pos": [72, 32]}]], "state_before": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\n\u22a2 IsCoprime x (\u220f i in t, s i) \u2194 \u2200 i \u2208 t, IsCoprime x (s i)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/IndicatorFunction.lean", "full_name": "Set.indicator_smul_left", "start": [515, 1], "end": [517, 44], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Rat/Lemmas.lean", "full_name": "Rat.intCast_neg", "start": [339, 9], "end": [340, 30], "traced_tactics": [{"tactic": "ext <;> simp [normalize_eq]", "annotated_tactic": ["ext <;> simp [<a>normalize_eq</a>]", [{"full_name": "Rat.normalize_eq", "def_path": "lake-packages/std/Std/Data/Rat/Lemmas.lean", "def_pos": [25, 9], "def_end_pos": [25, 21]}]], "state_before": "a : Int\n\u22a2 \u2191(-a) = -\u2191a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.Iterator.ValidFor.atEnd", "start": [581, 1], "end": [584, 85], "traced_tactics": [{"tactic": "simp [Iterator.atEnd, h.pos, h.toString]", "annotated_tactic": ["simp [<a>Iterator.atEnd</a>, h.pos, h.toString]", [{"full_name": "String.Iterator.atEnd", "def_path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "def_pos": [329, 5], "def_end_pos": [329, 10]}]], "state_before": "l r : List Char\nit : Iterator\nh : ValidFor l r it\n\u22a2 Iterator.atEnd it = true \u2194 r = []", "state_after": "l r : List Char\nit : Iterator\nh : ValidFor l r it\n\u22a2 utf8Len l \u2265 utf8Len l + utf8Len r \u2194 r = []"}, {"tactic": "exact (Nat.add_le_add_iff_left _ _ 0).trans <| Nat.le_zero.trans utf8Len_eq_zero", "annotated_tactic": ["exact (<a>Nat.add_le_add_iff_left</a> _ _ 0).<a>trans</a> <| Nat.le_zero.trans <a>utf8Len_eq_zero</a>", [{"full_name": "Nat.add_le_add_iff_left", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [363, 19], "def_end_pos": [363, 38]}, {"full_name": "Iff.trans", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [666, 9], "def_end_pos": [666, 18]}, {"full_name": "String.utf8Len_eq_zero", "def_path": "lake-packages/std/Std/Data/String/Lemmas.lean", "def_pos": [73, 17], "def_end_pos": [73, 32]}]], "state_before": "l r : List Char\nit : Iterator\nh : ValidFor l r it\n\u22a2 utf8Len l \u2265 utf8Len l + utf8Len r \u2194 r = []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Sigma.lean", "full_name": "Set.fst_image_sigma", "start": [242, 1], "end": [245, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "Matrix.submatrix_diagonal", "start": [2491, 1], "end": [2498, 64], "traced_tactics": [{"tactic": "rw [submatrix_apply]", "annotated_tactic": ["rw [<a>submatrix_apply</a>]", [{"full_name": "Matrix.submatrix_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [2429, 9], "def_end_pos": [2429, 24]}]], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\n\u22a2 submatrix (diagonal d) e e i j = diagonal (d \u2218 e) i j", "state_after": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\n\u22a2 diagonal d (e i) (e j) = diagonal (d \u2218 e) i j"}, {"tactic": "by_cases h : i = j", "annotated_tactic": ["by_cases h : i = j", []], "state_before": "l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\n\u22a2 diagonal d (e i) (e j) = diagonal (d \u2218 e) i j", "state_after": "case pos\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\nh : i = j\n\u22a2 diagonal d (e i) (e j) = diagonal (d \u2218 e) i j\n\ncase neg\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\nh : \u00aci = j\n\u22a2 diagonal d (e i) (e j) = diagonal (d \u2218 e) i j"}, {"tactic": "rw [h, diagonal_apply_eq, diagonal_apply_eq]", "annotated_tactic": ["rw [h, <a>diagonal_apply_eq</a>, <a>diagonal_apply_eq</a>]", [{"full_name": "Matrix.diagonal_apply_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [408, 9], "def_end_pos": [408, 26]}, {"full_name": "Matrix.diagonal_apply_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [408, 9], "def_end_pos": [408, 26]}]], "state_before": "case pos\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\nh : i = j\n\u22a2 diagonal d (e i) (e j) = diagonal (d \u2218 e) i j", "state_after": "case pos\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\nh : i = j\n\u22a2 d (e j) = (d \u2218 e) j"}, {"tactic": "simp only [Function.comp_apply]", "annotated_tactic": ["simp only [<a>Function.comp_apply</a>]", [{"full_name": "Function.comp_apply", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [33, 17], "def_end_pos": [33, 36]}]], "state_before": "case pos\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\nh : i = j\n\u22a2 d (e j) = (d \u2218 e) j", "state_after": "no goals"}, {"tactic": "rw [diagonal_apply_ne _ h, diagonal_apply_ne _ (he.ne h)]", "annotated_tactic": ["rw [<a>diagonal_apply_ne</a> _ h, <a>diagonal_apply_ne</a> _ (he.ne h)]", [{"full_name": "Matrix.diagonal_apply_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [413, 9], "def_end_pos": [413, 26]}, {"full_name": "Matrix.diagonal_apply_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Matrix/Basic.lean", "def_pos": [413, 9], "def_end_pos": [413, 26]}]], "state_before": "case neg\nl : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nm' : o \u2192 Type u_5\nn' : o \u2192 Type u_6\nR : Type u_7\nS : Type u_8\n\u03b1 : Type v\n\u03b2 : Type w\n\u03b3 : Type u_9\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : DecidableEq m\ninst\u271d : DecidableEq l\nd : m \u2192 \u03b1\ne : l \u2192 m\nhe : Function.Injective e\ni j : l\nh : \u00aci = j\n\u22a2 diagonal d (e i) (e j) = diagonal (d \u2218 e) i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/RBMap/WF.lean", "full_name": "Std.RBNode.Ordered.insert", "start": [116, 11], "end": [117, 74], "traced_tactics": [{"tactic": "unfold RBNode.insert", "annotated_tactic": ["unfold <a>RBNode.insert</a>", [{"full_name": "Std.RBNode.insert", "def_path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "def_pos": [315, 19], "def_end_pos": [315, 25]}]], "state_before": "\u03b1\u271d : Type u_1\ncmp : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Ordering\nt : RBNode \u03b1\u271d\nv : \u03b1\u271d\nh : Ordered cmp t\n\u22a2 Ordered cmp (insert cmp t v)", "state_after": "\u03b1\u271d : Type u_1\ncmp : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Ordering\nt : RBNode \u03b1\u271d\nv : \u03b1\u271d\nh : Ordered cmp t\n\u22a2 Ordered cmp\n    (match isRed t with\n    | red => setBlack (ins cmp v t)\n    | black => ins cmp v t)"}, {"tactic": "split <;> simp [Ordered.setBlack, h.ins (x := v)]", "annotated_tactic": ["split <;> simp [<a>Ordered.setBlack</a>, h.ins (x := v)]", [{"full_name": "Std.RBNode.Ordered.setBlack", "def_path": "lake-packages/std/Std/Data/RBMap/WF.lean", "def_pos": [79, 19], "def_end_pos": [79, 35]}]], "state_before": "\u03b1\u271d : Type u_1\ncmp : \u03b1\u271d \u2192 \u03b1\u271d \u2192 Ordering\nt : RBNode \u03b1\u271d\nv : \u03b1\u271d\nh : Ordered cmp t\n\u22a2 Ordered cmp\n    (match isRed t with\n    | red => setBlack (ins cmp v t)\n    | black => ins cmp v t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "IsLeast.image2", "start": [1405, 1], "end": [1406, 72], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Lattice.lean", "full_name": "List.foldr_sup_eq_sup_toFinset", "start": [213, 1], "end": [217, 6], "traced_tactics": [{"tactic": "rw [\u2190 coe_fold_r, \u2190 Multiset.fold_dedup_idem, sup_def, \u2190 List.toFinset_coe, toFinset_val,\n  Multiset.map_id]", "annotated_tactic": ["rw [\u2190 <a>coe_fold_r</a>, \u2190 <a>Multiset.fold_dedup_idem</a>, <a>sup_def</a>, \u2190 <a>List.toFinset_coe</a>, <a>toFinset_val</a>,\n    <a>Multiset.map_id</a>]", [{"full_name": "Multiset.coe_fold_r", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Fold.lean", "def_pos": [41, 9], "def_end_pos": [41, 19]}, {"full_name": "Multiset.fold_dedup_idem", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Fold.lean", "def_pos": [115, 9], "def_end_pos": [115, 24]}, {"full_name": "Finset.sup_def", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [44, 9], "def_end_pos": [44, 16]}, {"full_name": "List.toFinset_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3333, 9], "def_end_pos": [3333, 21]}, {"full_name": "Multiset.toFinset_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3209, 9], "def_end_pos": [3209, 21]}, {"full_name": "Multiset.map_id", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1291, 9], "def_end_pos": [1291, 15]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns s\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 List.foldr (fun x x_1 => x \u2294 x_1) \u22a5 l = sup (List.toFinset l) id", "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns s\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 Multiset.fold (fun x x_1 => x \u2294 x_1) \u22a5 (dedup \u2191l) = Multiset.sup (dedup \u2191l)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b9 : Type u_5\n\u03ba : Type u_6\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns s\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 Multiset.fold (fun x x_1 => x \u2294 x_1) \u22a5 (dedup \u2191l) = Multiset.sup (dedup \u2191l)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Quot.lean", "full_name": "Quotient.out_inj", "start": [409, 1], "end": [410, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.last_eq_of_concat_eq", "start": [529, 1], "end": [532, 50], "traced_tactics": [{"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\n\u22a2 concat l a = concat l b \u2192 a = b", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\nh : concat l a = concat l b\n\u22a2 a = b"}, {"tactic": "rw [concat_eq_append, concat_eq_append] at h", "annotated_tactic": ["rw [<a>concat_eq_append</a>, <a>concat_eq_append</a>] at h", [{"full_name": "List.concat_eq_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [850, 9], "def_end_pos": [850, 25]}, {"full_name": "List.concat_eq_append", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [850, 9], "def_end_pos": [850, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\nh : concat l a = concat l b\n\u22a2 a = b", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\nh : l ++ [a] = l ++ [b]\n\u22a2 a = b"}, {"tactic": "exact head_eq_of_cons_eq (append_left_cancel h)", "annotated_tactic": ["exact <a>head_eq_of_cons_eq</a> (<a>append_left_cancel</a> h)", [{"full_name": "List.head_eq_of_cons_eq", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [25, 9], "def_end_pos": [25, 27]}, {"full_name": "List.append_left_cancel", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [394, 9], "def_end_pos": [394, 27]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na b : \u03b1\nl : List \u03b1\nh : l ++ [a] = l ++ [b]\n\u22a2 a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Range.lean", "full_name": "List.nodup_range'", "start": [51, 1], "end": [52, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.Eventually.comap", "start": [2141, 1], "end": [2143, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Sign.lean", "full_name": "Equiv.Perm.sign_prod_list_swap", "start": [614, 1], "end": [621, 66], "traced_tactics": [{"tactic": "have h\u2081 : l.map sign = List.replicate l.length (-1) :=\n  List.eq_replicate.2\n    \u27e8by simp, fun u hu =>\n      let \u27e8g, hg\u27e9 := List.mem_map.1 hu\n      hg.2 \u25b8 (hl _ hg.1).sign_eq\u27e9", "annotated_tactic": ["have h\u2081 : l.map <a>sign</a> = <a>List.replicate</a> l.length (-1) :=\n    <a>List.eq_replicate</a>.2\n      \u27e8by simp, fun u hu =>\n        let \u27e8g, hg\u27e9 := <a>List.mem_map</a>.1 hu\n        hg.2 \u25b8 (hl _ hg.1).<a>sign_eq</a>\u27e9", [{"full_name": "Equiv.Perm.sign", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [537, 5], "def_end_pos": [537, 9]}, {"full_name": "List.replicate", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [736, 13], "def_end_pos": [736, 22]}, {"full_name": "List.eq_replicate", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [359, 9], "def_end_pos": [359, 21]}, {"full_name": "List.mem_map", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [154, 17], "def_end_pos": [154, 24]}, {"full_name": "Equiv.Perm.IsSwap.sign_eq", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [584, 9], "def_end_pos": [584, 23]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nl : List (Perm \u03b1)\nhl : \u2200 g \u2208 l, IsSwap g\n\u22a2 \u2191sign (List.prod l) = (-1) ^ List.length l", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nl : List (Perm \u03b1)\nhl : \u2200 g \u2208 l, IsSwap g\nh\u2081 : List.map (\u2191sign) l = List.replicate (List.length l) (-1)\n\u22a2 \u2191sign (List.prod l) = (-1) ^ List.length l"}, {"tactic": "rw [\u2190 List.prod_replicate, \u2190 h\u2081, List.prod_hom _ (@sign \u03b1 _ _)]", "annotated_tactic": ["rw [\u2190 <a>List.prod_replicate</a>, \u2190 h\u2081, <a>List.prod_hom</a> _ (@<a>sign</a> \u03b1 _ _)]", [{"full_name": "List.prod_replicate", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [86, 9], "def_end_pos": [86, 23]}, {"full_name": "List.prod_hom", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [108, 9], "def_end_pos": [108, 17]}, {"full_name": "Equiv.Perm.sign", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Sign.lean", "def_pos": [537, 5], "def_end_pos": [537, 9]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nl : List (Perm \u03b1)\nhl : \u2200 g \u2208 l, IsSwap g\nh\u2081 : List.map (\u2191sign) l = List.replicate (List.length l) (-1)\n\u22a2 \u2191sign (List.prod l) = (-1) ^ List.length l", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nl : List (Perm \u03b1)\nhl : \u2200 g \u2208 l, IsSwap g\n\u22a2 List.length (List.map (\u2191sign) l) = List.length l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Parity.lean", "full_name": "Nat.mod_two_ne_one", "start": [28, 1], "end": [29, 56], "traced_tactics": [{"tactic": "cases' mod_two_eq_zero_or_one n with h h <;> simp [h]", "annotated_tactic": ["cases' <a>mod_two_eq_zero_or_one</a> n with h h <;> simp [h]", [{"full_name": "Nat.mod_two_eq_zero_or_one", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [901, 9], "def_end_pos": [901, 31]}]], "state_before": "m n : \u2115\n\u22a2 \u00acn % 2 = 1 \u2194 n % 2 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.degree_derivative_eq", "start": [376, 1], "end": [390, 13], "traced_tactics": [{"tactic": "apply le_antisymm", "annotated_tactic": ["apply <a>le_antisymm</a>", [{"full_name": "le_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 degree (\u2191derivative p) = \u2191(natDegree p - 1)", "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 degree (\u2191derivative p) \u2264 \u2191(natDegree p - 1)\n\ncase a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 \u2191(natDegree p - 1) \u2264 degree (\u2191derivative p)"}, {"tactic": "rw [derivative_apply]", "annotated_tactic": ["rw [<a>derivative_apply</a>]", [{"full_name": "Polynomial.derivative_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [52, 9], "def_end_pos": [52, 25]}]], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 degree (\u2191derivative p) \u2264 \u2191(natDegree p - 1)", "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 degree (sum p fun n a => \u2191C (a * \u2191n) * X ^ (n - 1)) \u2264 \u2191(natDegree p - 1)"}, {"tactic": "apply le_trans (degree_sum_le _ _) (Finset.sup_le _)", "annotated_tactic": ["apply <a>le_trans</a> (<a>degree_sum_le</a> _ _) (<a>Finset.sup_le</a> _)", [{"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}, {"full_name": "Polynomial.degree_sum_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [776, 9], "def_end_pos": [776, 22]}, {"full_name": "Finset.sup_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [105, 11], "def_end_pos": [105, 17]}]], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 degree (sum p fun n a => \u2191C (a * \u2191n) * X ^ (n - 1)) \u2264 \u2191(natDegree p - 1)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 \u2200 b \u2208 support p, degree ((fun n a => \u2191C (a * \u2191n) * X ^ (n - 1)) b (coeff p b)) \u2264 \u2191(natDegree p - 1)"}, {"tactic": "intro n hn", "annotated_tactic": ["intro n hn", []], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 \u2200 b \u2208 support p, degree ((fun n a => \u2191C (a * \u2191n) * X ^ (n - 1)) b (coeff p b)) \u2264 \u2191(natDegree p - 1)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\nn : \u2115\nhn : n \u2208 support p\n\u22a2 degree ((fun n a => \u2191C (a * \u2191n) * X ^ (n - 1)) n (coeff p n)) \u2264 \u2191(natDegree p - 1)"}, {"tactic": "apply le_trans (degree_C_mul_X_pow_le _ _) (WithBot.coe_le_coe.2 (tsub_le_tsub_right _ _))", "annotated_tactic": ["apply <a>le_trans</a> (<a>degree_C_mul_X_pow_le</a> _ _) (<a>WithBot.coe_le_coe</a>.2 (<a>tsub_le_tsub_right</a> _ _))", [{"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}, {"full_name": "Polynomial.degree_C_mul_X_pow_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [306, 9], "def_end_pos": [306, 30]}, {"full_name": "WithBot.coe_le_coe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [206, 9], "def_end_pos": [206, 19]}, {"full_name": "tsub_le_tsub_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Defs.lean", "def_pos": [106, 19], "def_end_pos": [106, 37]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\nn : \u2115\nhn : n \u2208 support p\n\u22a2 degree ((fun n a => \u2191C (a * \u2191n) * X ^ (n - 1)) n (coeff p n)) \u2264 \u2191(natDegree p - 1)", "state_after": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\nn : \u2115\nhn : n \u2208 support p\n\u22a2 n \u2264 natDegree p"}, {"tactic": "apply le_natDegree_of_mem_supp _ hn", "annotated_tactic": ["apply <a>le_natDegree_of_mem_supp</a> _ hn", [{"full_name": "Polynomial.le_natDegree_of_mem_supp", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [186, 9], "def_end_pos": [186, 33]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn\u271d : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\nn : \u2115\nhn : n \u2208 support p\n\u22a2 n \u2264 natDegree p", "state_after": "no goals"}, {"tactic": "refine' le_sup _", "annotated_tactic": ["refine' <a>le_sup</a> _", [{"full_name": "Finset.le_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [114, 9], "def_end_pos": [114, 15]}]], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 \u2191(natDegree p - 1) \u2264 degree (\u2191derivative p)", "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 natDegree p - 1 \u2208 support (\u2191derivative p)"}, {"tactic": "rw [mem_support_derivative, tsub_add_cancel_of_le, mem_support_iff]", "annotated_tactic": ["rw [<a>mem_support_derivative</a>, <a>tsub_add_cancel_of_le</a>, <a>mem_support_iff</a>]", [{"full_name": "Polynomial.mem_support_derivative", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Derivative.lean", "def_pos": [367, 9], "def_end_pos": [367, 31]}, {"full_name": "tsub_add_cancel_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}, {"full_name": "Polynomial.mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [732, 9], "def_end_pos": [732, 24]}]], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 natDegree p - 1 \u2208 support (\u2191derivative p)", "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 coeff p (natDegree p) \u2260 0\n\ncase a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 1 \u2264 natDegree p"}, {"tactic": "exact hp", "annotated_tactic": ["exact hp", []], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 1 \u2264 natDegree p", "state_after": "no goals"}, {"tactic": "rw [coeff_natDegree, Ne.def, leadingCoeff_eq_zero]", "annotated_tactic": ["rw [<a>coeff_natDegree</a>, <a>Ne.def</a>, <a>leadingCoeff_eq_zero</a>]", [{"full_name": "Polynomial.coeff_natDegree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [111, 9], "def_end_pos": [111, 24]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [670, 9], "def_end_pos": [670, 29]}]], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 coeff p (natDegree p) \u2260 0", "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 \u00acp = 0"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\n\u22a2 \u00acp = 0", "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\nh : p = 0\n\u22a2 False"}, {"tactic": "rw [h, natDegree_zero] at hp", "annotated_tactic": ["rw [h, <a>natDegree_zero</a>] at hp", [{"full_name": "Polynomial.natDegree_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [106, 9], "def_end_pos": [106, 23]}]], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < natDegree p\nh : p = 0\n\u22a2 False", "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < 0\nh : p = 0\n\u22a2 False"}, {"tactic": "exact hp.false", "annotated_tactic": ["exact hp.false", []], "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroSMulDivisors \u2115 R\np : R[X]\nhp : 0 < 0\nh : p = 0\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Floor.lean", "full_name": "Nat.cast_floor_eq_int_floor", "start": [1709, 1], "end": [1710, 70], "traced_tactics": [{"tactic": "rw [\u2190 Int.floor_toNat, Int.toNat_of_nonneg (Int.floor_nonneg.2 ha)]", "annotated_tactic": ["rw [\u2190 <a>Int.floor_toNat</a>, <a>Int.toNat_of_nonneg</a> (<a>Int.floor_nonneg</a>.2 ha)]", [{"full_name": "Int.floor_toNat", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [1689, 9], "def_end_pos": [1689, 24]}, {"full_name": "Int.toNat_of_nonneg", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [1380, 17], "def_end_pos": [1380, 32]}, {"full_name": "Int.floor_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Floor.lean", "def_pos": [692, 9], "def_end_pos": [692, 21]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : LinearOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na : \u03b1\nha : 0 \u2264 a\n\u22a2 \u2191\u230aa\u230b\u208a = \u230aa\u230b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Join.lean", "full_name": "List.nthLe_join", "start": [179, 1], "end": [184, 73], "traced_tactics": [{"tactic": "have := nthLe_take L.join (sum_take_map_length_lt2 L hi hj) (sum_take_map_length_lt1 L hi hj)", "annotated_tactic": ["have := <a>nthLe_take</a> L.join (<a>sum_take_map_length_lt2</a> L hi hj) (<a>sum_take_map_length_lt1</a> L hi hj)", [{"full_name": "List.nthLe_take", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1935, 9], "def_end_pos": [1935, 19]}, {"full_name": "List.sum_take_map_length_lt2", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Join.lean", "def_pos": [167, 9], "def_end_pos": [167, 32]}, {"full_name": "List.sum_take_map_length_lt1", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Join.lean", "def_pos": [158, 9], "def_end_pos": [158, 32]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nL : List (List \u03b1)\ni j : \u2115\nhi : i < length L\nhj : j < length (nthLe L i hi)\n\u22a2 nthLe (join L) (sum (take i (map length L)) + j) (_ : sum (take i (map length L)) + j < length (join L)) =\n    nthLe (nthLe L i hi) j hj", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nL : List (List \u03b1)\ni j : \u2115\nhi : i < length L\nhj : j < length (nthLe L i hi)\nthis :\n  nthLe (join L) (sum (take i (map length L)) + j) (_ : sum (take i (map length L)) + j < length (join L)) =\n    nthLe (take (sum (take (i + 1) (map length L))) (join L)) (sum (take i (map length L)) + j)\n      (_ : sum (take i (map length L)) + j < length (take (sum (take (i + 1) (map length L))) (join L)))\n\u22a2 nthLe (join L) (sum (take i (map length L)) + j) (_ : sum (take i (map length L)) + j < length (join L)) =\n    nthLe (nthLe L i hi) j hj"}, {"tactic": "rw [this, nthLe_drop, nthLe_of_eq (drop_take_succ_join_eq_nthLe L hi)]", "annotated_tactic": ["rw [this, <a>nthLe_drop</a>, <a>nthLe_of_eq</a> (<a>drop_take_succ_join_eq_nthLe</a> L hi)]", [{"full_name": "List.nthLe_drop", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [2149, 9], "def_end_pos": [2149, 19]}, {"full_name": "List.nthLe_of_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [1257, 9], "def_end_pos": [1257, 20]}, {"full_name": "List.drop_take_succ_join_eq_nthLe", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Join.lean", "def_pos": [148, 9], "def_end_pos": [148, 37]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nL : List (List \u03b1)\ni j : \u2115\nhi : i < length L\nhj : j < length (nthLe L i hi)\nthis :\n  nthLe (join L) (sum (take i (map length L)) + j) (_ : sum (take i (map length L)) + j < length (join L)) =\n    nthLe (take (sum (take (i + 1) (map length L))) (join L)) (sum (take i (map length L)) + j)\n      (_ : sum (take i (map length L)) + j < length (take (sum (take (i + 1) (map length L))) (join L)))\n\u22a2 nthLe (join L) (sum (take i (map length L)) + j) (_ : sum (take i (map length L)) + j < length (join L)) =\n    nthLe (nthLe L i hi) j hj", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "irreducible_isUnit_mul", "start": [265, 1], "end": [267, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Setoid/Basic.lean", "full_name": "Setoid.sInf_def", "start": [155, 1], "end": [158, 6], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\n\u22a2 Rel (sInf s) = sInf (Rel '' s)", "state_after": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 Rel (sInf s) x\u271d\u00b9 x\u271d \u2194 sInf (Rel '' s) x\u271d\u00b9 x\u271d"}, {"tactic": "simp only [sInf_image, iInf_apply, iInf_Prop_eq]", "annotated_tactic": ["simp only [<a>sInf_image</a>, <a>iInf_apply</a>, <a>iInf_Prop_eq</a>]", [{"full_name": "sInf_image", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1464, 9], "def_end_pos": [1464, 19]}, {"full_name": "iInf_apply", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1859, 9], "def_end_pos": [1859, 19]}, {"full_name": "iInf_Prop_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1820, 9], "def_end_pos": [1820, 21]}]], "state_before": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 Rel (sInf s) x\u271d\u00b9 x\u271d \u2194 sInf (Rel '' s) x\u271d\u00b9 x\u271d", "state_after": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 Rel (sInf s) x\u271d\u00b9 x\u271d \u2194 \u2200 i \u2208 s, Rel i x\u271d\u00b9 x\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 Rel (sInf s) x\u271d\u00b9 x\u271d \u2194 \u2200 i \u2208 s, Rel i x\u271d\u00b9 x\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Opposites.lean", "full_name": "MulOpposite.unop_inj", "start": [180, 1], "end": [181, 24], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.curryFinFinset_symm_apply_piecewise_const", "start": [1545, 1], "end": [1557, 62], "traced_tactics": [{"tactic": "rw [curryFinFinset_symm_apply]", "annotated_tactic": ["rw [<a>curryFinFinset_symm_apply</a>]", [{"full_name": "MultilinearMap.curryFinFinset_symm_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Multilinear/Basic.lean", "def_pos": [1534, 9], "def_end_pos": [1534, 34]}]], "state_before": "R : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\n\u22a2 \u2191(\u2191(LinearEquiv.symm (curryFinFinset R M\u2082 M' hk hl)) f) (Finset.piecewise s (fun x_1 => x) fun x => y) =\n    \u2191(\u2191f fun x_1 => x) fun x => y", "state_after": "R : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\n\u22a2 (\u2191(\u2191f fun i => Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inl i))) fun i =>\n      Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inr i))) =\n    \u2191(\u2191f fun x_1 => x) fun x => y"}, {"tactic": "congr", "annotated_tactic": ["congr", []], "state_before": "R : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\n\u22a2 (\u2191(\u2191f fun i => Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inl i))) fun i =>\n      Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inr i))) =\n    \u2191(\u2191f fun x_1 => x) fun x => y", "state_after": "case h.e_5.h.h.e_6.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\n\u22a2 (fun i => Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inl i))) = fun x_1 => x\n\ncase h.e_6.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\n\u22a2 (fun i => Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inr i))) = fun x => y"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case h.e_5.h.h.e_6.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\n\u22a2 (fun i => Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inl i))) = fun x_1 => x", "state_after": "case h.e_5.h.h.e_6.h.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin k\n\u22a2 Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inl x\u271d)) = x"}, {"tactic": "rw [finSumEquivOfFinset_inl, Finset.piecewise_eq_of_mem]", "annotated_tactic": ["rw [<a>finSumEquivOfFinset_inl</a>, <a>Finset.piecewise_eq_of_mem</a>]", [{"full_name": "finSumEquivOfFinset_inl", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Sort.lean", "def_pos": [47, 9], "def_end_pos": [47, 32]}, {"full_name": "Finset.piecewise_eq_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2533, 9], "def_end_pos": [2533, 28]}]], "state_before": "case h.e_5.h.h.e_6.h.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin k\n\u22a2 Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inl x\u271d)) = x", "state_after": "case h.e_5.h.h.e_6.h.h.hi\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin k\n\u22a2 \u2191(Finset.orderEmbOfFin s hk) x\u271d \u2208 s"}, {"tactic": "apply Finset.orderEmbOfFin_mem", "annotated_tactic": ["apply <a>Finset.orderEmbOfFin_mem</a>", [{"full_name": "Finset.orderEmbOfFin_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Sort.lean", "def_pos": [180, 9], "def_end_pos": [180, 26]}]], "state_before": "case h.e_5.h.h.e_6.h.h.hi\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin k\n\u22a2 \u2191(Finset.orderEmbOfFin s hk) x\u271d \u2208 s", "state_after": "no goals"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case h.e_6.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\n\u22a2 (fun i => Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inr i))) = fun x => y", "state_after": "case h.e_6.h.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin l\n\u22a2 Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inr x\u271d)) = y"}, {"tactic": "rw [finSumEquivOfFinset_inr, Finset.piecewise_eq_of_not_mem]", "annotated_tactic": ["rw [<a>finSumEquivOfFinset_inr</a>, <a>Finset.piecewise_eq_of_not_mem</a>]", [{"full_name": "finSumEquivOfFinset_inr", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Sort.lean", "def_pos": [53, 9], "def_end_pos": [53, 32]}, {"full_name": "Finset.piecewise_eq_of_not_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2538, 9], "def_end_pos": [2538, 32]}]], "state_before": "case h.e_6.h.h\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin l\n\u22a2 Finset.piecewise s (fun x_1 => x) (fun x => y) (\u2191(finSumEquivOfFinset hk hl) (Sum.inr x\u271d)) = y", "state_after": "case h.e_6.h.h.hi\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin l\n\u22a2 \u2191(Finset.orderEmbOfFin s\u1d9c hl) x\u271d \u2209 s"}, {"tactic": "exact Finset.mem_compl.1 (Finset.orderEmbOfFin_mem _ _ _)", "annotated_tactic": ["exact <a>Finset.mem_compl</a>.1 (<a>Finset.orderEmbOfFin_mem</a> _ _ _)", [{"full_name": "Finset.mem_compl", "def_path": "lake-packages/mathlib/Mathlib/Data/Fintype/Basic.lean", "def_pos": [167, 9], "def_end_pos": [167, 18]}, {"full_name": "Finset.orderEmbOfFin_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Sort.lean", "def_pos": [180, 9], "def_end_pos": [180, 26]}]], "state_before": "case h.e_6.h.h.hi\nR : Type uR\nS : Type uS\n\u03b9 : Type u\u03b9\nn\u271d : \u2115\nM : Fin (Nat.succ n\u271d) \u2192 Type v\nM\u2081 : \u03b9 \u2192 Type v\u2081\nM\u2082 : Type v\u2082\nM\u2083 : Type v\u2083\nM' : Type v'\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : (i : Fin (Nat.succ n\u271d)) \u2192 AddCommMonoid (M i)\ninst\u271d\u2074 : AddCommMonoid M'\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : (i : Fin (Nat.succ n\u271d)) \u2192 Module R (M i)\ninst\u271d\u00b9 : Module R M'\ninst\u271d : Module R M\u2082\n\u03b9' : Type u_1\nk l n : \u2115\ns : Finset (Fin n)\nhk : Finset.card s = k\nhl : Finset.card s\u1d9c = l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M\u2082)\nx y : M'\nx\u271d : Fin l\n\u22a2 \u2191(Finset.orderEmbOfFin s\u1d9c hl) x\u271d \u2209 s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "AddMonoidAlgebra.domCongr_symm", "start": [2114, 9], "end": [2114, 96], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/EuclideanDomain/Basic.lean", "full_name": "EuclideanDomain.zero_mod", "start": [76, 1], "end": [77, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Order/Lemmas.lean", "full_name": "Nat.succ_div_of_dvd", "start": [154, 1], "end": [155, 28], "traced_tactics": [{"tactic": "rw [succ_div, if_pos hba]", "annotated_tactic": ["rw [<a>succ_div</a>, <a>if_pos</a> hba]", [{"full_name": "Nat.succ_div", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Order/Lemmas.lean", "def_pos": [124, 9], "def_end_pos": [124, 17]}, {"full_name": "if_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [790, 9], "def_end_pos": [790, 15]}]], "state_before": "a\u271d b\u271d m n k a b : \u2115\nhba : b \u2223 a + 1\n\u22a2 (a + 1) / b = a / b + 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.mem_image\u2082_iff", "start": [74, 1], "end": [75, 66], "traced_tactics": [{"tactic": "rw [\u2190 mem_coe, coe_image\u2082, mem_image2_iff hf, mem_coe, mem_coe]", "annotated_tactic": ["rw [\u2190 <a>mem_coe</a>, <a>coe_image\u2082</a>, <a>mem_image2_iff</a> hf, <a>mem_coe</a>, <a>mem_coe</a>]", [{"full_name": "Finset.mem_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 16]}, {"full_name": "Finset.coe_image\u2082", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/NAry.lean", "def_pos": [49, 9], "def_end_pos": [49, 19]}, {"full_name": "Set.mem_image2_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [48, 9], "def_end_pos": [48, 23]}, {"full_name": "Finset.mem_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 16]}, {"full_name": "Finset.mem_coe", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2077 : DecidableEq \u03b1'\ninst\u271d\u2076 : DecidableEq \u03b2'\ninst\u271d\u2075 : DecidableEq \u03b3\ninst\u271d\u2074 : DecidableEq \u03b3'\ninst\u271d\u00b3 : DecidableEq \u03b4\ninst\u271d\u00b2 : DecidableEq \u03b4'\ninst\u271d\u00b9 : DecidableEq \u03b5\ninst\u271d : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\nhf : Injective2 f\n\u22a2 f a b \u2208 image\u2082 f s t \u2194 a \u2208 s \u2227 b \u2208 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.map_iInf_eq", "start": [2571, 1], "end": [2579, 35], "traced_tactics": [{"tactic": "simp only [le_principal_iff, mem_map]", "annotated_tactic": ["simp only [<a>le_principal_iff</a>, <a>mem_map</a>]", [{"full_name": "Filter.le_principal_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [655, 9], "def_end_pos": [655, 25]}, {"full_name": "Filter.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [1861, 9], "def_end_pos": [1861, 16]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : \u03b9 \u2192 Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nhf : Directed (fun x x_1 => x \u2265 x_1) f\ninst\u271d : Nonempty \u03b9\ns : Set \u03b2\nhs : m \u207b\u00b9' s \u2208 iInf f\ni : \u03b9\nhi : m \u207b\u00b9' s \u2208 f i\n\u22a2 map m (f i) \u2264 \ud835\udcdf s", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : \u03b9 \u2192 Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nhf : Directed (fun x x_1 => x \u2265 x_1) f\ninst\u271d : Nonempty \u03b9\ns : Set \u03b2\nhs : m \u207b\u00b9' s \u2208 iInf f\ni : \u03b9\nhi : m \u207b\u00b9' s \u2208 f i\n\u22a2 m \u207b\u00b9' s \u2208 f i"}, {"tactic": "assumption", "annotated_tactic": ["assumption", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf : \u03b9 \u2192 Filter \u03b1\nm : \u03b1 \u2192 \u03b2\nhf : Directed (fun x x_1 => x \u2265 x_1) f\ninst\u271d : Nonempty \u03b9\ns : Set \u03b2\nhs : m \u207b\u00b9' s \u2208 iInf f\ni : \u03b9\nhi : m \u207b\u00b9' s \u2208 f i\n\u22a2 m \u207b\u00b9' s \u2208 f i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/MonoidLocalization.lean", "full_name": "Submonoid.LocalizationMap.lift_injective_iff", "start": [1100, 1], "end": [1113, 66], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "M : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\n\u22a2 Injective \u2191(lift f hg) \u2194 \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y", "state_after": "case mp\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\n\u22a2 Injective \u2191(lift f hg) \u2192 \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\n\ncase mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\n\u22a2 (\u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y) \u2192 Injective \u2191(lift f hg)"}, {"tactic": "intro H x y", "annotated_tactic": ["intro H x y", []], "state_before": "case mp\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\n\u22a2 Injective \u2191(lift f hg) \u2192 \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y", "state_after": "case mp\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y"}, {"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "case mp\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y", "state_after": "case mp.mp\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y \u2192 \u2191g x = \u2191g y\n\ncase mp.mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\n\u22a2 \u2191g x = \u2191g y \u2192 \u2191(toMap f) x = \u2191(toMap f) y"}, {"tactic": "exact f.eq_of_eq hg", "annotated_tactic": ["exact f.eq_of_eq hg", []], "state_before": "case mp.mp\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y \u2192 \u2191g x = \u2191g y", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp.mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\n\u22a2 \u2191g x = \u2191g y \u2192 \u2191(toMap f) x = \u2191(toMap f) y", "state_after": "case mp.mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\nh : \u2191g x = \u2191g y\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y"}, {"tactic": "rw [\u2190 f.lift_eq hg, \u2190 f.lift_eq hg] at h", "annotated_tactic": ["rw [\u2190 f.lift_eq hg, \u2190 f.lift_eq hg] at h", []], "state_before": "case mp.mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\nh : \u2191g x = \u2191g y\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y", "state_after": "case mp.mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\nh : \u2191(lift f hg) (\u2191(toMap f) x) = \u2191(lift f hg) (\u2191(toMap f) y)\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y"}, {"tactic": "exact H h", "annotated_tactic": ["exact H h", []], "state_before": "case mp.mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : Injective \u2191(lift f hg)\nx y : M\nh : \u2191(lift f hg) (\u2191(toMap f) x) = \u2191(lift f hg) (\u2191(toMap f) y)\n\u22a2 \u2191(toMap f) x = \u2191(toMap f) y", "state_after": "no goals"}, {"tactic": "intro H z w h", "annotated_tactic": ["intro H z w h", []], "state_before": "case mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\n\u22a2 (\u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y) \u2192 Injective \u2191(lift f hg)", "state_after": "case mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\n\u22a2 z = w"}, {"tactic": "obtain \u27e8_, _\u27e9 := f.surj z", "annotated_tactic": ["obtain \u27e8_, _\u27e9 := f.surj z", []], "state_before": "case mpr\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\n\u22a2 z = w", "state_after": "case mpr.intro\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\nw\u271d : M \u00d7 \u21a5S\nh\u271d : z * \u2191(toMap f) \u2191w\u271d.2 = \u2191(toMap f) w\u271d.1\n\u22a2 z = w"}, {"tactic": "obtain \u27e8_, _\u27e9 := f.surj w", "annotated_tactic": ["obtain \u27e8_, _\u27e9 := f.surj w", []], "state_before": "case mpr.intro\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\nw\u271d : M \u00d7 \u21a5S\nh\u271d : z * \u2191(toMap f) \u2191w\u271d.2 = \u2191(toMap f) w\u271d.1\n\u22a2 z = w", "state_after": "case mpr.intro.intro\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\nw\u271d\u00b9 : M \u00d7 \u21a5S\nh\u271d\u00b9 : z * \u2191(toMap f) \u2191w\u271d\u00b9.2 = \u2191(toMap f) w\u271d\u00b9.1\nw\u271d : M \u00d7 \u21a5S\nh\u271d : w * \u2191(toMap f) \u2191w\u271d.2 = \u2191(toMap f) w\u271d.1\n\u22a2 z = w"}, {"tactic": "rw [\u2190 f.mk'_sec z, \u2190 f.mk'_sec w]", "annotated_tactic": ["rw [\u2190 f.mk'_sec z, \u2190 f.mk'_sec w]", []], "state_before": "case mpr.intro.intro\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\nw\u271d\u00b9 : M \u00d7 \u21a5S\nh\u271d\u00b9 : z * \u2191(toMap f) \u2191w\u271d\u00b9.2 = \u2191(toMap f) w\u271d\u00b9.1\nw\u271d : M \u00d7 \u21a5S\nh\u271d : w * \u2191(toMap f) \u2191w\u271d.2 = \u2191(toMap f) w\u271d.1\n\u22a2 z = w", "state_after": "case mpr.intro.intro\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\nw\u271d\u00b9 : M \u00d7 \u21a5S\nh\u271d\u00b9 : z * \u2191(toMap f) \u2191w\u271d\u00b9.2 = \u2191(toMap f) w\u271d\u00b9.1\nw\u271d : M \u00d7 \u21a5S\nh\u271d : w * \u2191(toMap f) \u2191w\u271d.2 = \u2191(toMap f) w\u271d.1\n\u22a2 mk' f (sec f z).1 (sec f z).2 = mk' f (sec f w).1 (sec f w).2"}, {"tactic": "exact (mul_inv f.map_units).2 ((H _ _).2 <| (mul_inv hg).1 h)", "annotated_tactic": ["exact (<a>mul_inv</a> f.map_units).2 ((H _ _).2 <| (<a>mul_inv</a> hg).1 h)", [{"full_name": "Submonoid.LocalizationMap.mul_inv", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/MonoidLocalization.lean", "def_pos": [643, 9], "def_end_pos": [643, 16]}, {"full_name": "Submonoid.LocalizationMap.mul_inv", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/MonoidLocalization.lean", "def_pos": [643, 9], "def_end_pos": [643, 16]}]], "state_before": "case mpr.intro.intro\nM : Type u_1\ninst\u271d\u00b2 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b9 : CommMonoid N\nP : Type u_3\ninst\u271d : CommMonoid P\nf : LocalizationMap S N\ng : M \u2192* P\nhg : \u2200 (y : \u21a5S), IsUnit (\u2191g \u2191y)\nH : \u2200 (x y : M), \u2191(toMap f) x = \u2191(toMap f) y \u2194 \u2191g x = \u2191g y\nz w : N\nh : \u2191(lift f hg) z = \u2191(lift f hg) w\nw\u271d\u00b9 : M \u00d7 \u21a5S\nh\u271d\u00b9 : z * \u2191(toMap f) \u2191w\u271d\u00b9.2 = \u2191(toMap f) w\u271d\u00b9.1\nw\u271d : M \u00d7 \u21a5S\nh\u271d : w * \u2191(toMap f) \u2191w\u271d.2 = \u2191(toMap f) w\u271d.1\n\u22a2 mk' f (sec f z).1 (sec f z).2 = mk' f (sec f w).1 (sec f w).2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Rotate.lean", "full_name": "List.IsRotated.map", "start": [550, 1], "end": [554, 8], "traced_tactics": [{"tactic": "obtain \u27e8n, rfl\u27e9 := h", "annotated_tactic": ["obtain \u27e8n, rfl\u27e9 := h", []], "state_before": "\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 l\u2082 : List \u03b1\nh : l\u2081 ~r l\u2082\nf : \u03b1 \u2192 \u03b2\n\u22a2 List.map f l\u2081 ~r List.map f l\u2082", "state_after": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r List.map f (rotate l\u2081 n)"}, {"tactic": "rw [map_rotate]", "annotated_tactic": ["rw [<a>map_rotate</a>]", [{"full_name": "List.map_rotate", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Rotate.lean", "def_pos": [384, 9], "def_end_pos": [384, 19]}]], "state_before": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r List.map f (rotate l\u2081 n)", "state_after": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r rotate (List.map f l\u2081) n"}, {"tactic": "use n", "annotated_tactic": ["use n", []], "state_before": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r rotate (List.map f l\u2081) n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Parity.lean", "full_name": "isSquare_iff_exists_sq", "start": [119, 1], "end": [119, 100], "traced_tactics": [{"tactic": "simp [IsSquare, pow_two]", "annotated_tactic": ["simp [<a>IsSquare</a>, <a>pow_two</a>]", [{"full_name": "IsSquare", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Parity.lean", "def_pos": [49, 5], "def_end_pos": [49, 13]}, {"full_name": "pow_two", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [102, 9], "def_end_pos": [102, 16]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Monoid \u03b1\nn : \u2115\na m : \u03b1\n\u22a2 IsSquare m \u2194 \u2203 c, m = c ^ 2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/FieldDivision.lean", "full_name": "Polynomial.natDegree_map", "start": [153, 1], "end": [155, 45], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.prodCongrRight_apply", "start": [787, 1], "end": [788, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Basic.lean", "full_name": "exists_apply_eq", "start": [781, 1], "end": [781, 83], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Closure.lean", "full_name": "ClosureOperator.closed_eq_range_close", "start": [189, 1], "end": [193, 26], "traced_tactics": [{"tactic": "rintro \u27e8y, rfl\u27e9", "annotated_tactic": ["rintro \u27e8y, rfl\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_3\ninst\u271d\u00b9 inst\u271d : PartialOrder \u03b1\nc : ClosureOperator \u03b1\nx : \u03b1\n\u22a2 x \u2208 range \u2191c \u2192 x \u2208 closed c", "state_after": "case intro\n\u03b1 : Type u_1\n\u03b9 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_3\ninst\u271d\u00b9 inst\u271d : PartialOrder \u03b1\nc : ClosureOperator \u03b1\ny : \u03b1\n\u22a2 \u2191c y \u2208 closed c"}, {"tactic": "apply c.idempotent", "annotated_tactic": ["apply c.idempotent", []], "state_before": "case intro\n\u03b1 : Type u_1\n\u03b9 : Sort u_2\n\u03ba : \u03b9 \u2192 Sort u_3\ninst\u271d\u00b9 inst\u271d : PartialOrder \u03b1\nc : ClosureOperator \u03b1\ny : \u03b1\n\u22a2 \u2191c y \u2208 closed c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.mem_erase", "start": [1904, 1], "end": [1905, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/String/Lemmas.lean", "full_name": "String.Iterator.Valid.remainingBytes_le", "start": [648, 1], "end": [649, 97], "traced_tactics": [{"tactic": "simp [h.remainingBytes, h.toString, Nat.le_add_left]", "annotated_tactic": ["simp [h.remainingBytes, h.toString, <a>Nat.le_add_left</a>]", [{"full_name": "Nat.le_add_left", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [344, 9], "def_end_pos": [344, 20]}]], "state_before": "x\u271d : Iterator\nh\u271d : Valid x\u271d\nl r : List Char\nh : ValidFor l r x\u271d\n\u22a2 remainingBytes x\u271d \u2264 utf8ByteSize x\u271d.s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Star/Module.lean", "full_name": "selfAdjointPart_comp_subtype_selfAdjoint", "start": [147, 1], "end": [149, 52], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "inv_div'", "start": [487, 1], "end": [487, 52], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionCommMonoid \u03b1\na b c d : \u03b1\n\u22a2 (a / b)\u207b\u00b9 = a\u207b\u00b9 / b\u207b\u00b9", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.minFac_eq_one_iff", "start": [418, 1], "end": [426, 8], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "n : \u2115\n\u22a2 minFac n = 1 \u2194 n = 1", "state_after": "case mp\nn : \u2115\n\u22a2 minFac n = 1 \u2192 n = 1\n\ncase mpr\nn : \u2115\n\u22a2 n = 1 \u2192 minFac n = 1"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mp\nn : \u2115\n\u22a2 minFac n = 1 \u2192 n = 1", "state_after": "case mp\nn : \u2115\nh : minFac n = 1\n\u22a2 n = 1"}, {"tactic": "by_contra hn", "annotated_tactic": ["by_contra hn", []], "state_before": "case mp\nn : \u2115\nh : minFac n = 1\n\u22a2 n = 1", "state_after": "case mp\nn : \u2115\nh : minFac n = 1\nhn : \u00acn = 1\n\u22a2 False"}, {"tactic": "have := minFac_prime hn", "annotated_tactic": ["have := <a>minFac_prime</a> hn", [{"full_name": "Nat.minFac_prime", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [330, 9], "def_end_pos": [330, 21]}]], "state_before": "case mp\nn : \u2115\nh : minFac n = 1\nhn : \u00acn = 1\n\u22a2 False", "state_after": "case mp\nn : \u2115\nh : minFac n = 1\nhn : \u00acn = 1\nthis : Prime (minFac n)\n\u22a2 False"}, {"tactic": "rw [h] at this", "annotated_tactic": ["rw [h] at this", []], "state_before": "case mp\nn : \u2115\nh : minFac n = 1\nhn : \u00acn = 1\nthis : Prime (minFac n)\n\u22a2 False", "state_after": "case mp\nn : \u2115\nh : minFac n = 1\nhn : \u00acn = 1\nthis : Prime 1\n\u22a2 False"}, {"tactic": "exact not_prime_one this", "annotated_tactic": ["exact <a>not_prime_one</a> this", [{"full_name": "Nat.not_prime_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Prime.lean", "def_pos": [58, 9], "def_end_pos": [58, 22]}]], "state_before": "case mp\nn : \u2115\nh : minFac n = 1\nhn : \u00acn = 1\nthis : Prime 1\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "case mpr\nn : \u2115\n\u22a2 n = 1 \u2192 minFac n = 1", "state_after": "case mpr\n\n\u22a2 minFac 1 = 1"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mpr\n\n\u22a2 minFac 1 = 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Basic.lean", "full_name": "Set.inter_left_comm", "start": [949, 1], "end": [950, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/Cast/Defs.lean", "full_name": "Rat.cast_one", "start": [57, 1], "end": [58, 38], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Ioi_union_left", "start": [855, 1], "end": [856, 50], "traced_tactics": [{"tactic": "simp [eq_comm, le_iff_eq_or_lt]", "annotated_tactic": ["simp [<a>eq_comm</a>, <a>le_iff_eq_or_lt</a>]", [{"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}, {"full_name": "le_iff_eq_or_lt", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [390, 9], "def_end_pos": [390, 24]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PartialOrder \u03b1\na b c x : \u03b1\n\u22a2 x \u2208 Ioi a \u222a {a} \u2194 x \u2208 Ici a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "Decidable.not_forall", "start": [669, 11], "end": [672, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Lemmas.lean", "full_name": "Int.coe_nat_pow", "start": [545, 1], "end": [546, 33], "traced_tactics": [{"tactic": "induction' m with m _ <;> simp", "annotated_tactic": ["induction' m with m _ <;> simp", []], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\nn m : \u2115\n\u22a2 \u2191(n ^ m) = \u2191n ^ m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Regular/Basic.lean", "full_name": "not_isLeftRegular_zero_iff", "start": [214, 1], "end": [217, 16], "traced_tactics": [{"tactic": "rw [nontrivial_iff, not_iff_comm, isLeftRegular_zero_iff_subsingleton, subsingleton_iff]", "annotated_tactic": ["rw [<a>nontrivial_iff</a>, <a>not_iff_comm</a>, <a>isLeftRegular_zero_iff_subsingleton</a>, <a>subsingleton_iff</a>]", [{"full_name": "nontrivial_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [34, 9], "def_end_pos": [34, 23]}, {"full_name": "not_iff_comm", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [439, 9], "def_end_pos": [439, 21]}, {"full_name": "isLeftRegular_zero_iff_subsingleton", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Regular/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 44]}, {"full_name": "subsingleton_iff", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [75, 9], "def_end_pos": [75, 25]}]], "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 \u00acIsLeftRegular 0 \u2194 Nontrivial R", "state_after": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u00ac\u2203 x y, x \u2260 y) \u2194 \u2200 (x y : R), x = y"}, {"tactic": "push_neg", "annotated_tactic": ["push_neg", []], "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u00ac\u2203 x y, x \u2260 y) \u2194 \u2200 (x y : R), x = y", "state_after": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u2200 (x y : R), x = y) \u2194 \u2200 (x y : R), x = y"}, {"tactic": "exact Iff.rfl", "annotated_tactic": ["exact <a>Iff.rfl</a>", [{"full_name": "Iff.rfl", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [663, 19], "def_end_pos": [663, 26]}]], "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\n\u22a2 (\u2200 (x y : R), x = y) \u2194 \u2200 (x y : R), x = y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Basic.lean", "full_name": "div_pow", "start": [391, 1], "end": [392, 47], "traced_tactics": [{"tactic": "simp only [div_eq_mul_inv, mul_pow, inv_pow]", "annotated_tactic": ["simp only [<a>div_eq_mul_inv</a>, <a>mul_pow</a>, <a>inv_pow</a>]", [{"full_name": "div_eq_mul_inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [977, 9], "def_end_pos": [977, 23]}, {"full_name": "mul_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [257, 9], "def_end_pos": [257, 16]}, {"full_name": "inv_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [317, 9], "def_end_pos": [317, 16]}]], "state_before": "\u03b1 : Type u_1\nM : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d : DivisionCommMonoid \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 (a / b) ^ n = a ^ n / b ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/WF.lean", "full_name": "WellFounded.fix_eq_fixC", "start": [109, 18], "end": [111, 32], "traced_tactics": [{"tactic": "funext \u03b1 C r hwf F x", "annotated_tactic": ["funext \u03b1 C r hwf F x", []], "state_before": "\u22a2 @fix = @WellFounded.fixC", "state_after": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nC : \u03b1 \u2192 Sort u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhwf : WellFounded r\nF : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 C y) \u2192 C x\nx : \u03b1\n\u22a2 fix hwf F x = WellFounded.fixC hwf F x"}, {"tactic": "rw [fix, fixF_eq_fixFC, fixC]", "annotated_tactic": ["rw [<a>fix</a>, <a>fixF_eq_fixFC</a>, <a>fixC</a>]", [{"full_name": "WellFounded.fix", "def_path": "lake-packages/lean4/src/lean/Init/WF.lean", "def_pos": [71, 19], "def_end_pos": [71, 22]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.WF.0.WellFounded.fixF_eq_fixFC", "def_path": "lake-packages/std/Std/WF.lean", "def_pos": [100, 26], "def_end_pos": [100, 39]}, {"full_name": "_private.\u00ablake-packages\u00bb.std.Std.WF.0.WellFounded.fixC", "def_path": "lake-packages/std/Std/WF.lean", "def_pos": [105, 13], "def_end_pos": [105, 17]}]], "state_before": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nC : \u03b1 \u2192 Sort u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhwf : WellFounded r\nF : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 C y) \u2192 C x\nx : \u03b1\n\u22a2 fix hwf F x = WellFounded.fixC hwf F x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fintype/Card.lean", "full_name": "Fintype.card_le_one_iff_subsingleton", "start": [584, 1], "end": [585, 46], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/CompleteLattice.lean", "full_name": "sInfHom.symm_dual_comp", "start": [856, 1], "end": [858, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.withBotCongr_refl", "start": [1353, 1], "end": [1354, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.pred_succ", "start": [491, 1], "end": [493, 6], "traced_tactics": [{"tactic": "cases i", "annotated_tactic": ["cases i", []], "state_before": "n : Nat\ni : Fin n\nh : succ i \u2260 0\n\u22a2 pred (succ i) h = i", "state_after": "case mk\nn val\u271d : Nat\nisLt\u271d : val\u271d < n\nh : succ { val := val\u271d, isLt := isLt\u271d } \u2260 0\n\u22a2 pred (succ { val := val\u271d, isLt := isLt\u271d }) h = { val := val\u271d, isLt := isLt\u271d }"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case mk\nn val\u271d : Nat\nisLt\u271d : val\u271d < n\nh : succ { val := val\u271d, isLt := isLt\u271d } \u2260 0\n\u22a2 pred (succ { val := val\u271d, isLt := isLt\u271d }) h = { val := val\u271d, isLt := isLt\u271d }", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.dropWhile_nthLe_zero_not", "start": [3509, 1], "end": [3516, 28], "traced_tactics": [{"tactic": "induction' l with hd tl IH", "annotated_tactic": ["induction' l with hd tl IH", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nhl : 0 < length (dropWhile p l)\n\u22a2 \u00acp (nthLe (dropWhile p l) 0 hl) = true", "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhl : 0 < length (dropWhile p [])\n\u22a2 \u00acp (nthLe (dropWhile p []) 0 hl) = true\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\n\u22a2 \u00acp (nthLe (dropWhile p (hd :: tl)) 0 hl) = true"}, {"tactic": "cases hl", "annotated_tactic": ["cases hl", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhl : 0 < length (dropWhile p [])\n\u22a2 \u00acp (nthLe (dropWhile p []) 0 hl) = true", "state_after": "no goals"}, {"tactic": "simp only [dropWhile]", "annotated_tactic": ["simp only [<a>dropWhile</a>]", [{"full_name": "List.dropWhile", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [284, 5], "def_end_pos": [284, 14]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\n\u22a2 \u00acp (nthLe (dropWhile p (hd :: tl)) 0 hl) = true", "state_after": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\n\u22a2 \u00acp\n        (nthLe\n          (match p hd with\n          | true => dropWhile p tl\n          | false => hd :: tl)\n          0\n          (_ :\n            0 <\n              length\n                (match p hd with\n                | true => dropWhile p tl\n                | false => hd :: tl))) =\n      true"}, {"tactic": "by_cases hp : p hd", "annotated_tactic": ["by_cases hp : p hd", []], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\n\u22a2 \u00acp\n        (nthLe\n          (match p hd with\n          | true => dropWhile p tl\n          | false => hd :: tl)\n          0\n          (_ :\n            0 <\n              length\n                (match p hd with\n                | true => dropWhile p tl\n                | false => hd :: tl))) =\n      true", "state_after": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\nhp : p hd = true\n\u22a2 \u00acp\n        (nthLe\n          (match p hd with\n          | true => dropWhile p tl\n          | false => hd :: tl)\n          0\n          (_ :\n            0 <\n              length\n                (match p hd with\n                | true => dropWhile p tl\n                | false => hd :: tl))) =\n      true\n\ncase neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\nhp : \u00acp hd = true\n\u22a2 \u00acp\n        (nthLe\n          (match p hd with\n          | true => dropWhile p tl\n          | false => hd :: tl)\n          0\n          (_ :\n            0 <\n              length\n                (match p hd with\n                | true => dropWhile p tl\n                | false => hd :: tl))) =\n      true"}, {"tactic": "simp [hp, IH]", "annotated_tactic": ["simp [hp, IH]", []], "state_before": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\nhp : p hd = true\n\u22a2 \u00acp\n        (nthLe\n          (match p hd with\n          | true => dropWhile p tl\n          | false => hd :: tl)\n          0\n          (_ :\n            0 <\n              length\n                (match p hd with\n                | true => dropWhile p tl\n                | false => hd :: tl))) =\n      true", "state_after": "no goals"}, {"tactic": "simp [hp, nthLe_cons]", "annotated_tactic": ["simp [hp, <a>nthLe_cons</a>]", [{"full_name": "List.nthLe_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Basic.lean", "def_pos": [924, 9], "def_end_pos": [924, 19]}]], "state_before": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b1 \u2192 Bool\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (hl : 0 < length (dropWhile p tl)), \u00acp (nthLe (dropWhile p tl) 0 hl) = true\nhl : 0 < length (dropWhile p (hd :: tl))\nhp : \u00acp hd = true\n\u22a2 \u00acp\n        (nthLe\n          (match p hd with\n          | true => dropWhile p tl\n          | false => hd :: tl)\n          0\n          (_ :\n            0 <\n              length\n                (match p hd with\n                | true => dropWhile p tl\n                | false => hd :: tl))) =\n      true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "full_name": "Function.Injective.smulCommClass", "start": [229, 1], "end": [233, 74], "traced_tactics": [{"tactic": "simp only [h\u2081, h\u2082, smul_comm c\u2081 c\u2082 (f x)]", "annotated_tactic": ["simp only [h\u2081, h\u2082, <a>smul_comm</a> c\u2081 c\u2082 (f x)]", [{"full_name": "SMulCommClass.smul_comm", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [187, 3], "def_end_pos": [187, 12]}]], "state_before": "M : Type u_1\nN : Type u_2\nG : Type u_3\nA : Type u_4\nB : Type u_5\n\u03b1 : Type u_6\n\u03b2 : Type u_7\n\u03b3 : Type u_8\n\u03b4 : Type u_9\ninst\u271d\u2074 : SMul M \u03b1\ninst\u271d\u00b3 : SMul N \u03b1\ninst\u271d\u00b2 : SMul M \u03b2\ninst\u271d\u00b9 : SMul N \u03b2\ninst\u271d : SMulCommClass M N \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nh\u2081 : \u2200 (c : M) (x : \u03b1), f (c \u2022 x) = c \u2022 f x\nh\u2082 : \u2200 (c : N) (x : \u03b1), f (c \u2022 x) = c \u2022 f x\nc\u2081 : M\nc\u2082 : N\nx : \u03b1\n\u22a2 f (c\u2081 \u2022 c\u2082 \u2022 x) = f (c\u2082 \u2022 c\u2081 \u2022 x)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.compLinearMap_inj", "start": [428, 1], "end": [430, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/NAry.lean", "full_name": "Finset.image\u2082_inter_subset_right", "start": [216, 1], "end": [220, 36], "traced_tactics": [{"tactic": "push_cast", "annotated_tactic": ["push_cast", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b2\n\u22a2 \u2191(image\u2082 f s (t \u2229 t')) \u2286 \u2191(image\u2082 f s t \u2229 image\u2082 f s t')", "state_after": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b2\n\u22a2 image2 f (\u2191s) (\u2191t \u2229 \u2191t') \u2286 image2 f \u2191s \u2191t \u2229 image2 f \u2191s \u2191t'"}, {"tactic": "exact image2_inter_subset_right", "annotated_tactic": ["exact <a>image2_inter_subset_right</a>", [{"full_name": "Set.image2_inter_subset_right", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/NAry.lean", "def_pos": [189, 9], "def_end_pos": [189, 34]}]], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\ninst\u271d\u2078 : DecidableEq \u03b1'\ninst\u271d\u2077 : DecidableEq \u03b2'\ninst\u271d\u2076 : DecidableEq \u03b3\ninst\u271d\u2075 : DecidableEq \u03b3'\ninst\u271d\u2074 : DecidableEq \u03b4\ninst\u271d\u00b3 : DecidableEq \u03b4'\ninst\u271d\u00b2 : DecidableEq \u03b5\ninst\u271d\u00b9 : DecidableEq \u03b5'\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Finset \u03b1\nt t' : Finset \u03b2\nu u' : Finset \u03b3\na a' : \u03b1\nb b' : \u03b2\nc : \u03b3\ninst\u271d : DecidableEq \u03b2\n\u22a2 image2 f (\u2191s) (\u2191t \u2229 \u2191t') \u2286 image2 f \u2191s \u2191t \u2229 image2 f \u2191s \u2191t'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/ComputeDegree.lean", "full_name": "Mathlib.Tactic.ComputeDegree.degree_eq_of_le_of_coeff_ne_zero'", "start": [138, 1], "end": [146, 51], "traced_tactics": [{"tactic": "subst coeff_eq coeff_eq_deg deg_eq_deg", "annotated_tactic": ["subst coeff_eq coeff_eq_deg deg_eq_deg", []], "state_before": "R : Type u_1\ninst\u271d : Semiring R\ndeg m o : WithBot \u2115\nc : R\np : R[X]\nh_deg_le : degree p \u2264 m\ncoeff_eq : coeff p (WithBot.unbot' 0 deg) = c\ncoeff_ne_zero : c \u2260 0\ndeg_eq_deg : m = deg\ncoeff_eq_deg : o = deg\n\u22a2 degree p = deg", "state_after": "R : Type u_1\ninst\u271d : Semiring R\nm : WithBot \u2115\np : R[X]\nh_deg_le : degree p \u2264 m\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 m) \u2260 0\n\u22a2 degree p = m"}, {"tactic": "rcases eq_or_ne m \u22a5 with rfl|hh", "annotated_tactic": ["rcases <a>eq_or_ne</a> m \u22a5 with rfl|hh", [{"full_name": "eq_or_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "R : Type u_1\ninst\u271d : Semiring R\nm : WithBot \u2115\np : R[X]\nh_deg_le : degree p \u2264 m\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 m) \u2260 0\n\u22a2 degree p = m", "state_after": "case inl\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\nh_deg_le : degree p \u2264 \u22a5\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 \u22a5) \u2260 0\n\u22a2 degree p = \u22a5\n\ncase inr\nR : Type u_1\ninst\u271d : Semiring R\nm : WithBot \u2115\np : R[X]\nh_deg_le : degree p \u2264 m\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 m) \u2260 0\nhh : m \u2260 \u22a5\n\u22a2 degree p = m"}, {"tactic": "exact bot_unique h_deg_le", "annotated_tactic": ["exact <a>bot_unique</a> h_deg_le", [{"full_name": "bot_unique", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [359, 9], "def_end_pos": [359, 19]}]], "state_before": "case inl\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\nh_deg_le : degree p \u2264 \u22a5\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 \u22a5) \u2260 0\n\u22a2 degree p = \u22a5", "state_after": "no goals"}, {"tactic": "obtain \u27e8m, rfl\u27e9 := WithBot.ne_bot_iff_exists.mp hh", "annotated_tactic": ["obtain \u27e8m, rfl\u27e9 := WithBot.ne_bot_iff_exists.mp hh", []], "state_before": "case inr\nR : Type u_1\ninst\u271d : Semiring R\nm : WithBot \u2115\np : R[X]\nh_deg_le : degree p \u2264 m\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 m) \u2260 0\nhh : m \u2260 \u22a5\n\u22a2 degree p = m", "state_after": "case inr.intro\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\nm : \u2115\nh_deg_le : degree p \u2264 \u2191m\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 \u2191m) \u2260 0\nhh : \u2191m \u2260 \u22a5\n\u22a2 degree p = \u2191m"}, {"tactic": "exact degree_eq_of_le_of_coeff_ne_zero \u2039_\u203a \u2039_\u203a", "annotated_tactic": ["exact <a>degree_eq_of_le_of_coeff_ne_zero</a> \u2039_\u203a \u2039_\u203a", [{"full_name": "Polynomial.degree_eq_of_le_of_coeff_ne_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [190, 9], "def_end_pos": [190, 41]}]], "state_before": "case inr.intro\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\nm : \u2115\nh_deg_le : degree p \u2264 \u2191m\ncoeff_ne_zero : coeff p (WithBot.unbot' 0 \u2191m) \u2260 0\nhh : \u2191m \u2260 \u22a5\n\u22a2 degree p = \u2191m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Option/NAry.lean", "full_name": "Option.map_map\u2082", "start": [93, 1], "end": [94, 91], "traced_tactics": [{"tactic": "cases a <;> cases b <;> rfl", "annotated_tactic": ["cases a <;> cases b <;> rfl", []], "state_before": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_2\nf\u271d : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : Option \u03b1\nb : Option \u03b2\nc : Option \u03b3\n\u03b4 : Type u_1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng : \u03b3 \u2192 \u03b4\n\u22a2 Option.map g (map\u2082 f a b) = map\u2082 (fun a b => g (f a b)) a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Finiteness.lean", "full_name": "Submodule.fg_bot", "start": [144, 1], "end": [145, 44], "traced_tactics": [{"tactic": "rw [Finset.coe_empty, span_empty]", "annotated_tactic": ["rw [<a>Finset.coe_empty</a>, <a>span_empty</a>]", [{"full_name": "Finset.coe_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [619, 9], "def_end_pos": [619, 18]}, {"full_name": "Submodule.span_empty", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [237, 9], "def_end_pos": [237, 19]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u22a2 span R \u2191\u2205 = \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "WithBot.succ_unbot", "start": [1225, 1], "end": [1229, 22], "traced_tactics": [{"tactic": "induction a using WithBot.recBotCoe <;> simp", "annotated_tactic": ["induction a using <a>WithBot.recBotCoe</a> <;> simp", [{"full_name": "WithBot.recBotCoe", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [97, 5], "def_end_pos": [97, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : SuccOrder \u03b1\na : WithBot \u03b1\nha : a \u2260 \u22a5\n\u22a2 succ a \u2260 \u22a5", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Tendsto.prod_map_prod_atBot", "start": [1506, 1], "end": [1510, 23], "traced_tactics": [{"tactic": "rw [\u2190 prod_atBot_atBot_eq]", "annotated_tactic": ["rw [\u2190 <a>prod_atBot_atBot_eq</a>]", [{"full_name": "Filter.prod_atBot_atBot_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/AtTopBot.lean", "def_pos": [1473, 9], "def_end_pos": [1473, 28]}]], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeInf \u03b3\nF : Filter \u03b1\nG : Filter \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\nhf : Tendsto f F atBot\nhg : Tendsto g G atBot\n\u22a2 Tendsto (Prod.map f g) (F \u00d7\u02e2 G) atBot", "state_after": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeInf \u03b3\nF : Filter \u03b1\nG : Filter \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\nhf : Tendsto f F atBot\nhg : Tendsto g G atBot\n\u22a2 Tendsto (Prod.map f g) (F \u00d7\u02e2 G) (atBot \u00d7\u02e2 atBot)"}, {"tactic": "exact hf.prod_map hg", "annotated_tactic": ["exact hf.prod_map hg", []], "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : SemilatticeInf \u03b3\nF : Filter \u03b1\nG : Filter \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\nhf : Tendsto f F atBot\nhg : Tendsto g G atBot\n\u22a2 Tendsto (Prod.map f g) (F \u00d7\u02e2 G) (atBot \u00d7\u02e2 atBot)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Basis.lean", "full_name": "Basis.repr_unitsSMul", "start": [1264, 1], "end": [1266, 65], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.tendsto_atTop_add_left_of_le", "start": [828, 1], "end": [830, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Sigma/Basic.lean", "full_name": "PSigma.forall", "start": [256, 1], "end": [257, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "compl_le_of_compl_le", "start": [691, 1], "end": [692, 50], "traced_tactics": [{"tactic": "simpa only [compl_compl] using compl_le_compl h", "annotated_tactic": ["simpa only [<a>compl_compl</a>] using <a>compl_le_compl</a> h", [{"full_name": "compl_compl", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [634, 9], "def_end_pos": [634, 20]}, {"full_name": "compl_le_compl", "def_path": "lake-packages/mathlib/Mathlib/Order/Heyting/Basic.lean", "def_pos": [918, 9], "def_end_pos": [918, 23]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : BooleanAlgebra \u03b1\nh : y\u1d9c \u2264 x\n\u22a2 x\u1d9c \u2264 y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "mul_lt_of_mul_lt_right", "start": [239, 1], "end": [242, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units.lean", "full_name": "Units.eq_iff", "start": [147, 1], "end": [148, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/CompleteLattice.lean", "full_name": "le_iInf_iff", "start": [977, 1], "end": [978, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.perm_cons", "start": [643, 1], "end": [644, 31], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Cast/Lemmas.lean", "full_name": "MonoidHom.ext_int", "start": [263, 1], "end": [269, 57], "traced_tactics": [{"tactic": "ext (x | x)", "annotated_tactic": ["ext (x | x)", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\n\u22a2 f = g", "state_after": "case h.ofNat\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f (ofNat x) = \u2191g (ofNat x)\n\ncase h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f -[x+1] = \u2191g -[x+1]"}, {"tactic": "exact (FunLike.congr_fun h_nat x : _)", "annotated_tactic": ["exact (<a>FunLike.congr_fun</a> h_nat x : _)", [{"full_name": "FunLike.congr_fun", "def_path": "lake-packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [185, 19], "def_end_pos": [185, 28]}]], "state_before": "case h.ofNat\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f (ofNat x) = \u2191g (ofNat x)", "state_after": "no goals"}, {"tactic": "rw [Int.negSucc_eq, \u2190 neg_one_mul, f.map_mul, g.map_mul]", "annotated_tactic": ["rw [<a>Int.negSucc_eq</a>, \u2190 <a>neg_one_mul</a>, f.map_mul, g.map_mul]", [{"full_name": "Int.negSucc_eq", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [74, 9], "def_end_pos": [74, 19]}, {"full_name": "neg_one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [328, 9], "def_end_pos": [328, 20]}]], "state_before": "case h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f -[x+1] = \u2191g -[x+1]", "state_after": "case h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f (-1) * \u2191f (\u2191x + 1) = \u2191g (-1) * \u2191g (\u2191x + 1)"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "case h.negSucc\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f (-1) * \u2191f (\u2191x + 1) = \u2191g (-1) * \u2191g (\u2191x + 1)", "state_after": "case h.negSucc.e_a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f (\u2191x + 1) = \u2191g (\u2191x + 1)"}, {"tactic": "exact_mod_cast (FunLike.congr_fun h_nat (x + 1) : _)", "annotated_tactic": ["exact_mod_cast (<a>FunLike.congr_fun</a> h_nat (x + 1) : _)", [{"full_name": "FunLike.congr_fun", "def_path": "lake-packages/mathlib/Mathlib/Data/FunLike/Basic.lean", "def_pos": [185, 19], "def_end_pos": [185, 28]}]], "state_before": "case h.negSucc.e_a\nF : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nM : Type u_5\ninst\u271d : Monoid M\nf g : \u2124 \u2192* M\nh_neg_one : \u2191f (-1) = \u2191g (-1)\nh_nat : comp f \u2191ofNatHom = comp g \u2191ofNatHom\nx : \u2115\n\u22a2 \u2191f (\u2191x + 1) = \u2191g (\u2191x + 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Chain.lean", "full_name": "List.Chain'.iff", "start": [177, 1], "end": [179, 69], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.sublist_or_mem_of_sublist", "start": [441, 1], "end": [449, 65], "traced_tactics": [{"tactic": "induction l\u2081 generalizing l with\n| nil => match h with\n  | .cons _ h => exact .inl h\n  | .cons\u2082 _ h => exact .inr (.head ..)\n| cons b l\u2081 IH =>\n  match h with\n  | .cons _ h => exact (IH h).imp_left (Sublist.cons _)\n  | .cons\u2082 _ h => exact (IH h).imp (Sublist.cons\u2082 _) (.tail _)", "annotated_tactic": ["induction l\u2081 generalizing l with\n  | <a>nil</a> => match h with\n    | .cons _ h => exact .inl h\n    | .cons\u2082 _ h => exact .inr (.head ..)\n  | <a>cons</a> b l\u2081 IH =>\n    match h with\n    | .cons _ h => exact (IH h).<a>imp_left</a> (<a>Sublist.cons</a> _)\n    | .cons\u2082 _ h => exact (IH h).<a>imp</a> (<a>Sublist.cons\u2082</a> _) (.tail _)", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "Or.imp_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [257, 9], "def_end_pos": [257, 20]}, {"full_name": "List.Sublist.cons", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [442, 5], "def_end_pos": [442, 9]}, {"full_name": "Or.imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [255, 9], "def_end_pos": [255, 15]}, {"full_name": "List.Sublist.cons\u2082", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [444, 5], "def_end_pos": [444, 10]}]], "state_before": "\u03b1\u271d : Type u_1\nl l\u2081 : List \u03b1\u271d\na : \u03b1\u271d\nl\u2082 : List \u03b1\u271d\nh : l <+ l\u2081 ++ a :: l\u2082\n\u22a2 l <+ l\u2081 ++ l\u2082 \u2228 a \u2208 l", "state_after": "no goals"}, {"tactic": "match h with\n| .cons _ h => exact .inl h\n| .cons\u2082 _ h => exact .inr (.head ..)", "annotated_tactic": ["match h with\n    | .cons _ h => exact .inl h\n    | .cons\u2082 _ h => exact .inr (.head ..)", []], "state_before": "case nil\n\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl\u2082 l : List \u03b1\u271d\nh : l <+ [] ++ a :: l\u2082\n\u22a2 l <+ [] ++ l\u2082 \u2228 a \u2208 l", "state_after": "no goals"}, {"tactic": "exact .inl h", "annotated_tactic": ["exact .inl h", []], "state_before": "\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl\u2082 l\u271d : List \u03b1\u271d\nh\u271d : l\u271d <+ [] ++ a :: l\u2082\nl : List \u03b1\u271d\nh : l <+ l\u2082\n\u22a2 l <+ [] ++ l\u2082 \u2228 a \u2208 l", "state_after": "no goals"}, {"tactic": "exact .inr (.head ..)", "annotated_tactic": ["exact .inr (.head ..)", []], "state_before": "\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl\u2082 l : List \u03b1\u271d\nh\u271d : l <+ [] ++ a :: l\u2082\nl\u2081\u271d : List \u03b1\u271d\nh : l\u2081\u271d <+ l\u2082\n\u22a2 a :: l\u2081\u271d <+ [] ++ l\u2082 \u2228 a \u2208 a :: l\u2081\u271d", "state_after": "no goals"}, {"tactic": "match h with\n| .cons _ h => exact (IH h).imp_left (Sublist.cons _)\n| .cons\u2082 _ h => exact (IH h).imp (Sublist.cons\u2082 _) (.tail _)", "annotated_tactic": ["match h with\n    | .cons _ h => exact (IH h).<a>imp_left</a> (<a>Sublist.cons</a> _)\n    | .cons\u2082 _ h => exact (IH h).<a>imp</a> (<a>Sublist.cons\u2082</a> _) (.tail _)", [{"full_name": "Or.imp_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [257, 9], "def_end_pos": [257, 20]}, {"full_name": "List.Sublist.cons", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [442, 5], "def_end_pos": [442, 9]}, {"full_name": "Or.imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [255, 9], "def_end_pos": [255, 15]}, {"full_name": "List.Sublist.cons\u2082", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [444, 5], "def_end_pos": [444, 10]}]], "state_before": "case cons\n\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl\u2082 : List \u03b1\u271d\nb : \u03b1\u271d\nl\u2081 : List \u03b1\u271d\nIH : \u2200 {l : List \u03b1\u271d}, l <+ l\u2081 ++ a :: l\u2082 \u2192 l <+ l\u2081 ++ l\u2082 \u2228 a \u2208 l\nl : List \u03b1\u271d\nh : l <+ b :: l\u2081 ++ a :: l\u2082\n\u22a2 l <+ b :: l\u2081 ++ l\u2082 \u2228 a \u2208 l", "state_after": "no goals"}, {"tactic": "exact (IH h).imp_left (Sublist.cons _)", "annotated_tactic": ["exact (IH h).<a>imp_left</a> (<a>Sublist.cons</a> _)", [{"full_name": "Or.imp_left", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [257, 9], "def_end_pos": [257, 20]}, {"full_name": "List.Sublist.cons", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [442, 5], "def_end_pos": [442, 9]}]], "state_before": "\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl\u2082 : List \u03b1\u271d\nb : \u03b1\u271d\nl\u2081 : List \u03b1\u271d\nIH : \u2200 {l : List \u03b1\u271d}, l <+ l\u2081 ++ a :: l\u2082 \u2192 l <+ l\u2081 ++ l\u2082 \u2228 a \u2208 l\nl\u271d : List \u03b1\u271d\nh\u271d : l\u271d <+ b :: l\u2081 ++ a :: l\u2082\nl : List \u03b1\u271d\nh : l <+ List.append l\u2081 (a :: l\u2082)\n\u22a2 l <+ b :: l\u2081 ++ l\u2082 \u2228 a \u2208 l", "state_after": "no goals"}, {"tactic": "exact (IH h).imp (Sublist.cons\u2082 _) (.tail _)", "annotated_tactic": ["exact (IH h).<a>imp</a> (<a>Sublist.cons\u2082</a> _) (.tail _)", [{"full_name": "Or.imp", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [255, 9], "def_end_pos": [255, 15]}, {"full_name": "List.Sublist.cons\u2082", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [444, 5], "def_end_pos": [444, 10]}]], "state_before": "\u03b1\u271d : Type u_1\na : \u03b1\u271d\nl\u2082 : List \u03b1\u271d\nb : \u03b1\u271d\nl\u2081 : List \u03b1\u271d\nIH : \u2200 {l : List \u03b1\u271d}, l <+ l\u2081 ++ a :: l\u2082 \u2192 l <+ l\u2081 ++ l\u2082 \u2228 a \u2208 l\nl : List \u03b1\u271d\nh\u271d : l <+ b :: l\u2081 ++ a :: l\u2082\nl\u2081\u271d : List \u03b1\u271d\nh : l\u2081\u271d <+ List.append l\u2081 (a :: l\u2082)\n\u22a2 b :: l\u2081\u271d <+ b :: l\u2081 ++ l\u2082 \u2228 a \u2208 b :: l\u2081\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SymmDiff.lean", "full_name": "symmDiff_eq_sup", "start": [437, 1], "end": [440, 44], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, Disjoint.symmDiff_eq_sup\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, <a>Disjoint.symmDiff_eq_sup</a>\u27e9", [{"full_name": "Disjoint.symmDiff_eq_sup", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [161, 9], "def_end_pos": [161, 33]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\n\u22a2 a \u2206 b = a \u2294 b \u2194 Disjoint a b", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\nh : a \u2206 b = a \u2294 b\n\u22a2 Disjoint a b"}, {"tactic": "rw [symmDiff_eq_sup_sdiff_inf, sdiff_eq_self_iff_disjoint] at h", "annotated_tactic": ["rw [<a>symmDiff_eq_sup_sdiff_inf</a>, <a>sdiff_eq_self_iff_disjoint</a>] at h", [{"full_name": "symmDiff_eq_sup_sdiff_inf", "def_path": "lake-packages/mathlib/Mathlib/Order/SymmDiff.lean", "def_pos": [158, 9], "def_end_pos": [158, 34]}, {"full_name": "sdiff_eq_self_iff_disjoint", "def_path": "lake-packages/mathlib/Mathlib/Order/BooleanAlgebra.lean", "def_pos": [307, 9], "def_end_pos": [307, 35]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\nh : a \u2206 b = a \u2294 b\n\u22a2 Disjoint a b", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\nh : Disjoint (a \u2293 b) (a \u2294 b)\n\u22a2 Disjoint a b"}, {"tactic": "exact h.of_disjoint_inf_of_le le_sup_left", "annotated_tactic": ["exact h.of_disjoint_inf_of_le <a>le_sup_left</a>", [{"full_name": "le_sup_left", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [130, 9], "def_end_pos": [130, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03c0 : \u03b9 \u2192 Type u_4\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\na b c d : \u03b1\nh : Disjoint (a \u2293 b) (a \u2294 b)\n\u22a2 Disjoint a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Valuation/Basic.lean", "full_name": "Valuation.map_add", "start": [169, 1], "end": [170, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Cover.lean", "full_name": "Wcovby.inf_eq", "start": [208, 1], "end": [209, 93], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.Nontrivial.sdiff_singleton_nonempty", "start": [2348, 1], "end": [2352, 79], "traced_tactics": [{"tactic": "rw [Finset.sdiff_nonempty, Finset.subset_singleton_iff]", "annotated_tactic": ["rw [<a>Finset.sdiff_nonempty</a>, <a>Finset.subset_singleton_iff</a>]", [{"full_name": "Finset.sdiff_nonempty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2221, 9], "def_end_pos": [2221, 23]}, {"full_name": "Finset.subset_singleton_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [778, 9], "def_end_pos": [778, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na b c : \u03b1\ns : Finset \u03b1\nhS : Finset.Nontrivial s\n\u22a2 Finset.Nonempty (s \\ {c})", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na b c : \u03b1\ns : Finset \u03b1\nhS : Finset.Nontrivial s\n\u22a2 \u00ac(s = \u2205 \u2228 s = {c})"}, {"tactic": "push_neg", "annotated_tactic": ["push_neg", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na b c : \u03b1\ns : Finset \u03b1\nhS : Finset.Nontrivial s\n\u22a2 \u00ac(s = \u2205 \u2228 s = {c})", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na b c : \u03b1\ns : Finset \u03b1\nhS : Finset.Nontrivial s\n\u22a2 s \u2260 \u2205 \u2227 s \u2260 {c}"}, {"tactic": "exact \u27e8by rintro rfl; exact Finset.not_nontrivial_empty hS, hS.ne_singleton\u27e9", "annotated_tactic": ["exact \u27e8by rintro rfl; exact <a>Finset.not_nontrivial_empty</a> hS, hS.ne_singleton\u27e9", [{"full_name": "Finset.not_nontrivial_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [809, 9], "def_end_pos": [809, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na b c : \u03b1\ns : Finset \u03b1\nhS : Finset.Nontrivial s\n\u22a2 s \u2260 \u2205 \u2227 s \u2260 {c}", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns\u271d t u v : Finset \u03b1\na b c : \u03b1\ns : Finset \u03b1\nhS : Finset.Nontrivial s\n\u22a2 s \u2260 \u2205", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t u v : Finset \u03b1\na b c : \u03b1\nhS : Finset.Nontrivial \u2205\n\u22a2 False"}, {"tactic": "exact Finset.not_nontrivial_empty hS", "annotated_tactic": ["exact <a>Finset.not_nontrivial_empty</a> hS", [{"full_name": "Finset.not_nontrivial_empty", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [809, 9], "def_end_pos": [809, 29]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t u v : Finset \u03b1\na b c : \u03b1\nhS : Finset.Nontrivial \u2205\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_subtype_eq_prod_filter", "start": [871, 1], "end": [874, 52], "traced_tactics": [{"tactic": "conv_lhs => erw [\u2190 prod_map (s.subtype p) (Function.Embedding.subtype _) f]", "annotated_tactic": ["conv_lhs => erw [\u2190 <a>prod_map</a> (s.subtype p) (<a>Function.Embedding.subtype</a> _) f]", [{"full_name": "Finset.prod_map", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [376, 9], "def_end_pos": [376, 17]}, {"full_name": "Function.Embedding.subtype", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [229, 5], "def_end_pos": [229, 12]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u220f x in Finset.subtype p s, f \u2191x = \u220f x in filter p s, f x", "state_after": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u220f x in map (Function.Embedding.subtype p) (Finset.subtype p s), f x = \u220f x in filter p s, f x"}, {"tactic": "exact prod_congr (subtype_map _) fun x _hx => rfl", "annotated_tactic": ["exact <a>prod_congr</a> (<a>subtype_map</a> _) fun x _hx => <a>rfl</a>", [{"full_name": "Finset.prod_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [383, 9], "def_end_pos": [383, 19]}, {"full_name": "Finset.subtype_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [736, 9], "def_end_pos": [736, 20]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b2 : Type u\n\u03b1 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nf\u271d g : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : CommMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u220f x in map (Function.Embedding.subtype p) (Finset.subtype p s), f x = \u220f x in filter p s, f x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Pointwise/Basic.lean", "full_name": "Set.nsmul_univ", "start": [1002, 1], "end": [1005, 83], "traced_tactics": [{"tactic": "rw [succ_nsmul, nsmul_univ n.succ_ne_zero, univ_add_univ]", "annotated_tactic": ["rw [<a>succ_nsmul</a>, nsmul_univ n.succ_ne_zero, <a>univ_add_univ</a>]", [{"full_name": "succ_nsmul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [644, 15], "def_end_pos": [644, 25]}, {"full_name": "Set.univ_add_univ", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [994, 3], "def_end_pos": [994, 14]}]], "state_before": "F : Type u_1\n\u03b1\u271d : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\u271d\ns t : Set \u03b1\u271d\na : \u03b1\u271d\nm n\u271d : \u2115\n\u03b1 : Type u_5\ninst\u271d : AddMonoid \u03b1\nn : \u2115\nx\u271d : n + 2 \u2260 0\n\u22a2 (n + 2) \u2022 univ = univ", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Equiv/Basic.lean", "full_name": "MulEquiv.eq_comp_symm", "start": [451, 1], "end": [453, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Submodule.mem_smul_span_singleton", "start": [134, 1], "end": [143, 85], "traced_tactics": [{"tactic": "rw [add_smul, hy1, hy2]", "annotated_tactic": ["rw [<a>add_smul</a>, hy1, hy2]", [{"full_name": "add_smul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Basic.lean", "def_pos": [91, 9], "def_end_pos": [91, 17]}]], "state_before": "R : Type u\nM : Type v\nF : Type u_1\nG : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nI\u271d J : Ideal R\nN P : Submodule R M\nI : Ideal R\nm x : M\nhx : x \u2208 I \u2022 span R {m}\nm1 m2 : M\nx\u271d\u00b9 : \u2203 y \u2208 I, y \u2022 m = m1\nx\u271d : \u2203 y \u2208 I, y \u2022 m = m2\ny1 : R\nhyi1 : y1 \u2208 I\nhy1 : y1 \u2022 m = m1\ny2 : R\nhyi2 : y2 \u2208 I\nhy2 : y2 \u2022 m = m2\n\u22a2 (y1 + y2) \u2022 m = m1 + m2", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.eval_divByMonic_pow_rootMultiplicity_ne_zero", "start": [649, 1], "end": [662, 56], "traced_tactics": [{"tactic": "classical\nhaveI : Nontrivial R := Nontrivial.of_polynomial_ne hp\nrw [Ne.def, \u2190 IsRoot.def, \u2190 dvd_iff_isRoot]\nrintro \u27e8q, hq\u27e9\nhave := divByMonic_mul_pow_rootMultiplicity_eq p a\nrw [mul_comm, hq, \u2190 mul_assoc, \u2190 pow_succ', rootMultiplicity_eq_multiplicity, dif_neg hp] at this\nexact\n  multiplicity.is_greatest'\n    (multiplicity_finite_of_degree_pos_of_monic\n      (show (0 : WithBot \u2115) < degree (X - C a) by rw [degree_X_sub_C]; exact by decide)\n      (monic_X_sub_C _) hp)\n    (Nat.lt_succ_self _) (dvd_of_mul_right_eq _ this)", "annotated_tactic": ["classical\n  haveI : <a>Nontrivial</a> R := <a>Nontrivial.of_polynomial_ne</a> hp\n  rw [<a>Ne.def</a>, \u2190 <a>IsRoot.def</a>, \u2190 <a>dvd_iff_isRoot</a>]\n  rintro \u27e8q, hq\u27e9\n  have := <a>divByMonic_mul_pow_rootMultiplicity_eq</a> p a\n  rw [<a>mul_comm</a>, hq, \u2190 <a>mul_assoc</a>, \u2190 <a>pow_succ'</a>, <a>rootMultiplicity_eq_multiplicity</a>, <a>dif_neg</a> hp] at this\n  exact\n    <a>multiplicity.is_greatest'</a>\n      (<a>multiplicity_finite_of_degree_pos_of_monic</a>\n        (show (0 : <a>WithBot</a> \u2115) < <a>degree</a> (<a>X</a> - <a>C</a> a) by rw [<a>degree_X_sub_C</a>]; exact by decide)\n        (<a>monic_X_sub_C</a> _) hp)\n      (<a>Nat.lt_succ_self</a> _) (<a>dvd_of_mul_right_eq</a> _ this)", [{"full_name": "Nontrivial", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [29, 7], "def_end_pos": [29, 17]}, {"full_name": "Polynomial.Nontrivial.of_polynomial_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [817, 9], "def_end_pos": [817, 36]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Polynomial.IsRoot.def", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [501, 9], "def_end_pos": [501, 19]}, {"full_name": "Polynomial.dvd_iff_isRoot", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [472, 9], "def_end_pos": [472, 23]}, {"full_name": "Polynomial.divByMonic_mul_pow_rootMultiplicity_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [640, 9], "def_end_pos": [640, 47]}, {"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "pow_succ'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [213, 9], "def_end_pos": [213, 25]}, {"full_name": "Polynomial.rootMultiplicity_eq_multiplicity", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [592, 9], "def_end_pos": [592, 41]}, {"full_name": "dif_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [812, 9], "def_end_pos": [812, 16]}, {"full_name": "multiplicity.is_greatest'", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [117, 9], "def_end_pos": [117, 21]}, {"full_name": "Polynomial.multiplicity_finite_of_degree_pos_of_monic", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [65, 9], "def_end_pos": [65, 51]}, {"full_name": "WithBot", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [27, 5], "def_end_pos": [27, 12]}, {"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [566, 5], "def_end_pos": [566, 6]}, {"full_name": "Polynomial.C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [498, 5], "def_end_pos": [498, 6]}, {"full_name": "Polynomial.degree_X_sub_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1552, 9], "def_end_pos": [1552, 23]}, {"full_name": "Polynomial.monic_X_sub_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [373, 9], "def_end_pos": [373, 22]}, {"full_name": "Nat.lt_succ_self", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [294, 9], "def_end_pos": [294, 21]}, {"full_name": "dvd_of_mul_right_eq", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [52, 7], "def_end_pos": [52, 26]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q p : R[X]\na : R\nhp : p \u2260 0\n\u22a2 eval a (p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p) \u2260 0", "state_after": "no goals"}, {"tactic": "haveI : Nontrivial R := Nontrivial.of_polynomial_ne hp", "annotated_tactic": ["haveI : <a>Nontrivial</a> R := <a>Nontrivial.of_polynomial_ne</a> hp", [{"full_name": "Nontrivial", "def_path": "lake-packages/mathlib/Mathlib/Logic/Nontrivial/Defs.lean", "def_pos": [29, 7], "def_end_pos": [29, 17]}, {"full_name": "Polynomial.Nontrivial.of_polynomial_ne", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [817, 9], "def_end_pos": [817, 36]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q p : R[X]\na : R\nhp : p \u2260 0\n\u22a2 eval a (p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p) \u2260 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q p : R[X]\na : R\nhp : p \u2260 0\nthis : Nontrivial R\n\u22a2 eval a (p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p) \u2260 0"}, {"tactic": "rw [Ne.def, \u2190 IsRoot.def, \u2190 dvd_iff_isRoot]", "annotated_tactic": ["rw [<a>Ne.def</a>, \u2190 <a>IsRoot.def</a>, \u2190 <a>dvd_iff_isRoot</a>]", [{"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Polynomial.IsRoot.def", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Eval.lean", "def_pos": [501, 9], "def_end_pos": [501, 19]}, {"full_name": "Polynomial.dvd_iff_isRoot", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [472, 9], "def_end_pos": [472, 23]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q p : R[X]\na : R\nhp : p \u2260 0\nthis : Nontrivial R\n\u22a2 eval a (p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p) \u2260 0", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q p : R[X]\na : R\nhp : p \u2260 0\nthis : Nontrivial R\n\u22a2 \u00acX - \u2191C a \u2223 p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p"}, {"tactic": "rintro \u27e8q, hq\u27e9", "annotated_tactic": ["rintro \u27e8q, hq\u27e9", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q p : R[X]\na : R\nhp : p \u2260 0\nthis : Nontrivial R\n\u22a2 \u00acX - \u2191C a \u2223 p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\n\u22a2 False"}, {"tactic": "have := divByMonic_mul_pow_rootMultiplicity_eq p a", "annotated_tactic": ["have := <a>divByMonic_mul_pow_rootMultiplicity_eq</a> p a", [{"full_name": "Polynomial.divByMonic_mul_pow_rootMultiplicity_eq", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [640, 9], "def_end_pos": [640, 47]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p * (X - \u2191C a) ^ rootMultiplicity a p = p\n\u22a2 False"}, {"tactic": "rw [mul_comm, hq, \u2190 mul_assoc, \u2190 pow_succ', rootMultiplicity_eq_multiplicity, dif_neg hp] at this", "annotated_tactic": ["rw [<a>mul_comm</a>, hq, \u2190 <a>mul_assoc</a>, \u2190 <a>pow_succ'</a>, <a>rootMultiplicity_eq_multiplicity</a>, <a>dif_neg</a> hp] at this", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "pow_succ'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Commute/Defs.lean", "def_pos": [213, 9], "def_end_pos": [213, 25]}, {"full_name": "Polynomial.rootMultiplicity_eq_multiplicity", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [592, 9], "def_end_pos": [592, 41]}, {"full_name": "dif_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [812, 9], "def_end_pos": [812, 16]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p * (X - \u2191C a) ^ rootMultiplicity a p = p\n\u22a2 False", "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : (X - \u2191C a) ^ (Part.get (multiplicity (X - \u2191C a) p) (_ : multiplicity.Finite (X - \u2191C a) p) + 1) * q = p\n\u22a2 False"}, {"tactic": "exact\n  multiplicity.is_greatest'\n    (multiplicity_finite_of_degree_pos_of_monic\n      (show (0 : WithBot \u2115) < degree (X - C a) by rw [degree_X_sub_C]; exact by decide)\n      (monic_X_sub_C _) hp)\n    (Nat.lt_succ_self _) (dvd_of_mul_right_eq _ this)", "annotated_tactic": ["exact\n    <a>multiplicity.is_greatest'</a>\n      (<a>multiplicity_finite_of_degree_pos_of_monic</a>\n        (show (0 : <a>WithBot</a> \u2115) < <a>degree</a> (<a>X</a> - <a>C</a> a) by rw [<a>degree_X_sub_C</a>]; exact by decide)\n        (<a>monic_X_sub_C</a> _) hp)\n      (<a>Nat.lt_succ_self</a> _) (<a>dvd_of_mul_right_eq</a> _ this)", [{"full_name": "multiplicity.is_greatest'", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Multiplicity.lean", "def_pos": [117, 9], "def_end_pos": [117, 21]}, {"full_name": "Polynomial.multiplicity_finite_of_degree_pos_of_monic", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [65, 9], "def_end_pos": [65, 51]}, {"full_name": "WithBot", "def_path": "lake-packages/mathlib/Mathlib/Order/WithBot.lean", "def_pos": [27, 5], "def_end_pos": [27, 12]}, {"full_name": "Polynomial.degree", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [53, 5], "def_end_pos": [53, 11]}, {"full_name": "Polynomial.X", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [566, 5], "def_end_pos": [566, 6]}, {"full_name": "Polynomial.C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [498, 5], "def_end_pos": [498, 6]}, {"full_name": "Polynomial.degree_X_sub_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1552, 9], "def_end_pos": [1552, 23]}, {"full_name": "Polynomial.monic_X_sub_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [373, 9], "def_end_pos": [373, 22]}, {"full_name": "Nat.lt_succ_self", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [294, 9], "def_end_pos": [294, 21]}, {"full_name": "dvd_of_mul_right_eq", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [52, 7], "def_end_pos": [52, 26]}]], "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : (X - \u2191C a) ^ (Part.get (multiplicity (X - \u2191C a) p) (_ : multiplicity.Finite (X - \u2191C a) p) + 1) * q = p\n\u22a2 False", "state_after": "no goals"}, {"tactic": "rw [degree_X_sub_C]", "annotated_tactic": ["rw [<a>degree_X_sub_C</a>]", [{"full_name": "Polynomial.degree_X_sub_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [1552, 9], "def_end_pos": [1552, 23]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : (X - \u2191C a) ^ (Part.get (multiplicity (X - \u2191C a) p) (_ : multiplicity.Finite (X - \u2191C a) p) + 1) * q = p\n\u22a2 0 < degree (X - \u2191C a)", "state_after": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : (X - \u2191C a) ^ (Part.get (multiplicity (X - \u2191C a) p) (_ : multiplicity.Finite (X - \u2191C a) p) + 1) * q = p\n\u22a2 0 < 1"}, {"tactic": "exact by decide", "annotated_tactic": ["exact by decide", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : (X - \u2191C a) ^ (Part.get (multiplicity (X - \u2191C a) p) (_ : multiplicity.Finite (X - \u2191C a) p) + 1) * q = p\n\u22a2 0 < 1", "state_after": "no goals"}, {"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na\u271d b : R\nn : \u2115\ninst\u271d : CommRing R\np\u271d q\u271d p : R[X]\na : R\nhp : p \u2260 0\nthis\u271d : Nontrivial R\nq : R[X]\nhq : p /\u2098 (X - \u2191C a) ^ rootMultiplicity a p = (X - \u2191C a) * q\nthis : (X - \u2191C a) ^ (Part.get (multiplicity (X - \u2191C a) p) (_ : multiplicity.Finite (X - \u2191C a) p) + 1) * q = p\n\u22a2 0 < 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.compare_ne_gt", "start": [231, 11], "end": [232, 52], "traced_tactics": [{"tactic": "rw [compare_def_le]", "annotated_tactic": ["rw [<a>compare_def_le</a>]", [{"full_name": "Nat.compare_def_le", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [207, 9], "def_end_pos": [207, 23]}]], "state_before": "a b : Nat\n\u22a2 compare a b \u2260 Ordering.gt \u2194 a \u2264 b", "state_after": "a b : Nat\n\u22a2 (if a \u2264 b then if b \u2264 a then Ordering.eq else Ordering.lt else Ordering.gt) \u2260 Ordering.gt \u2194 a \u2264 b"}, {"tactic": "(repeat' split) <;> simp [*]", "annotated_tactic": ["(repeat' split) <;> simp [*]", []], "state_before": "a b : Nat\n\u22a2 (if a \u2264 b then if b \u2264 a then Ordering.eq else Ordering.lt else Ordering.gt) \u2260 Ordering.gt \u2194 a \u2264 b", "state_after": "no goals"}, {"tactic": "repeat' split", "annotated_tactic": ["repeat' split", []], "state_before": "a b : Nat\n\u22a2 (if a \u2264 b then if b \u2264 a then Ordering.eq else Ordering.lt else Ordering.gt) \u2260 Ordering.gt \u2194 a \u2264 b", "state_after": "case inl.inl\na b : Nat\nh\u271d\u00b9 : a \u2264 b\nh\u271d : b \u2264 a\n\u22a2 Ordering.eq \u2260 Ordering.gt \u2194 a \u2264 b\n\ncase inl.inr\na b : Nat\nh\u271d\u00b9 : a \u2264 b\nh\u271d : \u00acb \u2264 a\n\u22a2 Ordering.lt \u2260 Ordering.gt \u2194 a \u2264 b\n\ncase inr\na b : Nat\nh\u271d : \u00aca \u2264 b\n\u22a2 Ordering.gt \u2260 Ordering.gt \u2194 a \u2264 b"}, {"tactic": "split", "annotated_tactic": ["split", []], "state_before": "case inl\na b : Nat\nh\u271d : a \u2264 b\n\u22a2 (if b \u2264 a then Ordering.eq else Ordering.lt) \u2260 Ordering.gt \u2194 a \u2264 b", "state_after": "case inl.inl\na b : Nat\nh\u271d\u00b9 : a \u2264 b\nh\u271d : b \u2264 a\n\u22a2 Ordering.eq \u2260 Ordering.gt \u2194 a \u2264 b\n\ncase inl.inr\na b : Nat\nh\u271d\u00b9 : a \u2264 b\nh\u271d : \u00acb \u2264 a\n\u22a2 Ordering.lt \u2260 Ordering.gt \u2194 a \u2264 b"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Basic.lean", "full_name": "lt_iff_le_and_ne", "start": [394, 1], "end": [395, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Module/Submodule/Map.lean", "full_name": "Submodule.comap_zero", "start": [261, 1], "end": [262, 17], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\nR\u2081 : Type u_2\nR\u2082 : Type u_3\nR\u2083 : Type u_4\nS : Type u_5\nM : Type u_6\nM\u2081 : Type u_7\nM\u2082 : Type u_8\nM\u2083 : Type u_9\ninst\u271d\u00b9\u00b9 : Semiring R\ninst\u271d\u00b9\u2070 : Semiring R\u2082\ninst\u271d\u2079 : Semiring R\u2083\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : AddCommMonoid M\u2083\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R\u2082 M\u2082\ninst\u271d\u00b3 : Module R\u2083 M\u2083\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c3\u2081\u2083 : R \u2192+* R\u2083\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b2 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d\u00b9 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\ninst\u271d : RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083\np p' : Submodule R M\nq q' : Submodule R\u2082 M\u2082\nx : M\nF : Type u_10\nsc : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\n\u22a2 \u2200 (x : M), x \u2208 comap 0 q \u2194 x \u2208 \u22a4", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/MvPolynomial/Variables.lean", "full_name": "MvPolynomial.degrees_mul", "start": [160, 1], "end": [167, 57], "traced_tactics": [{"tactic": "classical\nrefine' Finset.sup_le fun b hb => _\nhave := support_mul p q hb\nsimp only [Finset.mem_biUnion, Finset.mem_singleton] at this\nrcases this with \u27e8a\u2081, h\u2081, a\u2082, h\u2082, rfl\u27e9\nrw [Finsupp.toMultiset_add]\nexact add_le_add (Finset.le_sup h\u2081) (Finset.le_sup h\u2082)", "annotated_tactic": ["classical\n  refine' <a>Finset.sup_le</a> fun b hb => _\n  have := <a>support_mul</a> p q hb\n  simp only [<a>Finset.mem_biUnion</a>, <a>Finset.mem_singleton</a>] at this\n  rcases this with \u27e8a\u2081, h\u2081, a\u2082, h\u2082, rfl\u27e9\n  rw [<a>Finsupp.toMultiset_add</a>]\n  exact <a>add_le_add</a> (<a>Finset.le_sup</a> h\u2081) (<a>Finset.le_sup</a> h\u2082)", [{"full_name": "Finset.sup_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [105, 11], "def_end_pos": [105, 17]}, {"full_name": "MvPolynomial.support_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [599, 9], "def_end_pos": [599, 20]}, {"full_name": "Finset.mem_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3636, 9], "def_end_pos": [3636, 20]}, {"full_name": "Finset.mem_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [679, 9], "def_end_pos": [679, 22]}, {"full_name": "Finsupp.toMultiset_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [45, 9], "def_end_pos": [45, 23]}, {"full_name": "add_le_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 15], "def_end_pos": [205, 25]}, {"full_name": "Finset.le_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [114, 9], "def_end_pos": [114, 15]}, {"full_name": "Finset.le_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [114, 9], "def_end_pos": [114, 15]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\n\u22a2 degrees (p * q) \u2264 degrees p + degrees q", "state_after": "no goals"}, {"tactic": "refine' Finset.sup_le fun b hb => _", "annotated_tactic": ["refine' <a>Finset.sup_le</a> fun b hb => _", [{"full_name": "Finset.sup_le", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [105, 11], "def_end_pos": [105, 17]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\n\u22a2 degrees (p * q) \u2264 degrees p + degrees q", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\nb : \u03c3 \u2192\u2080 \u2115\nhb : b \u2208 support (p * q)\n\u22a2 \u2191toMultiset b \u2264 degrees p + degrees q"}, {"tactic": "have := support_mul p q hb", "annotated_tactic": ["have := <a>support_mul</a> p q hb", [{"full_name": "MvPolynomial.support_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/MvPolynomial/Basic.lean", "def_pos": [599, 9], "def_end_pos": [599, 20]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\nb : \u03c3 \u2192\u2080 \u2115\nhb : b \u2208 support (p * q)\n\u22a2 \u2191toMultiset b \u2264 degrees p + degrees q", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\nb : \u03c3 \u2192\u2080 \u2115\nhb : b \u2208 support (p * q)\nthis : b \u2208 Finset.biUnion (support p) fun a => Finset.biUnion (support q) fun b => {a + b}\n\u22a2 \u2191toMultiset b \u2264 degrees p + degrees q"}, {"tactic": "simp only [Finset.mem_biUnion, Finset.mem_singleton] at this", "annotated_tactic": ["simp only [<a>Finset.mem_biUnion</a>, <a>Finset.mem_singleton</a>] at this", [{"full_name": "Finset.mem_biUnion", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3636, 9], "def_end_pos": [3636, 20]}, {"full_name": "Finset.mem_singleton", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [679, 9], "def_end_pos": [679, 22]}]], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\nb : \u03c3 \u2192\u2080 \u2115\nhb : b \u2208 support (p * q)\nthis : b \u2208 Finset.biUnion (support p) fun a => Finset.biUnion (support q) fun b => {a + b}\n\u22a2 \u2191toMultiset b \u2264 degrees p + degrees q", "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\nb : \u03c3 \u2192\u2080 \u2115\nhb : b \u2208 support (p * q)\nthis : \u2203 a \u2208 support p, \u2203 a_1 \u2208 support q, b = a + a_1\n\u22a2 \u2191toMultiset b \u2264 degrees p + degrees q"}, {"tactic": "rcases this with \u27e8a\u2081, h\u2081, a\u2082, h\u2082, rfl\u27e9", "annotated_tactic": ["rcases this with \u27e8a\u2081, h\u2081, a\u2082, h\u2082, rfl\u27e9", []], "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\nb : \u03c3 \u2192\u2080 \u2115\nhb : b \u2208 support (p * q)\nthis : \u2203 a \u2208 support p, \u2203 a_1 \u2208 support q, b = a + a_1\n\u22a2 \u2191toMultiset b \u2264 degrees p + degrees q", "state_after": "case intro.intro.intro.intro\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\na\u2081 : \u03c3 \u2192\u2080 \u2115\nh\u2081 : a\u2081 \u2208 support p\na\u2082 : \u03c3 \u2192\u2080 \u2115\nh\u2082 : a\u2082 \u2208 support q\nhb : a\u2081 + a\u2082 \u2208 support (p * q)\n\u22a2 \u2191toMultiset (a\u2081 + a\u2082) \u2264 degrees p + degrees q"}, {"tactic": "rw [Finsupp.toMultiset_add]", "annotated_tactic": ["rw [<a>Finsupp.toMultiset_add</a>]", [{"full_name": "Finsupp.toMultiset_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Multiset.lean", "def_pos": [45, 9], "def_end_pos": [45, 23]}]], "state_before": "case intro.intro.intro.intro\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\na\u2081 : \u03c3 \u2192\u2080 \u2115\nh\u2081 : a\u2081 \u2208 support p\na\u2082 : \u03c3 \u2192\u2080 \u2115\nh\u2082 : a\u2082 \u2208 support q\nhb : a\u2081 + a\u2082 \u2208 support (p * q)\n\u22a2 \u2191toMultiset (a\u2081 + a\u2082) \u2264 degrees p + degrees q", "state_after": "case intro.intro.intro.intro\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\na\u2081 : \u03c3 \u2192\u2080 \u2115\nh\u2081 : a\u2081 \u2208 support p\na\u2082 : \u03c3 \u2192\u2080 \u2115\nh\u2082 : a\u2082 \u2208 support q\nhb : a\u2081 + a\u2082 \u2208 support (p * q)\n\u22a2 \u2191toMultiset a\u2081 + \u2191toMultiset a\u2082 \u2264 degrees p + degrees q"}, {"tactic": "exact add_le_add (Finset.le_sup h\u2081) (Finset.le_sup h\u2082)", "annotated_tactic": ["exact <a>add_le_add</a> (<a>Finset.le_sup</a> h\u2081) (<a>Finset.le_sup</a> h\u2082)", [{"full_name": "add_le_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [205, 15], "def_end_pos": [205, 25]}, {"full_name": "Finset.le_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [114, 9], "def_end_pos": [114, 15]}, {"full_name": "Finset.le_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [114, 9], "def_end_pos": [114, 15]}]], "state_before": "case intro.intro.intro.intro\nR : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np\u271d q\u271d p q : MvPolynomial \u03c3 R\na\u2081 : \u03c3 \u2192\u2080 \u2115\nh\u2081 : a\u2081 \u2208 support p\na\u2082 : \u03c3 \u2192\u2080 \u2115\nh\u2082 : a\u2082 \u2208 support q\nhb : a\u2081 + a\u2082 \u2208 support (p * q)\n\u22a2 \u2191toMultiset a\u2081 + \u2191toMultiset a\u2082 \u2264 degrees p + degrees q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.disjoint_comm", "start": [53, 1], "end": [54, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Associated.lean", "full_name": "exists_associated_mem_of_dvd_prod", "start": [73, 1], "end": [81, 55], "traced_tactics": [{"tactic": "simp [mt isUnit_iff_dvd_one.2 hp.not_unit]", "annotated_tactic": ["simp [<a>mt</a> <a>isUnit_iff_dvd_one</a>.2 hp.not_unit]", [{"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "isUnit_iff_dvd_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Units.lean", "def_pos": [123, 9], "def_end_pos": [123, 27]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns : Multiset \u03b1\n\u22a2 (\u2200 r \u2208 0, Prime r) \u2192 p \u2223 Multiset.prod 0 \u2192 \u2203 q \u2208 0, p ~\u1d64 q", "state_after": "no goals"}, {"tactic": "rw [Multiset.prod_cons] at hps", "annotated_tactic": ["rw [<a>Multiset.prod_cons</a>] at hps", [{"full_name": "Multiset.prod_cons", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "def_pos": [83, 9], "def_end_pos": [83, 18]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 Multiset.prod (a ::\u2098 s)\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q"}, {"tactic": "cases' hp.dvd_or_dvd hps with h h", "annotated_tactic": ["cases' hp.dvd_or_dvd hps with h h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 a\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 Multiset.prod s\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q"}, {"tactic": "have hap := hs a (Multiset.mem_cons.2 (Or.inl rfl))", "annotated_tactic": ["have hap := hs a (<a>Multiset.mem_cons</a>.2 (<a>Or.inl</a> <a>rfl</a>))", [{"full_name": "Multiset.mem_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 17]}, {"full_name": "Or.inl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [517, 5], "def_end_pos": [517, 8]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 a\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q", "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 a\nhap : Prime a\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q"}, {"tactic": "exact \u27e8a, Multiset.mem_cons_self a _, hp.associated_of_dvd hap h\u27e9", "annotated_tactic": ["exact \u27e8a, <a>Multiset.mem_cons_self</a> a _, hp.associated_of_dvd hap h\u27e9", [{"full_name": "Multiset.mem_cons_self", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [244, 9], "def_end_pos": [244, 22]}]], "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 a\nhap : Prime a\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q", "state_after": "no goals"}, {"tactic": "rcases ih (fun r hr => hs _ (Multiset.mem_cons.2 (Or.inr hr))) h with \u27e8q, hq\u2081, hq\u2082\u27e9", "annotated_tactic": ["rcases ih (fun r hr => hs _ (<a>Multiset.mem_cons</a>.2 (<a>Or.inr</a> hr))) h with \u27e8q, hq\u2081, hq\u2082\u27e9", [{"full_name": "Multiset.mem_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 17]}, {"full_name": "Or.inr", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [519, 5], "def_end_pos": [519, 8]}]], "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 Multiset.prod s\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q", "state_after": "case inr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 Multiset.prod s\nq : \u03b1\nhq\u2081 : q \u2208 s\nhq\u2082 : p ~\u1d64 q\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q"}, {"tactic": "exact \u27e8q, Multiset.mem_cons.2 (Or.inr hq\u2081), hq\u2082\u27e9", "annotated_tactic": ["exact \u27e8q, <a>Multiset.mem_cons</a>.2 (<a>Or.inr</a> hq\u2081), hq\u2082\u27e9", [{"full_name": "Multiset.mem_cons", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [235, 9], "def_end_pos": [235, 17]}, {"full_name": "Or.inr", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [519, 5], "def_end_pos": [519, 8]}]], "state_before": "case inr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np : \u03b1\nhp : Prime p\ns\u271d : Multiset \u03b1\na : \u03b1\ns : Multiset \u03b1\nih : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 Multiset.prod s \u2192 \u2203 q \u2208 s, p ~\u1d64 q\nhs : \u2200 r \u2208 a ::\u2098 s, Prime r\nhps : p \u2223 a * Multiset.prod s\nh : p \u2223 Multiset.prod s\nq : \u03b1\nhq\u2081 : q \u2208 s\nhq\u2082 : p ~\u1d64 q\n\u22a2 \u2203 q \u2208 a ::\u2098 s, p ~\u1d64 q", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "abs_by_cases", "start": [73, 1], "end": [74, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Finset.prod_eq_multiset_prod", "start": [184, 1], "end": [186, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/MinMax.lean", "full_name": "min_le_of_left_le", "start": [106, 1], "end": [107, 20], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "IsCompl.hnot_eq", "start": [1064, 1], "end": [1065, 89], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/BooleanAlgebra.lean", "full_name": "sup_compl_eq_top", "start": [560, 1], "end": [561, 50], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Tree.lean", "full_name": "Tree.height_le_numNodes", "start": [126, 1], "end": [131, 73], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Cast/Defs.lean", "full_name": "Nat.cast_bit1", "start": [193, 1], "end": [194, 42], "traced_tactics": [{"tactic": "rw [bit1, cast_add_one, cast_bit0]", "annotated_tactic": ["rw [<a>bit1</a>, <a>cast_add_one</a>, <a>cast_bit0</a>]", [{"full_name": "bit1", "def_path": "lake-packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [39, 34], "def_end_pos": [39, 38]}, {"full_name": "Nat.cast_add_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [132, 9], "def_end_pos": [132, 21]}, {"full_name": "Nat.cast_bit0", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Cast/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 18]}]], "state_before": "R : Type u_1\ninst\u271d : AddMonoidWithOne R\nn : \u2115\n\u22a2 \u2191(bit1 n) = bit1 \u2191n", "state_after": "R : Type u_1\ninst\u271d : AddMonoidWithOne R\nn : \u2115\n\u22a2 bit0 \u2191n + 1 = bit1 \u2191n"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "R : Type u_1\ninst\u271d : AddMonoidWithOne R\nn : \u2115\n\u22a2 bit0 \u2191n + 1 = bit1 \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Preimage.lean", "full_name": "Finset.prod_preimage_of_bij", "start": [164, 1], "end": [167, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/AbsoluteValue.lean", "full_name": "AbsoluteValue.pos", "start": [119, 11], "end": [120, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Sigma/Basic.lean", "full_name": "PSigma.ext_iff", "start": [251, 1], "end": [252, 46], "traced_tactics": [{"tactic": "cases x\u2080", "annotated_tactic": ["cases x\u2080", []], "state_before": "\u03b1 : Sort u_1\n\u03b2 : \u03b1 \u2192 Sort u_2\nx\u2080 x\u2081 : PSigma \u03b2\n\u22a2 x\u2080 = x\u2081 \u2194 x\u2080.fst = x\u2081.fst \u2227 HEq x\u2080.snd x\u2081.snd", "state_after": "case mk\n\u03b1 : Sort u_1\n\u03b2 : \u03b1 \u2192 Sort u_2\nx\u2081 : PSigma \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2 fst\u271d\n\u22a2 { fst := fst\u271d, snd := snd\u271d } = x\u2081 \u2194\n    { fst := fst\u271d, snd := snd\u271d }.fst = x\u2081.fst \u2227 HEq { fst := fst\u271d, snd := snd\u271d }.snd x\u2081.snd"}, {"tactic": "cases x\u2081", "annotated_tactic": ["cases x\u2081", []], "state_before": "case mk\n\u03b1 : Sort u_1\n\u03b2 : \u03b1 \u2192 Sort u_2\nx\u2081 : PSigma \u03b2\nfst\u271d : \u03b1\nsnd\u271d : \u03b2 fst\u271d\n\u22a2 { fst := fst\u271d, snd := snd\u271d } = x\u2081 \u2194\n    { fst := fst\u271d, snd := snd\u271d }.fst = x\u2081.fst \u2227 HEq { fst := fst\u271d, snd := snd\u271d }.snd x\u2081.snd", "state_after": "case mk.mk\n\u03b1 : Sort u_1\n\u03b2 : \u03b1 \u2192 Sort u_2\nfst\u271d\u00b9 : \u03b1\nsnd\u271d\u00b9 : \u03b2 fst\u271d\u00b9\nfst\u271d : \u03b1\nsnd\u271d : \u03b2 fst\u271d\n\u22a2 { fst := fst\u271d\u00b9, snd := snd\u271d\u00b9 } = { fst := fst\u271d, snd := snd\u271d } \u2194\n    { fst := fst\u271d\u00b9, snd := snd\u271d\u00b9 }.fst = { fst := fst\u271d, snd := snd\u271d }.fst \u2227\n      HEq { fst := fst\u271d\u00b9, snd := snd\u271d\u00b9 }.snd { fst := fst\u271d, snd := snd\u271d }.snd"}, {"tactic": "exact PSigma.mk.inj_iff", "annotated_tactic": ["exact <a>PSigma.mk.inj_iff</a>", [{"full_name": "PSigma.mk.inj_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Sigma/Basic.lean", "def_pos": [239, 9], "def_end_pos": [239, 19]}]], "state_before": "case mk.mk\n\u03b1 : Sort u_1\n\u03b2 : \u03b1 \u2192 Sort u_2\nfst\u271d\u00b9 : \u03b1\nsnd\u271d\u00b9 : \u03b2 fst\u271d\u00b9\nfst\u271d : \u03b1\nsnd\u271d : \u03b2 fst\u271d\n\u22a2 { fst := fst\u271d\u00b9, snd := snd\u271d\u00b9 } = { fst := fst\u271d, snd := snd\u271d } \u2194\n    { fst := fst\u271d\u00b9, snd := snd\u271d\u00b9 }.fst = { fst := fst\u271d, snd := snd\u271d }.fst \u2227\n      HEq { fst := fst\u271d\u00b9, snd := snd\u271d\u00b9 }.snd { fst := fst\u271d, snd := snd\u271d }.snd", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/RowCol.lean", "full_name": "Matrix.updateColumn_reindex", "start": [342, 1], "end": [345, 41], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Localization/Basic.lean", "full_name": "IsLocalization.eq_of_eq", "start": [450, 1], "end": [452, 99], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Int/DivMod.lean", "full_name": "Int.fmod_one", "start": [359, 9], "end": [360, 45], "traced_tactics": [{"tactic": "simp [fmod_def, Int.one_mul, Int.sub_self]", "annotated_tactic": ["simp [<a>fmod_def</a>, <a>Int.one_mul</a>, <a>Int.sub_self</a>]", [{"full_name": "Int.fmod_def", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [332, 9], "def_end_pos": [332, 17]}, {"full_name": "Int.one_mul", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [521, 27], "def_end_pos": [521, 34]}, {"full_name": "Int.sub_self", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [343, 19], "def_end_pos": [343, 27]}]], "state_before": "a : Int\n\u22a2 fmod a 1 = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/SuccPred/Basic.lean", "full_name": "Order.succ_eq_iff_isMax", "start": [406, 1], "end": [407, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Notation.lean", "full_name": "Matrix.empty_vecMulVec", "start": [348, 1], "end": [349, 13], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Bases.lean", "full_name": "Filter.disjoint_principal_left", "start": [701, 1], "end": [702, 47], "traced_tactics": [{"tactic": "rw [disjoint_comm, disjoint_principal_right]", "annotated_tactic": ["rw [<a>disjoint_comm</a>, <a>disjoint_principal_right</a>]", [{"full_name": "disjoint_comm", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [49, 9], "def_end_pos": [49, 22]}, {"full_name": "Filter.disjoint_principal_right", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Bases.lean", "def_pos": [696, 9], "def_end_pos": [696, 33]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nl l' : Filter \u03b1\np : \u03b9 \u2192 Prop\ns\u271d : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\ni : \u03b9\np' : \u03b9' \u2192 Prop\ns' : \u03b9' \u2192 Set \u03b1\ni' : \u03b9'\nf : Filter \u03b1\ns : Set \u03b1\n\u22a2 Disjoint (\ud835\udcdf s) f \u2194 s\u1d9c \u2208 f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "div_eq_mul_one_div", "start": [329, 1], "end": [329, 94], "traced_tactics": [{"tactic": "rw [div_eq_mul_inv, one_div]", "annotated_tactic": ["rw [<a>div_eq_mul_inv</a>, <a>one_div</a>]", [{"full_name": "div_eq_mul_inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [977, 9], "def_end_pos": [977, 23]}, {"full_name": "one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [318, 9], "def_end_pos": [318, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivInvMonoid G\na\u271d b\u271d c a b : G\n\u22a2 a / b = a * (1 / b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Logic.lean", "full_name": "decide_True'", "start": [274, 1], "end": [274, 74], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "a b c d : Prop\np : ?m.24980\nh : Decidable True\n\u22a2 decide True = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Heyting/Basic.lean", "full_name": "PUnit.bot_eq", "start": [1351, 1], "end": [1352, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.tendsto_top", "start": [2983, 9], "end": [2983, 81], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/GCD.lean", "full_name": "Int.pow_dvd_pow_iff", "start": [386, 1], "end": [389, 23], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, fun h => pow_dvd_pow_of_dvd h _\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, fun h => <a>pow_dvd_pow_of_dvd</a> h _\u27e9", [{"full_name": "pow_dvd_pow_of_dvd", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Divisibility/Basic.lean", "def_pos": [203, 9], "def_end_pos": [203, 27]}]], "state_before": "m n : \u2124\nk : \u2115\nk0 : 0 < k\n\u22a2 m ^ k \u2223 n ^ k \u2194 m \u2223 n", "state_after": "m n : \u2124\nk : \u2115\nk0 : 0 < k\nh : m ^ k \u2223 n ^ k\n\u22a2 m \u2223 n"}, {"tactic": "rwa [\u2190 natAbs_dvd_natAbs, \u2190 Nat.pow_dvd_pow_iff k0, \u2190 Int.natAbs_pow, \u2190 Int.natAbs_pow,\n  natAbs_dvd_natAbs]", "annotated_tactic": ["rwa [\u2190 <a>natAbs_dvd_natAbs</a>, \u2190 <a>Nat.pow_dvd_pow_iff</a> k0, \u2190 <a>Int.natAbs_pow</a>, \u2190 <a>Int.natAbs_pow</a>,\n    <a>natAbs_dvd_natAbs</a>]", [{"full_name": "Int.natAbs_dvd_natAbs", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [652, 17], "def_end_pos": [652, 34]}, {"full_name": "Nat.pow_dvd_pow_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/GCD/Basic.lean", "def_pos": [309, 9], "def_end_pos": [309, 24]}, {"full_name": "Int.natAbs_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [549, 9], "def_end_pos": [549, 23]}, {"full_name": "Int.natAbs_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Lemmas.lean", "def_pos": [549, 9], "def_end_pos": [549, 23]}, {"full_name": "Int.natAbs_dvd_natAbs", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [652, 17], "def_end_pos": [652, 34]}]], "state_before": "m n : \u2124\nk : \u2115\nk0 : 0 < k\nh : m ^ k \u2223 n ^ k\n\u22a2 m \u2223 n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Option/Lemmas.lean", "full_name": "Option.liftOrGet_eq_or_eq", "start": [187, 1], "end": [192, 79], "traced_tactics": [{"tactic": "have := h a b", "annotated_tactic": ["have := h a b", []], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nh : \u2200 (a b : \u03b1), f a b = a \u2228 f a b = b\na b : \u03b1\n\u22a2 liftOrGet f (some a) (some b) = some a \u2228 liftOrGet f (some a) (some b) = some b", "state_after": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nh : \u2200 (a b : \u03b1), f a b = a \u2228 f a b = b\na b : \u03b1\nthis : f a b = a \u2228 f a b = b\n\u22a2 liftOrGet f (some a) (some b) = some a \u2228 liftOrGet f (some a) (some b) = some b"}, {"tactic": "simp [liftOrGet] at this \u22a2", "annotated_tactic": ["simp [<a>liftOrGet</a>] at this \u22a2", [{"full_name": "Option.liftOrGet", "def_path": "lake-packages/std/Std/Data/Option/Basic.lean", "def_pos": [73, 5], "def_end_pos": [73, 14]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nh : \u2200 (a b : \u03b1), f a b = a \u2228 f a b = b\na b : \u03b1\nthis : f a b = a \u2228 f a b = b\n\u22a2 liftOrGet f (some a) (some b) = some a \u2228 liftOrGet f (some a) (some b) = some b", "state_after": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nh : \u2200 (a b : \u03b1), f a b = a \u2228 f a b = b\na b : \u03b1\nthis : f a b = a \u2228 f a b = b\n\u22a2 f a b = a \u2228 f a b = b"}, {"tactic": "exact this", "annotated_tactic": ["exact this", []], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nh : \u2200 (a b : \u03b1), f a b = a \u2228 f a b = b\na b : \u03b1\nthis : f a b = a \u2228 f a b = b\n\u22a2 f a b = a \u2228 f a b = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Prime.lean", "full_name": "Nat.not_prime_zero", "start": [54, 1], "end": [55, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Basic.lean", "full_name": "Commute.sum_left", "start": [1792, 1], "end": [1794, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Pointwise.lean", "full_name": "Finset.smul_finset_subset_iff\u2080", "start": [2080, 1], "end": [2081, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Opposites.lean", "full_name": "MulOpposite.unop_op", "start": [99, 1], "end": [99, 49], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Vector/Basic.lean", "full_name": "Vector.get_replicate", "start": [128, 1], "end": [129, 27], "traced_tactics": [{"tactic": "apply List.get_replicate", "annotated_tactic": ["apply <a>List.get_replicate</a>", [{"full_name": "List.get_replicate", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [713, 17], "def_end_pos": [713, 30]}]], "state_before": "n : \u2115\n\u03b1 : Type u_1\na : \u03b1\ni : Fin n\n\u22a2 get (replicate n a) i = a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.leadingCoeff_monic_mul", "start": [1022, 1], "end": [1027, 65], "traced_tactics": [{"tactic": "rcases eq_or_ne q 0 with (rfl | H)", "annotated_tactic": ["rcases <a>eq_or_ne</a> q 0 with (rfl | H)", [{"full_name": "eq_or_ne", "def_path": "lake-packages/mathlib/Mathlib/Logic/Basic.lean", "def_pos": [208, 9], "def_end_pos": [208, 17]}]], "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d : R[X]\n\u03b9 : Type u_1\np q : R[X]\nhp : Monic p\n\u22a2 leadingCoeff (p * q) = leadingCoeff q", "state_after": "case inl\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\n\u03b9 : Type u_1\np : R[X]\nhp : Monic p\n\u22a2 leadingCoeff (p * 0) = leadingCoeff 0\n\ncase inr\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d : R[X]\n\u03b9 : Type u_1\np q : R[X]\nhp : Monic p\nH : q \u2260 0\n\u22a2 leadingCoeff (p * q) = leadingCoeff q"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inl\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q : R[X]\n\u03b9 : Type u_1\np : R[X]\nhp : Monic p\n\u22a2 leadingCoeff (p * 0) = leadingCoeff 0", "state_after": "no goals"}, {"tactic": "rw [leadingCoeff_mul', hp.leadingCoeff, one_mul]", "annotated_tactic": ["rw [<a>leadingCoeff_mul'</a>, hp.leadingCoeff, <a>one_mul</a>]", [{"full_name": "Polynomial.leadingCoeff_mul'", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [975, 9], "def_end_pos": [975, 26]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "case inr\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d : R[X]\n\u03b9 : Type u_1\np q : R[X]\nhp : Monic p\nH : q \u2260 0\n\u22a2 leadingCoeff (p * q) = leadingCoeff q", "state_after": "case inr\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d : R[X]\n\u03b9 : Type u_1\np q : R[X]\nhp : Monic p\nH : q \u2260 0\n\u22a2 leadingCoeff p * leadingCoeff q \u2260 0"}, {"tactic": "rwa [hp.leadingCoeff, one_mul, Ne.def, leadingCoeff_eq_zero]", "annotated_tactic": ["rwa [hp.leadingCoeff, <a>one_mul</a>, <a>Ne.def</a>, <a>leadingCoeff_eq_zero</a>]", [{"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Degree/Definitions.lean", "def_pos": [670, 9], "def_end_pos": [670, 29]}]], "state_before": "case inr\nR : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q\u271d : R[X]\n\u03b9 : Type u_1\np q : R[X]\nhp : Monic p\nH : q \u2260 0\n\u22a2 leadingCoeff p * leadingCoeff q \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Field/Basic.lean", "full_name": "div_le_iff'", "start": [159, 1], "end": [159, 92], "traced_tactics": [{"tactic": "rw [mul_comm, div_le_iff hb]", "annotated_tactic": ["rw [<a>mul_comm</a>, <a>div_le_iff</a> hb]", [{"full_name": "mul_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [302, 9], "def_end_pos": [302, 17]}, {"full_name": "div_le_iff", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Field/Basic.lean", "def_pos": [144, 9], "def_end_pos": [144, 19]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhb : 0 < b\n\u22a2 a / b \u2264 c \u2194 a \u2264 b * c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Ring.lean", "full_name": "Finset.prod_add_ordered", "start": [164, 1], "end": [185, 49], "traced_tactics": [{"tactic": "refine' Finset.induction_on_max s (by simp) _", "annotated_tactic": ["refine' <a>Finset.induction_on_max</a> s (by simp) _", [{"full_name": "Finset.induction_on_max", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [1717, 9], "def_end_pos": [1717, 25]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\ns : Finset \u03b9\nf g : \u03b9 \u2192 R\n\u22a2 \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\ns : Finset \u03b9\nf g : \u03b9 \u2192 R\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    (\u2200 x \u2208 s, x < a) \u2192\n      \u220f i in s, (f i + g i) =\n          \u220f i in s, f i +\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j \u2192\n        \u220f i in insert a s, (f i + g i) =\n          \u220f i in insert a s, f i +\n            \u2211 i in insert a s,\n              (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n                \u220f j in filter (fun j => i < j) (insert a s), f j"}, {"tactic": "clear s", "annotated_tactic": ["clear s", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\ns : Finset \u03b9\nf g : \u03b9 \u2192 R\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    (\u2200 x \u2208 s, x < a) \u2192\n      \u220f i in s, (f i + g i) =\n          \u220f i in s, f i +\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j \u2192\n        \u220f i in insert a s, (f i + g i) =\n          \u220f i in insert a s, f i +\n            \u2211 i in insert a s,\n              (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n                \u220f j in filter (fun j => i < j) (insert a s), f j", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    (\u2200 x \u2208 s, x < a) \u2192\n      \u220f i in s, (f i + g i) =\n          \u220f i in s, f i +\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j \u2192\n        \u220f i in insert a s, (f i + g i) =\n          \u220f i in insert a s, f i +\n            \u2211 i in insert a s,\n              (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n                \u220f j in filter (fun j => i < j) (insert a s), f j"}, {"tactic": "intro a s ha ihs", "annotated_tactic": ["intro a s ha ihs", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    (\u2200 x \u2208 s, x < a) \u2192\n      \u220f i in s, (f i + g i) =\n          \u220f i in s, f i +\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j \u2192\n        \u220f i in insert a s, (f i + g i) =\n          \u220f i in insert a s, f i +\n            \u2211 i in insert a s,\n              (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n                \u220f j in filter (fun j => i < j) (insert a s), f j", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\n\u22a2 \u220f i in insert a s, (f i + g i) =\n    \u220f i in insert a s, f i +\n      \u2211 i in insert a s,\n        (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => i < j) (insert a s), f j"}, {"tactic": "have ha' : a \u2209 s := fun ha' => lt_irrefl a (ha a ha')", "annotated_tactic": ["have ha' : a \u2209 s := fun ha' => <a>lt_irrefl</a> a (ha a ha')", [{"full_name": "lt_irrefl", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [79, 9], "def_end_pos": [79, 18]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\n\u22a2 \u220f i in insert a s, (f i + g i) =\n    \u220f i in insert a s, f i +\n      \u2211 i in insert a s,\n        (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => i < j) (insert a s), f j", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 \u220f i in insert a s, (f i + g i) =\n    \u220f i in insert a s, f i +\n      \u2211 i in insert a s,\n        (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => i < j) (insert a s), f j"}, {"tactic": "rw [prod_insert ha', prod_insert ha', sum_insert ha', filter_insert, if_neg (lt_irrefl a),\n  filter_true_of_mem ha, ihs, add_mul, mul_add, mul_add, add_assoc]", "annotated_tactic": ["rw [<a>prod_insert</a> ha', <a>prod_insert</a> ha', <a>sum_insert</a> ha', <a>filter_insert</a>, <a>if_neg</a> (<a>lt_irrefl</a> a),\n    <a>filter_true_of_mem</a> ha, ihs, <a>add_mul</a>, <a>mul_add</a>, <a>mul_add</a>, <a>add_assoc</a>]", [{"full_name": "Finset.prod_insert", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [319, 9], "def_end_pos": [319, 20]}, {"full_name": "Finset.prod_insert", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [319, 9], "def_end_pos": [319, 20]}, {"full_name": "Finset.sum_insert", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [318, 3], "def_end_pos": [318, 14]}, {"full_name": "Finset.filter_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2918, 9], "def_end_pos": [2918, 22]}, {"full_name": "if_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [795, 9], "def_end_pos": [795, 15]}, {"full_name": "lt_irrefl", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [79, 9], "def_end_pos": [79, 18]}, {"full_name": "Finset.filter_true_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2784, 9], "def_end_pos": [2784, 27]}, {"full_name": "add_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [91, 7], "def_end_pos": [91, 14]}, {"full_name": "mul_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "mul_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [83, 7], "def_end_pos": [83, 14]}, {"full_name": "add_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [263, 3], "def_end_pos": [263, 14]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 \u220f i in insert a s, (f i + g i) =\n    \u220f i in insert a s, f i +\n      \u2211 i in insert a s,\n        (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => i < j) (insert a s), f j", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 f a * \u220f i in s, f i +\n      (f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j +\n        (g a * \u220f i in s, f i +\n          g a *\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j)) =\n    f a * \u220f x in s, f x +\n      ((g a * \u220f i in s, f i +\n            g a *\n              \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n          \u220f j in filter (fun j => a < j) (insert a s), f j +\n        \u2211 x in s,\n          (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n            \u220f j in filter (fun j => x < j) (insert a s), f j)"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 f a * \u220f i in s, f i +\n      (f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j +\n        (g a * \u220f i in s, f i +\n          g a *\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j)) =\n    f a * \u220f x in s, f x +\n      ((g a * \u220f i in s, f i +\n            g a *\n              \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n          \u220f j in filter (fun j => a < j) (insert a s), f j +\n        \u2211 x in s,\n          (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n            \u220f j in filter (fun j => x < j) (insert a s), f j)", "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j +\n      (g a * \u220f i in s, f i +\n        g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) =\n    (g a * \u220f i in s, f i +\n          g a *\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n        \u220f j in filter (fun j => a < j) (insert a s), f j +\n      \u2211 x in s,\n        (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => x < j) (insert a s), f j"}, {"tactic": "rw [add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>]", [{"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}]], "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j +\n      (g a * \u220f i in s, f i +\n        g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) =\n    (g a * \u220f i in s, f i +\n          g a *\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n        \u220f j in filter (fun j => a < j) (insert a s), f j +\n      \u2211 x in s,\n        (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => x < j) (insert a s), f j", "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 g a * \u220f i in s, f i +\n        g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j +\n      f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j =\n    (g a * \u220f i in s, f i +\n          g a *\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n        \u220f j in filter (fun j => a < j) (insert a s), f j +\n      \u2211 x in s,\n        (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => x < j) (insert a s), f j"}, {"tactic": "congr 1", "annotated_tactic": ["congr 1", []], "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 g a * \u220f i in s, f i +\n        g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j +\n      f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j =\n    (g a * \u220f i in s, f i +\n          g a *\n            \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n        \u220f j in filter (fun j => a < j) (insert a s), f j +\n      \u2211 x in s,\n        (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n          \u220f j in filter (fun j => x < j) (insert a s), f j", "state_after": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 g a * \u220f i in s, f i +\n      g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j =\n    (g a * \u220f i in s, f i +\n        g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n      \u220f j in filter (fun j => a < j) (insert a s), f j\n\ncase e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j =\n    \u2211 x in s,\n      (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n        \u220f j in filter (fun j => x < j) (insert a s), f j"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\ns : Finset \u03b9\nf g : \u03b9 \u2192 R\n\u22a2 \u220f i in \u2205, (f i + g i) =\n    \u220f i in \u2205, f i +\n      \u2211 i in \u2205, (g i * \u220f j in filter (fun x => x < i) \u2205, (f j + g j)) * \u220f j in filter (fun j => i < j) \u2205, f j", "state_after": "no goals"}, {"tactic": "rw [filter_false_of_mem, prod_empty, mul_one]", "annotated_tactic": ["rw [<a>filter_false_of_mem</a>, <a>prod_empty</a>, <a>mul_one</a>]", [{"full_name": "Finset.filter_false_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2789, 9], "def_end_pos": [2789, 28]}, {"full_name": "Finset.prod_empty", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [301, 9], "def_end_pos": [301, 19]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 g a * \u220f i in s, f i +\n      g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j =\n    (g a * \u220f i in s, f i +\n        g a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) *\n      \u220f j in filter (fun j => a < j) (insert a s), f j", "state_after": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 \u2200 x \u2208 insert a s, \u00aca < x"}, {"tactic": "exact (forall_mem_insert _ _ _).2 \u27e8lt_irrefl a, fun i hi => (ha i hi).not_lt\u27e9", "annotated_tactic": ["exact (<a>forall_mem_insert</a> _ _ _).2 \u27e8<a>lt_irrefl</a> a, fun i hi => (ha i hi).<a>not_lt</a>\u27e9", [{"full_name": "Finset.forall_mem_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3160, 9], "def_end_pos": [3160, 26]}, {"full_name": "lt_irrefl", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [79, 9], "def_end_pos": [79, 18]}, {"full_name": "LT.lt.not_lt", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [157, 7], "def_end_pos": [157, 19]}]], "state_before": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 \u2200 x \u2208 insert a s, \u00aca < x", "state_after": "no goals"}, {"tactic": "rw [mul_sum]", "annotated_tactic": ["rw [<a>mul_sum</a>]", [{"full_name": "Finset.mul_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Ring.lean", "def_pos": [55, 9], "def_end_pos": [55, 16]}]], "state_before": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 f a * \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j =\n    \u2211 x in s,\n      (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n        \u220f j in filter (fun j => x < j) (insert a s), f j", "state_after": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 \u2211 x in s, f a * ((g x * \u220f j in filter (fun x_1 => x_1 < x) s, (f j + g j)) * \u220f j in filter (fun j => x < j) s, f j) =\n    \u2211 x in s,\n      (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n        \u220f j in filter (fun j => x < j) (insert a s), f j"}, {"tactic": "refine' sum_congr rfl fun i hi => _", "annotated_tactic": ["refine' <a>sum_congr</a> <a>rfl</a> fun i hi => _", [{"full_name": "Finset.sum_congr", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [382, 3], "def_end_pos": [382, 14]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\n\u22a2 \u2211 x in s, f a * ((g x * \u220f j in filter (fun x_1 => x_1 < x) s, (f j + g j)) * \u220f j in filter (fun j => x < j) s, f j) =\n    \u2211 x in s,\n      (g x * \u220f j in filter (fun x_1 => x_1 < x) (insert a s), (f j + g j)) *\n        \u220f j in filter (fun j => x < j) (insert a s), f j", "state_after": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\ni : \u03b9\nhi : i \u2208 s\n\u22a2 f a * ((g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) =\n    (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) * \u220f j in filter (fun j => i < j) (insert a s), f j"}, {"tactic": "rw [filter_insert, if_neg (ha i hi).not_lt, filter_insert, if_pos (ha i hi), prod_insert,\n  mul_left_comm]", "annotated_tactic": ["rw [<a>filter_insert</a>, <a>if_neg</a> (ha i hi).<a>not_lt</a>, <a>filter_insert</a>, <a>if_pos</a> (ha i hi), <a>prod_insert</a>,\n      <a>mul_left_comm</a>]", [{"full_name": "Finset.filter_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2918, 9], "def_end_pos": [2918, 22]}, {"full_name": "if_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [795, 9], "def_end_pos": [795, 15]}, {"full_name": "LT.lt.not_lt", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [157, 7], "def_end_pos": [157, 19]}, {"full_name": "Finset.filter_insert", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2918, 9], "def_end_pos": [2918, 22]}, {"full_name": "if_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [790, 9], "def_end_pos": [790, 15]}, {"full_name": "Finset.prod_insert", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [319, 9], "def_end_pos": [319, 20]}, {"full_name": "mul_left_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [96, 9], "def_end_pos": [96, 22]}]], "state_before": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\ni : \u03b9\nhi : i \u2208 s\n\u22a2 f a * ((g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j) =\n    (g i * \u220f j in filter (fun x => x < i) (insert a s), (f j + g j)) * \u220f j in filter (fun j => i < j) (insert a s), f j", "state_after": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\ni : \u03b9\nhi : i \u2208 s\n\u22a2 a \u2209 filter (fun j => i < j) s"}, {"tactic": "exact mt (fun ha => (mem_filter.1 ha).1) ha'", "annotated_tactic": ["exact <a>mt</a> (fun ha => (<a>mem_filter</a>.1 ha).1) ha'", [{"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "Finset.mem_filter", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [2731, 9], "def_end_pos": [2731, 19]}]], "state_before": "case e_a.e_a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u271d s\u2081 s\u2082 : Finset \u03b1\na\u271d : \u03b1\nb : \u03b2\nf\u271d g\u271d : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : CommSemiring \u03b2\n\u03b9 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : LinearOrder \u03b9\nf g : \u03b9 \u2192 R\na : \u03b9\ns : Finset \u03b9\nha : \u2200 x \u2208 s, x < a\nihs :\n  \u220f i in s, (f i + g i) =\n    \u220f i in s, f i +\n      \u2211 i in s, (g i * \u220f j in filter (fun x => x < i) s, (f j + g j)) * \u220f j in filter (fun j => i < j) s, f j\nha' : a \u2209 s\ni : \u03b9\nhi : i \u2208 s\n\u22a2 a \u2209 filter (fun j => i < j) s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "ite_mul_one", "start": [58, 1], "end": [60, 28], "traced_tactics": [{"tactic": "by_cases h:P <;> simp [h]", "annotated_tactic": ["by_cases h:P <;> simp [h]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM : Type u\ninst\u271d\u00b9 : MulOneClass M\nP : Prop\ninst\u271d : Decidable P\na b : M\n\u22a2 (if P then a * b else 1) = (if P then a else 1) * if P then b else 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.coe_Ioi", "start": [1162, 1], "end": [1163, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Lemmas.lean", "full_name": "Nat.pow_succ'", "start": [985, 1], "end": [986, 34], "traced_tactics": [{"tactic": "rw [Nat.pow_succ, Nat.mul_comm]", "annotated_tactic": ["rw [<a>Nat.pow_succ</a>, <a>Nat.mul_comm</a>]", [{"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}, {"full_name": "Nat.mul_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [174, 19], "def_end_pos": [174, 27]}]], "state_before": "m n : Nat\n\u22a2 m ^ succ n = m * m ^ n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "TensorProduct.tmul_ite", "start": [403, 1], "end": [404, 88], "traced_tactics": [{"tactic": "split_ifs <;> simp", "annotated_tactic": ["split_ifs <;> simp", []], "state_before": "R : Type u_1\ninst\u271d\u00b9\u2077 : CommSemiring R\nR' : Type u_2\ninst\u271d\u00b9\u2076 : Monoid R'\nR'' : Type u_3\ninst\u271d\u00b9\u2075 : Semiring R''\nM : Type u_4\nN : Type u_5\nP\u271d : Type u_6\nQ : Type u_7\nS : Type u_8\ninst\u271d\u00b9\u2074 : AddCommMonoid M\ninst\u271d\u00b9\u00b3 : AddCommMonoid N\ninst\u271d\u00b9\u00b2 : AddCommMonoid P\u271d\ninst\u271d\u00b9\u00b9 : AddCommMonoid Q\ninst\u271d\u00b9\u2070 : AddCommMonoid S\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module R N\ninst\u271d\u2077 : Module R P\u271d\ninst\u271d\u2076 : Module R Q\ninst\u271d\u2075 : Module R S\ninst\u271d\u2074 : DistribMulAction R' M\ninst\u271d\u00b3 : Module R'' M\ninst\u271d\u00b2 : SMulCommClass R R' M\ninst\u271d\u00b9 : SMulCommClass R R'' M\nx\u2081 : M\nx\u2082 : N\nP : Prop\ninst\u271d : Decidable P\n\u22a2 (x\u2081 \u2297\u209c[R] if P then x\u2082 else 0) = if P then x\u2081 \u2297\u209c[R] x\u2082 else 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.coe_sup", "start": [576, 1], "end": [577, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderIso.withBotCongr_symm", "start": [1358, 1], "end": [1359, 54], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/Basic.lean", "full_name": "Nat.mod_mod_of_dvd", "start": [762, 1], "end": [767, 40], "traced_tactics": [{"tactic": "conv =>\nrhs\nrw [\u2190 mod_add_div n k]", "annotated_tactic": ["conv =>\n  rhs\n  rw [\u2190 <a>mod_add_div</a> n k]", [{"full_name": "Nat.mod_add_div", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [749, 9], "def_end_pos": [749, 20]}]], "state_before": "m\u271d n\u271d k\u271d n m k : \u2115\nh : m \u2223 k\n\u22a2 n % k % m = n % m", "state_after": "m\u271d n\u271d k\u271d n m k : \u2115\nh : m \u2223 k\n\u22a2 n % k % m = (n % k + k * (n / k)) % m"}, {"tactic": "rcases h with \u27e8t, rfl\u27e9", "annotated_tactic": ["rcases h with \u27e8t, rfl\u27e9", []], "state_before": "m\u271d n\u271d k\u271d n m k : \u2115\nh : m \u2223 k\n\u22a2 n % k % m = (n % k + k * (n / k)) % m", "state_after": "case intro\nm\u271d n\u271d k n m t : \u2115\n\u22a2 n % (m * t) % m = (n % (m * t) + m * t * (n / (m * t))) % m"}, {"tactic": "rw [mul_assoc, add_mul_mod_self_left]", "annotated_tactic": ["rw [<a>mul_assoc</a>, <a>add_mul_mod_self_left</a>]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "Nat.add_mul_mod_self_left", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [915, 17], "def_end_pos": [915, 38]}]], "state_before": "case intro\nm\u271d n\u271d k n m t : \u2115\n\u22a2 n % (m * t) % m = (n % (m * t) + m * t * (n / (m * t))) % m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Logic.lean", "full_name": "Decidable.not_imp", "start": [589, 1], "end": [590, 66], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/ToDFinsupp.lean", "full_name": "sigmaFinsuppEquivDFinsupp_single", "start": [323, 1], "end": [333, 48], "traced_tactics": [{"tactic": "obtain \u27e8i, a\u27e9 := a", "annotated_tactic": ["obtain \u27e8i, a\u27e9 := a", []], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\na : (i : \u03b9) \u00d7 \u03b7 i\nn : N\n\u22a2 (\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | a => n) = DFinsupp.single a.fst fun\u2080 | a.snd => n", "state_after": "case mk\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\n\u22a2 (\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) =\n    DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n"}, {"tactic": "ext j b", "annotated_tactic": ["ext j b", []], "state_before": "case mk\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\n\u22a2 (\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) =\n    DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n", "state_after": "case mk.h.h\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) j) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) j) b"}, {"tactic": "by_cases h : i = j", "annotated_tactic": ["by_cases h : i = j", []], "state_before": "case mk.h.h\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) j) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) j) b", "state_after": "case pos\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : i = j\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) j) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) j) b\n\ncase neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) j) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) j) b"}, {"tactic": "suffices Finsupp.single (\u27e8i, a\u27e9 : \u03a3i, \u03b7 i) n \u27e8j, b\u27e9 = 0 by simp [split_apply, dif_neg h, this]", "annotated_tactic": ["suffices <a>Finsupp.single</a> (\u27e8i, a\u27e9 : \u03a3i, \u03b7 i) n \u27e8j, b\u27e9 = 0 by simp [<a>split_apply</a>, <a>dif_neg</a> h, this]", [{"full_name": "Finsupp.single", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [289, 5], "def_end_pos": [289, 11]}, {"full_name": "Finsupp.split_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1775, 9], "def_end_pos": [1775, 20]}, {"full_name": "dif_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [812, 9], "def_end_pos": [812, 16]}]], "state_before": "case neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) j) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) j) b", "state_after": "case neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\n\u22a2 (\u2191fun\u2080 | { fst := i, snd := a } => n) { fst := j, snd := b } = 0"}, {"tactic": "have H : (\u27e8i, a\u27e9 : \u03a3i, \u03b7 i) \u2260 \u27e8j, b\u27e9 := by simp [h]", "annotated_tactic": ["have H : (\u27e8i, a\u27e9 : \u03a3i, \u03b7 i) \u2260 \u27e8j, b\u27e9 := by simp [h]", []], "state_before": "case neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\n\u22a2 (\u2191fun\u2080 | { fst := i, snd := a } => n) { fst := j, snd := b } = 0", "state_after": "case neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\nH : { fst := i, snd := a } \u2260 { fst := j, snd := b }\n\u22a2 (\u2191fun\u2080 | { fst := i, snd := a } => n) { fst := j, snd := b } = 0"}, {"tactic": "classical rw [Finsupp.single_apply, if_neg H]", "annotated_tactic": ["classical rw [<a>Finsupp.single_apply</a>, <a>if_neg</a> H]", [{"full_name": "Finsupp.single_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [307, 9], "def_end_pos": [307, 21]}, {"full_name": "if_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [795, 9], "def_end_pos": [795, 15]}]], "state_before": "case neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\nH : { fst := i, snd := a } \u2260 { fst := j, snd := b }\n\u22a2 (\u2191fun\u2080 | { fst := i, snd := a } => n) { fst := j, snd := b } = 0", "state_after": "no goals"}, {"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "case pos\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : i = j\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) j) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) j) b", "state_after": "case pos\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na b : \u03b7 i\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) i) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) i) b"}, {"tactic": "classical simp [split_apply, Finsupp.single_apply]", "annotated_tactic": ["classical simp [<a>split_apply</a>, <a>Finsupp.single_apply</a>]", [{"full_name": "Finsupp.split_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1775, 9], "def_end_pos": [1775, 20]}, {"full_name": "Finsupp.single_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [307, 9], "def_end_pos": [307, 21]}]], "state_before": "case pos\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na b : \u03b7 i\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) i) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) i) b", "state_after": "no goals"}, {"tactic": "simp [split_apply, Finsupp.single_apply]", "annotated_tactic": ["simp [<a>split_apply</a>, <a>Finsupp.single_apply</a>]", [{"full_name": "Finsupp.split_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1775, 9], "def_end_pos": [1775, 20]}, {"full_name": "Finsupp.single_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [307, 9], "def_end_pos": [307, 21]}]], "state_before": "case pos\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na b : \u03b7 i\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) i) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) i) b", "state_after": "no goals"}, {"tactic": "simp [split_apply, dif_neg h, this]", "annotated_tactic": ["simp [<a>split_apply</a>, <a>dif_neg</a> h, this]", [{"full_name": "Finsupp.split_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Basic.lean", "def_pos": [1775, 9], "def_end_pos": [1775, 20]}, {"full_name": "dif_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [812, 9], "def_end_pos": [812, 16]}]], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\nthis : (\u2191fun\u2080 | { fst := i, snd := a } => n) { fst := j, snd := b } = 0\n\u22a2 \u2191(\u2191(\u2191sigmaFinsuppEquivDFinsupp fun\u2080 | { fst := i, snd := a } => n) j) b =\n    \u2191(\u2191(DFinsupp.single { fst := i, snd := a }.fst fun\u2080 | { fst := i, snd := a }.snd => n) j) b", "state_after": "no goals"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\n\u22a2 { fst := i, snd := a } \u2260 { fst := j, snd := b }", "state_after": "no goals"}, {"tactic": "rw [Finsupp.single_apply, if_neg H]", "annotated_tactic": ["rw [<a>Finsupp.single_apply</a>, <a>if_neg</a> H]", [{"full_name": "Finsupp.single_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [307, 9], "def_end_pos": [307, 21]}, {"full_name": "if_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [795, 9], "def_end_pos": [795, 15]}]], "state_before": "case neg\n\u03b9 : Type u_1\nR : Type u_2\nM : Type u_3\n\u03b7 : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Zero N\nn : N\ni : \u03b9\na : \u03b7 i\nj : \u03b9\nb : \u03b7 j\nh : \u00aci = j\nH : { fst := i, snd := a } \u2260 { fst := j, snd := b }\n\u22a2 (\u2191fun\u2080 | { fst := i, snd := a } => n) { fst := j, snd := b } = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Multiset/Basic.lean", "full_name": "Multiset.add_cons", "start": [678, 1], "end": [679, 36], "traced_tactics": [{"tactic": "rw [add_comm, cons_add, add_comm]", "annotated_tactic": ["rw [<a>add_comm</a>, <a>cons_add</a>, <a>add_comm</a>]", [{"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}, {"full_name": "Multiset.cons_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [673, 9], "def_end_pos": [673, 17]}, {"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\na : \u03b1\ns t : Multiset \u03b1\n\u22a2 s + a ::\u2098 t = a ::\u2098 (s + t)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Basic.lean", "full_name": "Equiv.sigmaUnique_symm_apply", "start": [257, 1], "end": [259, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Duplicate.lean", "full_name": "List.Duplicate.elim_singleton", "start": [85, 1], "end": [86, 32], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Rat/Cast/CharZero.lean", "full_name": "Rat.cast_bit1", "start": [78, 1], "end": [79, 48], "traced_tactics": [{"tactic": "rw [bit1, cast_add, cast_one, cast_bit0]", "annotated_tactic": ["rw [<a>bit1</a>, <a>cast_add</a>, <a>cast_one</a>, <a>cast_bit0</a>]", [{"full_name": "bit1", "def_path": "lake-packages/mathlib/Mathlib/Init/ZeroOne.lean", "def_pos": [39, 34], "def_end_pos": [39, 38]}, {"full_name": "Rat.cast_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Cast/CharZero.lean", "def_pos": [54, 9], "def_end_pos": [54, 17]}, {"full_name": "Rat.cast_one", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Cast/Defs.lean", "def_pos": [57, 9], "def_end_pos": [57, 17]}, {"full_name": "Rat.cast_bit0", "def_path": "lake-packages/mathlib/Mathlib/Data/Rat/Cast/CharZero.lean", "def_pos": [73, 9], "def_end_pos": [73, 18]}]], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : DivisionRing \u03b1\ninst\u271d : CharZero \u03b1\nn : \u211a\n\u22a2 \u2191(bit1 n) = bit1 \u2191n", "state_after": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : DivisionRing \u03b1\ninst\u271d : CharZero \u03b1\nn : \u211a\n\u22a2 bit0 \u2191n + 1 = bit1 \u2191n"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "F : Type u_1\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : DivisionRing \u03b1\ninst\u271d : CharZero \u03b1\nn : \u211a\n\u22a2 bit0 \u2191n + 1 = bit1 \u2191n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Cycle.lean", "full_name": "Cycle.mk_eq_coe", "start": [470, 1], "end": [471, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.get?_modifyNth_ne", "start": [887, 9], "end": [889, 48], "traced_tactics": [{"tactic": "simp only [get?_modifyNth, if_neg h, id_map']", "annotated_tactic": ["simp only [<a>get?_modifyNth</a>, <a>if_neg</a> h, <a>id_map'</a>]", [{"full_name": "List.get?_modifyNth", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [854, 9], "def_end_pos": [854, 23]}, {"full_name": "if_neg", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [795, 9], "def_end_pos": [795, 15]}, {"full_name": "id_map'", "def_path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "def_pos": [25, 17], "def_end_pos": [25, 24]}]], "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\nm n : Nat\nl : List \u03b1\nh : m \u2260 n\n\u22a2 get? (modifyNth f m l) n = get? l n", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Powerset.lean", "full_name": "Finset.powersetCard_empty", "start": [230, 1], "end": [231, 81], "traced_tactics": [{"tactic": "rw [card_powersetCard, Nat.choose_eq_zero_of_lt h]", "annotated_tactic": ["rw [<a>card_powersetCard</a>, <a>Nat.choose_eq_zero_of_lt</a> h]", [{"full_name": "Finset.card_powersetCard", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Powerset.lean", "def_pos": [215, 9], "def_end_pos": [215, 26]}, {"full_name": "Nat.choose_eq_zero_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Choose/Basic.lean", "def_pos": [68, 9], "def_end_pos": [68, 29]}]], "state_before": "\u03b1 : Type u_1\ns\u271d t : Finset \u03b1\nn : \u2115\ns : Finset \u03b1\nh : card s < n\n\u22a2 card (powersetCard n s) = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Pi/Algebra.lean", "full_name": "Pi.mulSingle_comm", "start": [278, 1], "end": [280, 34], "traced_tactics": [{"tactic": "simp [mulSingle_apply, eq_comm]", "annotated_tactic": ["simp [<a>mulSingle_apply</a>, <a>eq_comm</a>]", [{"full_name": "Pi.mulSingle_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Pi/Algebra.lean", "def_pos": [269, 9], "def_end_pos": [269, 24]}, {"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "I : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : I \u2192 Type v\u2081\ng : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx\u271d y : (i : I) \u2192 f i\ni\u271d : I\ninst\u271d\u2074 : DecidableEq I\ninst\u271d\u00b3 : (i : I) \u2192 One (f i)\ninst\u271d\u00b2 : (i : I) \u2192 One (g i)\ninst\u271d\u00b9 : (i : I) \u2192 One (h i)\ninst\u271d : One \u03b2\ni : I\nx : \u03b2\ni' : I\n\u22a2 mulSingle i x i' = mulSingle i' x i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "full_name": "Subgroup.mul_normal", "start": [167, 1], "end": [180, 49], "traced_tactics": [{"tactic": "rw [sup_eq_closure_mul]", "annotated_tactic": ["rw [<a>sup_eq_closure_mul</a>]", [{"full_name": "Subgroup.sup_eq_closure_mul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Pointwise.lean", "def_pos": [148, 9], "def_end_pos": [148, 27]}]], "state_before": "\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\n\u22a2 \u2191(H \u2294 N) = \u2191H * \u2191N", "state_after": "\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\n\u22a2 \u2191(closure (\u2191H * \u2191N)) = \u2191H * \u2191N"}, {"tactic": "refine Set.Subset.antisymm (fun x hx => ?_) subset_closure", "annotated_tactic": ["refine <a>Set.Subset.antisymm</a> (fun x hx => ?_) <a>subset_closure</a>", [{"full_name": "Set.Subset.antisymm", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [371, 9], "def_end_pos": [371, 24]}, {"full_name": "Subgroup.subset_closure", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [1116, 9], "def_end_pos": [1116, 23]}]], "state_before": "\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\n\u22a2 \u2191(closure (\u2191H * \u2191N)) = \u2191H * \u2191N", "state_after": "\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 x \u2208 \u2191H * \u2191N"}, {"tactic": "refine closure_induction'' (p := fun x => x \u2208 (H : Set G) * (N : Set G)) hx ?_ ?_ ?_ ?_", "annotated_tactic": ["refine <a>closure_induction''</a> (p := fun x => x \u2208 (H : <a>Set</a> G) * (N : <a>Set</a> G)) hx ?_ ?_ ?_ ?_", [{"full_name": "Subgroup.closure_induction''", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Pointwise.lean", "def_pos": [100, 9], "def_end_pos": [100, 28]}, {"full_name": "Set", "def_path": "lake-packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [38, 5], "def_end_pos": [38, 8]}, {"full_name": "Set", "def_path": "lake-packages/mathlib/Mathlib/Init/Set.lean", "def_pos": [38, 5], "def_end_pos": [38, 8]}]], "state_before": "\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 x \u2208 \u2191H * \u2191N", "state_after": "case refine_1\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 \u2200 x \u2208 \u2191H * \u2191N, (fun x => x \u2208 \u2191H * \u2191N) x\n\ncase refine_2\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 \u2200 x \u2208 \u2191H * \u2191N, (fun x => x \u2208 \u2191H * \u2191N) x\u207b\u00b9\n\ncase refine_3\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 (fun x => x \u2208 \u2191H * \u2191N) 1\n\ncase refine_4\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 \u2200 (x y : G), (fun x => x \u2208 \u2191H * \u2191N) x \u2192 (fun x => x \u2208 \u2191H * \u2191N) y \u2192 (fun x => x \u2208 \u2191H * \u2191N) (x * y)"}, {"tactic": "rintro _ \u27e8x, y, hx, hy, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8x, y, hx, hy, rfl\u27e9", []], "state_before": "case refine_1\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 \u2200 x \u2208 \u2191H * \u2191N, (fun x => x \u2208 \u2191H * \u2191N) x", "state_after": "case refine_1.intro.intro.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\n\u22a2 (fun x x_1 => x * x_1) x y \u2208 \u2191H * \u2191N"}, {"tactic": "exact mul_mem_mul hx hy", "annotated_tactic": ["exact <a>mul_mem_mul</a> hx hy", [{"full_name": "Set.mul_mem_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [342, 9], "def_end_pos": [342, 20]}]], "state_before": "case refine_1.intro.intro.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\n\u22a2 (fun x x_1 => x * x_1) x y \u2208 \u2191H * \u2191N", "state_after": "no goals"}, {"tactic": "rintro _ \u27e8x, y, hx, hy, rfl\u27e9", "annotated_tactic": ["rintro _ \u27e8x, y, hx, hy, rfl\u27e9", []], "state_before": "case refine_2\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 \u2200 x \u2208 \u2191H * \u2191N, (fun x => x \u2208 \u2191H * \u2191N) x\u207b\u00b9", "state_after": "case refine_2.intro.intro.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\n\u22a2 ((fun x x_1 => x * x_1) x y)\u207b\u00b9 \u2208 \u2191H * \u2191N"}, {"tactic": "simpa only [mul_inv_rev, mul_assoc, inv_inv, inv_mul_cancel_left]\n  using mul_mem_mul (inv_mem hx) (hN.conj_mem _ (inv_mem hy) x)", "annotated_tactic": ["simpa only [<a>mul_inv_rev</a>, <a>mul_assoc</a>, <a>inv_inv</a>, <a>inv_mul_cancel_left</a>]\n      using <a>mul_mem_mul</a> (<a>inv_mem</a> hx) (hN.conj_mem _ (<a>inv_mem</a> hy) x)", [{"full_name": "mul_inv_rev", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1050, 9], "def_end_pos": [1050, 20]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "inv_inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [800, 9], "def_end_pos": [800, 16]}, {"full_name": "inv_mul_cancel_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1147, 9], "def_end_pos": [1147, 28]}, {"full_name": "Set.mul_mem_mul", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Pointwise/Basic.lean", "def_pos": [342, 9], "def_end_pos": [342, 20]}, {"full_name": "InvMemClass.inv_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [101, 3], "def_end_pos": [101, 10]}, {"full_name": "InvMemClass.inv_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subgroup/Basic.lean", "def_pos": [101, 3], "def_end_pos": [101, 10]}]], "state_before": "case refine_2.intro.intro.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\n\u22a2 ((fun x x_1 => x * x_1) x y)\u207b\u00b9 \u2208 \u2191H * \u2191N", "state_after": "no goals"}, {"tactic": "exact \u27e81, 1, one_mem _, one_mem _, mul_one 1\u27e9", "annotated_tactic": ["exact \u27e81, 1, <a>one_mem</a> _, <a>one_mem</a> _, <a>mul_one</a> 1\u27e9", [{"full_name": "OneMemClass.one_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [73, 3], "def_end_pos": [73, 10]}, {"full_name": "OneMemClass.one_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [73, 3], "def_end_pos": [73, 10]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case refine_3\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 (fun x => x \u2208 \u2191H * \u2191N) 1", "state_after": "no goals"}, {"tactic": "rintro _ _ \u27e8x, y, hx, hy, rfl\u27e9 \u27e8x', y', hx', hy', rfl\u27e9", "annotated_tactic": ["rintro _ _ \u27e8x, y, hx, hy, rfl\u27e9 \u27e8x', y', hx', hy', rfl\u27e9", []], "state_before": "case refine_4\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx : G\nhx : x \u2208 \u2191(closure (\u2191H * \u2191N))\n\u22a2 \u2200 (x y : G), (fun x => x \u2208 \u2191H * \u2191N) x \u2192 (fun x => x \u2208 \u2191H * \u2191N) y \u2192 (fun x => x \u2208 \u2191H * \u2191N) (x * y)", "state_after": "case refine_4.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\nx' y' : G\nhx' : x' \u2208 \u2191H\nhy' : y' \u2208 \u2191N\n\u22a2 (fun x x_1 => x * x_1) x y * (fun x x_1 => x * x_1) x' y' \u2208 \u2191H * \u2191N"}, {"tactic": "refine \u27e8x * x', x'\u207b\u00b9 * y * x' * y', mul_mem hx hx', mul_mem ?_ hy', ?_\u27e9", "annotated_tactic": ["refine \u27e8x * x', x'\u207b\u00b9 * y * x' * y', <a>mul_mem</a> hx hx', <a>mul_mem</a> ?_ hy', ?_\u27e9", [{"full_name": "MulMemClass.mul_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Basic.lean", "def_pos": [64, 3], "def_end_pos": [64, 10]}, {"full_name": "MulMemClass.mul_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Subsemigroup/Basic.lean", "def_pos": [64, 3], "def_end_pos": [64, 10]}]], "state_before": "case refine_4.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\nx' y' : G\nhx' : x' \u2208 \u2191H\nhy' : y' \u2208 \u2191N\n\u22a2 (fun x x_1 => x * x_1) x y * (fun x x_1 => x * x_1) x' y' \u2208 \u2191H * \u2191N", "state_after": "case refine_4.intro.intro.intro.intro.intro.intro.intro.intro.refine_1\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\nx' y' : G\nhx' : x' \u2208 \u2191H\nhy' : y' \u2208 \u2191N\n\u22a2 x'\u207b\u00b9 * y * x' \u2208 N\n\ncase refine_4.intro.intro.intro.intro.intro.intro.intro.intro.refine_2\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\nx' y' : G\nhx' : x' \u2208 \u2191H\nhy' : y' \u2208 \u2191N\n\u22a2 (fun x x_1 => x * x_1) (x * x') (x'\u207b\u00b9 * y * x' * y') = (fun x x_1 => x * x_1) x y * (fun x x_1 => x * x_1) x' y'"}, {"tactic": "simpa using hN.conj_mem _ hy x'\u207b\u00b9", "annotated_tactic": ["simpa using hN.conj_mem _ hy x'\u207b\u00b9", []], "state_before": "case refine_4.intro.intro.intro.intro.intro.intro.intro.intro.refine_1\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\nx' y' : G\nhx' : x' \u2208 \u2191H\nhy' : y' \u2208 \u2191N\n\u22a2 x'\u207b\u00b9 * y * x' \u2208 N", "state_after": "no goals"}, {"tactic": "simp only [mul_assoc, mul_inv_cancel_left]", "annotated_tactic": ["simp only [<a>mul_assoc</a>, <a>mul_inv_cancel_left</a>]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "mul_inv_cancel_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [1153, 9], "def_end_pos": [1153, 28]}]], "state_before": "case refine_4.intro.intro.intro.intro.intro.intro.intro.intro.refine_2\n\u03b1 : Type u_1\nG : Type u_2\nA : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : Group G\ninst\u271d : AddGroup A\ns : Set G\nH N : Subgroup G\nhN : Normal N\nx\u271d : G\nhx\u271d : x\u271d \u2208 \u2191(closure (\u2191H * \u2191N))\nx y : G\nhx : x \u2208 \u2191H\nhy : y \u2208 \u2191N\nx' y' : G\nhx' : x' \u2208 \u2191H\nhy' : y' \u2208 \u2191N\n\u22a2 (fun x x_1 => x * x_1) (x * x') (x'\u207b\u00b9 * y * x' * y') = (fun x x_1 => x * x_1) x y * (fun x x_1 => x * x_1) x' y'", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Sort.lean", "full_name": "Fin.sort_univ", "start": [268, 1], "end": [273, 34], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "n : \u2115\n\u22a2 List.toFinset (Finset.sort (fun x y => x \u2264 y) Finset.univ) = List.toFinset (List.finRange n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Bool.lean", "full_name": "Bool.or_and_distrib_right", "start": [86, 1], "end": [87, 9], "traced_tactics": [{"tactic": "decide", "annotated_tactic": ["decide", []], "state_before": "\u22a2 \u2200 (x y z : Bool), (x && y || z) = ((x || z) && (y || z))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Encodable/Basic.lean", "full_name": "Encodable.mem_decode\u2082", "start": [197, 1], "end": [198, 67], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.leftpad_prefix", "start": [1678, 1], "end": [1681, 27], "traced_tactics": [{"tactic": "simp only [IsPrefix, leftpad]", "annotated_tactic": ["simp only [<a>IsPrefix</a>, <a>leftpad</a>]", [{"full_name": "List.IsPrefix", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [810, 5], "def_end_pos": [810, 13]}, {"full_name": "List.leftpad", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [628, 5], "def_end_pos": [628, 12]}]], "state_before": "\u03b1 : Type u_1\nn : Nat\na : \u03b1\nl : List \u03b1\n\u22a2 replicate (n - length l) a <+: leftpad n a l", "state_after": "\u03b1 : Type u_1\nn : Nat\na : \u03b1\nl : List \u03b1\n\u22a2 \u2203 t, replicate (n - length l) a ++ t = replicate (n - length l) a ++ l"}, {"tactic": "exact Exists.intro l rfl", "annotated_tactic": ["exact <a>Exists.intro</a> l <a>rfl</a>", [{"full_name": "Exists.intro", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [199, 5], "def_end_pos": [199, 10]}, {"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "\u03b1 : Type u_1\nn : Nat\na : \u03b1\nl : List \u03b1\n\u22a2 \u2203 t, replicate (n - length l) a ++ t = replicate (n - length l) a ++ l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.comap_sup_eq", "start": [3236, 1], "end": [3239, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Option.lean", "full_name": "Finset.eraseNone_empty", "start": [135, 1], "end": [137, 7], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 \u2191eraseNone \u2205 = \u2205", "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 \u2191eraseNone \u2205 \u2194 a\u271d \u2208 \u2205"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 \u2191eraseNone \u2205 \u2194 a\u271d \u2208 \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Disjoint.lean", "full_name": "codisjoint_inf_left", "start": [375, 1], "end": [376, 60], "traced_tactics": [{"tactic": "simp only [codisjoint_iff, sup_inf_right, inf_eq_top_iff]", "annotated_tactic": ["simp only [<a>codisjoint_iff</a>, <a>sup_inf_right</a>, <a>inf_eq_top_iff</a>]", [{"full_name": "codisjoint_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/Disjoint.lean", "def_pos": [314, 9], "def_end_pos": [314, 23]}, {"full_name": "sup_inf_right", "def_path": "lake-packages/mathlib/Mathlib/Order/Lattice.lean", "def_pos": [769, 9], "def_end_pos": [769, 22]}, {"full_name": "inf_eq_top_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [484, 9], "def_end_pos": [484, 23]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DistribLattice \u03b1\ninst\u271d : OrderTop \u03b1\na b c : \u03b1\n\u22a2 Codisjoint (a \u2293 b) c \u2194 Codisjoint a c \u2227 Codisjoint b c", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "UpperSet.coe_prod", "start": [1793, 1], "end": [1794, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/Basic.lean", "full_name": "isGLB_iff_le_iff", "start": [323, 1], "end": [324, 30], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "full_name": "le_mul_of_one_le_of_le", "start": [937, 1], "end": [943, 40], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Nat/Gcd.lean", "full_name": "Nat.gcd_gcd_self_right_right", "start": [165, 9], "end": [166, 45], "traced_tactics": [{"tactic": "rw [gcd_comm n m, gcd_gcd_self_right_left]", "annotated_tactic": ["rw [<a>gcd_comm</a> n m, <a>gcd_gcd_self_right_left</a>]", [{"full_name": "Nat.gcd_comm", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [59, 9], "def_end_pos": [59, 17]}, {"full_name": "Nat.gcd_gcd_self_right_left", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [162, 17], "def_end_pos": [162, 40]}]], "state_before": "m n : Nat\n\u22a2 gcd m (gcd n m) = gcd n m", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Pi/Algebra.lean", "full_name": "Function.extend_inv", "start": [379, 1], "end": [383, 71], "traced_tactics": [{"tactic": "classical\nfunext x\nsimp only [not_exists, extend_def, Pi.inv_apply, apply_dite Inv.inv]", "annotated_tactic": ["classical\n  funext x\n  simp only [<a>not_exists</a>, <a>extend_def</a>, <a>Pi.inv_apply</a>, <a>apply_dite</a> <a>Inv.inv</a>]", [{"full_name": "not_exists", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [428, 17], "def_end_pos": [428, 27]}, {"full_name": "Function.extend_def", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [731, 9], "def_end_pos": [731, 19]}, {"full_name": "Pi.inv_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Pi/Algebra.lean", "def_pos": [171, 9], "def_end_pos": [171, 18]}, {"full_name": "apply_dite", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [746, 9], "def_end_pos": [746, 19]}, {"full_name": "Inv.inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [109, 3], "def_end_pos": [109, 6]}]], "state_before": "I : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng\u271d : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Inv \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ne : \u03b2 \u2192 \u03b3\n\u22a2 extend f g\u207b\u00b9 e\u207b\u00b9 = (extend f g e)\u207b\u00b9", "state_after": "no goals"}, {"tactic": "funext x", "annotated_tactic": ["funext x", []], "state_before": "I : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng\u271d : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Inv \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ne : \u03b2 \u2192 \u03b3\n\u22a2 extend f g\u207b\u00b9 e\u207b\u00b9 = (extend f g e)\u207b\u00b9", "state_after": "case h\nI : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng\u271d : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx\u271d y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Inv \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ne : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 extend f g\u207b\u00b9 e\u207b\u00b9 x = (extend f g e)\u207b\u00b9 x"}, {"tactic": "simp only [not_exists, extend_def, Pi.inv_apply, apply_dite Inv.inv]", "annotated_tactic": ["simp only [<a>not_exists</a>, <a>extend_def</a>, <a>Pi.inv_apply</a>, <a>apply_dite</a> <a>Inv.inv</a>]", [{"full_name": "not_exists", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [428, 17], "def_end_pos": [428, 27]}, {"full_name": "Function.extend_def", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [731, 9], "def_end_pos": [731, 19]}, {"full_name": "Pi.inv_apply", "def_path": "lake-packages/mathlib/Mathlib/Data/Pi/Algebra.lean", "def_pos": [171, 9], "def_end_pos": [171, 18]}, {"full_name": "apply_dite", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [746, 9], "def_end_pos": [746, 19]}, {"full_name": "Inv.inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [109, 3], "def_end_pos": [109, 6]}]], "state_before": "case h\nI : Type u\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf\u271d : I \u2192 Type v\u2081\ng\u271d : I \u2192 Type v\u2082\nh : I \u2192 Type v\u2083\nx\u271d y : (i : I) \u2192 f\u271d i\ni : I\ninst\u271d : Inv \u03b3\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ne : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 extend f g\u207b\u00b9 e\u207b\u00b9 x = (extend f g e)\u207b\u00b9 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Ring.lean", "full_name": "sq_eq_zero_iff", "start": [92, 1], "end": [93, 26], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "abs_pos_of_pos", "start": [140, 1], "end": [141, 22], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Sigma.lean", "full_name": "Finset.pairwiseDisjoint_map_sigmaMk", "start": [75, 1], "end": [81, 43], "traced_tactics": [{"tactic": "intro i _ j _ hij", "annotated_tactic": ["intro i _ j _ hij", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\n\u22a2 Set.PairwiseDisjoint \u2191s fun i => map (Embedding.sigmaMk i) (t i)", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\n\u22a2 (_root_.Disjoint on fun i => map (Embedding.sigmaMk i) (t i)) i j"}, {"tactic": "rw [Function.onFun, disjoint_left]", "annotated_tactic": ["rw [<a>Function.onFun</a>, <a>disjoint_left</a>]", [{"full_name": "Function.onFun", "def_path": "lake-packages/mathlib/Mathlib/Init/Function.lean", "def_pos": [49, 5], "def_end_pos": [49, 10]}, {"full_name": "Finset.disjoint_left", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [951, 9], "def_end_pos": [951, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\n\u22a2 (_root_.Disjoint on fun i => map (Embedding.sigmaMk i) (t i)) i j", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\n\u22a2 \u2200 \u2983a : (x : \u03b9) \u00d7 \u03b1 x\u2984, a \u2208 map (Embedding.sigmaMk i) (t i) \u2192 a \u2209 map (Embedding.sigmaMk j) (t j)"}, {"tactic": "simp_rw [mem_map, Function.Embedding.sigmaMk_apply]", "annotated_tactic": ["simp_rw [<a>mem_map</a>, <a>Function.Embedding.sigmaMk_apply</a>]", [{"full_name": "Finset.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Image.lean", "def_pos": [68, 9], "def_end_pos": [68, 16]}, {"full_name": "Function.Embedding.sigmaMk_apply", "def_path": "lake-packages/mathlib/Mathlib/Logic/Embedding/Basic.lean", "def_pos": [320, 9], "def_end_pos": [320, 14]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\n\u22a2 \u2200 \u2983a : (x : \u03b9) \u00d7 \u03b1 x\u2984, a \u2208 map (Embedding.sigmaMk i) (t i) \u2192 a \u2209 map (Embedding.sigmaMk j) (t j)", "state_after": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\n\u22a2 \u2200 \u2983a : (x : \u03b9) \u00d7 \u03b1 x\u2984, (\u2203 a_1 \u2208 t i, { fst := i, snd := a_1 } = a) \u2192 \u00ac\u2203 a_2 \u2208 t j, { fst := j, snd := a_2 } = a"}, {"tactic": "rintro _ \u27e8y, _, rfl\u27e9 \u27e8z, _, hz'\u27e9", "annotated_tactic": ["rintro _ \u27e8y, _, rfl\u27e9 \u27e8z, _, hz'\u27e9", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\n\u22a2 \u2200 \u2983a : (x : \u03b9) \u00d7 \u03b1 x\u2984, (\u2203 a_1 \u2208 t i, { fst := i, snd := a_1 } = a) \u2192 \u00ac\u2203 a_2 \u2208 t j, { fst := j, snd := a_2 } = a", "state_after": "case intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\ny : \u03b1 i\nleft\u271d\u00b9 : y \u2208 t i\nz : \u03b1 j\nleft\u271d : z \u2208 t j\nhz' : { fst := j, snd := z } = { fst := i, snd := y }\n\u22a2 False"}, {"tactic": "exact hij (congr_arg Sigma.fst hz'.symm)", "annotated_tactic": ["exact hij (<a>congr_arg</a> <a>Sigma.fst</a> hz'.symm)", [{"full_name": "congr_arg", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [43, 7], "def_end_pos": [43, 16]}, {"full_name": "Sigma.fst", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [142, 3], "def_end_pos": [142, 6]}]], "state_before": "case intro.intro.intro.intro\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\ns s\u2081 s\u2082 : Finset \u03b9\nt t\u2081 t\u2082 : (i : \u03b9) \u2192 Finset (\u03b1 i)\ni : \u03b9\na\u271d\u00b9 : i \u2208 \u2191s\nj : \u03b9\na\u271d : j \u2208 \u2191s\nhij : i \u2260 j\ny : \u03b1 i\nleft\u271d\u00b9 : y \u2208 t i\nz : \u03b1 j\nleft\u271d : z \u2208 t j\nhz' : { fst := j, snd := z } = { fst := i, snd := y }\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/TensorProduct.lean", "full_name": "LinearMap.lTensor_add", "start": [1090, 1], "end": [1091, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Nat/GCD/Basic.lean", "full_name": "Nat.coprime_pow_left_iff", "start": [243, 1], "end": [247, 54], "traced_tactics": [{"tactic": "obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero hn.ne'", "annotated_tactic": ["obtain \u27e8n, rfl\u27e9 := <a>exists_eq_succ_of_ne_zero</a> hn.ne'", [{"full_name": "Nat.exists_eq_succ_of_ne_zero", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [291, 9], "def_end_pos": [291, 34]}]], "state_before": "n : \u2115\nhn : 0 < n\na b : \u2115\n\u22a2 Coprime (a ^ n) b \u2194 Coprime a b", "state_after": "case intro\na b n : \u2115\nhn : 0 < succ n\n\u22a2 Coprime (a ^ succ n) b \u2194 Coprime a b"}, {"tactic": "rw [pow_succ, Nat.coprime_mul_iff_left]", "annotated_tactic": ["rw [<a>pow_succ</a>, <a>Nat.coprime_mul_iff_left</a>]", [{"full_name": "Nat.pow_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [473, 9], "def_end_pos": [473, 17]}, {"full_name": "Nat.coprime_mul_iff_left", "def_path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "def_pos": [348, 9], "def_end_pos": [348, 29]}]], "state_before": "case intro\na b n : \u2115\nhn : 0 < succ n\n\u22a2 Coprime (a ^ succ n) b \u2194 Coprime a b", "state_after": "case intro\na b n : \u2115\nhn : 0 < succ n\n\u22a2 Coprime (a ^ n) b \u2227 Coprime a b \u2194 Coprime a b"}, {"tactic": "exact \u27e8And.right, fun hab => \u27e8hab.pow_left _, hab\u27e9\u27e9", "annotated_tactic": ["exact \u27e8<a>And.right</a>, fun hab => \u27e8hab.pow_left _, hab\u27e9\u27e9", [{"full_name": "And.right", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [507, 3], "def_end_pos": [507, 8]}]], "state_before": "case intro\na b n : \u2115\nhn : 0 < succ n\n\u22a2 Coprime (a ^ n) b \u2227 Coprime a b \u2194 Coprime a b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Option/NAry.lean", "full_name": "Option.map\u2082_some_some", "start": [54, 1], "end": [54, 97], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/UpperLower/Basic.lean", "full_name": "LowerSet.mem_iSup\u2082_iff", "start": [810, 1], "end": [811, 25], "traced_tactics": [{"tactic": "simp_rw [mem_iSup_iff]", "annotated_tactic": ["simp_rw [<a>mem_iSup_iff</a>]", [{"full_name": "LowerSet.mem_iSup_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/UpperLower/Basic.lean", "def_pos": [798, 9], "def_end_pos": [798, 21]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03ba : \u03b9 \u2192 Sort u_5\ninst\u271d : LE \u03b1\nS : Set (LowerSet \u03b1)\ns t : LowerSet \u03b1\na : \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 LowerSet \u03b1\n\u22a2 a \u2208 \u2a06 i, \u2a06 j, f i j \u2194 \u2203 i j, a \u2208 f i j", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Function/Basic.lean", "full_name": "Function.Bijective.of_comp_iff'", "start": [282, 1], "end": [284, 82], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Logic/Equiv/Set.lean", "full_name": "Equiv.prod_assoc_symm_image", "start": [160, 1], "end": [162, 65], "traced_tactics": [{"tactic": "simpa only [Equiv.image_eq_preimage] using prod_assoc_preimage", "annotated_tactic": ["simpa only [<a>Equiv.image_eq_preimage</a>] using <a>prod_assoc_preimage</a>", [{"full_name": "Equiv.image_eq_preimage", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [40, 19], "def_end_pos": [40, 36]}, {"full_name": "Equiv.prod_assoc_preimage", "def_path": "lake-packages/mathlib/Mathlib/Logic/Equiv/Set.lean", "def_pos": [140, 9], "def_end_pos": [140, 28]}]], "state_before": "\u03b1\u271d : Sort u\n\u03b2\u271d : Sort v\n\u03b3\u271d : Sort w\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\n\u22a2 \u2191(prodAssoc \u03b1 \u03b2 \u03b3).symm '' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Cofinite.lean", "full_name": "Function.Surjective.le_map_cofinite", "start": [201, 1], "end": [202, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Monotone/Basic.lean", "full_name": "Nat.rel_of_forall_rel_succ_of_le_of_lt", "start": [1002, 1], "end": [1006, 70], "traced_tactics": [{"tactic": "induction' hbc with k b_lt_k r_b_k", "annotated_tactic": ["induction' hbc with k b_lt_k r_b_k", []], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Preorder \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsTrans \u03b2 r\nf : \u2115 \u2192 \u03b2\na : \u2115\nh : \u2200 (n : \u2115), a \u2264 n \u2192 r (f n) (f (n + 1))\nb c : \u2115\nhab : a \u2264 b\nhbc : b < c\n\u22a2 r (f b) (f c)", "state_after": "case refl\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Preorder \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsTrans \u03b2 r\nf : \u2115 \u2192 \u03b2\na : \u2115\nh : \u2200 (n : \u2115), a \u2264 n \u2192 r (f n) (f (n + 1))\nb c : \u2115\nhab : a \u2264 b\n\u22a2 r (f b) (f (succ b))\n\ncase step\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Preorder \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsTrans \u03b2 r\nf : \u2115 \u2192 \u03b2\na : \u2115\nh : \u2200 (n : \u2115), a \u2264 n \u2192 r (f n) (f (n + 1))\nb c : \u2115\nhab : a \u2264 b\nk : \u2115\nb_lt_k : Nat.le (succ b) k\nr_b_k : r (f b) (f k)\n\u22a2 r (f b) (f (succ k))"}, {"tactic": "exacts [h _ hab, _root_.trans r_b_k (h _ (hab.trans_lt b_lt_k).le)]", "annotated_tactic": ["exacts [h _ hab, <a>_root_.trans</a> r_b_k (h _ (hab.trans_lt b_lt_k).<a>le</a>)]", [{"full_name": "trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Algebra/Classes.lean", "def_pos": [308, 9], "def_end_pos": [308, 14]}, {"full_name": "LT.lt.le", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [142, 7], "def_end_pos": [142, 15]}]], "state_before": "case refl\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Preorder \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsTrans \u03b2 r\nf : \u2115 \u2192 \u03b2\na : \u2115\nh : \u2200 (n : \u2115), a \u2264 n \u2192 r (f n) (f (n + 1))\nb c : \u2115\nhab : a \u2264 b\n\u22a2 r (f b) (f (succ b))\n\ncase step\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_2\n\u03c0 : \u03b9 \u2192 Type u_3\nr\u271d : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b9 : Preorder \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\ninst\u271d : IsTrans \u03b2 r\nf : \u2115 \u2192 \u03b2\na : \u2115\nh : \u2200 (n : \u2115), a \u2264 n \u2192 r (f n) (f (n + 1))\nb c : \u2115\nhab : a \u2264 b\nk : \u2115\nb_lt_k : Nat.le (succ b) k\nr_b_k : r (f b) (f k)\n\u22a2 r (f b) (f (succ k))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/BigOperators/Basic.lean", "full_name": "List.exists_mem_ne_one_of_prod_ne_one", "start": [540, 1], "end": [541, 91], "traced_tactics": [{"tactic": "simpa only [not_forall, exists_prop] using mt prod_eq_one h", "annotated_tactic": ["simpa only [<a>not_forall</a>, <a>exists_prop</a>] using <a>mt</a> <a>prod_eq_one</a> h", [{"full_name": "Classical.not_forall", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [692, 9], "def_end_pos": [692, 19]}, {"full_name": "exists_prop", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [491, 17], "def_end_pos": [491, 28]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}, {"full_name": "List.prod_eq_one", "def_path": "lake-packages/mathlib/Mathlib/Data/List/BigOperators/Basic.lean", "def_pos": [531, 9], "def_end_pos": [531, 20]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\nN : Type u_4\nP : Type u_5\nM\u2080 : Type u_6\nG : Type u_7\nR : Type u_8\ninst\u271d : Monoid M\nl : List M\nh : prod l \u2260 1\n\u22a2 \u2203 x, x \u2208 l \u2227 x \u2260 1", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Forall2.lean", "full_name": "List.forall\u2082_nil_left_iff", "start": [78, 1], "end": [79, 63], "traced_tactics": [{"tactic": "cases H", "annotated_tactic": ["cases H", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b2\nH : Forall\u2082 R [] l\n\u22a2 l = []", "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 [] = []"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 [] = []", "state_after": "no goals"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b2\n\u22a2 l = [] \u2192 Forall\u2082 R [] l", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 Forall\u2082 R [] []"}, {"tactic": "exact Forall\u2082.nil", "annotated_tactic": ["exact <a>Forall\u2082.nil</a>", [{"full_name": "List.Forall\u2082.nil", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [917, 5], "def_end_pos": [917, 8]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nR S : \u03b1 \u2192 \u03b2 \u2192 Prop\nP : \u03b3 \u2192 \u03b4 \u2192 Prop\nR\u2090 : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 Forall\u2082 R [] []", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Int/Basic.lean", "full_name": "Int.normalize_coe_nat", "start": [111, 1], "end": [112, 62], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Derivative.lean", "full_name": "Polynomial.derivative_neg", "start": [576, 1], "end": [577, 33], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Subring/Basic.lean", "full_name": "Subring.mem_map_equiv", "start": [1185, 1], "end": [1187, 51], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.size_pos'", "start": [24, 1], "end": [24, 68], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "full_name": "MultilinearMap.neg_apply", "start": [1094, 1], "end": [1095, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "full_name": "AlternatingMap.coe_neg", "start": [380, 1], "end": [381, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "full_name": "le_csSup_iff'", "start": [1215, 1], "end": [1217, 80], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Order.lean", "full_name": "Fintype.prod_mono'", "start": [708, 1], "end": [709, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Control/Traversable/Instances.lean", "full_name": "List.id_traverse", "start": [77, 11], "end": [78, 63], "traced_tactics": [{"tactic": "induction xs <;> simp! [*, List.traverse, functor_norm]", "annotated_tactic": ["induction xs <;> simp! [*, <a>List.traverse</a>, functor_norm]", [{"full_name": "List.traverse", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Defs.lean", "def_pos": [452, 15], "def_end_pos": [452, 23]}]], "state_before": "F G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 : Type u_1\nxs : List \u03b1\n\u22a2 List.traverse pure xs = xs", "state_after": "case cons\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 : Type u_1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : List.traverse pure tail\u271d = tail\u271d\n\u22a2 (Seq.seq (cons head\u271d) fun x => tail\u271d) = head\u271d :: tail\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case cons\nF G : Type u \u2192 Type u\ninst\u271d\u00b3 : Applicative F\ninst\u271d\u00b2 : Applicative G\ninst\u271d\u00b9 : LawfulApplicative F\ninst\u271d : LawfulApplicative G\n\u03b1 : Type u_1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : List.traverse pure tail\u271d = tail\u271d\n\u22a2 (Seq.seq (cons head\u271d) fun x => tail\u271d) = head\u271d :: tail\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "full_name": "Subalgebra.mem_of_finset_sum_eq_one_of_pow_smul_mem", "start": [1429, 1], "end": [1457, 25], "traced_tactics": [{"tactic": "let _i : Algebra { x // x \u2208 S' } { x // x \u2208 S' } := Algebra.id _", "annotated_tactic": ["let _i : <a>Algebra</a> { x // x \u2208 S' } { x // x \u2208 S' } := <a>Algebra.id</a> _", [{"full_name": "Algebra", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [116, 7], "def_end_pos": [116, 14]}, {"full_name": "Algebra.id", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Basic.lean", "def_pos": [439, 10], "def_end_pos": [439, 12]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 x \u2208 S'\n\u22a2 x \u2208 S'", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 x \u2208 S'\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\n\u22a2 x \u2208 S'"}, {"tactic": "suffices x \u2208 Subalgebra.toSubmodule (Algebra.ofId S' S).range by\n  obtain \u27e8x, rfl\u27e9 := this\n  exact x.2", "annotated_tactic": ["suffices x \u2208 <a>Subalgebra.toSubmodule</a> (<a>Algebra.ofId</a> S' S).<a>range</a> by\n    obtain \u27e8x, rfl\u27e9 := this\n    exact x.2", [{"full_name": "Subalgebra.toSubmodule", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "def_pos": [334, 5], "def_end_pos": [334, 16]}, {"full_name": "Algebra.ofId", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [554, 5], "def_end_pos": [554, 9]}, {"full_name": "AlgHom.range", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "def_pos": [613, 15], "def_end_pos": [613, 20]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 x \u2208 S'\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\n\u22a2 x \u2208 S'", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 x \u2208 S'\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "choose n hn using H", "annotated_tactic": ["choose n hn using H", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 x \u2208 S'\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "let s' : \u03b9 \u2192 S' := fun x => \u27e8s x, hs x\u27e9", "annotated_tactic": ["let s' : \u03b9 \u2192 S' := fun x => \u27e8s x, hs x\u27e9", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "let l' : \u03b9 \u2192 S' := fun x => \u27e8l x, hl x\u27e9", "annotated_tactic": ["let l' : \u03b9 \u2192 S' := fun x => \u27e8l x, hl x\u27e9", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "have e' : \u2211 i in \u03b9', l' i * s' i = 1 := by\n  ext\n  show S'.subtype (\u2211 i in \u03b9', l' i * s' i) = 1\n  simpa only [map_sum, map_mul] using e", "annotated_tactic": ["have e' : \u2211 i in \u03b9', l' i * s' i = 1 := by\n    ext\n    show S'.subtype (\u2211 i in \u03b9', l' i * s' i) = 1\n    simpa only [<a>map_sum</a>, <a>map_mul</a>] using e", [{"full_name": "map_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [204, 3], "def_end_pos": [204, 14]}, {"full_name": "map_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [299, 9], "def_end_pos": [299, 16]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "have : Ideal.span (s' '' \u03b9') = \u22a4 := by\n  rw [Ideal.eq_top_iff_one, \u2190 e']\n  apply sum_mem\n  intros i hi\n  exact Ideal.mul_mem_left _ _ <| Ideal.subset_span <| Set.mem_image_of_mem s' hi", "annotated_tactic": ["have : <a>Ideal.span</a> (s' '' \u03b9') = \u22a4 := by\n    rw [<a>Ideal.eq_top_iff_one</a>, \u2190 e']\n    apply <a>sum_mem</a>\n    intros i hi\n    exact <a>Ideal.mul_mem_left</a> _ _ <| <a>Ideal.subset_span</a> <| <a>Set.mem_image_of_mem</a> s' hi", [{"full_name": "Ideal.span", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [109, 5], "def_end_pos": [109, 9]}, {"full_name": "Ideal.eq_top_iff_one", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [92, 9], "def_end_pos": [92, 23]}, {"full_name": "sum_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [94, 3], "def_end_pos": [94, 14]}, {"full_name": "Ideal.mul_mem_left", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [63, 9], "def_end_pos": [63, 21]}, {"full_name": "Ideal.subset_span", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "Set.mem_image_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [240, 9], "def_end_pos": [240, 25]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "let N := \u03b9'.sup n", "annotated_tactic": ["let N := \u03b9'.sup n", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "have hN := Ideal.span_pow_eq_top _ this N", "annotated_tactic": ["have hN := <a>Ideal.span_pow_eq_top</a> _ this N", [{"full_name": "Ideal.span_pow_eq_top", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [621, 9], "def_end_pos": [621, 24]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "apply (Algebra.ofId S' S).range.toSubmodule.mem_of_span_top_of_smul_mem _ hN", "annotated_tactic": ["apply (<a>Algebra.ofId</a> S' S).range.toSubmodule.mem_of_span_top_of_smul_mem _ hN", [{"full_name": "Algebra.ofId", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Algebra/Hom.lean", "def_pos": [554, 5], "def_end_pos": [554, 9]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\n\u22a2 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "case H\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\n\u22a2 \u2200 (r : \u2191((fun x => x ^ N) '' (s' '' \u2191\u03b9'))), \u2191r \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "rintro \u27e8_, _, \u27e8i, hi, rfl\u27e9, rfl\u27e9", "annotated_tactic": ["rintro \u27e8_, _, \u27e8i, hi, rfl\u27e9, rfl\u27e9", []], "state_before": "case H\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\n\u22a2 \u2200 (r : \u2191((fun x => x ^ N) '' (s' '' \u2191\u03b9'))), \u2191r \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 \u2191{ val := (fun x => x ^ N) (s' i), property := (_ : \u2203 a \u2208 s' '' \u2191\u03b9', (fun x => x ^ N) a = (fun x => x ^ N) (s' i)) } \u2022\n      x \u2208\n    \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "change s' i ^ N \u2022 x \u2208 _", "annotated_tactic": ["change s' i ^ N \u2022 x \u2208 _", []], "state_before": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 \u2191{ val := (fun x => x ^ N) (s' i), property := (_ : \u2203 a \u2208 s' '' \u2191\u03b9', (fun x => x ^ N) a = (fun x => x ^ N) (s' i)) } \u2022\n      x \u2208\n    \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 s' i ^ N \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "rw [\u2190 tsub_add_cancel_of_le (show n i \u2264 N from Finset.le_sup hi), pow_add, mul_smul]", "annotated_tactic": ["rw [\u2190 <a>tsub_add_cancel_of_le</a> (show n i \u2264 N from <a>Finset.le_sup</a> hi), <a>pow_add</a>, <a>mul_smul</a>]", [{"full_name": "tsub_add_cancel_of_le", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [30, 9], "def_end_pos": [30, 30]}, {"full_name": "Finset.le_sup", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Lattice.lean", "def_pos": [114, 9], "def_end_pos": [114, 15]}, {"full_name": "pow_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 16]}, {"full_name": "MulAction.mul_smul", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [112, 3], "def_end_pos": [112, 11]}]], "state_before": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 s' i ^ N \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 s' i ^ (N - n i) \u2022 s' i ^ n i \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "refine' Submodule.smul_mem _ (\u27e8_, pow_mem (hs i) _\u27e9 : S') _", "annotated_tactic": ["refine' <a>Submodule.smul_mem</a> _ (\u27e8_, <a>pow_mem</a> (hs i) _\u27e9 : S') _", [{"full_name": "Submodule.smul_mem", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Basic.lean", "def_pos": [243, 9], "def_end_pos": [243, 17]}, {"full_name": "pow_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Basic.lean", "def_pos": [135, 9], "def_end_pos": [135, 16]}]], "state_before": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 s' i ^ (N - n i) \u2022 s' i ^ n i \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 s' i ^ n i \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))"}, {"tactic": "exact \u27e8\u27e8_, hn i\u27e9, rfl\u27e9", "annotated_tactic": ["exact \u27e8\u27e8_, hn i\u27e9, <a>rfl</a>\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case H.mk.intro.intro.intro.intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\nthis : Ideal.span (s' '' \u2191\u03b9') = \u22a4\nN : \u2115 := Finset.sup \u03b9' n\nhN : Ideal.span ((fun x => x ^ N) '' (s' '' \u2191\u03b9')) = \u22a4\ni : \u03b9\nhi : i \u2208 \u2191\u03b9'\n\u22a2 s' i ^ n i \u2022 x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))", "state_after": "no goals"}, {"tactic": "obtain \u27e8x, rfl\u27e9 := this", "annotated_tactic": ["obtain \u27e8x, rfl\u27e9 := this", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 x \u2208 S'\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nthis : x \u2208 \u2191toSubmodule (AlgHom.range (ofId (\u21a5S') S))\n\u22a2 x \u2208 S'", "state_after": "case intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nx : \u21a5S'\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 \u2191\u2191(ofId (\u21a5S') S) x \u2208 S'\n\u22a2 \u2191\u2191(ofId (\u21a5S') S) x \u2208 S'"}, {"tactic": "exact x.2", "annotated_tactic": ["exact x.2", []], "state_before": "case intro\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nx : \u21a5S'\nH : \u2200 (i : \u03b9), \u2203 n, s i ^ n \u2022 \u2191\u2191(ofId (\u21a5S') S) x \u2208 S'\n\u22a2 \u2191\u2191(ofId (\u21a5S') S) x \u2208 S'", "state_after": "no goals"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\n\u22a2 \u2211 i in \u03b9', l' i * s' i = 1", "state_after": "case a\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\n\u22a2 \u2191(\u2211 i in \u03b9', l' i * s' i) = \u21911"}, {"tactic": "show S'.subtype (\u2211 i in \u03b9', l' i * s' i) = 1", "annotated_tactic": ["show S'.subtype (\u2211 i in \u03b9', l' i * s' i) = 1", []], "state_before": "case a\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\n\u22a2 \u2191(\u2211 i in \u03b9', l' i * s' i) = \u21911", "state_after": "case a\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\n\u22a2 \u2191(Subsemiring.subtype S'.toSubsemiring) (\u2211 i in \u03b9', l' i * s' i) = 1"}, {"tactic": "simpa only [map_sum, map_mul] using e", "annotated_tactic": ["simpa only [<a>map_sum</a>, <a>map_mul</a>] using e", [{"full_name": "map_sum", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [204, 3], "def_end_pos": [204, 14]}, {"full_name": "map_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Hom/Defs.lean", "def_pos": [299, 9], "def_end_pos": [299, 16]}]], "state_before": "case a\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\n\u22a2 \u2191(Subsemiring.subtype S'.toSubsemiring) (\u2211 i in \u03b9', l' i * s' i) = 1", "state_after": "no goals"}, {"tactic": "rw [Ideal.eq_top_iff_one, \u2190 e']", "annotated_tactic": ["rw [<a>Ideal.eq_top_iff_one</a>, \u2190 e']", [{"full_name": "Ideal.eq_top_iff_one", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [92, 9], "def_end_pos": [92, 23]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\n\u22a2 Ideal.span (s' '' \u2191\u03b9') = \u22a4", "state_after": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\n\u22a2 \u2211 i in \u03b9', l' i * s' i \u2208 Ideal.span (s' '' \u2191\u03b9')"}, {"tactic": "apply sum_mem", "annotated_tactic": ["apply <a>sum_mem</a>", [{"full_name": "sum_mem", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Submonoid/Membership.lean", "def_pos": [94, 3], "def_end_pos": [94, 14]}]], "state_before": "R : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\n\u22a2 \u2211 i in \u03b9', l' i * s' i \u2208 Ideal.span (s' '' \u2191\u03b9')", "state_after": "case h\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\n\u22a2 \u2200 c \u2208 \u03b9', l' c * s' c \u2208 Ideal.span (s' '' \u2191\u03b9')"}, {"tactic": "intros i hi", "annotated_tactic": ["intros i hi", []], "state_before": "case h\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\n\u22a2 \u2200 c \u2208 \u03b9', l' c * s' c \u2208 Ideal.span (s' '' \u2191\u03b9')", "state_after": "case h\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\ni : \u03b9\nhi : i \u2208 \u03b9'\n\u22a2 l' i * s' i \u2208 Ideal.span (s' '' \u2191\u03b9')"}, {"tactic": "exact Ideal.mul_mem_left _ _ <| Ideal.subset_span <| Set.mem_image_of_mem s' hi", "annotated_tactic": ["exact <a>Ideal.mul_mem_left</a> _ _ <| <a>Ideal.subset_span</a> <| <a>Set.mem_image_of_mem</a> s' hi", [{"full_name": "Ideal.mul_mem_left", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [63, 9], "def_end_pos": [63, 21]}, {"full_name": "Ideal.subset_span", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [140, 9], "def_end_pos": [140, 20]}, {"full_name": "Set.mem_image_of_mem", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [240, 9], "def_end_pos": [240, 25]}]], "state_before": "case h\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Semiring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Semiring B\ninst\u271d\u00b2 : Algebra R B\nS\u271d : Subalgebra R A\nS : Type u_1\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nS' : Subalgebra R S\n\u03b9 : Type u_2\n\u03b9' : Finset \u03b9\ns l : \u03b9 \u2192 S\ne : \u2211 i in \u03b9', l i * s i = 1\nhs : \u2200 (i : \u03b9), s i \u2208 S'\nhl : \u2200 (i : \u03b9), l i \u2208 S'\nx : S\n_i : Algebra (\u21a5S') (\u21a5S') := Algebra.id (\u21a5S')\nn : \u03b9 \u2192 \u2115\nhn : \u2200 (i : \u03b9), s i ^ n i \u2022 x \u2208 S'\ns' : \u03b9 \u2192 \u21a5S' := fun x => { val := s x, property := (_ : s x \u2208 S') }\nl' : \u03b9 \u2192 \u21a5S' := fun x => { val := l x, property := (_ : l x \u2208 S') }\ne' : \u2211 i in \u03b9', l' i * s' i = 1\ni : \u03b9\nhi : i \u2208 \u03b9'\n\u22a2 l' i * s' i \u2208 Ideal.span (s' '' \u2191\u03b9')", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.not_mem_empty", "start": [549, 1], "end": [551, 62], "traced_tactics": [{"tactic": "simp only [mem_def, empty_val, not_mem_zero, not_false_iff]", "annotated_tactic": ["simp only [<a>mem_def</a>, <a>empty_val</a>, <a>not_mem_zero</a>, <a>not_false_iff</a>]", [{"full_name": "Finset.mem_def", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [179, 9], "def_end_pos": [179, 16]}, {"full_name": "Finset.empty_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [544, 9], "def_end_pos": [544, 18]}, {"full_name": "Multiset.not_mem_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [260, 9], "def_end_pos": [260, 21]}, {"full_name": "not_false_iff", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [82, 9], "def_end_pos": [82, 22]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Finset \u03b1\na : \u03b1\n\u22a2 a \u2209 \u2205", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Sum/Basic.lean", "full_name": "Sum.update_inr_apply_inl", "start": [153, 1], "end": [155, 39], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Basic.lean", "full_name": "AlgEquiv.mapMatrix_symm", "start": [1653, 1], "end": [1655, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "LinearEquiv.prodProdProdComm_symm", "start": [779, 1], "end": [781, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/Fin/Lemmas.lean", "full_name": "Fin.coeSucc_eq_succ", "start": [396, 1], "end": [399, 73], "traced_tactics": [{"tactic": "cases n", "annotated_tactic": ["cases n", []], "state_before": "n : Nat\na : Fin n\n\u22a2 castSucc a + 1 = succ a", "state_after": "case zero\na : Fin Nat.zero\n\u22a2 castSucc a + 1 = succ a\n\ncase succ\nn\u271d : Nat\na : Fin (Nat.succ n\u271d)\n\u22a2 castSucc a + 1 = succ a"}, {"tactic": "exact a.elim0", "annotated_tactic": ["exact a.elim0", []], "state_before": "case zero\na : Fin Nat.zero\n\u22a2 castSucc a + 1 = succ a", "state_after": "no goals"}, {"tactic": "simp [ext_iff, add_def, Nat.mod_eq_of_lt (Nat.succ_lt_succ a.is_lt)]", "annotated_tactic": ["simp [<a>ext_iff</a>, <a>add_def</a>, <a>Nat.mod_eq_of_lt</a> (<a>Nat.succ_lt_succ</a> a.is_lt)]", [{"full_name": "Fin.ext_iff", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [39, 9], "def_end_pos": [39, 16]}, {"full_name": "Fin.add_def", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [177, 9], "def_end_pos": [177, 16]}, {"full_name": "Nat.mod_eq_of_lt", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "def_pos": [111, 9], "def_end_pos": [111, 21]}, {"full_name": "Nat.succ_lt_succ", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [209, 9], "def_end_pos": [209, 21]}]], "state_before": "case succ\nn\u271d : Nat\na : Fin (Nat.succ n\u271d)\n\u22a2 castSucc a + 1 = succ a", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Associated.lean", "full_name": "Associated.symm", "start": [398, 11], "end": [399, 71], "traced_tactics": [{"tactic": "rw [mul_assoc, Units.mul_inv, mul_one]", "annotated_tactic": ["rw [<a>mul_assoc</a>, <a>Units.mul_inv</a>, <a>mul_one</a>]", [{"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}, {"full_name": "Units.mul_inv", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Units.lean", "def_pos": [268, 9], "def_end_pos": [268, 16]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : Monoid \u03b1\nx : \u03b1\nu : \u03b1\u02e3\n\u22a2 x * \u2191u * \u2191u\u207b\u00b9 = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finsupp/Basic.lean", "full_name": "Finsupp.subtypeDomain_eq_zero_iff", "start": [1044, 1], "end": [1050, 32], "traced_tactics": [{"tactic": "classical exact if hx : p x then H x hx else not_mem_support_iff.1 <| mt (hf x) hx", "annotated_tactic": ["classical exact if hx : p x then H x hx else <a>not_mem_support_iff</a>.1 <| <a>mt</a> (hf x) hx", [{"full_name": "Finsupp.not_mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [195, 9], "def_end_pos": [195, 28]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH\u271d : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\np : \u03b1 \u2192 Prop\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 x \u2208 f.support, p x\nH : \u2200 (x : \u03b1), p x \u2192 \u2191f x = 0\nx : \u03b1\n\u22a2 \u2191f x = \u21910 x", "state_after": "no goals"}, {"tactic": "exact if hx : p x then H x hx else not_mem_support_iff.1 <| mt (hf x) hx", "annotated_tactic": ["exact if hx : p x then H x hx else <a>not_mem_support_iff</a>.1 <| <a>mt</a> (hf x) hx", [{"full_name": "Finsupp.not_mem_support_iff", "def_path": "lake-packages/mathlib/Mathlib/Data/Finsupp/Defs.lean", "def_pos": [195, 9], "def_end_pos": [195, 28]}, {"full_name": "mt", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [516, 9], "def_end_pos": [516, 11]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH\u271d : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\np : \u03b1 \u2192 Prop\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 x \u2208 f.support, p x\nH : \u2200 (x : \u03b1), p x \u2192 \u2191f x = 0\nx : \u03b1\n\u22a2 \u2191f x = \u21910 x", "state_after": "no goals"}, {"tactic": "simp [H]", "annotated_tactic": ["simp [H]", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\nM : Type u_5\nM' : Type u_6\nN : Type u_7\nP : Type u_8\nG : Type u_9\nH\u271d : Type u_10\nR : Type u_11\nS : Type u_12\ninst\u271d : Zero M\np : \u03b1 \u2192 Prop\nf : \u03b1 \u2192\u2080 M\nhf : \u2200 x \u2208 f.support, p x\nH : f = 0\nx : \u03b1\nx\u271d : p x\n\u22a2 \u2191f x = 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/Basic.lean", "full_name": "Filter.eq_biInf_of_mem_iff_exists_mem", "start": [805, 1], "end": [808, 98], "traced_tactics": [{"tactic": "rw [iInf_subtype']", "annotated_tactic": ["rw [<a>iInf_subtype'</a>]", [{"full_name": "iInf_subtype'", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [1279, 9], "def_end_pos": [1279, 22]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\np : \u03b9 \u2192 Prop\nl : Filter \u03b1\nh : \u2200 {s : Set \u03b1}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i\n\u22a2 l = \u2a05 i, \u2a05 (_ : p i), f i", "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\np : \u03b9 \u2192 Prop\nl : Filter \u03b1\nh : \u2200 {s : Set \u03b1}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i\n\u22a2 l = \u2a05 x, f \u2191x"}, {"tactic": "exact eq_iInf_of_mem_iff_exists_mem <| fun {_} => by simp only [Subtype.exists, h, exists_prop]", "annotated_tactic": ["exact <a>eq_iInf_of_mem_iff_exists_mem</a> <| fun {_} => by simp only [<a>Subtype.exists</a>, h, <a>exists_prop</a>]", [{"full_name": "Filter.eq_iInf_of_mem_iff_exists_mem", "def_path": "lake-packages/mathlib/Mathlib/Order/Filter/Basic.lean", "def_pos": [799, 9], "def_end_pos": [799, 38]}, {"full_name": "Subtype.exists", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "exists_prop", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [491, 17], "def_end_pos": [491, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\np : \u03b9 \u2192 Prop\nl : Filter \u03b1\nh : \u2200 {s : Set \u03b1}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i\n\u22a2 l = \u2a05 x, f \u2191x", "state_after": "no goals"}, {"tactic": "simp only [Subtype.exists, h, exists_prop]", "annotated_tactic": ["simp only [<a>Subtype.exists</a>, h, <a>exists_prop</a>]", [{"full_name": "Subtype.exists", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "exists_prop", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [491, 17], "def_end_pos": [491, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type u_1\n\u03b9 : Sort x\nf\u271d g : Filter \u03b1\ns t : Set \u03b1\nf : \u03b9 \u2192 Filter \u03b1\np : \u03b9 \u2192 Prop\nl : Filter \u03b1\nh : \u2200 {s : Set \u03b1}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i\nx\u271d : Set \u03b1\n\u22a2 x\u271d \u2208 l \u2194 \u2203 i, x\u271d \u2208 f \u2191i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Order.lean", "full_name": "pow_le_pow_of_le_left", "start": [101, 1], "end": [110, 26], "traced_tactics": [{"tactic": "intro i", "annotated_tactic": ["intro i", []], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\n\u22a2 \u2200 (i : \u2115), a ^ i \u2264 b ^ i", "state_after": "M : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\ni : \u2115\n\u22a2 a ^ i \u2264 b ^ i"}, {"tactic": "induction i with\n| zero => simp\n| succ k ih =>\n  rw [pow_succ, pow_succ]\n  apply mul_le_mul hab\n  apply ih\n  apply pow_nonneg ha\n  apply le_trans ha hab", "annotated_tactic": ["induction i with\n  | <a>zero</a> => simp\n  | <a>succ</a> k ih =>\n    rw [<a>pow_succ</a>, <a>pow_succ</a>]\n    apply <a>mul_le_mul</a> hab\n    apply ih\n    apply <a>pow_nonneg</a> ha\n    apply <a>le_trans</a> ha hab", [{"full_name": "Nat.zero", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1041, 5], "def_end_pos": [1041, 9]}, {"full_name": "Nat.succ", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [1044, 5], "def_end_pos": [1044, 9]}, {"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}, {"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}, {"full_name": "mul_le_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [414, 9], "def_end_pos": [414, 19]}, {"full_name": "pow_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [244, 9], "def_end_pos": [244, 19]}, {"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}]], "state_before": "M : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\ni : \u2115\n\u22a2 a ^ i \u2264 b ^ i", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case zero\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\n\u22a2 a ^ Nat.zero \u2264 b ^ Nat.zero", "state_after": "no goals"}, {"tactic": "rw [pow_succ, pow_succ]", "annotated_tactic": ["rw [<a>pow_succ</a>, <a>pow_succ</a>]", [{"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}, {"full_name": "pow_succ", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [645, 9], "def_end_pos": [645, 17]}]], "state_before": "case succ\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 a ^ Nat.succ k \u2264 b ^ Nat.succ k", "state_after": "case succ\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 a * a ^ k \u2264 b * b ^ k"}, {"tactic": "apply mul_le_mul hab", "annotated_tactic": ["apply <a>mul_le_mul</a> hab", [{"full_name": "mul_le_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [414, 9], "def_end_pos": [414, 19]}]], "state_before": "case succ\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 a * a ^ k \u2264 b * b ^ k", "state_after": "case succ.h\u2082\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 a ^ k \u2264 b ^ k\n\ncase succ.c0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 a ^ k\n\ncase succ.b0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 b"}, {"tactic": "apply ih", "annotated_tactic": ["apply ih", []], "state_before": "case succ.h\u2082\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 a ^ k \u2264 b ^ k\n\ncase succ.c0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 a ^ k\n\ncase succ.b0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 b", "state_after": "case succ.c0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 a ^ k\n\ncase succ.b0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 b"}, {"tactic": "apply pow_nonneg ha", "annotated_tactic": ["apply <a>pow_nonneg</a> ha", [{"full_name": "pow_nonneg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Defs.lean", "def_pos": [244, 9], "def_end_pos": [244, 19]}]], "state_before": "case succ.c0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 a ^ k\n\ncase succ.b0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 b", "state_after": "case succ.b0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 b"}, {"tactic": "apply le_trans ha hab", "annotated_tactic": ["apply <a>le_trans</a> ha hab", [{"full_name": "le_trans", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [56, 9], "def_end_pos": [56, 17]}]], "state_before": "case succ.b0\nM : Type u_1\nR : Type u_2\ninst\u271d : OrderedSemiring R\na\u271d x y : R\nn m : \u2115\na b : R\nha : 0 \u2264 a\nhab : a \u2264 b\nk : \u2115\nih : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Div.lean", "full_name": "Polynomial.dvd_iff_isRoot", "start": [472, 1], "end": [476, 73], "traced_tactics": [{"tactic": "rwa [\u2190 dvd_iff_modByMonic_eq_zero (monic_X_sub_C _), modByMonic_X_sub_C_eq_C_eval, \u2190 C_0,\n  C_inj] at h", "annotated_tactic": ["rwa [\u2190 <a>dvd_iff_modByMonic_eq_zero</a> (<a>monic_X_sub_C</a> _), <a>modByMonic_X_sub_C_eq_C_eval</a>, \u2190 <a>C_0</a>,\n      <a>C_inj</a>] at h", [{"full_name": "Polynomial.dvd_iff_modByMonic_eq_zero", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [409, 9], "def_end_pos": [409, 35]}, {"full_name": "Polynomial.monic_X_sub_C", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Monic.lean", "def_pos": [373, 9], "def_end_pos": [373, 22]}, {"full_name": "Polynomial.modByMonic_X_sub_C_eq_C_eval", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [446, 9], "def_end_pos": [446, 37]}, {"full_name": "Polynomial.C_0", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [515, 9], "def_end_pos": [515, 12]}, {"full_name": "Polynomial.C_inj", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Basic.lean", "def_pos": [798, 9], "def_end_pos": [798, 14]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nh : X - \u2191C a \u2223 p\n\u22a2 IsRoot p a", "state_after": "no goals"}, {"tactic": "rw [mul_divByMonic_eq_iff_isRoot.2 h]", "annotated_tactic": ["rw [<a>mul_divByMonic_eq_iff_isRoot</a>.2 h]", [{"full_name": "Polynomial.mul_divByMonic_eq_iff_isRoot", "def_path": "lake-packages/mathlib/Mathlib/Data/Polynomial/Div.lean", "def_pos": [463, 9], "def_end_pos": [463, 37]}]], "state_before": "R : Type u\nS : Type v\nT : Type w\nA : Type z\na b : R\nn : \u2115\ninst\u271d : CommRing R\np q : R[X]\nh : IsRoot p a\n\u22a2 p = (X - \u2191C a) * (p /\u2098 (X - \u2191C a))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.scanr_cons", "start": [2611, 1], "end": [2616, 43], "traced_tactics": [{"tactic": "simp only [scanr, foldr, cons.injEq, and_true]", "annotated_tactic": ["simp only [<a>scanr</a>, <a>foldr</a>, cons.injEq, <a>and_true</a>]", [{"full_name": "List.scanr", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [667, 5], "def_end_pos": [667, 10]}, {"full_name": "List.foldr", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [514, 19], "def_end_pos": [514, 24]}, {"full_name": "and_true", "def_path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "def_pos": [89, 17], "def_end_pos": [89, 25]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 scanr f b (a :: l) = foldr f b (a :: l) :: scanr f b l", "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 f a (foldr (fun a x => (f a x.1, x.1 :: x.2)) (b, []) l).1 = f a (foldr f b l)"}, {"tactic": "induction l generalizing a with\n| nil => rfl\n| cons hd tl ih => simp only [foldr, ih]", "annotated_tactic": ["induction l generalizing a with\n  | <a>nil</a> => rfl\n  | <a>cons</a> hd tl ih => simp only [<a>foldr</a>, ih]", [{"full_name": "List.nil", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2199, 5], "def_end_pos": [2199, 8]}, {"full_name": "List.cons", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [2202, 5], "def_end_pos": [2202, 9]}, {"full_name": "List.foldr", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [514, 19], "def_end_pos": [514, 24]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\na : \u03b1\nl : List \u03b1\n\u22a2 f a (foldr (fun a x => (f a x.1, x.1 :: x.2)) (b, []) l).1 = f a (foldr f b l)", "state_after": "no goals"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 f a (foldr (fun a x => (f a x.1, x.1 :: x.2)) (b, []) []).1 = f a (foldr f b [])", "state_after": "no goals"}, {"tactic": "simp only [foldr, ih]", "annotated_tactic": ["simp only [<a>foldr</a>, ih]", [{"full_name": "List.foldr", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [514, 19], "def_end_pos": [514, 24]}]], "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b2\nb : \u03b2\nhd : \u03b1\ntl : List \u03b1\nih : \u2200 (a : \u03b1), f a (foldr (fun a x => (f a x.1, x.1 :: x.2)) (b, []) tl).1 = f a (foldr f b tl)\na : \u03b1\n\u22a2 f a (foldr (fun a x => (f a x.1, x.1 :: x.2)) (b, []) (hd :: tl)).1 = f a (foldr f b (hd :: tl))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.domRestrict_le", "start": [757, 1], "end": [758, 50], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "R : Type u_1\ninst\u271d\u2076 : Ring R\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module R E\nF : Type u_3\ninst\u271d\u00b3 : AddCommGroup F\ninst\u271d\u00b2 : Module R F\nG : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module R G\nf : E \u2192\u2097.[R] F\nS : Submodule R E\n\u22a2 (domRestrict f S).domain \u2264 f.domain", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Filter/AtTopBot.lean", "full_name": "Filter.Ici_mem_atTop", "start": [57, 1], "end": [58, 14], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Vector/Basic.lean", "full_name": "Vector.cons_val", "start": [56, 1], "end": [57, 18], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Fin/Tuple/Basic.lean", "full_name": "Fin.update_snoc_last", "start": [535, 1], "end": [541, 9], "traced_tactics": [{"tactic": "ext j", "annotated_tactic": ["ext j", []], "state_before": "m n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\n\u22a2 update (snoc p x) (last n) z = snoc p z", "state_after": "case h\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\n\u22a2 update (snoc p x) (last n) z j = snoc p z j"}, {"tactic": "by_cases h : j.val < n", "annotated_tactic": ["by_cases h : j.val < n", []], "state_before": "case h\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\n\u22a2 update (snoc p x) (last n) z j = snoc p z j", "state_after": "case pos\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u2191j < n\n\u22a2 update (snoc p x) (last n) z j = snoc p z j\n\ncase neg\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u00ac\u2191j < n\n\u22a2 update (snoc p x) (last n) z j = snoc p z j"}, {"tactic": "have : j \u2260 last n := ne_of_lt h", "annotated_tactic": ["have : j \u2260 <a>last</a> n := <a>ne_of_lt</a> h", [{"full_name": "Fin.last", "def_path": "lake-packages/std/Std/Data/Fin/Basic.lean", "def_pos": [14, 15], "def_end_pos": [14, 19]}, {"full_name": "ne_of_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [101, 9], "def_end_pos": [101, 17]}]], "state_before": "case pos\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u2191j < n\n\u22a2 update (snoc p x) (last n) z j = snoc p z j", "state_after": "case pos\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u2191j < n\nthis : j \u2260 last n\n\u22a2 update (snoc p x) (last n) z j = snoc p z j"}, {"tactic": "simp [h, update_noteq, this, snoc]", "annotated_tactic": ["simp [h, <a>update_noteq</a>, this, <a>snoc</a>]", [{"full_name": "Function.update_noteq", "def_path": "lake-packages/mathlib/Mathlib/Logic/Function/Basic.lean", "def_pos": [571, 9], "def_end_pos": [571, 21]}, {"full_name": "Fin.snoc", "def_path": "lake-packages/mathlib/Mathlib/Data/Fin/Tuple/Basic.lean", "def_pos": [448, 5], "def_end_pos": [448, 9]}]], "state_before": "case pos\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u2191j < n\nthis : j \u2260 last n\n\u22a2 update (snoc p x) (last n) z j = snoc p z j", "state_after": "no goals"}, {"tactic": "rw [eq_last_of_not_lt h]", "annotated_tactic": ["rw [<a>eq_last_of_not_lt</a> h]", [{"full_name": "Fin.eq_last_of_not_lt", "def_path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "def_pos": [153, 9], "def_end_pos": [153, 26]}]], "state_before": "case neg\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u00ac\u2191j < n\n\u22a2 update (snoc p x) (last n) z j = snoc p z j", "state_after": "case neg\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u00ac\u2191j < n\n\u22a2 update (snoc p x) (last n) z (last n) = snoc p z (last n)"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case neg\nm n : \u2115\n\u03b1 : Fin (n + 1) \u2192 Type u\nx : \u03b1 (last n)\nq : (i : Fin (n + 1)) \u2192 \u03b1 i\np : (i : Fin n) \u2192 \u03b1 (castSucc i)\ni : Fin n\ny : \u03b1 (castSucc i)\nz : \u03b1 (last n)\nj : Fin (n + 1)\nh : \u00ac\u2191j < n\n\u22a2 update (snoc p x) (last n) z (last n) = snoc p z (last n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "tsub_left_inj", "start": [47, 1], "end": [48, 82], "traced_tactics": [{"tactic": "simp_rw [le_antisymm_iff, tsub_le_tsub_iff_right h1, tsub_le_tsub_iff_right h2]", "annotated_tactic": ["simp_rw [<a>le_antisymm_iff</a>, <a>tsub_le_tsub_iff_right</a> h1, <a>tsub_le_tsub_iff_right</a> h2]", [{"full_name": "le_antisymm_iff", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [192, 9], "def_end_pos": [192, 24]}, {"full_name": "tsub_le_tsub_iff_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [43, 9], "def_end_pos": [43, 31]}, {"full_name": "tsub_le_tsub_iff_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [43, 9], "def_end_pos": [43, 31]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh1 : c \u2264 a\nh2 : c \u2264 b\n\u22a2 a - c = b - c \u2194 a = b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Int/Order/Basic.lean", "full_name": "Int.exists_lt_and_lt_iff_not_dvd", "start": [382, 1], "end": [395, 51], "traced_tactics": [{"tactic": "constructor", "annotated_tactic": ["constructor", []], "state_before": "a b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\n\u22a2 (\u2203 k, n * k < m \u2227 m < n * (k + 1)) \u2194 \u00acn \u2223 m", "state_after": "case mp\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\n\u22a2 (\u2203 k, n * k < m \u2227 m < n * (k + 1)) \u2192 \u00acn \u2223 m\n\ncase mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\n\u22a2 \u00acn \u2223 m \u2192 \u2203 k, n * k < m \u2227 m < n * (k + 1)"}, {"tactic": "rintro \u27e8k, h1k, h2k\u27e9 \u27e8l, rfl\u27e9", "annotated_tactic": ["rintro \u27e8k, h1k, h2k\u27e9 \u27e8l, rfl\u27e9", []], "state_before": "case mp\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\n\u22a2 (\u2203 k, n * k < m \u2227 m < n * (k + 1)) \u2192 \u00acn \u2223 m", "state_after": "case mp.intro.intro.intro\na b : \u2124\nn\u271d : \u2115\nn : \u2124\nhn : 0 < n\nk l : \u2124\nh1k : n * k < n * l\nh2k : n * l < n * (k + 1)\n\u22a2 False"}, {"tactic": "rw [mul_lt_mul_left hn] at h1k h2k", "annotated_tactic": ["rw [<a>mul_lt_mul_left</a> hn] at h1k h2k", [{"full_name": "mul_lt_mul_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Ring/Lemmas.lean", "def_pos": [197, 9], "def_end_pos": [197, 24]}]], "state_before": "case mp.intro.intro.intro\na b : \u2124\nn\u271d : \u2115\nn : \u2124\nhn : 0 < n\nk l : \u2124\nh1k : n * k < n * l\nh2k : n * l < n * (k + 1)\n\u22a2 False", "state_after": "case mp.intro.intro.intro\na b : \u2124\nn\u271d : \u2115\nn : \u2124\nhn : 0 < n\nk l : \u2124\nh1k : k < l\nh2k : l < k + 1\n\u22a2 False"}, {"tactic": "rw [lt_add_one_iff, \u2190 not_lt] at h2k", "annotated_tactic": ["rw [<a>lt_add_one_iff</a>, \u2190 <a>not_lt</a>] at h2k", [{"full_name": "Int.lt_add_one_iff", "def_path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "def_pos": [851, 9], "def_end_pos": [851, 23]}, {"full_name": "not_lt", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [368, 9], "def_end_pos": [368, 15]}]], "state_before": "case mp.intro.intro.intro\na b : \u2124\nn\u271d : \u2115\nn : \u2124\nhn : 0 < n\nk l : \u2124\nh1k : k < l\nh2k : l < k + 1\n\u22a2 False", "state_after": "case mp.intro.intro.intro\na b : \u2124\nn\u271d : \u2115\nn : \u2124\nhn : 0 < n\nk l : \u2124\nh1k : k < l\nh2k : \u00ack < l\n\u22a2 False"}, {"tactic": "exact h2k h1k", "annotated_tactic": ["exact h2k h1k", []], "state_before": "case mp.intro.intro.intro\na b : \u2124\nn\u271d : \u2115\nn : \u2124\nhn : 0 < n\nk l : \u2124\nh1k : k < l\nh2k : \u00ack < l\n\u22a2 False", "state_after": "no goals"}, {"tactic": "intro h", "annotated_tactic": ["intro h", []], "state_before": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\n\u22a2 \u00acn \u2223 m \u2192 \u2203 k, n * k < m \u2227 m < n * (k + 1)", "state_after": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : \u00acn \u2223 m\n\u22a2 \u2203 k, n * k < m \u2227 m < n * (k + 1)"}, {"tactic": "rw [dvd_iff_emod_eq_zero, \u2190 Ne.def] at h", "annotated_tactic": ["rw [<a>dvd_iff_emod_eq_zero</a>, \u2190 <a>Ne.def</a>] at h", [{"full_name": "Int.dvd_iff_emod_eq_zero", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [695, 9], "def_end_pos": [695, 29]}, {"full_name": "Ne.def", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [59, 9], "def_end_pos": [59, 15]}]], "state_before": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : \u00acn \u2223 m\n\u22a2 \u2203 k, n * k < m \u2227 m < n * (k + 1)", "state_after": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\n\u22a2 \u2203 k, n * k < m \u2227 m < n * (k + 1)"}, {"tactic": "have := (emod_nonneg m hn.ne.symm).lt_of_ne h.symm", "annotated_tactic": ["have := (<a>emod_nonneg</a> m hn.ne.symm).<a>lt_of_ne</a> h.symm", [{"full_name": "Int.emod_nonneg", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [376, 9], "def_end_pos": [376, 20]}, {"full_name": "LE.le.lt_of_ne", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [132, 7], "def_end_pos": [132, 21]}]], "state_before": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\n\u22a2 \u2203 k, n * k < m \u2227 m < n * (k + 1)", "state_after": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 \u2203 k, n * k < m \u2227 m < n * (k + 1)"}, {"tactic": "simp (config := { singlePass := true }) only [\u2190 emod_add_ediv m n]", "annotated_tactic": ["simp (config := { singlePass := <a>true</a> }) only [\u2190 <a>emod_add_ediv</a> m n]", [{"full_name": "Bool.true", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [549, 5], "def_end_pos": [549, 9]}, {"full_name": "Int.emod_add_ediv", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [306, 9], "def_end_pos": [306, 22]}]], "state_before": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 \u2203 k, n * k < m \u2227 m < n * (k + 1)", "state_after": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 \u2203 k, n * k < m % n + n * (m / n) \u2227 m % n + n * (m / n) < n * (k + 1)"}, {"tactic": "refine' \u27e8m / n, lt_add_of_pos_left _ this, _\u27e9", "annotated_tactic": ["refine' \u27e8m / n, <a>lt_add_of_pos_left</a> _ this, _\u27e9", [{"full_name": "lt_add_of_pos_left", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [513, 15], "def_end_pos": [513, 33]}]], "state_before": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 \u2203 k, n * k < m % n + n * (m / n) \u2227 m % n + n * (m / n) < n * (k + 1)", "state_after": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 m % n + n * (m / n) < n * (m / n + 1)"}, {"tactic": "rw [add_comm _ (1 : \u2124), left_distrib, mul_one]", "annotated_tactic": ["rw [<a>add_comm</a> _ (1 : \u2124), <a>left_distrib</a>, <a>mul_one</a>]", [{"full_name": "add_comm", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [301, 3], "def_end_pos": [301, 14]}, {"full_name": "left_distrib", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [78, 9], "def_end_pos": [78, 21]}, {"full_name": "mul_one", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [470, 9], "def_end_pos": [470, 16]}]], "state_before": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 m % n + n * (m / n) < n * (m / n + 1)", "state_after": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 m % n + n * (m / n) < n + n * (m / n)"}, {"tactic": "exact add_lt_add_right (emod_lt_of_pos _ hn) _", "annotated_tactic": ["exact <a>add_lt_add_right</a> (<a>emod_lt_of_pos</a> _ hn) _", [{"full_name": "add_lt_add_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Monoid/Lemmas.lean", "def_pos": [135, 15], "def_end_pos": [135, 31]}, {"full_name": "Int.emod_lt_of_pos", "def_path": "lake-packages/std/Std/Data/Int/DivMod.lean", "def_pos": [392, 9], "def_end_pos": [392, 23]}]], "state_before": "case mpr\na b : \u2124\nn\u271d : \u2115\nm n : \u2124\nhn : 0 < n\nh : m % n \u2260 0\nthis : 0 < m % n\n\u22a2 m % n + n * (m / n) < n + n * (m / n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderHom.apply_mono", "start": [314, 1], "end": [315, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/Prod.lean", "full_name": "Submodule.snd_map_snd", "start": [668, 1], "end": [672, 45], "traced_tactics": [{"tactic": "rw [eq_top_iff]", "annotated_tactic": ["rw [<a>eq_top_iff</a>]", [{"full_name": "eq_top_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [165, 9], "def_end_pos": [165, 19]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 map (LinearMap.snd R M M\u2082) (snd R M M\u2082) = \u22a4", "state_after": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 \u22a4 \u2264 map (LinearMap.snd R M M\u2082) (snd R M M\u2082)"}, {"tactic": "rintro x -", "annotated_tactic": ["rintro x -", []], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\n\u22a2 \u22a4 \u2264 map (LinearMap.snd R M M\u2082) (snd R M M\u2082)", "state_after": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\u2082\n\u22a2 x \u2208 map (LinearMap.snd R M M\u2082) (snd R M M\u2082)"}, {"tactic": "simp only [snd, comap_bot, mem_map, mem_ker, snd_apply, fst_apply,\n  Prod.exists, exists_eq_right, exists_eq]", "annotated_tactic": ["simp only [<a>snd</a>, <a>comap_bot</a>, <a>mem_map</a>, <a>mem_ker</a>, <a>snd_apply</a>, <a>fst_apply</a>,\n    <a>Prod.exists</a>, <a>exists_eq_right</a>, <a>exists_eq</a>]", [{"full_name": "Submodule.snd", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [640, 5], "def_end_pos": [640, 8]}, {"full_name": "Submodule.comap_bot", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [1130, 9], "def_end_pos": [1130, 18]}, {"full_name": "Submodule.mem_map", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Module/Submodule/Map.lean", "def_pos": [91, 9], "def_end_pos": [91, 16]}, {"full_name": "LinearMap.mem_ker", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Basic.lean", "def_pos": [809, 9], "def_end_pos": [809, 16]}, {"full_name": "LinearMap.snd_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [80, 9], "def_end_pos": [80, 18]}, {"full_name": "LinearMap.fst_apply", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Prod.lean", "def_pos": [75, 9], "def_end_pos": [75, 18]}, {"full_name": "Prod.exists", "def_path": "lake-packages/mathlib/Mathlib/Data/Prod/Basic.lean", "def_pos": [41, 9], "def_end_pos": [41, 17]}, {"full_name": "exists_eq_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [468, 17], "def_end_pos": [468, 32]}, {"full_name": "exists_eq", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [461, 17], "def_end_pos": [461, 26]}]], "state_before": "R : Type u\nK : Type u'\nM : Type v\nV : Type v'\nM\u2082 : Type w\nV\u2082 : Type w'\nM\u2083 : Type y\nV\u2083 : Type y'\nM\u2084 : Type z\n\u03b9 : Type x\nM\u2085 : Type u_1\nM\u2086 : Type u_2\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M\u2082\np : Submodule R M\nq : Submodule R M\u2082\nx : M\u2082\n\u22a2 x \u2208 map (LinearMap.snd R M M\u2082) (snd R M M\u2082)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "full_name": "lt_of_tsub_lt_tsub_right_of_le", "start": [56, 1], "end": [59, 17], "traced_tactics": [{"tactic": "refine' ((tsub_le_tsub_iff_right h).mp h2.le).lt_of_ne _", "annotated_tactic": ["refine' ((<a>tsub_le_tsub_iff_right</a> h).<a>mp</a> h2.le).<a>lt_of_ne</a> _", [{"full_name": "tsub_le_tsub_iff_right", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Sub/Canonical.lean", "def_pos": [43, 9], "def_end_pos": [43, 31]}, {"full_name": "Iff.mp", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [90, 3], "def_end_pos": [90, 5]}, {"full_name": "LE.le.lt_of_ne", "def_path": "lake-packages/mathlib/Mathlib/Order/Basic.lean", "def_pos": [132, 7], "def_end_pos": [132, 21]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : c \u2264 b\nh2 : a - c < b - c\n\u22a2 a < b", "state_after": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : c \u2264 b\nh2 : a - c < b - c\n\u22a2 a \u2260 b"}, {"tactic": "rintro rfl", "annotated_tactic": ["rintro rfl", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : c \u2264 b\nh2 : a - c < b - c\n\u22a2 a \u2260 b", "state_after": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na c d : \u03b1\nh : c \u2264 a\nh2 : a - c < a - c\n\u22a2 False"}, {"tactic": "exact h2.false", "annotated_tactic": ["exact h2.false", []], "state_before": "\u03b1 : Type u_1\ninst\u271d\u2075 : AddCommSemigroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : ExistsAddOfLE \u03b1\ninst\u271d\u00b2 : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na c d : \u03b1\nh : c \u2264 a\nh2 : a - c < a - c\n\u22a2 False", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "full_name": "Subgroup.zpowers_eq_closure", "start": [40, 1], "end": [42, 35], "traced_tactics": [{"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\ng : G\n\u22a2 zpowers g = closure {g}", "state_after": "case h\nG : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\ng x\u271d : G\n\u22a2 x\u271d \u2208 zpowers g \u2194 x\u271d \u2208 closure {g}"}, {"tactic": "exact mem_closure_singleton.symm", "annotated_tactic": ["exact mem_closure_singleton.symm", []], "state_before": "case h\nG : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\ng x\u271d : G\n\u22a2 x\u271d \u2208 zpowers g \u2194 x\u271d \u2208 closure {g}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/GroupPower/Basic.lean", "full_name": "pow_eq_pow_mod", "start": [178, 1], "end": [182, 48], "traced_tactics": [{"tactic": "have t : x ^ m = x ^ (n * (m / n) + m % n) :=\n  congr_arg (fun a => x ^ a) ((Nat.add_comm _ _).trans (Nat.mod_add_div _ _)).symm", "annotated_tactic": ["have t : x ^ m = x ^ (n * (m / n) + m % n) :=\n    <a>congr_arg</a> (fun a => x ^ a) ((<a>Nat.add_comm</a> _ _).<a>trans</a> (<a>Nat.mod_add_div</a> _ _)).<a>symm</a>", [{"full_name": "congr_arg", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [43, 7], "def_end_pos": [43, 16]}, {"full_name": "Nat.add_comm", "def_path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "def_pos": [131, 19], "def_end_pos": [131, 27]}, {"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}, {"full_name": "Nat.mod_add_div", "def_path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "def_pos": [749, 9], "def_end_pos": [749, 20]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}]], "state_before": "\u03b1 : Type u_1\nM\u271d : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b2 : Monoid M\u271d\ninst\u271d\u00b9 : AddMonoid A\nM : Type u_2\ninst\u271d : Monoid M\nx : M\nm n : \u2115\nh : x ^ n = 1\n\u22a2 x ^ m = x ^ (m % n)", "state_after": "\u03b1 : Type u_1\nM\u271d : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b2 : Monoid M\u271d\ninst\u271d\u00b9 : AddMonoid A\nM : Type u_2\ninst\u271d : Monoid M\nx : M\nm n : \u2115\nh : x ^ n = 1\nt : x ^ m = x ^ (n * (m / n) + m % n)\n\u22a2 x ^ m = x ^ (m % n)"}, {"tactic": "rw [t, pow_add, pow_mul, h, one_pow, one_mul]", "annotated_tactic": ["rw [t, <a>pow_add</a>, <a>pow_mul</a>, h, <a>one_pow</a>, <a>one_mul</a>]", [{"full_name": "pow_add", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [118, 9], "def_end_pos": [118, 16]}, {"full_name": "pow_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [125, 9], "def_end_pos": [125, 16]}, {"full_name": "one_pow", "def_path": "lake-packages/mathlib/Mathlib/Algebra/GroupPower/Basic.lean", "def_pos": [90, 9], "def_end_pos": [90, 16]}, {"full_name": "one_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [464, 9], "def_end_pos": [464, 16]}]], "state_before": "\u03b1 : Type u_1\nM\u271d : Type u\nN : Type v\nG : Type w\nH : Type x\nA : Type y\nB : Type z\nR : Type u\u2081\nS : Type u\u2082\ninst\u271d\u00b2 : Monoid M\u271d\ninst\u271d\u00b9 : AddMonoid A\nM : Type u_2\ninst\u271d : Monoid M\nx : M\nm n : \u2115\nh : x ^ n = 1\nt : x ^ m = x ^ (n * (m / n) + m % n)\n\u22a2 x ^ m = x ^ (m % n)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Basic.lean", "full_name": "OrderHomClass.coe_coe", "start": [258, 9], "end": [260, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Logic.lean", "full_name": "imp_of_if_pos", "start": [357, 1], "end": [358, 39], "traced_tactics": [{"tactic": "have := if_pos hc \u25b8 h", "annotated_tactic": ["have := <a>if_pos</a> hc \u25b8 h", [{"full_name": "if_pos", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [790, 9], "def_end_pos": [790, 15]}]], "state_before": "a b c\u271d d : Prop\np : ?m.27511\nc t e : Prop\ninst\u271d : Decidable c\nh : if c then t else e\nhc : c\n\u22a2 t", "state_after": "a b c\u271d d : Prop\np : ?m.27511\nc t e : Prop\ninst\u271d : Decidable c\nh : if c then t else e\nhc : c\nthis : t\n\u22a2 t"}, {"tactic": "exact this", "annotated_tactic": ["exact this", []], "state_before": "a b c\u271d d : Prop\np : ?m.27511\nc t e : Prop\ninst\u271d : Decidable c\nh : if c then t else e\nhc : c\nthis : t\n\u22a2 t", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/BigOperators/Intervals.lean", "full_name": "Finset.sum_range_by_parts", "start": [310, 1], "end": [316, 30], "traced_tactics": [{"tactic": "by_cases hn : n = 0", "annotated_tactic": ["by_cases hn : n = 0", []], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\n\u22a2 \u2211 i in range n, f i \u2022 g i =\n    f (n - 1) \u2022 \u2211 i in range n, g i - \u2211 i in range (n - 1), (f (i + 1) - f i) \u2022 \u2211 i in range (i + 1), g i", "state_after": "case pos\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\nhn : n = 0\n\u22a2 \u2211 i in range n, f i \u2022 g i =\n    f (n - 1) \u2022 \u2211 i in range n, g i - \u2211 i in range (n - 1), (f (i + 1) - f i) \u2022 \u2211 i in range (i + 1), g i\n\ncase neg\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\nhn : \u00acn = 0\n\u22a2 \u2211 i in range n, f i \u2022 g i =\n    f (n - 1) \u2022 \u2211 i in range n, g i - \u2211 i in range (n - 1), (f (i + 1) - f i) \u2022 \u2211 i in range (i + 1), g i"}, {"tactic": "simp [hn]", "annotated_tactic": ["simp [hn]", []], "state_before": "case pos\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\nhn : n = 0\n\u22a2 \u2211 i in range n, f i \u2022 g i =\n    f (n - 1) \u2022 \u2211 i in range n, g i - \u2211 i in range (n - 1), (f (i + 1) - f i) \u2022 \u2211 i in range (i + 1), g i", "state_after": "no goals"}, {"tactic": "rw [range_eq_Ico, sum_Ico_by_parts f g (Nat.pos_of_ne_zero hn), sum_range_zero, smul_zero,\n  sub_zero, range_eq_Ico]", "annotated_tactic": ["rw [<a>range_eq_Ico</a>, <a>sum_Ico_by_parts</a> f g (<a>Nat.pos_of_ne_zero</a> hn), <a>sum_range_zero</a>, <a>smul_zero</a>,\n      <a>sub_zero</a>, <a>range_eq_Ico</a>]", [{"full_name": "Finset.range_eq_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [93, 9], "def_end_pos": [93, 35]}, {"full_name": "Finset.sum_Ico_by_parts", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Intervals.lean", "def_pos": [268, 9], "def_end_pos": [268, 25]}, {"full_name": "Nat.pos_of_ne_zero", "def_path": "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "def_pos": [25, 19], "def_end_pos": [25, 33]}, {"full_name": "Finset.sum_range_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/BigOperators/Basic.lean", "def_pos": [1268, 3], "def_end_pos": [1268, 14]}, {"full_name": "smul_zero", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/GroupAction/Defs.lean", "def_pos": [732, 9], "def_end_pos": [732, 18]}, {"full_name": "sub_zero", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [339, 3], "def_end_pos": [339, 14]}, {"full_name": "Finset.range_eq_Ico", "def_path": "lake-packages/mathlib/Mathlib/Data/Nat/Interval.lean", "def_pos": [93, 9], "def_end_pos": [93, 35]}]], "state_before": "case neg\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\nhn : \u00acn = 0\n\u22a2 \u2211 i in range n, f i \u2022 g i =\n    f (n - 1) \u2022 \u2211 i in range n, g i - \u2211 i in range (n - 1), (f (i + 1) - f i) \u2022 \u2211 i in range (i + 1), g i", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Order/Group/Abs.lean", "full_name": "abs_pos", "start": [133, 1], "end": [137, 41], "traced_tactics": [{"tactic": "rcases lt_trichotomy a 0 with (ha | rfl | ha)", "annotated_tactic": ["rcases <a>lt_trichotomy</a> a 0 with (ha | rfl | ha)", [{"full_name": "lt_trichotomy", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [311, 9], "def_end_pos": [311, 22]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\na b c : \u03b1\n\u22a2 0 < |a| \u2194 a \u2260 0", "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\na b c : \u03b1\nha : a < 0\n\u22a2 0 < |a| \u2194 a \u2260 0\n\ncase inr.inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nb c : \u03b1\n\u22a2 0 < |0| \u2194 0 \u2260 0\n\ncase inr.inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\na b c : \u03b1\nha : 0 < a\n\u22a2 0 < |a| \u2194 a \u2260 0"}, {"tactic": "simp [abs_of_neg ha, neg_pos, ha.ne, ha]", "annotated_tactic": ["simp [<a>abs_of_neg</a> ha, <a>neg_pos</a>, ha.ne, ha]", [{"full_name": "abs_of_neg", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [119, 9], "def_end_pos": [119, 19]}, {"full_name": "neg_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Defs.lean", "def_pos": [677, 24], "def_end_pos": [677, 31]}]], "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\na b c : \u03b1\nha : a < 0\n\u22a2 0 < |a| \u2194 a \u2260 0", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case inr.inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\nb c : \u03b1\n\u22a2 0 < |0| \u2194 0 \u2260 0", "state_after": "no goals"}, {"tactic": "simp [abs_of_pos ha, ha, ha.ne.symm]", "annotated_tactic": ["simp [<a>abs_of_pos</a> ha, ha, ha.ne.symm]", [{"full_name": "abs_of_pos", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Order/Group/Abs.lean", "def_pos": [111, 9], "def_end_pos": [111, 19]}]], "state_before": "case inr.inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\na b c : \u03b1\nha : 0 < a\n\u22a2 0 < |a| \u2194 a \u2260 0", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "div_mul_div_comm", "start": [582, 1], "end": [582, 72], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\ninst\u271d : DivisionCommMonoid \u03b1\na b c d : \u03b1\n\u22a2 a / b * (c / d) = a * c / (b * d)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "full_name": "Polynomial.degree_C_lt", "start": [257, 1], "end": [258, 61], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Image.lean", "full_name": "Set.range_subtype_map", "start": [1021, 1], "end": [1034, 14], "traced_tactics": [{"tactic": "ext \u27e8x, hx\u27e9", "annotated_tactic": ["ext \u27e8x, hx\u27e9", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\n\u22a2 range (Subtype.map f h) = Subtype.val \u207b\u00b9' (f '' {x | p x})", "state_after": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 { val := x, property := hx } \u2208 range (Subtype.map f h) \u2194\n    { val := x, property := hx } \u2208 Subtype.val \u207b\u00b9' (f '' {x | p x})"}, {"tactic": "rw [mem_preimage, mem_range, mem_image, Subtype.exists, Subtype.coe_mk]", "annotated_tactic": ["rw [<a>mem_preimage</a>, <a>mem_range</a>, <a>mem_image</a>, <a>Subtype.exists</a>, <a>Subtype.coe_mk</a>]", [{"full_name": "Set.mem_preimage", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [64, 9], "def_end_pos": [64, 21]}, {"full_name": "Set.mem_range", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [673, 9], "def_end_pos": [673, 18]}, {"full_name": "Set.mem_image", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [231, 9], "def_end_pos": [231, 18]}, {"full_name": "Subtype.exists", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [54, 19], "def_end_pos": [54, 27]}, {"full_name": "Subtype.coe_mk", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [99, 9], "def_end_pos": [99, 15]}]], "state_before": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 { val := x, property := hx } \u2208 range (Subtype.map f h) \u2194\n    { val := x, property := hx } \u2208 Subtype.val \u207b\u00b9' (f '' {x | p x})", "state_after": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }) \u2194\n    \u2203 x_1 \u2208 {x | p x}, f x_1 = x"}, {"tactic": "apply Iff.intro", "annotated_tactic": ["apply <a>Iff.intro</a>", [{"full_name": "Iff.intro", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [88, 3], "def_end_pos": [88, 8]}]], "state_before": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }) \u2194\n    \u2203 x_1 \u2208 {x | p x}, f x_1 = x", "state_after": "case h.mk.mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }) \u2192\n    \u2203 x_1 \u2208 {x | p x}, f x_1 = x\n\ncase h.mk.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 x_1 \u2208 {x | p x}, f x_1 = x) \u2192\n    \u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }"}, {"tactic": "rintro \u27e8a, b, hab\u27e9", "annotated_tactic": ["rintro \u27e8a, b, hab\u27e9", []], "state_before": "case h.mk.mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }) \u2192\n    \u2203 x_1 \u2208 {x | p x}, f x_1 = x", "state_after": "case h.mk.mp.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : p a\nhab : Subtype.map f h { val := a, property := b } = { val := x, property := hx }\n\u22a2 \u2203 x_1 \u2208 {x | p x}, f x_1 = x"}, {"tactic": "rw [Subtype.map, Subtype.mk.injEq] at hab", "annotated_tactic": ["rw [<a>Subtype.map</a>, Subtype.mk.injEq] at hab", [{"full_name": "Subtype.map", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [200, 5], "def_end_pos": [200, 8]}]], "state_before": "case h.mk.mp.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : p a\nhab : Subtype.map f h { val := a, property := b } = { val := x, property := hx }\n\u22a2 \u2203 x_1 \u2208 {x | p x}, f x_1 = x", "state_after": "case h.mk.mp.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : p a\nhab : f \u2191{ val := a, property := b } = x\n\u22a2 \u2203 x_1 \u2208 {x | p x}, f x_1 = x"}, {"tactic": "use a", "annotated_tactic": ["use a", []], "state_before": "case h.mk.mp.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : p a\nhab : f \u2191{ val := a, property := b } = x\n\u22a2 \u2203 x_1 \u2208 {x | p x}, f x_1 = x", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : p a\nhab : f \u2191{ val := a, property := b } = x\n\u22a2 a \u2208 {x | p x} \u2227 f a = x"}, {"tactic": "trivial", "annotated_tactic": ["trivial", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : p a\nhab : f \u2191{ val := a, property := b } = x\n\u22a2 a \u2208 {x | p x} \u2227 f a = x", "state_after": "no goals"}, {"tactic": "rintro \u27e8a, b, hab\u27e9", "annotated_tactic": ["rintro \u27e8a, b, hab\u27e9", []], "state_before": "case h.mk.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 x_1 \u2208 {x | p x}, f x_1 = x) \u2192\n    \u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }", "state_after": "case h.mk.mpr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 \u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }"}, {"tactic": "use a", "annotated_tactic": ["use a", []], "state_before": "case h.mk.mpr.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 \u2203 a, \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }"}, {"tactic": "use b", "annotated_tactic": ["use b", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 \u2203 (b : p a), Subtype.map f h { val := a, property := b } = { val := x, property := hx }", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 Subtype.map f h { val := a, property := b } = { val := x, property := hx }"}, {"tactic": "rw [Subtype.map, Subtype.mk.injEq]", "annotated_tactic": ["rw [<a>Subtype.map</a>, Subtype.mk.injEq]", [{"full_name": "Subtype.map", "def_path": "lake-packages/mathlib/Mathlib/Data/Subtype.lean", "def_pos": [200, 5], "def_end_pos": [200, 8]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 Subtype.map f h { val := a, property := b } = { val := x, property := hx }", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 f \u2191{ val := a, property := b } = x"}, {"tactic": "exact hab", "annotated_tactic": ["exact hab", []], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_4\n\u03b9' : Sort u_5\nf\u271d : \u03b9 \u2192 \u03b1\ns t : Set \u03b1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\na : \u03b1\nb : a \u2208 {x | p x}\nhab : f a = x\n\u22a2 f \u2191{ val := a, property := b } = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Prod.lean", "full_name": "AlgHom.coe_prod", "start": [82, 1], "end": [83, 6], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Init/Order/Defs.lean", "full_name": "le_antisymm_iff", "start": [192, 1], "end": [193, 78], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Matrix/Block.lean", "full_name": "Matrix.blockDiag_transpose", "start": [535, 1], "end": [537, 21], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/Intervals/Basic.lean", "full_name": "Set.Iio_union_Ioo'", "start": [1456, 1], "end": [1462, 42], "traced_tactics": [{"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\n\u22a2 Iio b \u222a Ioo c d = Iio (max b d)", "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\n\u22a2 x \u2208 Iio b \u222a Ioo c d \u2194 x \u2208 Iio (max b d)"}, {"tactic": "cases' lt_or_le x b with hba hba", "annotated_tactic": ["cases' <a>lt_or_le</a> x b with hba hba", [{"full_name": "lt_or_le", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [336, 9], "def_end_pos": [336, 17]}]], "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\n\u22a2 x \u2208 Iio b \u222a Ioo c d \u2194 x \u2208 Iio (max b d)", "state_after": "case h.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : x < b\n\u22a2 x \u2208 Iio b \u222a Ioo c d \u2194 x \u2208 Iio (max b d)\n\ncase h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : b \u2264 x\n\u22a2 x \u2208 Iio b \u222a Ioo c d \u2194 x \u2208 Iio (max b d)"}, {"tactic": "simp [hba, h\u2081]", "annotated_tactic": ["simp [hba, h\u2081]", []], "state_before": "case h.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : x < b\n\u22a2 x \u2208 Iio b \u222a Ioo c d \u2194 x \u2208 Iio (max b d)", "state_after": "no goals"}, {"tactic": "simp only [mem_Iio, mem_union, mem_Ioo, lt_max_iff]", "annotated_tactic": ["simp only [<a>mem_Iio</a>, <a>mem_union</a>, <a>mem_Ioo</a>, <a>lt_max_iff</a>]", [{"full_name": "Set.mem_Iio", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [126, 9], "def_end_pos": [126, 16]}, {"full_name": "Set.mem_union", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Basic.lean", "def_pos": [760, 9], "def_end_pos": [760, 18]}, {"full_name": "Set.mem_Ioo", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Intervals/Basic.lean", "def_pos": [116, 9], "def_end_pos": [116, 16]}, {"full_name": "lt_max_iff", "def_path": "lake-packages/mathlib/Mathlib/Order/MinMax.lean", "def_pos": [58, 9], "def_end_pos": [58, 19]}]], "state_before": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : b \u2264 x\n\u22a2 x \u2208 Iio b \u222a Ioo c d \u2194 x \u2208 Iio (max b d)", "state_after": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : b \u2264 x\n\u22a2 x < b \u2228 c < x \u2227 x < d \u2194 x < b \u2228 x < d"}, {"tactic": "refine' or_congr Iff.rfl \u27e8And.right, _\u27e9", "annotated_tactic": ["refine' <a>or_congr</a> <a>Iff.rfl</a> \u27e8<a>And.right</a>, _\u27e9", [{"full_name": "or_congr", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [261, 9], "def_end_pos": [261, 17]}, {"full_name": "Iff.rfl", "def_path": "lake-packages/lean4/src/lean/Init/Core.lean", "def_pos": [663, 19], "def_end_pos": [663, 26]}, {"full_name": "And.right", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [507, 3], "def_end_pos": [507, 8]}]], "state_before": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : b \u2264 x\n\u22a2 x < b \u2228 c < x \u2227 x < d \u2194 x < b \u2228 x < d", "state_after": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : b \u2264 x\n\u22a2 x < d \u2192 c < x \u2227 x < d"}, {"tactic": "exact fun h\u2082 => \u27e8h\u2081.trans_le hba, h\u2082\u27e9", "annotated_tactic": ["exact fun h\u2082 => \u27e8h\u2081.trans_le hba, h\u2082\u27e9", []], "state_before": "case h.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : LinearOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c d : \u03b1\nh\u2081 : c < b\nx : \u03b1\nhba : b \u2264 x\n\u22a2 x < d \u2192 c < x \u2227 x < d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Set/NAry.lean", "full_name": "Set.image2_singleton", "start": [204, 1], "end": [204, 65], "traced_tactics": [{"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u_1\n\u03b1' : Type u_2\n\u03b2 : Type u_3\n\u03b2' : Type u_4\n\u03b3 : Type u_5\n\u03b3' : Type u_6\n\u03b4 : Type u_7\n\u03b4' : Type u_8\n\u03b5 : Type u_9\n\u03b5' : Type u_10\n\u03b6 : Type u_11\n\u03b6' : Type u_12\n\u03bd : Type u_13\nf f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ng g' : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4\ns s' : Set \u03b1\nt t' : Set \u03b2\nu u' : Set \u03b3\nv : Set \u03b4\na a' : \u03b1\nb b' : \u03b2\nc c' : \u03b3\nd d' : \u03b4\n\u22a2 image2 f {a} {b} = {f a b}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Hom/Bounded.lean", "full_name": "BotHom.cancel_left", "start": [482, 1], "end": [485, 17], "traced_tactics": [{"tactic": "rw [\u2190 BotHom.comp_apply, h, BotHom.comp_apply]", "annotated_tactic": ["rw [\u2190 <a>BotHom.comp_apply</a>, h, <a>BotHom.comp_apply</a>]", [{"full_name": "BotHom.comp_apply", "def_path": "lake-packages/mathlib/Mathlib/Order/Hom/Bounded.lean", "def_pos": [455, 9], "def_end_pos": [455, 19]}, {"full_name": "BotHom.comp_apply", "def_path": "lake-packages/mathlib/Mathlib/Order/Hom/Bounded.lean", "def_pos": [455, 9], "def_end_pos": [455, 19]}]], "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\n\u03b4 : Type u_5\ninst\u271d\u00b3 : Bot \u03b1\ninst\u271d\u00b2 : Bot \u03b2\ninst\u271d\u00b9 : Bot \u03b3\ninst\u271d : Bot \u03b4\ng : BotHom \u03b2 \u03b3\nf\u2081 f\u2082 : BotHom \u03b1 \u03b2\nhg : Injective \u2191g\nh : comp g f\u2081 = comp g f\u2082\na : \u03b1\n\u22a2 \u2191g (\u2191f\u2081 a) = \u2191g (\u2191f\u2082 a)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Basic.lean", "full_name": "eq_inv_iff_mul_eq_one", "start": [667, 1], "end": [668, 29], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Coset.lean", "full_name": "leftCoset_assoc", "start": [124, 1], "end": [125, 82], "traced_tactics": [{"tactic": "simp [leftCoset, rightCoset, (image_comp _ _ _).symm, Function.comp, mul_assoc]", "annotated_tactic": ["simp [<a>leftCoset</a>, <a>rightCoset</a>, (<a>image_comp</a> _ _ _).<a>symm</a>, <a>Function.comp</a>, <a>mul_assoc</a>]", [{"full_name": "leftCoset", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Coset.lean", "def_pos": [48, 5], "def_end_pos": [48, 14]}, {"full_name": "rightCoset", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Coset.lean", "def_pos": [56, 5], "def_end_pos": [56, 15]}, {"full_name": "Set.image_comp", "def_path": "lake-packages/mathlib/Mathlib/Data/Set/Image.lean", "def_pos": [293, 9], "def_end_pos": [293, 19]}, {"full_name": "Eq.symm", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [310, 9], "def_end_pos": [310, 16]}, {"full_name": "Function.comp", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [52, 15], "def_end_pos": [52, 28]}, {"full_name": "mul_assoc", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Defs.lean", "def_pos": [264, 9], "def_end_pos": [264, 18]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\ns : Set \u03b1\na b : \u03b1\n\u22a2 a *l (b *l s) = a * b *l s", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Basic.lean", "full_name": "Ideal.span_singleton_mul_left_unit", "start": [178, 1], "end": [181, 56], "traced_tactics": [{"tactic": "apply le_antisymm <;> rw [span_singleton_le_iff_mem, mem_span_singleton']", "annotated_tactic": ["apply <a>le_antisymm</a> <;> rw [<a>span_singleton_le_iff_mem</a>, <a>mem_span_singleton'</a>]", [{"full_name": "le_antisymm", "def_path": "lake-packages/mathlib/Mathlib/Init/Order/Defs.lean", "def_pos": [188, 9], "def_end_pos": [188, 20]}, {"full_name": "Ideal.span_singleton_le_iff_mem", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [174, 9], "def_end_pos": [174, 34]}, {"full_name": "Ideal.mem_span_singleton'", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Basic.lean", "def_pos": [170, 9], "def_end_pos": [170, 28]}]], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b a : \u03b1\nh2 : IsUnit a\nx : \u03b1\n\u22a2 span {a * x} = span {x}", "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b a : \u03b1\nh2 : IsUnit a\nx : \u03b1\n\u22a2 \u2203 a_1, a_1 * x = a * x\n\ncase a\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b a : \u03b1\nh2 : IsUnit a\nx : \u03b1\n\u22a2 \u2203 a_1, a_1 * (a * x) = x"}, {"tactic": "exacts [\u27e8a, rfl\u27e9, \u27e8_, h2.unit.inv_mul_cancel_left x\u27e9]", "annotated_tactic": ["exacts [\u27e8a, <a>rfl</a>\u27e9, \u27e8_, h2.unit.inv_mul_cancel_left x\u27e9]", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b a : \u03b1\nh2 : IsUnit a\nx : \u03b1\n\u22a2 \u2203 a_1, a_1 * x = a * x\n\ncase a\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na\u271d b a : \u03b1\nh2 : IsUnit a\nx : \u03b1\n\u22a2 \u2203 a_1, a_1 * (a * x) = x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover/std4", "commit": "28f42676168ea8431dbacf3e486ff25aabbf3322", "file_path": "Std/Data/List/Lemmas.lean", "full_name": "List.length_singleton", "start": [37, 14], "end": [37, 70], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "full_name": "MonoidAlgebra.lift_unique", "start": [925, 1], "end": [929, 22], "traced_tactics": [{"tactic": "conv_lhs =>\n  rw [lift_unique' F]\n  simp [lift_apply]", "annotated_tactic": ["conv_lhs =>\n    rw [<a>lift_unique'</a> F]\n    simp [<a>lift_apply</a>]", [{"full_name": "MonoidAlgebra.lift_unique'", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [918, 9], "def_end_pos": [918, 21]}, {"full_name": "MonoidAlgebra.lift_apply", "def_path": "lake-packages/mathlib/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "def_pos": [895, 9], "def_end_pos": [895, 19]}]], "state_before": "k : Type u\u2081\nG : Type u\u2082\nH : Type u_1\nR : Type u_2\ninst\u271d\u2076 : CommSemiring k\ninst\u271d\u2075 : Monoid G\ninst\u271d\u2074 : Monoid H\nA : Type u\u2083\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra k A\nB : Type u_3\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra k B\nF : MonoidAlgebra k G \u2192\u2090[k] A\nf : MonoidAlgebra k G\n\u22a2 \u2191F f = sum f fun a b => b \u2022 \u2191F (single a 1)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "full_name": "Subgroup.closure_mono", "start": [1237, 1], "end": [1238, 35], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Tactic/NormNum/Basic.lean", "full_name": "Mathlib.Meta.NormNum.isRat_neg", "start": [239, 1], "end": [241, 85], "traced_tactics": [{"tactic": "rw [\u2190 neg_mul, \u2190 Int.cast_neg]", "annotated_tactic": ["rw [\u2190 <a>neg_mul</a>, \u2190 <a>Int.cast_neg</a>]", [{"full_name": "neg_mul", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Ring/Defs.lean", "def_pos": [289, 9], "def_end_pos": [289, 16]}, {"full_name": "Int.cast_neg", "def_path": "lake-packages/mathlib/Mathlib/Data/Int/Cast/Basic.lean", "def_pos": [83, 9], "def_end_pos": [83, 17]}]], "state_before": "\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\nnum\u271d : \u2124\ndenom\u271d : \u2115\nh : Invertible \u2191denom\u271d\n\u22a2 -(\u2191num\u271d * \u215f\u2191denom\u271d) = \u2191(Int.neg num\u271d) * \u215f\u2191denom\u271d", "state_after": "\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\nnum\u271d : \u2124\ndenom\u271d : \u2115\nh : Invertible \u2191denom\u271d\n\u22a2 \u2191(-num\u271d) * \u215f\u2191denom\u271d = \u2191(Int.neg num\u271d) * \u215f\u2191denom\u271d"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "\u03b1 : Type u_1\ninst\u271d : Ring \u03b1\nnum\u271d : \u2124\ndenom\u271d : \u2115\nh : Invertible \u2191denom\u271d\n\u22a2 \u2191(-num\u271d) * \u215f\u2191denom\u271d = \u2191(Int.neg num\u271d) * \u215f\u2191denom\u271d", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Perm.lean", "full_name": "List.Perm.union", "start": [997, 1], "end": [999, 47], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Basic.lean", "full_name": "List.pmap_map", "start": [3018, 1], "end": [3020, 50], "traced_tactics": [{"tactic": "induction l <;> [rfl; simp only [*, pmap, map]]", "annotated_tactic": ["induction l <;> [rfl; simp only [*, <a>pmap</a>, <a>map</a>]]", [{"full_name": "List.pmap", "def_path": "lake-packages/std/Std/Data/List/Basic.lean", "def_pos": [754, 13], "def_end_pos": [754, 17]}, {"full_name": "List.map", "def_path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "def_pos": [151, 19], "def_end_pos": [151, 22]}]], "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\np : \u03b2 \u2192 Prop\ng : (b : \u03b2) \u2192 p b \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\nl : List \u03b1\nH : \u2200 (a : \u03b2), a \u2208 map f l \u2192 p a\n\u22a2 pmap g (map f l) H = pmap (fun a h => g (f a) h) l (_ : \u2200 (a : \u03b1), a \u2208 l \u2192 p (f a))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/DFinsupp/Basic.lean", "full_name": "DFinsupp.finite_support", "start": [574, 1], "end": [578, 64], "traced_tactics": [{"tactic": "classical!", "annotated_tactic": ["classical!", []], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Zero (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\n\u22a2 Set.Finite {i | \u2191f i \u2260 0}", "state_after": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Zero (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nem\u271d : (a : Prop) \u2192 Decidable a\n\u22a2 Set.Finite {i | \u2191f i \u2260 0}"}, {"tactic": "exact Trunc.induction_on f.support' fun xs =>\n      (Multiset.toFinset xs.1).finite_toSet.subset fun i H =>\n        Multiset.mem_toFinset.2 ((xs.prop i).resolve_right H)", "annotated_tactic": ["exact <a>Trunc.induction_on</a> f.support' fun xs =>\n        (<a>Multiset.toFinset</a> xs.1).finite_toSet.subset fun i H =>\n          <a>Multiset.mem_toFinset</a>.2 ((xs.prop i).<a>resolve_right</a> H)", [{"full_name": "Trunc.induction_on", "def_path": "lake-packages/mathlib/Mathlib/Data/Quot.lean", "def_pos": [503, 19], "def_end_pos": [503, 31]}, {"full_name": "Multiset.toFinset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3204, 5], "def_end_pos": [3204, 13]}, {"full_name": "Multiset.mem_toFinset", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [3223, 9], "def_end_pos": [3223, 21]}, {"full_name": "Or.resolve_right", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [278, 9], "def_end_pos": [278, 25]}]], "state_before": "\u03b9 : Type u\n\u03b3 : Type w\n\u03b2 : \u03b9 \u2192 Type v\n\u03b2\u2081 : \u03b9 \u2192 Type v\u2081\n\u03b2\u2082 : \u03b9 \u2192 Type v\u2082\ndec : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 Zero (\u03b2 i)\nf : \u03a0\u2080 (i : \u03b9), \u03b2 i\nem\u271d : (a : Prop) \u2192 Decidable a\n\u22a2 Set.Finite {i | \u2191f i \u2260 0}", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Algebra/Operations.lean", "full_name": "Submodule.map_mul", "start": [258, 11], "end": [276, 21], "traced_tactics": [{"tactic": "apply congr_arg sSup", "annotated_tactic": ["apply <a>congr_arg</a> <a>sSup</a>", [{"full_name": "congr_arg", "def_path": "lake-packages/mathlib/Mathlib/Init/Logic.lean", "def_pos": [43, 7], "def_end_pos": [43, 16]}, {"full_name": "SupSet.sSup", "def_path": "lake-packages/mathlib/Mathlib/Order/CompleteLattice.lean", "def_pos": [55, 3], "def_end_pos": [55, 7]}]], "state_before": "\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\n\u22a2 \u2a06 i, map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N) =\n    map (AlgHom.toLinearMap f) M * map (AlgHom.toLinearMap f) N", "state_after": "\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\n\u22a2 (range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) =\n    range fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)"}, {"tactic": "ext S", "annotated_tactic": ["ext S", []], "state_before": "\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\n\u22a2 (range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) =\n    range fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)", "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\n\u22a2 (S \u2208 range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) \u2194\n    S \u2208 range fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)"}, {"tactic": "constructor <;> rintro \u27e8y, hy\u27e9", "annotated_tactic": ["constructor <;> rintro \u27e8y, hy\u27e9", []], "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\n\u22a2 (S \u2208 range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) \u2194\n    S \u2208 range fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)", "state_after": "case h.mp.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\n\u22a2 S \u2208 range fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)\n\ncase h.mpr.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\n\u22a2 S \u2208 range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)"}, {"tactic": "use \u27e8f y, mem_map.mpr \u27e8y.1, y.2, rfl\u27e9\u27e9", "annotated_tactic": ["use \u27e8f y, mem_map.mpr \u27e8y.1, y.2, <a>rfl</a>\u27e9\u27e9", [{"full_name": "rfl", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [281, 22], "def_end_pos": [281, 25]}]], "state_before": "case h.mp.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\n\u22a2 S \u2208 range fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)", "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\n\u22a2 (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N))\n      { val := \u2191f \u2191y, property := (_ : \u2191f \u2191y \u2208 map (AlgHom.toLinearMap f) M) } =\n    S"}, {"tactic": "refine' Eq.trans _ hy", "annotated_tactic": ["refine' <a>Eq.trans</a> _ hy", [{"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}]], "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\n\u22a2 (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N))\n      { val := \u2191f \u2191y, property := (_ : \u2191f \u2191y \u2208 map (AlgHom.toLinearMap f) M) } =\n    S", "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\n\u22a2 (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N))\n      { val := \u2191f \u2191y, property := (_ : \u2191f \u2191y \u2208 map (AlgHom.toLinearMap f) M) } =\n    (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\n\u22a2 (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N))\n      { val := \u2191f \u2191y, property := (_ : \u2191f \u2191y \u2208 map (AlgHom.toLinearMap f) M) } =\n    (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y", "state_after": "case h.h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\nx\u271d : A'\n\u22a2 x\u271d \u2208\n      (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N))\n        { val := \u2191f \u2191y, property := (_ : \u2191f \u2191y \u2208 map (AlgHom.toLinearMap f) M) } \u2194\n    x\u271d \u2208 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "case h.h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5M\nhy : (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y = S\nx\u271d : A'\n\u22a2 x\u271d \u2208\n      (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N))\n        { val := \u2191f \u2191y, property := (_ : \u2191f \u2191y \u2208 map (AlgHom.toLinearMap f) M) } \u2194\n    x\u271d \u2208 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) y", "state_after": "no goals"}, {"tactic": "obtain \u27e8y', hy', fy_eq\u27e9 := mem_map.mp y.2", "annotated_tactic": ["obtain \u27e8y', hy', fy_eq\u27e9 := mem_map.mp y.2", []], "state_before": "case h.mpr.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\n\u22a2 S \u2208 range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)", "state_after": "case h.mpr.intro.intro.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191(AlgHom.toLinearMap f) y' = \u2191y\n\u22a2 S \u2208 range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)"}, {"tactic": "use \u27e8y', hy'\u27e9", "annotated_tactic": ["use \u27e8y', hy'\u27e9", []], "state_before": "case h.mpr.intro.intro.intro\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191(AlgHom.toLinearMap f) y' = \u2191y\n\u22a2 S \u2208 range fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)", "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191(AlgHom.toLinearMap f) y' = \u2191y\n\u22a2 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } = S"}, {"tactic": "refine' Eq.trans _ hy", "annotated_tactic": ["refine' <a>Eq.trans</a> _ hy", [{"full_name": "Eq.trans", "def_path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "def_pos": [322, 9], "def_end_pos": [322, 17]}]], "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191(AlgHom.toLinearMap f) y' = \u2191y\n\u22a2 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } = S", "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191(AlgHom.toLinearMap f) y' = \u2191y\n\u22a2 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } =\n    (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y"}, {"tactic": "rw [f.toLinearMap_apply] at fy_eq", "annotated_tactic": ["rw [f.toLinearMap_apply] at fy_eq", []], "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191(AlgHom.toLinearMap f) y' = \u2191y\n\u22a2 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } =\n    (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y", "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191f y' = \u2191y\n\u22a2 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } =\n    (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y"}, {"tactic": "ext", "annotated_tactic": ["ext", []], "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191f y' = \u2191y\n\u22a2 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } =\n    (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y", "state_after": "case h.h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191f y' = \u2191y\nx\u271d : A'\n\u22a2 x\u271d \u2208 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } \u2194\n    x\u271d \u2208 (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y"}, {"tactic": "simp [fy_eq]", "annotated_tactic": ["simp [fy_eq]", []], "state_before": "case h.h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u2074 : CommSemiring R\nA : Type v\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\nS\u271d T : Set A\nM N P Q : Submodule R A\nm n : A\nA' : Type u_1\ninst\u271d\u00b9 : Semiring A'\ninst\u271d : Algebra R A'\nf : A \u2192\u2090[R] A'\nS : Submodule R A'\ny : \u21a5map (AlgHom.toLinearMap f) M\nhy : (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y = S\ny' : A\nhy' : y' \u2208 M\nfy_eq : \u2191f y' = \u2191y\nx\u271d : A'\n\u22a2 x\u271d \u2208 (fun i => map (AlgHom.toLinearMap f) (map (\u2191(LinearMap.mul R A) \u2191i) N)) { val := y', property := hy' } \u2194\n    x\u271d \u2208 (fun s => map (\u2191(LinearMap.mul R A') \u2191s) (map (AlgHom.toLinearMap f) N)) y", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Fold.lean", "full_name": "Finset.fold_union_inter", "start": [112, 1], "end": [116, 23], "traced_tactics": [{"tactic": "unfold fold", "annotated_tactic": ["unfold <a>fold</a>", [{"full_name": "Finset.fold", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Fold.lean", "def_pos": [34, 5], "def_end_pos": [34, 9]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Finset \u03b1\nb\u2081 b\u2082 : \u03b2\n\u22a2 op (fold op b\u2081 f (s\u2081 \u222a s\u2082)) (fold op b\u2082 f (s\u2081 \u2229 s\u2082)) = op (fold op b\u2082 f s\u2081) (fold op b\u2081 f s\u2082)", "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Finset \u03b1\nb\u2081 b\u2082 : \u03b2\n\u22a2 op (Multiset.fold op b\u2081 (Multiset.map f (s\u2081 \u222a s\u2082).val)) (Multiset.fold op b\u2082 (Multiset.map f (s\u2081 \u2229 s\u2082).val)) =\n    op (Multiset.fold op b\u2082 (Multiset.map f s\u2081.val)) (Multiset.fold op b\u2081 (Multiset.map f s\u2082.val))"}, {"tactic": "rw [\u2190 fold_add op, \u2190 Multiset.map_add, union_val, inter_val, union_add_inter, Multiset.map_add,\n  hc.comm, fold_add]", "annotated_tactic": ["rw [\u2190 <a>fold_add</a> op, \u2190 <a>Multiset.map_add</a>, <a>union_val</a>, <a>inter_val</a>, <a>union_add_inter</a>, <a>Multiset.map_add</a>,\n    hc.comm, <a>fold_add</a>]", [{"full_name": "Multiset.fold_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Fold.lean", "def_pos": [76, 9], "def_end_pos": [76, 17]}, {"full_name": "Multiset.map_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1200, 9], "def_end_pos": [1200, 16]}, {"full_name": "Finset.union_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1385, 9], "def_end_pos": [1385, 18]}, {"full_name": "Finset.inter_val", "def_path": "lake-packages/mathlib/Mathlib/Data/Finset/Basic.lean", "def_pos": [1613, 9], "def_end_pos": [1613, 18]}, {"full_name": "Multiset.union_add_inter", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1898, 9], "def_end_pos": [1898, 24]}, {"full_name": "Multiset.map_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Basic.lean", "def_pos": [1200, 9], "def_end_pos": [1200, 16]}, {"full_name": "Multiset.fold_add", "def_path": "lake-packages/mathlib/Mathlib/Data/Multiset/Fold.lean", "def_pos": [76, 9], "def_end_pos": [76, 17]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nop : \u03b2 \u2192 \u03b2 \u2192 \u03b2\nhc : IsCommutative \u03b2 op\nha : IsAssociative \u03b2 op\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ns : Finset \u03b1\na : \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Finset \u03b1\nb\u2081 b\u2082 : \u03b2\n\u22a2 op (Multiset.fold op b\u2081 (Multiset.map f (s\u2081 \u222a s\u2082).val)) (Multiset.fold op b\u2082 (Multiset.map f (s\u2081 \u2229 s\u2082).val)) =\n    op (Multiset.fold op b\u2082 (Multiset.map f s\u2081.val)) (Multiset.fold op b\u2081 (Multiset.map f s\u2082.val))", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/GroupTheory/Perm/Support.lean", "full_name": "Equiv.Perm.disjoint_refl_iff", "start": [81, 1], "end": [84, 38], "traced_tactics": [{"tactic": "refine' \u27e8fun h => _, fun h => h.symm \u25b8 disjoint_one_left 1\u27e9", "annotated_tactic": ["refine' \u27e8fun h => _, fun h => h.symm \u25b8 <a>disjoint_one_left</a> 1\u27e9", [{"full_name": "Equiv.Perm.disjoint_one_left", "def_path": "lake-packages/mathlib/Mathlib/GroupTheory/Perm/Support.lean", "def_pos": [69, 9], "def_end_pos": [69, 26]}]], "state_before": "\u03b1 : Type u_1\nf g h : Perm \u03b1\n\u22a2 Disjoint f f \u2194 f = 1", "state_after": "\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : Disjoint f f\n\u22a2 f = 1"}, {"tactic": "ext x", "annotated_tactic": ["ext x", []], "state_before": "\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : Disjoint f f\n\u22a2 f = 1", "state_after": "case H\n\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : Disjoint f f\nx : \u03b1\n\u22a2 \u2191f x = \u21911 x"}, {"tactic": "cases' h x with hx hx <;> simp [hx]", "annotated_tactic": ["cases' h x with hx hx <;> simp [hx]", []], "state_before": "case H\n\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : Disjoint f f\nx : \u03b1\n\u22a2 \u2191f x = \u21911 x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Group/Units/Hom.lean", "full_name": "Units.val_zpow_eq_zpow_val", "start": [134, 1], "end": [135, 28], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Finiteness.lean", "full_name": "Submodule.fg_iff_add_subgroup_fg", "start": [63, 1], "end": [66, 64], "traced_tactics": [{"tactic": "simpa [\u2190 span_int_eq_addSubgroup_closure] using hS", "annotated_tactic": ["simpa [\u2190 <a>span_int_eq_addSubgroup_closure</a>] using hS", [{"full_name": "Submodule.span_int_eq_addSubgroup_closure", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [208, 9], "def_end_pos": [208, 40]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nG : Type u_3\ninst\u271d : AddCommGroup G\nP : Submodule \u2124 G\nx\u271d : FG P\nS : Finset G\nhS : span \u2124 \u2191S = P\n\u22a2 AddSubgroup.closure \u2191S = toAddSubgroup P", "state_after": "no goals"}, {"tactic": "simpa [\u2190 span_int_eq_addSubgroup_closure] using hS", "annotated_tactic": ["simpa [\u2190 <a>span_int_eq_addSubgroup_closure</a>] using hS", [{"full_name": "Submodule.span_int_eq_addSubgroup_closure", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/Span.lean", "def_pos": [208, 9], "def_end_pos": [208, 40]}]], "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nG : Type u_3\ninst\u271d : AddCommGroup G\nP : Submodule \u2124 G\nx\u271d : AddSubgroup.FG (toAddSubgroup P)\nS : Finset G\nhS : AddSubgroup.closure \u2191S = toAddSubgroup P\n\u22a2 span \u2124 \u2191S = P", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/Field/Basic.lean", "full_name": "Commute.inv_add_inv", "start": [81, 11], "end": [83, 69], "traced_tactics": [{"tactic": "rw [inv_eq_one_div, inv_eq_one_div, hab.one_div_add_one_div ha hb]", "annotated_tactic": ["rw [<a>inv_eq_one_div</a>, <a>inv_eq_one_div</a>, hab.one_div_add_one_div ha hb]", [{"full_name": "inv_eq_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [295, 9], "def_end_pos": [295, 23]}, {"full_name": "inv_eq_one_div", "def_path": "lake-packages/mathlib/Mathlib/Algebra/Group/Basic.lean", "def_pos": [295, 9], "def_end_pos": [295, 23]}]], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nK : Type u_3\ninst\u271d : DivisionSemiring \u03b1\na b c d : \u03b1\nhab : Commute a b\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 a\u207b\u00b9 + b\u207b\u00b9 = (a + b) / (a * b)", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Compare.lean", "full_name": "Ordering.Compares.eq_lt", "start": [82, 1], "end": [85, 77], "traced_tactics": [{"tactic": "injection h", "annotated_tactic": ["injection h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b1\na b : \u03b1\nh\u271d : Compares eq a b\nh : eq = lt\n\u22a2 a < b", "state_after": "no goals"}, {"tactic": "injection h", "annotated_tactic": ["injection h", []], "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Preorder \u03b1\na b : \u03b1\nh\u271d : Compares gt a b\nh : gt = lt\n\u22a2 a < b", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Indexes.lean", "full_name": "List.mapIdx_cons", "start": [175, 1], "end": [178, 41], "traced_tactics": [{"tactic": "simp [mapIdx_eq_enum_map, enum_eq_zip_range, map_uncurry_zip_eq_zipWith,\n  range_succ_eq_map, zipWith_map_left]", "annotated_tactic": ["simp [<a>mapIdx_eq_enum_map</a>, <a>enum_eq_zip_range</a>, <a>map_uncurry_zip_eq_zipWith</a>,\n    <a>range_succ_eq_map</a>, <a>zipWith_map_left</a>]", [{"full_name": "List.mapIdx_eq_enum_map", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Indexes.lean", "def_pos": [165, 9], "def_end_pos": [165, 27]}, {"full_name": "List.enum_eq_zip_range", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Range.lean", "def_pos": [188, 9], "def_end_pos": [188, 26]}, {"full_name": "List.map_uncurry_zip_eq_zipWith", "def_path": "lake-packages/mathlib/Mathlib/Data/List/Zip.lean", "def_pos": [389, 9], "def_end_pos": [389, 35]}, {"full_name": "List.range_succ_eq_map", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [2108, 9], "def_end_pos": [2108, 26]}, {"full_name": "List.zipWith_map_left", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [181, 9], "def_end_pos": [181, 25]}]], "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : List \u03b1\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 mapIdx f (a :: l) = f 0 a :: mapIdx (fun i => f (i + 1)) l", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Algebra/MonoidAlgebra/Degree.lean", "full_name": "AddMonoidAlgebra.supDegree_add_le", "start": [239, 1], "end": [241, 27], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/Finset/Basic.lean", "full_name": "Finset.union_sdiff_right", "start": [2188, 1], "end": [2189, 23], "traced_tactics": []}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Data/List/Nodup.lean", "full_name": "List.Nodup.erase_eq_filter", "start": [300, 1], "end": [310, 13], "traced_tactics": [{"tactic": "induction' d with b l m _ IH", "annotated_tactic": ["induction' d with b l m _ IH", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nd : Nodup l\na : \u03b1\n\u22a2 List.erase l a = List.filter (fun x => decide (x \u2260 a)) l", "state_after": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\na : \u03b1\n\u22a2 List.erase [] a = List.filter (fun x => decide (x \u2260 a)) []\n\ncase cons\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\n\u22a2 List.erase (b :: l) a = List.filter (fun x => decide (x \u2260 a)) (b :: l)"}, {"tactic": "by_cases h : b = a", "annotated_tactic": ["by_cases h : b = a", []], "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\n\u22a2 List.erase (b :: l) a = List.filter (fun x => decide (x \u2260 a)) (b :: l)", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\nh : b = a\n\u22a2 List.erase (b :: l) a = List.filter (fun x => decide (x \u2260 a)) (b :: l)\n\ncase neg\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\nh : \u00acb = a\n\u22a2 List.erase (b :: l) a = List.filter (fun x => decide (x \u2260 a)) (b :: l)"}, {"tactic": "rfl", "annotated_tactic": ["rfl", []], "state_before": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\na : \u03b1\n\u22a2 List.erase [] a = List.filter (fun x => decide (x \u2260 a)) []", "state_after": "no goals"}, {"tactic": "subst h", "annotated_tactic": ["subst h", []], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\nh : b = a\n\u22a2 List.erase (b :: l) a = List.filter (fun x => decide (x \u2260 a)) (b :: l)", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 List.erase (b :: l) b = List.filter (fun x => decide (x \u2260 b)) (b :: l)"}, {"tactic": "rw [erase_cons_head, filter_cons_of_neg _ (by simp)]", "annotated_tactic": ["rw [<a>erase_cons_head</a>, <a>filter_cons_of_neg</a> _ (by simp)]", [{"full_name": "List.erase_cons_head", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1191, 17], "def_end_pos": [1191, 32]}, {"full_name": "List.filter_cons_of_neg", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1266, 17], "def_end_pos": [1266, 35]}]], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 List.erase (b :: l) b = List.filter (fun x => decide (x \u2260 b)) (b :: l)", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 l = List.filter (fun x => decide (x \u2260 b)) l"}, {"tactic": "symm", "annotated_tactic": ["symm", []], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 l = List.filter (fun x => decide (x \u2260 b)) l", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 List.filter (fun x => decide (x \u2260 b)) l = l"}, {"tactic": "rw [filter_eq_self]", "annotated_tactic": ["rw [<a>filter_eq_self</a>]", [{"full_name": "List.filter_eq_self", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1397, 9], "def_end_pos": [1397, 23]}]], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 List.filter (fun x => decide (x \u2260 b)) l = l", "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 \u2200 a \u2208 l, decide (a \u2260 b) = true"}, {"tactic": "simpa [@eq_comm \u03b1] using m", "annotated_tactic": ["simpa [@<a>eq_comm</a> \u03b1] using m", [{"full_name": "eq_comm", "def_path": "lake-packages/std/Std/Logic.lean", "def_pos": [104, 9], "def_end_pos": [104, 16]}]], "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 \u2200 a \u2208 l, decide (a \u2260 b) = true", "state_after": "no goals"}, {"tactic": "simp", "annotated_tactic": ["simp", []], "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\nb : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l b = List.filter (fun x => decide (x \u2260 b)) l\n\u22a2 \u00acdecide (b \u2260 b) = true", "state_after": "no goals"}, {"tactic": "rw [erase_cons_tail _ h, filter_cons_of_pos, IH]", "annotated_tactic": ["rw [<a>erase_cons_tail</a> _ h, <a>filter_cons_of_pos</a>, IH]", [{"full_name": "List.erase_cons_tail", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1194, 17], "def_end_pos": [1194, 32]}, {"full_name": "List.filter_cons_of_pos", "def_path": "lake-packages/std/Std/Data/List/Lemmas.lean", "def_pos": [1263, 17], "def_end_pos": [1263, 35]}]], "state_before": "case neg\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\nh : \u00acb = a\n\u22a2 List.erase (b :: l) a = List.filter (fun x => decide (x \u2260 a)) (b :: l)", "state_after": "case neg.pa\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\nh : \u00acb = a\n\u22a2 decide (b \u2260 a) = true"}, {"tactic": "simp [h]", "annotated_tactic": ["simp [h]", []], "state_before": "case neg.pa\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d\u00b9 l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d\u00b9 b\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\nl\u271d : List \u03b1\na b : \u03b1\nl : List \u03b1\nm : \u2200 a' \u2208 l, b \u2260 a'\na\u271d : Pairwise (fun x x_1 => x \u2260 x_1) l\nIH : List.erase l a = List.filter (fun x => decide (x \u2260 a)) l\nh : \u00acb = a\n\u22a2 decide (b \u2260 a) = true", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/Order/Bounds/OrderIso.lean", "full_name": "OrderIso.isLUB_preimage'", "start": [59, 1], "end": [60, 42], "traced_tactics": [{"tactic": "rw [isLUB_preimage, f.apply_symm_apply]", "annotated_tactic": ["rw [<a>isLUB_preimage</a>, f.apply_symm_apply]", [{"full_name": "OrderIso.isLUB_preimage", "def_path": "lake-packages/mathlib/Mathlib/Order/Bounds/OrderIso.lean", "def_pos": [55, 9], "def_end_pos": [55, 23]}]], "state_before": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2243o \u03b2\ns : Set \u03b2\nx : \u03b2\n\u22a2 IsLUB (\u2191f \u207b\u00b9' s) (\u2191(symm f) x) \u2194 IsLUB s x", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/LinearAlgebra/LinearPMap.lean", "full_name": "LinearPMap.mem_domain_of_mem_graph", "start": [887, 1], "end": [890, 15], "traced_tactics": [{"tactic": "rw [mem_domain_iff]", "annotated_tactic": ["rw [<a>mem_domain_iff</a>]", [{"full_name": "LinearPMap.mem_domain_iff", "def_path": "lake-packages/mathlib/Mathlib/LinearAlgebra/LinearPMap.lean", "def_pos": [875, 9], "def_end_pos": [875, 23]}]], "state_before": "R : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nh : (x, y) \u2208 graph f\n\u22a2 x \u2208 f.domain", "state_after": "R : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nh : (x, y) \u2208 graph f\n\u22a2 \u2203 y, (x, y) \u2208 graph f"}, {"tactic": "exact \u27e8y, h\u27e9", "annotated_tactic": ["exact \u27e8y, h\u27e9", []], "state_before": "R : Type u_1\ninst\u271d\u2079 : Ring R\nE : Type u_2\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module R E\nF : Type u_3\ninst\u271d\u2076 : AddCommGroup F\ninst\u271d\u2075 : Module R F\nG : Type u_4\ninst\u271d\u2074 : AddCommGroup G\ninst\u271d\u00b3 : Module R G\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : DistribMulAction M F\ninst\u271d : SMulCommClass R M F\ny\u271d : M\nf : E \u2192\u2097.[R] F\nx : E\ny : F\nh : (x, y) \u2208 graph f\n\u22a2 \u2203 y, (x, y) \u2208 graph f", "state_after": "no goals"}]}, {"url": "https://github.com/leanprover-community/mathlib4", "commit": "e6d6f9ddc8888f245b6a5be6e3b67bbe1ecf2a0d", "file_path": "Mathlib/RingTheory/Ideal/Operations.lean", "full_name": "Ideal.sup_prod_eq_top", "start": [709, 1], "end": [713, 44], "traced_tactics": [{"tactic": "simp_rw [one_eq_top, sup_top_eq]", "annotated_tactic": ["simp_rw [<a>one_eq_top</a>, <a>sup_top_eq</a>]", [{"full_name": "Ideal.one_eq_top", "def_path": "lake-packages/mathlib/Mathlib/RingTheory/Ideal/Operations.lean", "def_pos": [441, 9], "def_end_pos": [441, 19]}, {"full_name": "sup_top_eq", "def_path": "lake-packages/mathlib/Mathlib/Order/BoundedOrder.lean", "def_pos": [443, 9], "def_end_pos": [443, 19]}]], "state_before": "R : Type u\n\u03b9 : Type u_1\ninst\u271d : CommSemiring R\nI J\u271d K L : Ideal R\ns : Finset \u03b9\nJ : \u03b9 \u2192 Ideal R\nh : \u2200 i \u2208 s, I \u2294 J i = \u22a4\n\u22a2 (fun J => I \u2294 J = \u22a4) 1", "state_after": "no goals"}]}]